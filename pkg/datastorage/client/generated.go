// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for AuditEventEventCategory.
const (
	AuditEventEventCategoryAnalysis         AuditEventEventCategory = "analysis"
	AuditEventEventCategoryExecution        AuditEventEventCategory = "execution"
	AuditEventEventCategoryGateway          AuditEventEventCategory = "gateway"
	AuditEventEventCategoryNotification     AuditEventEventCategory = "notification"
	AuditEventEventCategoryOrchestration    AuditEventEventCategory = "orchestration"
	AuditEventEventCategorySignalprocessing AuditEventEventCategory = "signalprocessing"
	AuditEventEventCategoryWebhook          AuditEventEventCategory = "webhook"
	AuditEventEventCategoryWorkflow         AuditEventEventCategory = "workflow"
)

// Defines values for AuditEventEventOutcome.
const (
	AuditEventEventOutcomeFailure AuditEventEventOutcome = "failure"
	AuditEventEventOutcomePending AuditEventEventOutcome = "pending"
	AuditEventEventOutcomeSuccess AuditEventEventOutcome = "success"
)

// Defines values for AuditEventRequestEventCategory.
const (
	AuditEventRequestEventCategoryAnalysis         AuditEventRequestEventCategory = "analysis"
	AuditEventRequestEventCategoryExecution        AuditEventRequestEventCategory = "execution"
	AuditEventRequestEventCategoryGateway          AuditEventRequestEventCategory = "gateway"
	AuditEventRequestEventCategoryNotification     AuditEventRequestEventCategory = "notification"
	AuditEventRequestEventCategoryOrchestration    AuditEventRequestEventCategory = "orchestration"
	AuditEventRequestEventCategorySignalprocessing AuditEventRequestEventCategory = "signalprocessing"
	AuditEventRequestEventCategoryWebhook          AuditEventRequestEventCategory = "webhook"
	AuditEventRequestEventCategoryWorkflow         AuditEventRequestEventCategory = "workflow"
)

// Defines values for AuditEventRequestEventOutcome.
const (
	AuditEventRequestEventOutcomeFailure AuditEventRequestEventOutcome = "failure"
	AuditEventRequestEventOutcomePending AuditEventRequestEventOutcome = "pending"
	AuditEventRequestEventOutcomeSuccess AuditEventRequestEventOutcome = "success"
)

// Defines values for AuditExportResponseExportMetadataExportFormat.
const (
	AuditExportResponseExportMetadataExportFormatCsv  AuditExportResponseExportMetadataExportFormat = "csv"
	AuditExportResponseExportMetadataExportFormatJson AuditExportResponseExportMetadataExportFormat = "json"
)

// Defines values for DetectedLabelsFailedDetections.
const (
	GitOpsManaged   DetectedLabelsFailedDetections = "gitOpsManaged"
	HelmManaged     DetectedLabelsFailedDetections = "helmManaged"
	HpaEnabled      DetectedLabelsFailedDetections = "hpaEnabled"
	NetworkIsolated DetectedLabelsFailedDetections = "networkIsolated"
	PdbProtected    DetectedLabelsFailedDetections = "pdbProtected"
	ServiceMesh     DetectedLabelsFailedDetections = "serviceMesh"
	Stateful        DetectedLabelsFailedDetections = "stateful"
)

// Defines values for DetectedLabelsGitOpsTool.
const (
	DetectedLabelsGitOpsToolArgocd   DetectedLabelsGitOpsTool = "argocd"
	DetectedLabelsGitOpsToolAsterisk DetectedLabelsGitOpsTool = "*"
	DetectedLabelsGitOpsToolFlux     DetectedLabelsGitOpsTool = "flux"
)

// Defines values for DetectedLabelsServiceMesh.
const (
	DetectedLabelsServiceMeshAsterisk DetectedLabelsServiceMesh = "*"
	DetectedLabelsServiceMeshIstio    DetectedLabelsServiceMesh = "istio"
	DetectedLabelsServiceMeshLinkerd  DetectedLabelsServiceMesh = "linkerd"
)

// Defines values for MandatoryLabelsPriority.
const (
	MandatoryLabelsPriorityAsterisk MandatoryLabelsPriority = "*"
	MandatoryLabelsPriorityP0       MandatoryLabelsPriority = "P0"
	MandatoryLabelsPriorityP1       MandatoryLabelsPriority = "P1"
	MandatoryLabelsPriorityP2       MandatoryLabelsPriority = "P2"
	MandatoryLabelsPriorityP3       MandatoryLabelsPriority = "P3"
)

// Defines values for MandatoryLabelsSeverity.
const (
	MandatoryLabelsSeverityCritical MandatoryLabelsSeverity = "critical"
	MandatoryLabelsSeverityHigh     MandatoryLabelsSeverity = "high"
	MandatoryLabelsSeverityLow      MandatoryLabelsSeverity = "low"
	MandatoryLabelsSeverityMedium   MandatoryLabelsSeverity = "medium"
)

// Defines values for NotificationAuditChannel.
const (
	NotificationAuditChannelEmail     NotificationAuditChannel = "email"
	NotificationAuditChannelPagerduty NotificationAuditChannel = "pagerduty"
	NotificationAuditChannelSlack     NotificationAuditChannel = "slack"
	NotificationAuditChannelWebhook   NotificationAuditChannel = "webhook"
)

// Defines values for NotificationAuditStatus.
const (
	NotificationAuditStatusFailed  NotificationAuditStatus = "failed"
	NotificationAuditStatusPending NotificationAuditStatus = "pending"
	NotificationAuditStatusSent    NotificationAuditStatus = "sent"
)

// Defines values for NotificationAuditResponseChannel.
const (
	NotificationAuditResponseChannelEmail     NotificationAuditResponseChannel = "email"
	NotificationAuditResponseChannelPagerduty NotificationAuditResponseChannel = "pagerduty"
	NotificationAuditResponseChannelSlack     NotificationAuditResponseChannel = "slack"
	NotificationAuditResponseChannelWebhook   NotificationAuditResponseChannel = "webhook"
)

// Defines values for NotificationAuditResponseStatus.
const (
	NotificationAuditResponseStatusFailed  NotificationAuditResponseStatus = "failed"
	NotificationAuditResponseStatusPending NotificationAuditResponseStatus = "pending"
	NotificationAuditResponseStatusSent    NotificationAuditResponseStatus = "sent"
)

// Defines values for RemediationWorkflowStatus.
const (
	RemediationWorkflowStatusActive     RemediationWorkflowStatus = "active"
	RemediationWorkflowStatusArchived   RemediationWorkflowStatus = "archived"
	RemediationWorkflowStatusDeprecated RemediationWorkflowStatus = "deprecated"
	RemediationWorkflowStatusDisabled   RemediationWorkflowStatus = "disabled"
)

// Defines values for WorkflowSearchFiltersPriority.
const (
	WorkflowSearchFiltersPriorityP0 WorkflowSearchFiltersPriority = "P0"
	WorkflowSearchFiltersPriorityP1 WorkflowSearchFiltersPriority = "P1"
	WorkflowSearchFiltersPriorityP2 WorkflowSearchFiltersPriority = "P2"
	WorkflowSearchFiltersPriorityP3 WorkflowSearchFiltersPriority = "P3"
)

// Defines values for WorkflowSearchFiltersSeverity.
const (
	WorkflowSearchFiltersSeverityCritical WorkflowSearchFiltersSeverity = "critical"
	WorkflowSearchFiltersSeverityHigh     WorkflowSearchFiltersSeverity = "high"
	WorkflowSearchFiltersSeverityLow      WorkflowSearchFiltersSeverity = "low"
	WorkflowSearchFiltersSeverityMedium   WorkflowSearchFiltersSeverity = "medium"
)

// Defines values for WorkflowSearchFiltersStatus.
const (
	WorkflowSearchFiltersStatusActive     WorkflowSearchFiltersStatus = "active"
	WorkflowSearchFiltersStatusArchived   WorkflowSearchFiltersStatus = "archived"
	WorkflowSearchFiltersStatusDeprecated WorkflowSearchFiltersStatus = "deprecated"
	WorkflowSearchFiltersStatusDisabled   WorkflowSearchFiltersStatus = "disabled"
)

// Defines values for WorkflowUpdateRequestStatus.
const (
	WorkflowUpdateRequestStatusActive     WorkflowUpdateRequestStatus = "active"
	WorkflowUpdateRequestStatusArchived   WorkflowUpdateRequestStatus = "archived"
	WorkflowUpdateRequestStatusDeprecated WorkflowUpdateRequestStatus = "deprecated"
	WorkflowUpdateRequestStatusDisabled   WorkflowUpdateRequestStatus = "disabled"
)

// Defines values for QueryAuditEventsParamsEventOutcome.
const (
	Failure QueryAuditEventsParamsEventOutcome = "failure"
	Pending QueryAuditEventsParamsEventOutcome = "pending"
	Success QueryAuditEventsParamsEventOutcome = "success"
)

// Defines values for ExportAuditEventsParamsFormat.
const (
	ExportAuditEventsParamsFormatCsv  ExportAuditEventsParamsFormat = "csv"
	ExportAuditEventsParamsFormatJson ExportAuditEventsParamsFormat = "json"
)

// Defines values for ListWorkflowsParamsStatus.
const (
	ListWorkflowsParamsStatusActive     ListWorkflowsParamsStatus = "active"
	ListWorkflowsParamsStatusArchived   ListWorkflowsParamsStatus = "archived"
	ListWorkflowsParamsStatusDeprecated ListWorkflowsParamsStatus = "deprecated"
	ListWorkflowsParamsStatusDisabled   ListWorkflowsParamsStatus = "disabled"
)

// AuditEvent defines model for AuditEvent.
type AuditEvent struct {
	ActorId     *string `json:"actor_id,omitempty"`
	ActorType   *string `json:"actor_type,omitempty"`
	ClusterName *string `json:"cluster_name"`

	// CorrelationId Unique identifier for request correlation
	CorrelationId string `json:"correlation_id"`
	DurationMs    *int   `json:"duration_ms"`

	// EventAction Action performed (ADR-034)
	EventAction string `json:"event_action"`

	// EventCategory Service-level event category (ADR-034 v1.4).
	// Per ADR-034 v1.2: event_category MUST match the service name that emits the event.
	// Values:
	// - gateway: Gateway Service
	// - notification: Notification Service
	// - analysis: AI Analysis Service
	// - signalprocessing: Signal Processing Service
	// - workflow: Workflow Catalog Service
	// - execution: Remediation Execution Service
	// - orchestration: Remediation Orchestrator Service
	// - webhook: Authentication Webhook Service (SOC2 CC8.1 operator attribution)
	EventCategory AuditEventEventCategory `json:"event_category"`

	// EventData Service-specific event data as structured Go type.
	// Accepts any JSON-marshalable type (structs, maps, etc.).
	// V1.0: Eliminates map[string]interface{} - use structured types directly.
	// See DD-AUDIT-004 for structured type requirements.
	EventData interface{} `json:"event_data"`

	// EventDate Date of the event (YYYY-MM-DD). Nullable to handle format mismatches from DataStorage.
	EventDate *openapi_types.Date `json:"event_date"`
	EventId   *openapi_types.UUID `json:"event_id,omitempty"`

	// EventOutcome Result of the event
	EventOutcome AuditEventEventOutcome `json:"event_outcome"`

	// EventTimestamp ISO 8601 timestamp when the event occurred
	EventTimestamp time.Time `json:"event_timestamp"`

	// EventType Event type identifier (e.g., gateway.signal.received)
	EventType     string              `json:"event_type"`
	Namespace     *string             `json:"namespace"`
	ParentEventId *openapi_types.UUID `json:"parent_event_id"`
	ResourceId    *string             `json:"resource_id,omitempty"`
	ResourceType  *string             `json:"resource_type,omitempty"`
	Severity      *string             `json:"severity"`

	// Version Schema version (e.g., "1.0")
	Version string `json:"version"`
}

// AuditEventEventCategory Service-level event category (ADR-034 v1.4).
// Per ADR-034 v1.2: event_category MUST match the service name that emits the event.
// Values:
// - gateway: Gateway Service
// - notification: Notification Service
// - analysis: AI Analysis Service
// - signalprocessing: Signal Processing Service
// - workflow: Workflow Catalog Service
// - execution: Remediation Execution Service
// - orchestration: Remediation Orchestrator Service
// - webhook: Authentication Webhook Service (SOC2 CC8.1 operator attribution)
type AuditEventEventCategory string

// AuditEventEventOutcome Result of the event
type AuditEventEventOutcome string

// AuditEventRequest defines model for AuditEventRequest.
type AuditEventRequest struct {
	ActorId     *string `json:"actor_id,omitempty"`
	ActorType   *string `json:"actor_type,omitempty"`
	ClusterName *string `json:"cluster_name"`

	// CorrelationId Unique identifier for request correlation
	CorrelationId string `json:"correlation_id"`
	DurationMs    *int   `json:"duration_ms"`

	// EventAction Action performed (ADR-034)
	EventAction string `json:"event_action"`

	// EventCategory Service-level event category (ADR-034 v1.4).
	// Per ADR-034 v1.2: event_category MUST match the service name that emits the event.
	// Values:
	// - gateway: Gateway Service
	// - notification: Notification Service
	// - analysis: AI Analysis Service
	// - signalprocessing: Signal Processing Service
	// - workflow: Workflow Catalog Service
	// - execution: Remediation Execution Service
	// - orchestration: Remediation Orchestrator Service
	// - webhook: Authentication Webhook Service (SOC2 CC8.1 operator attribution)
	EventCategory AuditEventRequestEventCategory `json:"event_category"`

	// EventData Service-specific event data as structured Go type.
	// Accepts any JSON-marshalable type (structs, maps, etc.).
	// V1.0: Eliminates map[string]interface{} - use structured types directly.
	// See DD-AUDIT-004 for structured type requirements.
	EventData interface{} `json:"event_data"`

	// EventOutcome Result of the event
	EventOutcome AuditEventRequestEventOutcome `json:"event_outcome"`

	// EventTimestamp ISO 8601 timestamp when the event occurred
	EventTimestamp time.Time `json:"event_timestamp"`

	// EventType Event type identifier (e.g., gateway.signal.received)
	EventType     string              `json:"event_type"`
	Namespace     *string             `json:"namespace"`
	ParentEventId *openapi_types.UUID `json:"parent_event_id"`
	ResourceId    *string             `json:"resource_id,omitempty"`
	ResourceType  *string             `json:"resource_type,omitempty"`
	Severity      *string             `json:"severity"`

	// Version Schema version (e.g., "1.0")
	Version string `json:"version"`
}

// AuditEventRequestEventCategory Service-level event category (ADR-034 v1.4).
// Per ADR-034 v1.2: event_category MUST match the service name that emits the event.
// Values:
// - gateway: Gateway Service
// - notification: Notification Service
// - analysis: AI Analysis Service
// - signalprocessing: Signal Processing Service
// - workflow: Workflow Catalog Service
// - execution: Remediation Execution Service
// - orchestration: Remediation Orchestrator Service
// - webhook: Authentication Webhook Service (SOC2 CC8.1 operator attribution)
type AuditEventRequestEventCategory string

// AuditEventRequestEventOutcome Result of the event
type AuditEventRequestEventOutcome string

// AuditEventResponse defines model for AuditEventResponse.
type AuditEventResponse struct {
	EventId        openapi_types.UUID `json:"event_id"`
	EventTimestamp time.Time          `json:"event_timestamp"`
	Message        string             `json:"message"`
}

// AuditEventsQueryResponse defines model for AuditEventsQueryResponse.
type AuditEventsQueryResponse struct {
	Data       *[]AuditEvent `json:"data,omitempty"`
	Pagination *struct {
		// HasMore Whether more results are available beyond current page
		HasMore *bool `json:"has_more,omitempty"`

		// Limit Maximum number of events per page
		Limit *int `json:"limit,omitempty"`

		// Offset Number of events to skip
		Offset *int `json:"offset,omitempty"`

		// Total Total number of events matching the query
		Total *int `json:"total,omitempty"`
	} `json:"pagination,omitempty"`
}

// AuditExportResponse Signed audit export with tamper-evident hash chain verification
type AuditExportResponse struct {
	// DetachedSignature Detached PEM-encoded signature (if requested)
	DetachedSignature *string `json:"detached_signature,omitempty"`

	// Events Audit events matching the query filters
	Events []struct {
		CorrelationId *string                 `json:"correlation_id,omitempty"`
		EventAction   *string                 `json:"event_action,omitempty"`
		EventCategory *string                 `json:"event_category,omitempty"`
		EventData     *map[string]interface{} `json:"event_data,omitempty"`

		// EventHash SHA256 hash of this event
		EventHash      *string             `json:"event_hash,omitempty"`
		EventId        *openapi_types.UUID `json:"event_id,omitempty"`
		EventOutcome   *string             `json:"event_outcome,omitempty"`
		EventTimestamp *time.Time          `json:"event_timestamp,omitempty"`
		EventType      *string             `json:"event_type,omitempty"`

		// HashChainValid Whether this event's hash chain is valid
		HashChainValid *bool `json:"hash_chain_valid,omitempty"`

		// LegalHold Whether this event is under legal hold
		LegalHold *bool `json:"legal_hold,omitempty"`

		// PreviousEventHash Hash of previous event in chain
		PreviousEventHash *string `json:"previous_event_hash,omitempty"`
		Version           *string `json:"version,omitempty"`
	} `json:"events"`
	ExportMetadata struct {
		// CertificateFingerprint SHA256 fingerprint of signing certificate
		CertificateFingerprint *string `json:"certificate_fingerprint,omitempty"`

		// ExportFormat Format of exported data
		ExportFormat AuditExportResponseExportMetadataExportFormat `json:"export_format"`

		// ExportTimestamp When this export was generated
		ExportTimestamp time.Time `json:"export_timestamp"`

		// ExportedBy User who initiated the export (from X-Auth-Request-User)
		ExportedBy *string `json:"exported_by,omitempty"`

		// QueryFilters Filters applied to this export
		QueryFilters *struct {
			CorrelationId *string    `json:"correlation_id,omitempty"`
			EndTime       *time.Time `json:"end_time,omitempty"`
			EventCategory *string    `json:"event_category,omitempty"`
			Limit         *int       `json:"limit,omitempty"`
			Offset        *int       `json:"offset,omitempty"`
			StartTime     *time.Time `json:"start_time,omitempty"`
		} `json:"query_filters,omitempty"`

		// Signature Digital signature of export (base64-encoded)
		Signature string `json:"signature"`

		// SignatureAlgorithm Signature algorithm used
		SignatureAlgorithm *string `json:"signature_algorithm,omitempty"`

		// TotalEvents Total number of events in this export
		TotalEvents int `json:"total_events"`
	} `json:"export_metadata"`
	HashChainVerification struct {
		// BrokenChainEvents Events with broken hash chains (tampered)
		BrokenChainEvents int `json:"broken_chain_events"`

		// ChainIntegrityPercentage Percentage of events with valid chains
		ChainIntegrityPercentage *float64 `json:"chain_integrity_percentage,omitempty"`

		// TamperedEventIds String UUIDs of tampered events (if any)
		TamperedEventIds *[]string `json:"tampered_event_ids,omitempty"`

		// TotalEventsVerified Total events with hash chain data
		TotalEventsVerified int `json:"total_events_verified"`

		// ValidChainEvents Events with valid hash chains
		ValidChainEvents int `json:"valid_chain_events"`

		// VerificationTimestamp When verification was performed
		VerificationTimestamp time.Time `json:"verification_timestamp"`
	} `json:"hash_chain_verification"`
}

// AuditExportResponseExportMetadataExportFormat Format of exported data
type AuditExportResponseExportMetadataExportFormat string

// BatchAuditEventResponse defines model for BatchAuditEventResponse.
type BatchAuditEventResponse struct {
	EventIds *[]openapi_types.UUID `json:"event_ids,omitempty"`
	Message  *string               `json:"message,omitempty"`
}

// CustomLabels Customer-defined labels (DD-WORKFLOW-001 v1.5) - subdomain-based format
type CustomLabels map[string][]string

// DetectedLabels Auto-detected labels from Kubernetes resources (DD-WORKFLOW-001 v2.3) - V1.0 structured types
type DetectedLabels struct {
	// FailedDetections Fields where detection failed (RBAC, timeout, etc.) - consumer should ignore these fields
	FailedDetections *[]DetectedLabelsFailedDetections `json:"failed_detections,omitempty"`

	// GitOpsManaged Resource is managed by GitOps (ArgoCD/Flux)
	GitOpsManaged *bool `json:"gitOpsManaged,omitempty"`

	// GitOpsTool GitOps tool: argocd, flux, or * (wildcard = any tool)
	GitOpsTool *DetectedLabelsGitOpsTool `json:"gitOpsTool,omitempty"`

	// HelmManaged Resource is managed by Helm
	HelmManaged *bool `json:"helmManaged,omitempty"`

	// HpaEnabled HorizontalPodAutoscaler is configured
	HpaEnabled *bool `json:"hpaEnabled,omitempty"`

	// NetworkIsolated NetworkPolicy restricts traffic
	NetworkIsolated *bool `json:"networkIsolated,omitempty"`

	// PdbProtected PodDisruptionBudget protects this workload
	PdbProtected *bool `json:"pdbProtected,omitempty"`

	// ServiceMesh Service mesh type: istio, linkerd, or * (wildcard = any mesh)
	ServiceMesh *DetectedLabelsServiceMesh `json:"serviceMesh,omitempty"`

	// Stateful Workload uses persistent storage or is StatefulSet
	Stateful *bool `json:"stateful,omitempty"`
}

// DetectedLabelsFailedDetections defines model for DetectedLabels.FailedDetections.
type DetectedLabelsFailedDetections string

// DetectedLabelsGitOpsTool GitOps tool: argocd, flux, or * (wildcard = any tool)
type DetectedLabelsGitOpsTool string

// DetectedLabelsServiceMesh Service mesh type: istio, linkerd, or * (wildcard = any mesh)
type DetectedLabelsServiceMesh string

// MandatoryLabels 5 mandatory workflow labels (DD-WORKFLOW-001 v2.3)
type MandatoryLabels struct {
	// Component Kubernetes resource type this workflow targets (e.g., pod, deployment, node)
	Component string `json:"component"`

	// Environment Target environment (production, staging, development, test, * for any)
	Environment string `json:"environment"`

	// Priority Business priority level (P0, P1, P2, P3, * for any)
	Priority MandatoryLabelsPriority `json:"priority"`

	// Severity Severity level this workflow is designed for
	Severity MandatoryLabelsSeverity `json:"severity"`

	// SignalType Signal type this workflow handles (e.g., OOMKilled, CrashLoopBackOff)
	SignalType string `json:"signal_type"`
}

// MandatoryLabelsPriority Business priority level (P0, P1, P2, P3, * for any)
type MandatoryLabelsPriority string

// MandatoryLabelsSeverity Severity level this workflow is designed for
type MandatoryLabelsSeverity string

// NotificationAudit Notification audit record for tracking delivery attempts.
// Maps to `notification_audit` PostgreSQL table.
type NotificationAudit struct {
	// Channel Notification delivery channel.
	// Determines recipient format and delivery mechanism.
	Channel NotificationAuditChannel `json:"channel"`

	// DeliveryStatus HTTP status code or delivery confirmation from notification channel.
	// Optional - only present for sent notifications.
	DeliveryStatus *string `json:"delivery_status"`

	// ErrorMessage Error message from notification channel if delivery failed.
	// Optional - only present for failed notifications.
	ErrorMessage *string `json:"error_message"`

	// EscalationLevel Escalation level for notification (0 = first attempt, 1+ = escalated).
	// Tracks how many times this incident has been escalated.
	EscalationLevel *int `json:"escalation_level,omitempty"`

	// MessageSummary Human-readable summary of notification content.
	// Truncated to 1000 characters for audit purposes.
	MessageSummary string `json:"message_summary"`

	// NotificationId Unique notification identifier from Notification Controller.
	// Used as unique constraint to prevent duplicate audit records.
	NotificationId string `json:"notification_id"`

	// Recipient Notification recipient (email address, Slack channel, PagerDuty key, etc.).
	// Format depends on channel type.
	Recipient string `json:"recipient"`

	// RemediationId Kubernetes RemediationRequest CRD name.
	// Links notification to originating remediation workflow.
	RemediationId string `json:"remediation_id"`

	// SentAt Timestamp when notification was sent (RFC 3339 format).
	// Used to calculate audit lag (time between event and audit write).
	SentAt time.Time `json:"sent_at"`

	// Status Notification delivery status from Notification Controller.
	Status NotificationAuditStatus `json:"status"`
}

// NotificationAuditChannel Notification delivery channel.
// Determines recipient format and delivery mechanism.
type NotificationAuditChannel string

// NotificationAuditStatus Notification delivery status from Notification Controller.
type NotificationAuditStatus string

// NotificationAuditResponse defines model for NotificationAuditResponse.
type NotificationAuditResponse struct {
	// Channel Notification delivery channel.
	// Determines recipient format and delivery mechanism.
	Channel NotificationAuditResponseChannel `json:"channel"`

	// CreatedAt Timestamp when record was created in PostgreSQL.
	CreatedAt time.Time `json:"created_at"`

	// DeliveryStatus HTTP status code or delivery confirmation from notification channel.
	// Optional - only present for sent notifications.
	DeliveryStatus *string `json:"delivery_status"`

	// ErrorMessage Error message from notification channel if delivery failed.
	// Optional - only present for failed notifications.
	ErrorMessage *string `json:"error_message"`

	// EscalationLevel Escalation level for notification (0 = first attempt, 1+ = escalated).
	// Tracks how many times this incident has been escalated.
	EscalationLevel *int `json:"escalation_level,omitempty"`

	// Id Auto-generated primary key from PostgreSQL.
	Id int64 `json:"id"`

	// MessageSummary Human-readable summary of notification content.
	// Truncated to 1000 characters for audit purposes.
	MessageSummary string `json:"message_summary"`

	// NotificationId Unique notification identifier from Notification Controller.
	// Used as unique constraint to prevent duplicate audit records.
	NotificationId string `json:"notification_id"`

	// Recipient Notification recipient (email address, Slack channel, PagerDuty key, etc.).
	// Format depends on channel type.
	Recipient string `json:"recipient"`

	// RemediationId Kubernetes RemediationRequest CRD name.
	// Links notification to originating remediation workflow.
	RemediationId string `json:"remediation_id"`

	// SentAt Timestamp when notification was sent (RFC 3339 format).
	// Used to calculate audit lag (time between event and audit write).
	SentAt time.Time `json:"sent_at"`

	// Status Notification delivery status from Notification Controller.
	Status NotificationAuditResponseStatus `json:"status"`

	// UpdatedAt Timestamp when record was last updated in PostgreSQL.
	UpdatedAt time.Time `json:"updated_at"`
}

// NotificationAuditResponseChannel Notification delivery channel.
// Determines recipient format and delivery mechanism.
type NotificationAuditResponseChannel string

// NotificationAuditResponseStatus Notification delivery status from Notification Controller.
type NotificationAuditResponseStatus string

// RFC7807Problem RFC 7807 Problem Details for HTTP APIs.
// Standard error response format (BR-STORAGE-024).
// See: https://www.rfc-editor.org/rfc/rfc7807.html
type RFC7807Problem struct {
	// Detail Human-readable explanation specific to this occurrence.
	Detail *string `json:"detail,omitempty"`

	// FieldErrors Map of field names to error messages for validation errors.
	// Only present for 400 Bad Request responses.
	FieldErrors *map[string]string `json:"field_errors,omitempty"`

	// Instance URI reference identifying the specific occurrence.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code for this occurrence.
	Status int32 `json:"status"`

	// Title Short, human-readable summary of the problem type.
	// Should not change from occurrence to occurrence.
	Title string `json:"title"`

	// Type URI reference identifying the problem type.
	// Dereferenceable URI when possible.
	Type string `json:"type"`
}

// RemediationWorkflow defines model for RemediationWorkflow.
type RemediationWorkflow struct {
	// ActualSuccessRate Actual success rate (0.0-1.0)
	ActualSuccessRate *float32 `json:"actual_success_rate,omitempty"`

	// ApprovedAt When this version was approved
	ApprovedAt *time.Time `json:"approved_at,omitempty"`

	// ApprovedBy Who approved this version
	ApprovedBy *string `json:"approved_by,omitempty"`

	// ChangeSummary Summary of changes in this version
	ChangeSummary *string `json:"change_summary,omitempty"`

	// ContainerDigest OCI image digest
	ContainerDigest *string `json:"container_digest,omitempty"`

	// ContainerImage OCI image reference
	ContainerImage *string `json:"container_image,omitempty"`

	// Content YAML workflow definition
	Content string `json:"content"`

	// ContentHash SHA-256 hash of content
	ContentHash string     `json:"content_hash"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	CreatedBy   *string    `json:"created_by,omitempty"`

	// CustomLabels Customer-defined labels (DD-WORKFLOW-001 v1.5) - subdomain-based format
	CustomLabels *CustomLabels `json:"custom_labels,omitempty"`

	// DeprecationNotice Deprecation notice
	DeprecationNotice *string `json:"deprecation_notice,omitempty"`

	// Description Workflow description
	Description string `json:"description"`

	// DetectedLabels Auto-detected labels from Kubernetes resources (DD-WORKFLOW-001 v2.3) - V1.0 structured types
	DetectedLabels *DetectedLabels `json:"detected_labels,omitempty"`

	// DisabledAt When workflow was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`

	// DisabledBy Who disabled the workflow
	DisabledBy *string `json:"disabled_by,omitempty"`

	// DisabledReason Why workflow was disabled
	DisabledReason *string `json:"disabled_reason,omitempty"`

	// ExecutionEngine Execution engine (e.g., argo-workflows)
	ExecutionEngine string `json:"execution_engine"`

	// ExpectedDurationSeconds Expected execution duration
	ExpectedDurationSeconds *int `json:"expected_duration_seconds,omitempty"`

	// ExpectedSuccessRate Expected success rate (0.0-1.0)
	ExpectedSuccessRate *float32 `json:"expected_success_rate,omitempty"`

	// IsLatestVersion Is this the latest version?
	IsLatestVersion *bool `json:"is_latest_version,omitempty"`

	// Labels 5 mandatory workflow labels (DD-WORKFLOW-001 v2.3)
	Labels MandatoryLabels `json:"labels"`

	// Maintainer Workflow maintainer email
	Maintainer *openapi_types.Email `json:"maintainer,omitempty"`

	// Name Human-readable workflow title
	Name string `json:"name"`

	// Owner Workflow owner
	Owner *string `json:"owner,omitempty"`

	// Parameters Workflow parameters (JSONB)
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// PreviousVersion Previous version identifier
	PreviousVersion *string `json:"previous_version,omitempty"`

	// Status Workflow lifecycle status
	Status RemediationWorkflowStatus `json:"status"`

	// SuccessfulExecutions Number of successful executions
	SuccessfulExecutions *int `json:"successful_executions,omitempty"`

	// TotalExecutions Total number of executions
	TotalExecutions *int       `json:"total_executions,omitempty"`
	UpdatedAt       *time.Time `json:"updated_at,omitempty"`
	UpdatedBy       *string    `json:"updated_by,omitempty"`

	// Version Semantic version (e.g., v1.0.0)
	Version string `json:"version"`

	// VersionNotes Version release notes
	VersionNotes *string `json:"version_notes,omitempty"`

	// WorkflowId Unique workflow identifier (UUID, auto-generated)
	WorkflowId *openapi_types.UUID `json:"workflow_id,omitempty"`

	// WorkflowName Workflow name (identifier for versions)
	WorkflowName string `json:"workflow_name"`
}

// RemediationWorkflowStatus Workflow lifecycle status
type RemediationWorkflowStatus string

// WorkflowDisableRequest Convenience request to disable a workflow
type WorkflowDisableRequest struct {
	// Reason Why the workflow is being disabled
	Reason *string `json:"reason,omitempty"`

	// UpdatedBy Who is disabling the workflow
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// WorkflowListResponse defines model for WorkflowListResponse.
type WorkflowListResponse struct {
	Limit     *int                   `json:"limit,omitempty"`
	Offset    *int                   `json:"offset,omitempty"`
	Total     *int                   `json:"total,omitempty"`
	Workflows *[]RemediationWorkflow `json:"workflows,omitempty"`
}

// WorkflowSearchFilters defines model for WorkflowSearchFilters.
type WorkflowSearchFilters struct {
	// Component Component type (mandatory: pod, node, deployment, etc.)
	Component string `json:"component"`

	// CustomLabels Customer-defined labels (DD-WORKFLOW-001 v1.5) - subdomain-based format
	CustomLabels *CustomLabels `json:"custom_labels,omitempty"`

	// DetectedLabels Auto-detected labels from Kubernetes resources (DD-WORKFLOW-001 v2.3) - V1.0 structured types
	DetectedLabels *DetectedLabels `json:"detected_labels,omitempty"`

	// Environment Environment (mandatory: production, staging, development)
	Environment string `json:"environment"`

	// Priority Priority level (mandatory: P0, P1, P2, P3)
	Priority WorkflowSearchFiltersPriority `json:"priority"`

	// Severity Severity level (mandatory: critical, high, medium, low)
	Severity WorkflowSearchFiltersSeverity `json:"severity"`

	// SignalType Signal type (mandatory: OOMKilled, CrashLoopBackOff, etc.)
	SignalType string `json:"signal_type"`

	// Status Workflow lifecycle status filter
	Status *[]WorkflowSearchFiltersStatus `json:"status,omitempty"`
}

// WorkflowSearchFiltersPriority Priority level (mandatory: P0, P1, P2, P3)
type WorkflowSearchFiltersPriority string

// WorkflowSearchFiltersSeverity Severity level (mandatory: critical, high, medium, low)
type WorkflowSearchFiltersSeverity string

// WorkflowSearchFiltersStatus defines model for WorkflowSearchFilters.Status.
type WorkflowSearchFiltersStatus string

// WorkflowSearchRequest defines model for WorkflowSearchRequest.
type WorkflowSearchRequest struct {
	Filters WorkflowSearchFilters `json:"filters"`

	// IncludeDisabled Include disabled workflows in results
	IncludeDisabled *bool `json:"include_disabled,omitempty"`

	// MinScore Minimum normalized score threshold (0.0-1.0)
	MinScore *float32 `json:"min_score,omitempty"`

	// RemediationId Optional remediation ID for audit correlation
	RemediationId *string `json:"remediation_id,omitempty"`

	// TopK Maximum number of results to return
	TopK *int `json:"top_k,omitempty"`
}

// WorkflowSearchResponse defines model for WorkflowSearchResponse.
type WorkflowSearchResponse struct {
	Filters *WorkflowSearchFilters `json:"filters,omitempty"`

	// TotalResults Total number of matching workflows
	TotalResults *int                    `json:"total_results,omitempty"`
	Workflows    *[]WorkflowSearchResult `json:"workflows,omitempty"`
}

// WorkflowSearchResult Flat response structure (DD-WORKFLOW-002 v3.0)
type WorkflowSearchResult struct {
	// Confidence Normalized label score (0.0-1.0)
	Confidence float32 `json:"confidence"`

	// ContainerDigest OCI image digest
	ContainerDigest *string `json:"container_digest,omitempty"`

	// ContainerImage OCI image reference
	ContainerImage *string `json:"container_image,omitempty"`

	// CustomLabels Customer-defined labels (DD-WORKFLOW-001 v1.5) - subdomain-based format
	CustomLabels *CustomLabels `json:"custom_labels,omitempty"`

	// Description Workflow description
	Description string `json:"description"`

	// DetectedLabels Auto-detected labels from Kubernetes resources (DD-WORKFLOW-001 v2.3) - V1.0 structured types
	DetectedLabels *DetectedLabels `json:"detected_labels,omitempty"`

	// FinalScore Final normalized score (same as confidence)
	FinalScore float32 `json:"final_score"`

	// LabelBoost Boost from matching DetectedLabels
	LabelBoost *float32 `json:"label_boost,omitempty"`

	// LabelPenalty Penalty from conflicting DetectedLabels
	LabelPenalty *float32 `json:"label_penalty,omitempty"`

	// Rank Position in result set (1-based)
	Rank int `json:"rank"`

	// SignalType Signal type this workflow handles
	SignalType string `json:"signal_type"`

	// Title Human-readable workflow name
	Title string `json:"title"`

	// WorkflowId UUID primary key (DD-WORKFLOW-002 v3.0)
	WorkflowId openapi_types.UUID `json:"workflow_id"`
}

// WorkflowUpdateRequest Update mutable workflow fields only (DD-WORKFLOW-012)
type WorkflowUpdateRequest struct {
	// DisabledBy Who disabled the workflow
	DisabledBy *string `json:"disabled_by,omitempty"`

	// DisabledReason Why the workflow was disabled
	DisabledReason *string `json:"disabled_reason,omitempty"`

	// Status Workflow status (mutable)
	Status *WorkflowUpdateRequestStatus `json:"status,omitempty"`
}

// WorkflowUpdateRequestStatus Workflow status (mutable)
type WorkflowUpdateRequestStatus string

// QueryAuditEventsParams defines parameters for QueryAuditEvents.
type QueryAuditEventsParams struct {
	// EventType Filter by event type (ADR-034)
	EventType *string `form:"event_type,omitempty" json:"event_type,omitempty"`

	// EventCategory Filter by event category (ADR-034)
	EventCategory *string `form:"event_category,omitempty" json:"event_category,omitempty"`

	// EventOutcome Filter by event outcome (ADR-034)
	EventOutcome *QueryAuditEventsParamsEventOutcome `form:"event_outcome,omitempty" json:"event_outcome,omitempty"`

	// Severity Filter by severity level
	Severity *string `form:"severity,omitempty" json:"severity,omitempty"`

	// CorrelationId Filter by correlation ID
	CorrelationId *string `form:"correlation_id,omitempty" json:"correlation_id,omitempty"`

	// Since Start time (relative like "24h" or absolute RFC3339)
	Since *string `form:"since,omitempty" json:"since,omitempty"`

	// Until End time (absolute RFC3339)
	Until *string `form:"until,omitempty" json:"until,omitempty"`

	// Limit Page size (1-1000, default 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Page offset (default 0)
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// QueryAuditEventsParamsEventOutcome defines parameters for QueryAuditEvents.
type QueryAuditEventsParamsEventOutcome string

// CreateAuditEventsBatchJSONBody defines parameters for CreateAuditEventsBatch.
type CreateAuditEventsBatchJSONBody = []AuditEventRequest

// ExportAuditEventsParams defines parameters for ExportAuditEvents.
type ExportAuditEventsParams struct {
	// StartTime Start of time range (ISO 8601)
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End of time range (ISO 8601)
	EndTime *time.Time `form:"end_time,omitempty" json:"end_time,omitempty"`

	// CorrelationId Filter by correlation ID
	CorrelationId *string `form:"correlation_id,omitempty" json:"correlation_id,omitempty"`

	// EventCategory Filter by event category
	EventCategory *string `form:"event_category,omitempty" json:"event_category,omitempty"`

	// Format Export format (json or csv)
	Format *ExportAuditEventsParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// IncludeDetachedSignature Include detached signature file in response
	IncludeDetachedSignature *bool `form:"include_detached_signature,omitempty" json:"include_detached_signature,omitempty"`

	// Offset Pagination offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Maximum records per export
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ExportAuditEventsParamsFormat defines parameters for ExportAuditEvents.
type ExportAuditEventsParamsFormat string

// PlaceLegalHoldJSONBody defines parameters for PlaceLegalHold.
type PlaceLegalHoldJSONBody struct {
	// CorrelationId Correlation ID of events to place legal hold on
	CorrelationId string `json:"correlation_id"`

	// Reason Reason for legal hold (e.g., "litigation", "investigation")
	Reason string `json:"reason"`
}

// ReleaseLegalHoldJSONBody defines parameters for ReleaseLegalHold.
type ReleaseLegalHoldJSONBody struct {
	// ReleaseReason Reason for releasing legal hold
	ReleaseReason string `json:"release_reason"`
}

// ListWorkflowsParams defines parameters for ListWorkflows.
type ListWorkflowsParams struct {
	Status      *ListWorkflowsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
	Environment *string                    `form:"environment,omitempty" json:"environment,omitempty"`
	Priority    *string                    `form:"priority,omitempty" json:"priority,omitempty"`
	Component   *string                    `form:"component,omitempty" json:"component,omitempty"`
	Limit       *int                       `form:"limit,omitempty" json:"limit,omitempty"`
	Offset      *int                       `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListWorkflowsParamsStatus defines parameters for ListWorkflows.
type ListWorkflowsParamsStatus string

// CreateAuditEventJSONRequestBody defines body for CreateAuditEvent for application/json ContentType.
type CreateAuditEventJSONRequestBody = AuditEventRequest

// CreateAuditEventsBatchJSONRequestBody defines body for CreateAuditEventsBatch for application/json ContentType.
type CreateAuditEventsBatchJSONRequestBody = CreateAuditEventsBatchJSONBody

// PlaceLegalHoldJSONRequestBody defines body for PlaceLegalHold for application/json ContentType.
type PlaceLegalHoldJSONRequestBody PlaceLegalHoldJSONBody

// ReleaseLegalHoldJSONRequestBody defines body for ReleaseLegalHold for application/json ContentType.
type ReleaseLegalHoldJSONRequestBody ReleaseLegalHoldJSONBody

// CreateNotificationAuditJSONRequestBody defines body for CreateNotificationAudit for application/json ContentType.
type CreateNotificationAuditJSONRequestBody = NotificationAudit

// CreateWorkflowJSONRequestBody defines body for CreateWorkflow for application/json ContentType.
type CreateWorkflowJSONRequestBody = RemediationWorkflow

// SearchWorkflowsJSONRequestBody defines body for SearchWorkflows for application/json ContentType.
type SearchWorkflowsJSONRequestBody = WorkflowSearchRequest

// UpdateWorkflowJSONRequestBody defines body for UpdateWorkflow for application/json ContentType.
type UpdateWorkflowJSONRequestBody = WorkflowUpdateRequest

// DisableWorkflowJSONRequestBody defines body for DisableWorkflow for application/json ContentType.
type DisableWorkflowJSONRequestBody = WorkflowDisableRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// QueryAuditEvents request
	QueryAuditEvents(ctx context.Context, params *QueryAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuditEventWithBody request with any body
	CreateAuditEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuditEvent(ctx context.Context, body CreateAuditEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuditEventsBatchWithBody request with any body
	CreateAuditEventsBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAuditEventsBatch(ctx context.Context, body CreateAuditEventsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportAuditEvents request
	ExportAuditEvents(ctx context.Context, params *ExportAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegalHolds request
	ListLegalHolds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlaceLegalHoldWithBody request with any body
	PlaceLegalHoldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlaceLegalHold(ctx context.Context, body PlaceLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseLegalHoldWithBody request with any body
	ReleaseLegalHoldWithBody(ctx context.Context, correlationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReleaseLegalHold(ctx context.Context, correlationId string, body ReleaseLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationAuditWithBody request with any body
	CreateNotificationAuditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationAudit(ctx context.Context, body CreateNotificationAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflows request
	ListWorkflows(ctx context.Context, params *ListWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkflowWithBody request with any body
	CreateWorkflowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkflow(ctx context.Context, body CreateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWorkflowsWithBody request with any body
	SearchWorkflowsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchWorkflows(ctx context.Context, body SearchWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowByID request
	GetWorkflowByID(ctx context.Context, workflowId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkflowWithBody request with any body
	UpdateWorkflowWithBody(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkflow(ctx context.Context, workflowId openapi_types.UUID, body UpdateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableWorkflowWithBody request with any body
	DisableWorkflowWithBody(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableWorkflow(ctx context.Context, workflowId openapi_types.UUID, body DisableWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LivenessCheck request
	LivenessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadinessCheck request
	ReadinessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetrics request
	GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) QueryAuditEvents(ctx context.Context, params *QueryAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryAuditEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuditEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuditEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuditEvent(ctx context.Context, body CreateAuditEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuditEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuditEventsBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuditEventsBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuditEventsBatch(ctx context.Context, body CreateAuditEventsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuditEventsBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportAuditEvents(ctx context.Context, params *ExportAuditEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportAuditEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegalHolds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegalHoldsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaceLegalHoldWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaceLegalHoldRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlaceLegalHold(ctx context.Context, body PlaceLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlaceLegalHoldRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseLegalHoldWithBody(ctx context.Context, correlationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseLegalHoldRequestWithBody(c.Server, correlationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseLegalHold(ctx context.Context, correlationId string, body ReleaseLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseLegalHoldRequest(c.Server, correlationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationAuditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationAuditRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationAudit(ctx context.Context, body CreateNotificationAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationAuditRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflows(ctx context.Context, params *ListWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflow(ctx context.Context, body CreateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWorkflowsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWorkflowsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWorkflows(ctx context.Context, body SearchWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWorkflowsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowByID(ctx context.Context, workflowId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowByIDRequest(c.Server, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowWithBody(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflow(ctx context.Context, workflowId openapi_types.UUID, body UpdateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableWorkflowWithBody(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableWorkflowRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableWorkflow(ctx context.Context, workflowId openapi_types.UUID, body DisableWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableWorkflowRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LivenessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLivenessCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadinessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadinessCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewQueryAuditEventsRequest generates requests for QueryAuditEvents
func NewQueryAuditEventsRequest(server string, params *QueryAuditEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_type", runtime.ParamLocationQuery, *params.EventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_category", runtime.ParamLocationQuery, *params.EventCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventOutcome != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_outcome", runtime.ParamLocationQuery, *params.EventOutcome); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CorrelationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "correlation_id", runtime.ParamLocationQuery, *params.CorrelationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Since != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Until != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAuditEventRequest calls the generic CreateAuditEvent builder with application/json body
func NewCreateAuditEventRequest(server string, body CreateAuditEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuditEventRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuditEventRequestWithBody generates requests for CreateAuditEvent with any type of body
func NewCreateAuditEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAuditEventsBatchRequest calls the generic CreateAuditEventsBatch builder with application/json body
func NewCreateAuditEventsBatchRequest(server string, body CreateAuditEventsBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAuditEventsBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAuditEventsBatchRequestWithBody generates requests for CreateAuditEventsBatch with any type of body
func NewCreateAuditEventsBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/events/batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportAuditEventsRequest generates requests for ExportAuditEvents
func NewExportAuditEventsRequest(server string, params *ExportAuditEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CorrelationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "correlation_id", runtime.ParamLocationQuery, *params.CorrelationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventCategory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_category", runtime.ParamLocationQuery, *params.EventCategory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeDetachedSignature != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_detached_signature", runtime.ParamLocationQuery, *params.IncludeDetachedSignature); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLegalHoldsRequest generates requests for ListLegalHolds
func NewListLegalHoldsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/legal-hold")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlaceLegalHoldRequest calls the generic PlaceLegalHold builder with application/json body
func NewPlaceLegalHoldRequest(server string, body PlaceLegalHoldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlaceLegalHoldRequestWithBody(server, "application/json", bodyReader)
}

// NewPlaceLegalHoldRequestWithBody generates requests for PlaceLegalHold with any type of body
func NewPlaceLegalHoldRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/legal-hold")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReleaseLegalHoldRequest calls the generic ReleaseLegalHold builder with application/json body
func NewReleaseLegalHoldRequest(server string, correlationId string, body ReleaseLegalHoldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleaseLegalHoldRequestWithBody(server, correlationId, "application/json", bodyReader)
}

// NewReleaseLegalHoldRequestWithBody generates requests for ReleaseLegalHold with any type of body
func NewReleaseLegalHoldRequestWithBody(server string, correlationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "correlation_id", runtime.ParamLocationPath, correlationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/legal-hold/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNotificationAuditRequest calls the generic CreateNotificationAudit builder with application/json body
func NewCreateNotificationAuditRequest(server string, body CreateNotificationAuditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationAuditRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationAuditRequestWithBody generates requests for CreateNotificationAudit with any type of body
func NewCreateNotificationAuditRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/audit/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkflowsRequest generates requests for ListWorkflows
func NewListWorkflowsRequest(server string, params *ListWorkflowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Environment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Priority != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "priority", runtime.ParamLocationQuery, *params.Priority); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Component != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component", runtime.ParamLocationQuery, *params.Component); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkflowRequest calls the generic CreateWorkflow builder with application/json body
func NewCreateWorkflowRequest(server string, body CreateWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkflowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkflowRequestWithBody generates requests for CreateWorkflow with any type of body
func NewCreateWorkflowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchWorkflowsRequest calls the generic SearchWorkflows builder with application/json body
func NewSearchWorkflowsRequest(server string, body SearchWorkflowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchWorkflowsRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchWorkflowsRequestWithBody generates requests for SearchWorkflows with any type of body
func NewSearchWorkflowsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowByIDRequest generates requests for GetWorkflowByID
func NewGetWorkflowByIDRequest(server string, workflowId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkflowRequest calls the generic UpdateWorkflow builder with application/json body
func NewUpdateWorkflowRequest(server string, workflowId openapi_types.UUID, body UpdateWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkflowRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewUpdateWorkflowRequestWithBody generates requests for UpdateWorkflow with any type of body
func NewUpdateWorkflowRequestWithBody(server string, workflowId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableWorkflowRequest calls the generic DisableWorkflow builder with application/json body
func NewDisableWorkflowRequest(server string, workflowId openapi_types.UUID, body DisableWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableWorkflowRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewDisableWorkflowRequestWithBody generates requests for DisableWorkflow with any type of body
func NewDisableWorkflowRequestWithBody(server string, workflowId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/workflows/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLivenessCheckRequest generates requests for LivenessCheck
func NewLivenessCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadinessCheckRequest generates requests for ReadinessCheck
func NewReadinessCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// QueryAuditEventsWithResponse request
	QueryAuditEventsWithResponse(ctx context.Context, params *QueryAuditEventsParams, reqEditors ...RequestEditorFn) (*QueryAuditEventsResponse, error)

	// CreateAuditEventWithBodyWithResponse request with any body
	CreateAuditEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuditEventResponse, error)

	CreateAuditEventWithResponse(ctx context.Context, body CreateAuditEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuditEventResponse, error)

	// CreateAuditEventsBatchWithBodyWithResponse request with any body
	CreateAuditEventsBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuditEventsBatchResponse, error)

	CreateAuditEventsBatchWithResponse(ctx context.Context, body CreateAuditEventsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuditEventsBatchResponse, error)

	// ExportAuditEventsWithResponse request
	ExportAuditEventsWithResponse(ctx context.Context, params *ExportAuditEventsParams, reqEditors ...RequestEditorFn) (*ExportAuditEventsResponse, error)

	// ListLegalHoldsWithResponse request
	ListLegalHoldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLegalHoldsResponse, error)

	// PlaceLegalHoldWithBodyWithResponse request with any body
	PlaceLegalHoldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlaceLegalHoldResponse, error)

	PlaceLegalHoldWithResponse(ctx context.Context, body PlaceLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*PlaceLegalHoldResponse, error)

	// ReleaseLegalHoldWithBodyWithResponse request with any body
	ReleaseLegalHoldWithBodyWithResponse(ctx context.Context, correlationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseLegalHoldResponse, error)

	ReleaseLegalHoldWithResponse(ctx context.Context, correlationId string, body ReleaseLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseLegalHoldResponse, error)

	// CreateNotificationAuditWithBodyWithResponse request with any body
	CreateNotificationAuditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationAuditResponse, error)

	CreateNotificationAuditWithResponse(ctx context.Context, body CreateNotificationAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationAuditResponse, error)

	// ListWorkflowsWithResponse request
	ListWorkflowsWithResponse(ctx context.Context, params *ListWorkflowsParams, reqEditors ...RequestEditorFn) (*ListWorkflowsResponse, error)

	// CreateWorkflowWithBodyWithResponse request with any body
	CreateWorkflowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowResponse, error)

	CreateWorkflowWithResponse(ctx context.Context, body CreateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowResponse, error)

	// SearchWorkflowsWithBodyWithResponse request with any body
	SearchWorkflowsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchWorkflowsResponse, error)

	SearchWorkflowsWithResponse(ctx context.Context, body SearchWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchWorkflowsResponse, error)

	// GetWorkflowByIDWithResponse request
	GetWorkflowByIDWithResponse(ctx context.Context, workflowId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWorkflowByIDResponse, error)

	// UpdateWorkflowWithBodyWithResponse request with any body
	UpdateWorkflowWithBodyWithResponse(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowResponse, error)

	UpdateWorkflowWithResponse(ctx context.Context, workflowId openapi_types.UUID, body UpdateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowResponse, error)

	// DisableWorkflowWithBodyWithResponse request with any body
	DisableWorkflowWithBodyWithResponse(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableWorkflowResponse, error)

	DisableWorkflowWithResponse(ctx context.Context, workflowId openapi_types.UUID, body DisableWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableWorkflowResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// LivenessCheckWithResponse request
	LivenessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessCheckResponse, error)

	// ReadinessCheckWithResponse request
	ReadinessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessCheckResponse, error)

	// GetMetricsWithResponse request
	GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)
}

type QueryAuditEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditEventsQueryResponse
}

// Status returns HTTPResponse.Status
func (r QueryAuditEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryAuditEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuditEventResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *AuditEventResponse
	JSON202                   *AuditEventResponse
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON500 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r CreateAuditEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuditEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuditEventsBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BatchAuditEventResponse
}

// Status returns HTTPResponse.Status
func (r CreateAuditEventsBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuditEventsBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportAuditEventsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AuditExportResponse
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON401 *RFC7807Problem
	ApplicationproblemJSON413 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r ExportAuditEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportAuditEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegalHoldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Holds *[]struct {
			CorrelationId  *string    `json:"correlation_id,omitempty"`
			EventsAffected *int       `json:"events_affected,omitempty"`
			PlacedAt       *time.Time `json:"placed_at,omitempty"`
			PlacedBy       *string    `json:"placed_by,omitempty"`
			Reason         *string    `json:"reason,omitempty"`
		} `json:"holds,omitempty"`
		Total *int `json:"total,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListLegalHoldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegalHoldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlaceLegalHoldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CorrelationId  *string    `json:"correlation_id,omitempty"`
		EventsAffected *int       `json:"events_affected,omitempty"`
		PlacedAt       *time.Time `json:"placed_at,omitempty"`
		PlacedBy       *string    `json:"placed_by,omitempty"`
		Reason         *string    `json:"reason,omitempty"`
	}
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON401 *RFC7807Problem
	ApplicationproblemJSON404 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r PlaceLegalHoldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlaceLegalHoldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseLegalHoldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CorrelationId  *string    `json:"correlation_id,omitempty"`
		EventsReleased *int       `json:"events_released,omitempty"`
		ReleasedAt     *time.Time `json:"released_at,omitempty"`
		ReleasedBy     *string    `json:"released_by,omitempty"`
	}
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON401 *RFC7807Problem
	ApplicationproblemJSON404 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r ReleaseLegalHoldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseLegalHoldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationAuditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NotificationAuditResponse
	JSON202      *struct {
		Message string                           `json:"message"`
		Status  CreateNotificationAudit202Status `json:"status"`
	}
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON409 *RFC7807Problem
	ApplicationproblemJSON500 *RFC7807Problem
}
type CreateNotificationAudit202Status string

// Status returns HTTPResponse.Status
func (r CreateNotificationAuditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationAuditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *WorkflowListResponse
	ApplicationproblemJSON500 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r ListWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkflowResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON201                   *RemediationWorkflow
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON500 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r CreateWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWorkflowsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *WorkflowSearchResponse
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON500 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r SearchWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowByIDResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RemediationWorkflow
	ApplicationproblemJSON404 *RFC7807Problem
	ApplicationproblemJSON500 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r GetWorkflowByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkflowResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RemediationWorkflow
	ApplicationproblemJSON400 *RFC7807Problem
	ApplicationproblemJSON404 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableWorkflowResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *RemediationWorkflow
	ApplicationproblemJSON404 *RFC7807Problem
}

// Status returns HTTPResponse.Status
func (r DisableWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *HealthCheck200Status `json:"status,omitempty"`
	}
	JSON503 *struct {
		Error  *string               `json:"error,omitempty"`
		Status *HealthCheck503Status `json:"status,omitempty"`
	}
}
type HealthCheck200Status string
type HealthCheck503Status string

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LivenessCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LivenessCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LivenessCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadinessCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReadinessCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadinessCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// QueryAuditEventsWithResponse request returning *QueryAuditEventsResponse
func (c *ClientWithResponses) QueryAuditEventsWithResponse(ctx context.Context, params *QueryAuditEventsParams, reqEditors ...RequestEditorFn) (*QueryAuditEventsResponse, error) {
	rsp, err := c.QueryAuditEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryAuditEventsResponse(rsp)
}

// CreateAuditEventWithBodyWithResponse request with arbitrary body returning *CreateAuditEventResponse
func (c *ClientWithResponses) CreateAuditEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuditEventResponse, error) {
	rsp, err := c.CreateAuditEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuditEventResponse(rsp)
}

func (c *ClientWithResponses) CreateAuditEventWithResponse(ctx context.Context, body CreateAuditEventJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuditEventResponse, error) {
	rsp, err := c.CreateAuditEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuditEventResponse(rsp)
}

// CreateAuditEventsBatchWithBodyWithResponse request with arbitrary body returning *CreateAuditEventsBatchResponse
func (c *ClientWithResponses) CreateAuditEventsBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAuditEventsBatchResponse, error) {
	rsp, err := c.CreateAuditEventsBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuditEventsBatchResponse(rsp)
}

func (c *ClientWithResponses) CreateAuditEventsBatchWithResponse(ctx context.Context, body CreateAuditEventsBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAuditEventsBatchResponse, error) {
	rsp, err := c.CreateAuditEventsBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuditEventsBatchResponse(rsp)
}

// ExportAuditEventsWithResponse request returning *ExportAuditEventsResponse
func (c *ClientWithResponses) ExportAuditEventsWithResponse(ctx context.Context, params *ExportAuditEventsParams, reqEditors ...RequestEditorFn) (*ExportAuditEventsResponse, error) {
	rsp, err := c.ExportAuditEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportAuditEventsResponse(rsp)
}

// ListLegalHoldsWithResponse request returning *ListLegalHoldsResponse
func (c *ClientWithResponses) ListLegalHoldsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLegalHoldsResponse, error) {
	rsp, err := c.ListLegalHolds(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegalHoldsResponse(rsp)
}

// PlaceLegalHoldWithBodyWithResponse request with arbitrary body returning *PlaceLegalHoldResponse
func (c *ClientWithResponses) PlaceLegalHoldWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlaceLegalHoldResponse, error) {
	rsp, err := c.PlaceLegalHoldWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaceLegalHoldResponse(rsp)
}

func (c *ClientWithResponses) PlaceLegalHoldWithResponse(ctx context.Context, body PlaceLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*PlaceLegalHoldResponse, error) {
	rsp, err := c.PlaceLegalHold(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlaceLegalHoldResponse(rsp)
}

// ReleaseLegalHoldWithBodyWithResponse request with arbitrary body returning *ReleaseLegalHoldResponse
func (c *ClientWithResponses) ReleaseLegalHoldWithBodyWithResponse(ctx context.Context, correlationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleaseLegalHoldResponse, error) {
	rsp, err := c.ReleaseLegalHoldWithBody(ctx, correlationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseLegalHoldResponse(rsp)
}

func (c *ClientWithResponses) ReleaseLegalHoldWithResponse(ctx context.Context, correlationId string, body ReleaseLegalHoldJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleaseLegalHoldResponse, error) {
	rsp, err := c.ReleaseLegalHold(ctx, correlationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseLegalHoldResponse(rsp)
}

// CreateNotificationAuditWithBodyWithResponse request with arbitrary body returning *CreateNotificationAuditResponse
func (c *ClientWithResponses) CreateNotificationAuditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationAuditResponse, error) {
	rsp, err := c.CreateNotificationAuditWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationAuditResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationAuditWithResponse(ctx context.Context, body CreateNotificationAuditJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationAuditResponse, error) {
	rsp, err := c.CreateNotificationAudit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationAuditResponse(rsp)
}

// ListWorkflowsWithResponse request returning *ListWorkflowsResponse
func (c *ClientWithResponses) ListWorkflowsWithResponse(ctx context.Context, params *ListWorkflowsParams, reqEditors ...RequestEditorFn) (*ListWorkflowsResponse, error) {
	rsp, err := c.ListWorkflows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowsResponse(rsp)
}

// CreateWorkflowWithBodyWithResponse request with arbitrary body returning *CreateWorkflowResponse
func (c *ClientWithResponses) CreateWorkflowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowResponse, error) {
	rsp, err := c.CreateWorkflowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkflowWithResponse(ctx context.Context, body CreateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowResponse, error) {
	rsp, err := c.CreateWorkflow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowResponse(rsp)
}

// SearchWorkflowsWithBodyWithResponse request with arbitrary body returning *SearchWorkflowsResponse
func (c *ClientWithResponses) SearchWorkflowsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchWorkflowsResponse, error) {
	rsp, err := c.SearchWorkflowsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWorkflowsResponse(rsp)
}

func (c *ClientWithResponses) SearchWorkflowsWithResponse(ctx context.Context, body SearchWorkflowsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchWorkflowsResponse, error) {
	rsp, err := c.SearchWorkflows(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWorkflowsResponse(rsp)
}

// GetWorkflowByIDWithResponse request returning *GetWorkflowByIDResponse
func (c *ClientWithResponses) GetWorkflowByIDWithResponse(ctx context.Context, workflowId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetWorkflowByIDResponse, error) {
	rsp, err := c.GetWorkflowByID(ctx, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowByIDResponse(rsp)
}

// UpdateWorkflowWithBodyWithResponse request with arbitrary body returning *UpdateWorkflowResponse
func (c *ClientWithResponses) UpdateWorkflowWithBodyWithResponse(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowResponse, error) {
	rsp, err := c.UpdateWorkflowWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkflowWithResponse(ctx context.Context, workflowId openapi_types.UUID, body UpdateWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowResponse, error) {
	rsp, err := c.UpdateWorkflow(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowResponse(rsp)
}

// DisableWorkflowWithBodyWithResponse request with arbitrary body returning *DisableWorkflowResponse
func (c *ClientWithResponses) DisableWorkflowWithBodyWithResponse(ctx context.Context, workflowId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableWorkflowResponse, error) {
	rsp, err := c.DisableWorkflowWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableWorkflowResponse(rsp)
}

func (c *ClientWithResponses) DisableWorkflowWithResponse(ctx context.Context, workflowId openapi_types.UUID, body DisableWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableWorkflowResponse, error) {
	rsp, err := c.DisableWorkflow(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableWorkflowResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// LivenessCheckWithResponse request returning *LivenessCheckResponse
func (c *ClientWithResponses) LivenessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LivenessCheckResponse, error) {
	rsp, err := c.LivenessCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLivenessCheckResponse(rsp)
}

// ReadinessCheckWithResponse request returning *ReadinessCheckResponse
func (c *ClientWithResponses) ReadinessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReadinessCheckResponse, error) {
	rsp, err := c.ReadinessCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadinessCheckResponse(rsp)
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// ParseQueryAuditEventsResponse parses an HTTP response from a QueryAuditEventsWithResponse call
func ParseQueryAuditEventsResponse(rsp *http.Response) (*QueryAuditEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryAuditEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditEventsQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAuditEventResponse parses an HTTP response from a CreateAuditEventWithResponse call
func ParseCreateAuditEventResponse(rsp *http.Response) (*CreateAuditEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuditEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuditEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AuditEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateAuditEventsBatchResponse parses an HTTP response from a CreateAuditEventsBatchWithResponse call
func ParseCreateAuditEventsBatchResponse(rsp *http.Response) (*CreateAuditEventsBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuditEventsBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BatchAuditEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseExportAuditEventsResponse parses an HTTP response from a ExportAuditEventsWithResponse call
func ParseExportAuditEventsResponse(rsp *http.Response) (*ExportAuditEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportAuditEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON413 = &dest

	}

	return response, nil
}

// ParseListLegalHoldsResponse parses an HTTP response from a ListLegalHoldsWithResponse call
func ParseListLegalHoldsResponse(rsp *http.Response) (*ListLegalHoldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegalHoldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Holds *[]struct {
				CorrelationId  *string    `json:"correlation_id,omitempty"`
				EventsAffected *int       `json:"events_affected,omitempty"`
				PlacedAt       *time.Time `json:"placed_at,omitempty"`
				PlacedBy       *string    `json:"placed_by,omitempty"`
				Reason         *string    `json:"reason,omitempty"`
			} `json:"holds,omitempty"`
			Total *int `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlaceLegalHoldResponse parses an HTTP response from a PlaceLegalHoldWithResponse call
func ParsePlaceLegalHoldResponse(rsp *http.Response) (*PlaceLegalHoldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlaceLegalHoldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CorrelationId  *string    `json:"correlation_id,omitempty"`
			EventsAffected *int       `json:"events_affected,omitempty"`
			PlacedAt       *time.Time `json:"placed_at,omitempty"`
			PlacedBy       *string    `json:"placed_by,omitempty"`
			Reason         *string    `json:"reason,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseReleaseLegalHoldResponse parses an HTTP response from a ReleaseLegalHoldWithResponse call
func ParseReleaseLegalHoldResponse(rsp *http.Response) (*ReleaseLegalHoldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseLegalHoldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CorrelationId  *string    `json:"correlation_id,omitempty"`
			EventsReleased *int       `json:"events_released,omitempty"`
			ReleasedAt     *time.Time `json:"released_at,omitempty"`
			ReleasedBy     *string    `json:"released_by,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseCreateNotificationAuditResponse parses an HTTP response from a CreateNotificationAuditWithResponse call
func ParseCreateNotificationAuditResponse(rsp *http.Response) (*CreateNotificationAuditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationAuditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationAuditResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message string                           `json:"message"`
			Status  CreateNotificationAudit202Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseListWorkflowsResponse parses an HTTP response from a ListWorkflowsWithResponse call
func ParseListWorkflowsResponse(rsp *http.Response) (*ListWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseCreateWorkflowResponse parses an HTTP response from a CreateWorkflowWithResponse call
func ParseCreateWorkflowResponse(rsp *http.Response) (*CreateWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RemediationWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseSearchWorkflowsResponse parses an HTTP response from a SearchWorkflowsWithResponse call
func ParseSearchWorkflowsResponse(rsp *http.Response) (*SearchWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkflowByIDResponse parses an HTTP response from a GetWorkflowByIDWithResponse call
func ParseGetWorkflowByIDResponse(rsp *http.Response) (*GetWorkflowByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemediationWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	}

	return response, nil
}

// ParseUpdateWorkflowResponse parses an HTTP response from a UpdateWorkflowWithResponse call
func ParseUpdateWorkflowResponse(rsp *http.Response) (*UpdateWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemediationWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseDisableWorkflowResponse parses an HTTP response from a DisableWorkflowWithResponse call
func ParseDisableWorkflowResponse(rsp *http.Response) (*DisableWorkflowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemediationWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest RFC7807Problem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *HealthCheck200Status `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Error  *string               `json:"error,omitempty"`
			Status *HealthCheck503Status `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseLivenessCheckResponse parses an HTTP response from a LivenessCheckWithResponse call
func ParseLivenessCheckResponse(rsp *http.Response) (*LivenessCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LivenessCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReadinessCheckResponse parses an HTTP response from a ReadinessCheckWithResponse call
func ParseReadinessCheckResponse(rsp *http.Response) (*ReadinessCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadinessCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
