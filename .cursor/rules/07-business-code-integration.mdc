---
alwaysApply: true
description: "Business code integration patterns and validation requirements for kubernaut"
---
# Business Code Integration Standards

## Core Requirement - MANDATORY

**Rule**: ALL business logic MUST be integrated into main application workflows
**Prevention**: Design integration points during APDC Analysis and Plan phases

## Integration Definition

Business code is **properly integrated** when:
1. **Main Application Entry**: Code is instantiated and used in main application entry points
2. **Runtime Execution**: Code executes during normal application workflows (not just tests)
3. **Dependency Chain**: All dependencies are properly wired in main application
4. **Interface Implementation**: Interfaces are implemented by real business code (not just mocks)
5. **Configuration Loading**: Business code configuration is loaded in main application
6. **Error Integration**: Business code errors are handled in main application flow
7. **Monitoring Integration**: Business code metrics are exposed in main application

## Integration Validation Matrix

| Integration Aspect | Validation Method | Required Evidence |
|-------------------|------------------|-------------------|
| **Main Entry Point** | Code tracing from `cmd/*/main.go` | Direct instantiation or factory usage |
| **Runtime Path** | Execution flow analysis | Normal workflow execution path |
| **Dependency Wiring** | Dependency injection validation | All deps available at runtime |
| **Interface Usage** | Implementation verification | Real implementations in main app |
| **Configuration** | Config loading verification | Business config loaded in main |
| **Error Handling** | Error flow analysis | Business errors handled in main |
| **Monitoring** | Metrics integration check | Business metrics exposed |

## üö´ **IRONCLAD INTEGRATION VERIFICATION PROCESS**

### **MANDATORY INTEGRATION VALIDATION - BLOCKING REQUIREMENTS**

**üö´ BLOCKING REQUIREMENT - BEFORE ANY BUSINESS CODE CREATION**:

<function_calls>
<invoke name="Grep">
<parameter name="pattern">[BusinessComponentType]</parameter>
<parameter name="path">cmd/</parameter>
<parameter name="output_mode">content</parameter>
<parameter name="-n">true</parameter>
</invoke>
</function_calls>

<function_calls>
<invoke name="Task">
<parameter name="subagent_type">general-purpose</parameter>
<parameter name="description">Main application integration analysis</parameter>
<parameter name="prompt">Analyze main applications in cmd/ directory to understand integration patterns. Find how similar business components are instantiated, configured, and wired into the application flow.</parameter>
</invoke>
</function_calls>

```
‚úÖ INTEGRATION VERIFICATION CHECKPOINT:
- [ ] Main application search executed ‚úÖ/‚ùå
- [ ] Integration patterns identified and documented ‚úÖ/‚ùå
- [ ] Similar component usage patterns discovered ‚úÖ/‚ùå
- [ ] Integration plan developed for cmd/ applications ‚úÖ/‚ùå
- [ ] Runtime execution path verified ‚úÖ/‚ùå

‚ùå STOP: Cannot create business code until ALL checkboxes are ‚úÖ
```

**üö´ MANDATORY INTEGRATION EVIDENCE - POST-IMPLEMENTATION**:

<function_calls>
<invoke name="Grep">
<parameter name="pattern">[ImplementedBusinessComponent]</parameter>
<parameter name="path">cmd/</parameter>
<parameter name="output_mode">files_with_matches</parameter>
</invoke>
</function_calls>

<function_calls>
<invoke name="Grep">
<parameter name="pattern">New[BusinessComponent]|Create[BusinessComponent]</parameter>
<parameter name="path">cmd/</parameter>
<parameter name="output_mode">content</parameter>
</invoke>
</function_calls>

```
‚úÖ INTEGRATION EVIDENCE CHECKPOINT:
- [ ] Component appears in main applications ‚úÖ/‚ùå
- [ ] Component instantiation confirmed ‚úÖ/‚ùå
- [ ] Runtime execution path verified ‚úÖ/‚ùå
- [ ] No orphaned business code ‚úÖ/‚ùå

‚ùå VIOLATION: If ANY checkbox is ‚ùå ‚Üí "üö® ORPHANED BUSINESS CODE VIOLATION: All business code MUST be integrated in main applications - DEVELOPMENT STOPPED"
```

### Step 1: Call Graph Analysis (Tool-Enforced)
```bash
# MANDATORY: Execute these validation commands
grep -r "[BusinessComponentType]" cmd/ --include="*.go"
find pkg/ -name "*.go" -not -name "*_test.go" -exec grep -l "[BusinessComponentType]" {} \;
```

### Step 2: Runtime Path Verification
```go
// Add integration validation to main application startup
func validateBusinessIntegration() error {
    // Verify each business component is properly integrated
    if businessComponent == nil {
        return fmt.Errorf("business component not integrated")
    }

    // Test business component can be invoked
    if err := businessComponent.HealthCheck(); err != nil {
        return fmt.Errorf("business component not functional: %w", err)
    }

    return nil
}
```

### Step 3: Dependency Chain Validation
```go
// Verify all business code dependencies are available
func validateDependencyChain() error {
    requiredDeps := []string{"database", "vectorDB", "llmClient", "k8sClient"}

    for _, dep := range requiredDeps {
        if !isDependencyAvailable(dep) {
            return fmt.Errorf("required dependency %s not available for business code", dep)
        }
    }

    return nil
}
```

## Integration Patterns

### Pattern 1: Direct Main Application Integration
```go
// cmd/kubernaut/main.go
func main() {
    // Create business components
    analyticsEngine := insights.NewAnalyticsEngine(deps...)
    workflowBuilder := engine.NewIntelligentWorkflowBuilder(deps...)

    // Integrate into main application flow
    processor := processor.New(analyticsEngine, workflowBuilder)
    server.Start(processor)
}
```

### Pattern 2: Factory-Based Integration
```go
// cmd/dynamic-toolset-server/main.go
func createBusinessComponents(config *Config) (*BusinessComponents, error) {
    components := &BusinessComponents{
        Analytics:       createAnalyticsEngine(config),
        WorkflowBuilder: createWorkflowBuilder(config),
    }
    return components, components.Validate()
}
```

### Pattern 3: Interface-Based Integration
```go
// Integration point
func integrateBusinessLogic(engine WorkflowEngine, config *Config) {
    analytics := insights.NewAnalyticsEngine(config.Analytics)
    patterns := intelligence.NewPatternMatcher(config.Patterns)

    engine.SetAnalyticsEngine(analytics)
    engine.SetPatternMatcher(patterns)
}
```

## Anti-Patterns - FORBIDDEN

### Test-Only Business Code
```go
// ‚ùå WRONG: Business code only used in tests
func TestAnalytics(t *testing.T) {
    engine := insights.NewAnalyticsEngine() // Only used here!
}

// ‚úÖ CORRECT: Business code used in main application
func main() {
    engine := insights.NewAnalyticsEngine()
    processor.SetAnalyticsEngine(engine)
}
```

### Mock-Only Interfaces
```go
// ‚ùå WRONG: Interface only implemented by mocks
type BusinessService interface { Process() error }
type MockBusinessService struct{}  // Only implementation

// ‚úÖ CORRECT: Real implementation used in main
type RealBusinessService struct{}
func main() {
    service := &RealBusinessService{}
    app.SetBusinessService(service)
}
```

## Prevention-Focused Integration

### Integration Verification Through APDC
**Prevention-focused approach**:
1. **APDC Analysis**: Search for existing components and usage patterns
2. **APDC Plan**: Design integration points before implementation begins
3. **APDC Do-GREEN**: Integrate component during GREEN phase (mandatory)
4. **APDC Check**: Verify integration success through main app validation

### Integration Success Indicators
**Built-in quality indicators**:
- ‚úÖ Component instantiated in main application entry points
- ‚úÖ Runtime execution path confirmed in normal workflows
- ‚úÖ Dependency chain properly wired in main application
- ‚úÖ Business errors handled in main application flow

## Enforcement Protocol

### Integration Failure Response
1. **STOP**: Halt development until integration fixed
2. **INTEGRATE**: Add component to main application
3. **VERIFY**: Confirm integration through APDC Check phase validation
4. **DOCUMENT**: Record integration approach

### Continuous Prevention
**Prevention through APDC methodology**:
- **Analysis Phase**: Identify integration points before coding
- **Plan Phase**: Design component usage in main applications
- **Do-GREEN Phase**: Mandatory integration during minimal implementation
- **Check Phase**: Verify integration success before completion

## Integration Points

**Enforces**: [00-core-development-methodology.mdc](mdc:.cursor/rules/00-core-development-methodology.mdc) integration mandate
**Supports**: [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) business requirement testing
**Priority**: MANDATORY - no business code without main application integration