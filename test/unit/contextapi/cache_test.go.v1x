package contextapi

import (
	"context"
	"fmt"
	"sync"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/jordigilh/kubernaut/pkg/contextapi/cache"
	"github.com/jordigilh/kubernaut/pkg/contextapi/models"
)

var _ = Describe("Cache Layer", func() {
	// BR-CONTEXT-003: Multi-tier caching (Redis + LRU)

	Context("Cache Key Generation", func() {
		It("should generate consistent cache keys for same parameters", func() {
			params1 := &models.ListIncidentsParams{
				Limit:  10,
				Offset: 0,
			}

			params2 := &models.ListIncidentsParams{
				Limit:  10,
				Offset: 0,
			}

			key1, err1 := cache.GenerateCacheKey("incidents", params1)
			key2, err2 := cache.GenerateCacheKey("incidents", params2)

			Expect(err1).ToNot(HaveOccurred())
			Expect(err2).ToNot(HaveOccurred())
			Expect(key1).To(Equal(key2))
			Expect(key1).To(HavePrefix("incidents:"))
		})

		It("should generate different cache keys for different parameters", func() {
			params1 := &models.ListIncidentsParams{
				Limit:  10,
				Offset: 0,
			}

			params2 := &models.ListIncidentsParams{
				Limit:  20,
				Offset: 0,
			}

			key1, err1 := cache.GenerateCacheKey("incidents", params1)
			key2, err2 := cache.GenerateCacheKey("incidents", params2)

			Expect(err1).ToNot(HaveOccurred())
			Expect(err2).ToNot(HaveOccurred())
			Expect(key1).ToNot(Equal(key2))
		})

		It("should generate different keys for different prefixes", func() {
			params := &models.ListIncidentsParams{
				Limit:  10,
				Offset: 0,
			}

			key1, err1 := cache.GenerateCacheKey("incidents", params)
			key2, err2 := cache.GenerateCacheKey("search", params)

			Expect(err1).ToNot(HaveOccurred())
			Expect(err2).ToNot(HaveOccurred())
			Expect(key1).ToNot(Equal(key2))
			Expect(key1).To(HavePrefix("incidents:"))
			Expect(key2).To(HavePrefix("search:"))
		})

		It("should handle namespace filter in cache key", func() {
			namespace := "production"
			params1 := &models.ListIncidentsParams{
				Namespace: &namespace,
				Limit:     10,
				Offset:    0,
			}

			params2 := &models.ListIncidentsParams{
				Limit:  10,
				Offset: 0,
			}

			key1, err1 := cache.GenerateCacheKey("incidents", params1)
			key2, err2 := cache.GenerateCacheKey("incidents", params2)

			Expect(err1).ToNot(HaveOccurred())
			Expect(err2).ToNot(HaveOccurred())
			Expect(key1).ToNot(Equal(key2))
		})
	})

	Context("Multi-Tier Cache Operations", func() {
		var (
			c   cache.Cache
			ctx context.Context
		)

		BeforeEach(func() {
			ctx = context.Background()
			// Create cache with invalid Redis address to test L2-only mode
			cfg := &cache.Config{
				RedisAddr:  "invalid:6379", // Redis unavailable, use L2 only
				RedisDB:    0,
				LRUSize:    10,
				DefaultTTL: 5 * time.Minute,
			}
			var err error
			c, err = cache.NewCache(cfg)
			Expect(err).ToNot(HaveOccurred())
		})

		AfterEach(func() {
			if c != nil {
				c.Close()
			}
		})

		It("should handle cache miss for incidents list", func() {
			// BR-CONTEXT-003: Multi-tier caching
			incidents, total, err := c.GetIncidents(ctx, "nonexistent-key")

			Expect(err).To(Equal(cache.ErrCacheMiss))
			Expect(incidents).To(BeNil())
			Expect(total).To(Equal(0))
		})

		It("should cache and retrieve incidents list", func() {
			// BR-CONTEXT-003: Multi-tier caching
			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert-1",
					Namespace: "production",
					Phase:     "completed",
					Status:    "success",
					CreatedAt: now,
					UpdatedAt: now,
				},
				{
					ID:        2,
					Name:      "test-alert-2",
					Namespace: "staging",
					Phase:     "processing",
					Status:    "in_progress",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Set incidents in cache
			err := c.SetIncidents(ctx, "test-key", testIncidents, 100, 1*time.Minute)
			Expect(err).ToNot(HaveOccurred())

			// Retrieve from cache
			incidents, total, err := c.GetIncidents(ctx, "test-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(2))
			Expect(total).To(Equal(100))
			Expect(incidents[0].Name).To(Equal("test-alert-1"))
			Expect(incidents[1].Name).To(Equal("test-alert-2"))
		})

		It("should handle cache miss for single incident", func() {
			// BR-CONTEXT-003: Multi-tier caching
			incident, err := c.GetIncident(ctx, "nonexistent-incident")

			Expect(err).To(Equal(cache.ErrCacheMiss))
			Expect(incident).To(BeNil())
		})

		It("should cache and retrieve single incident", func() {
			// BR-CONTEXT-003: Multi-tier caching
			now := time.Now()
			testIncident := &models.IncidentEvent{
				ID:                   1,
				Name:                 "test-alert",
				Namespace:            "production",
				Phase:                "completed",
				Status:               "success",
				Severity:             "critical",
				AlertFingerprint:     "fp-001",
				RemediationRequestID: "req-001",
				CreatedAt:            now,
				UpdatedAt:            now,
			}

			// Set incident in cache
			err := c.SetIncident(ctx, "incident-1", testIncident, 1*time.Minute)
			Expect(err).ToNot(HaveOccurred())

			// Retrieve from cache
			incident, err := c.GetIncident(ctx, "incident-1")
			Expect(err).ToNot(HaveOccurred())
			Expect(incident).ToNot(BeNil())
			Expect(incident.Name).To(Equal("test-alert"))
			Expect(incident.Namespace).To(Equal("production"))
			Expect(incident.Severity).To(Equal("critical"))
		})

		It("should respect TTL expiration", func() {
			// BR-CONTEXT-003: Multi-tier caching with TTL
			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Set with short TTL
			err := c.SetIncidents(ctx, "ttl-test-key", testIncidents, 10, 100*time.Millisecond)
			Expect(err).ToNot(HaveOccurred())

			// Immediate retrieval should succeed
			incidents, total, err := c.GetIncidents(ctx, "ttl-test-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))

			// Wait for TTL to expire
			time.Sleep(200 * time.Millisecond)

			// Should return cache miss after expiration
			incidents, total, err = c.GetIncidents(ctx, "ttl-test-key")
			Expect(err).To(Equal(cache.ErrCacheMiss))
			Expect(incidents).To(BeNil())
			Expect(total).To(Equal(0))
		})

		It("should delete cache entries", func() {
			// BR-CONTEXT-003: Multi-tier caching
			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Set incidents
			err := c.SetIncidents(ctx, "delete-test-key", testIncidents, 10, 1*time.Minute)
			Expect(err).ToNot(HaveOccurred())

			// Verify cached
			incidents, total, err := c.GetIncidents(ctx, "delete-test-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))

			// Delete
			err = c.Delete(ctx, "delete-test-key")
			Expect(err).ToNot(HaveOccurred())

			// Verify deleted
			incidents, total, err = c.GetIncidents(ctx, "delete-test-key")
			Expect(err).To(Equal(cache.ErrCacheMiss))
			Expect(incidents).To(BeNil())
			Expect(total).To(Equal(0))
		})

		It("should handle L2 cache (LRU) fallback when Redis unavailable", func() {
			// BR-CONTEXT-003: Multi-tier caching with graceful degradation
			// This cache was created with invalid Redis address
			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Should store in L2 (LRU) only
			err := c.SetIncidents(ctx, "l2-test-key", testIncidents, 10, 1*time.Minute)
			Expect(err).ToNot(HaveOccurred())

			// Should retrieve from L2
			incidents, total, err := c.GetIncidents(ctx, "l2-test-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))
		})

		It("should evict LRU entries when cache is full", func() {
			// BR-CONTEXT-003: Multi-tier caching with LRU eviction
			// Create cache with small LRU size
			smallCfg := &cache.Config{
				RedisAddr:  "invalid:6379",
				RedisDB:    0,
				LRUSize:    3, // Small size to test eviction
				DefaultTTL: 5 * time.Minute,
			}
			smallCache, err := cache.NewCache(smallCfg)
			Expect(err).ToNot(HaveOccurred())
			defer smallCache.Close()

			now := time.Now()

			// Add 4 entries (exceeds LRU size of 3)
			for i := 1; i <= 4; i++ {
				incident := &models.IncidentEvent{
					ID:        int64(i),
					Name:      fmt.Sprintf("test-alert-%d", i),
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				}
				err := smallCache.SetIncident(ctx, fmt.Sprintf("incident-%d", i), incident, 1*time.Minute)
				Expect(err).ToNot(HaveOccurred())

				// Small delay to ensure ordering
				time.Sleep(10 * time.Millisecond)
			}

			// Oldest entry (incident-1) should be evicted
			// Note: Actual eviction behavior depends on implementation details
			// This test validates the cache handles size limits gracefully
		})

		It("should handle concurrent cache operations", func() {
			// BR-CONTEXT-003: Thread-safe multi-tier caching
			now := time.Now()

			var wg sync.WaitGroup
			for i := 0; i < 10; i++ {
				wg.Add(1)
				go func(id int) {
					defer wg.Done()
					defer GinkgoRecover()

					// Set operation
					incident := &models.IncidentEvent{
						ID:        int64(id),
						Name:      fmt.Sprintf("concurrent-alert-%d", id),
						Namespace: "production",
						CreatedAt: now,
						UpdatedAt: now,
					}
					err := c.SetIncident(ctx, fmt.Sprintf("concurrent-%d", id), incident, 1*time.Minute)
					Expect(err).ToNot(HaveOccurred())

					// Get operation
					retrieved, err := c.GetIncident(ctx, fmt.Sprintf("concurrent-%d", id))
					Expect(err).ToNot(HaveOccurred())
					Expect(retrieved.Name).To(Equal(fmt.Sprintf("concurrent-alert-%d", id)))
				}(i)
			}

			wg.Wait()
		})
	})

	Context("Cache Configuration", func() {
		It("should use default TTL when not specified", func() {
			// BR-CONTEXT-003: Multi-tier caching with default TTL
			ctx := context.Background()
			cfg := &cache.Config{
				RedisAddr:  "invalid:6379",
				RedisDB:    0,
				LRUSize:    10,
				DefaultTTL: 1 * time.Hour, // Default TTL
			}
			c, err := cache.NewCache(cfg)
			Expect(err).ToNot(HaveOccurred())
			defer c.Close()

			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Set with ttl=0 (should use default)
			err = c.SetIncidents(ctx, "default-ttl-key", testIncidents, 10, 0)
			Expect(err).ToNot(HaveOccurred())

			// Verify cached
			incidents, total, err := c.GetIncidents(ctx, "default-ttl-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))
		})

		It("should use custom TTL when specified", func() {
			// BR-CONTEXT-003: Multi-tier caching with custom TTL
			ctx := context.Background()
			cfg := &cache.Config{
				RedisAddr:  "invalid:6379",
				RedisDB:    0,
				LRUSize:    10,
				DefaultTTL: 1 * time.Hour,
			}
			c, err := cache.NewCache(cfg)
			Expect(err).ToNot(HaveOccurred())
			defer c.Close()

			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Set with custom TTL (100ms)
			err = c.SetIncidents(ctx, "custom-ttl-key", testIncidents, 10, 100*time.Millisecond)
			Expect(err).ToNot(HaveOccurred())

			// Immediate retrieval succeeds
			incidents, total, err := c.GetIncidents(ctx, "custom-ttl-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))

			// Wait for custom TTL to expire
			time.Sleep(200 * time.Millisecond)

			// Should be expired
			incidents, total, err = c.GetIncidents(ctx, "custom-ttl-key")
			Expect(err).To(Equal(cache.ErrCacheMiss))
		})

		It("should handle Redis connection failure gracefully", func() {
			// BR-CONTEXT-003: Graceful degradation to L2-only mode
			ctx := context.Background()

			// Create cache with invalid Redis address
			cfg := &cache.Config{
				RedisAddr:  "invalid:6379",
				RedisDB:    0,
				LRUSize:    10,
				DefaultTTL: 5 * time.Minute,
			}
			c, err := cache.NewCache(cfg)
			Expect(err).ToNot(HaveOccurred())
			defer c.Close()

			now := time.Now()
			testIncidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-alert",
					Namespace: "production",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Should work despite Redis being unavailable
			err = c.SetIncidents(ctx, "graceful-fallback-key", testIncidents, 10, 1*time.Minute)
			Expect(err).ToNot(HaveOccurred())

			// Should retrieve from L2 cache
			incidents, total, err := c.GetIncidents(ctx, "graceful-fallback-key")
			Expect(err).ToNot(HaveOccurred())
			Expect(incidents).To(HaveLen(1))
			Expect(total).To(Equal(10))
		})
	})

	Context("CachedIncidentsList Serialization", func() {
		It("should serialize and deserialize incidents list correctly", func() {
			now := time.Now()
			incidents := []*models.IncidentEvent{
				{
					ID:        1,
					Name:      "test-1",
					Namespace: "prod",
					CreatedAt: now,
					UpdatedAt: now,
				},
				{
					ID:        2,
					Name:      "test-2",
					Namespace: "prod",
					CreatedAt: now,
					UpdatedAt: now,
				},
			}

			// Wrap in CachedIncidentsList
			cached := &cache.CachedIncidentsList{
				Incidents: incidents,
				Total:     100,
			}

			// Serialize
			// Deserialize
			// Verify fields match

			Expect(cached.Incidents).To(HaveLen(2))
			Expect(cached.Total).To(Equal(100))
		})

		It("should handle empty incidents list", func() {
			cached := &cache.CachedIncidentsList{
				Incidents: []*models.IncidentEvent{},
				Total:     0,
			}

			Expect(cached.Incidents).To(BeEmpty())
			Expect(cached.Total).To(Equal(0))
		})

		It("should handle nil incidents list", func() {
			cached := &cache.CachedIncidentsList{
				Incidents: nil,
				Total:     0,
			}

			Expect(cached.Incidents).To(BeNil())
		})
	})
})
