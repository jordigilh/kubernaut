---
globs: "*_test.go,test/**/*"
description: "Critical testing anti-patterns to avoid in kubernaut development"
---

# Testing Anti-Patterns - CRITICAL REFERENCE WITH AUTOMATED DETECTION

## ü§ñ **AUTOMATED ANTI-PATTERN DETECTION - MANDATORY**

### Detection Scripts - MANDATORY
Run these checks before ANY test commit:

```bash
# Run comprehensive cursor rule validation
./scripts/cursor-rule-validator.sh

# Individual pattern checks:
# 1. NULL-TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeEmpty())\|ToNot(BeNil())" {} \;
# VIOLATION: Any matches = immediate rejection

# 2. STATIC DATA TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \;
# VIOLATION: Testing hardcoded strings = immediate rejection

# 3. LIBRARY TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \;
# VIOLATION: Testing libraries instead of business logic = immediate rejection

# 4. BUSINESS LOGIC INTEGRATION CHECK
for file in $(find test/ -name "*_test.go"); do
  if ! grep -q "github.com/jordigilh/kubernaut/pkg/" "$file"; then
    echo "VIOLATION: $file - No business logic imports"
  fi
done
```

### Enforcement Levels - MANDATORY
- **LEVEL 1 - BLOCK COMPILATION**: Tests with anti-patterns MUST NOT compile
- **LEVEL 2 - PRE-COMMIT GATE**: Git hooks prevent commits with violations
- **LEVEL 3 - CI/CD GATE**: Pipeline fails on cursor rule violations

### Git Hook Integration - MANDATORY
```bash
#!/bin/bash
# .git/hooks/pre-commit (MANDATORY)

# Run cursor rule validation
./scripts/cursor-rule-validator.sh
if [ $? -ne 0 ]; then
    echo "‚ùå Cursor rule violations detected. Commit blocked."
    exit 1
fi

echo "‚úÖ All cursor rule validations passed"
```

---

## üö® **CRITICAL ANTI-PATTERNS - IMMEDIATE REJECTION**

### **ANTI-PATTERN 1: NULL-TESTING (MOST CRITICAL)**

**Definition**: Testing for basic existence rather than business outcomes

**‚ùå VIOLATION EXAMPLES**:
```go
// NULL-TESTING: Tests nothing meaningful
Expect(result).ToNot(BeNil())           // ‚ùå VIOLATION
Expect(result).ToNot(BeEmpty())         // ‚ùå VIOLATION
Expect(len(items)).To(BeNumerically(">", 0))  // ‚ùå VIOLATION
Expect(err).To(BeNil())                 // ‚ùå VIOLATION (weak error testing)
```

**‚úÖ CORRECT BUSINESS TESTING**:
```go
// BUSINESS OUTCOME TESTING: Tests meaningful business results
Expect(workflow.Template.SafetyValidation).To(ContainElement("resource-limits"))
Expect(analysis.ConfidenceScore).To(BeNumerically(">=", 0.8))
Expect(recommendation.Actions).To(HaveLen(3))
Expect(result.BusinessMetrics.SuccessRate).To(BeNumerically(">", 0.9))
```

**Automated Detection**:
```bash
# Detect NULL-TESTING violations
grep -r "ToNot(BeNil())\|ToNot(BeEmpty())\|BeNumerically(\">\".*0)" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 2: STATIC DATA TESTING**

**Definition**: Testing hardcoded values instead of business logic

**‚ùå VIOLATION EXAMPLES**:
```go
// STATIC DATA TESTING: Tests hardcoded strings
input := "test-alert-name"               // ‚ùå VIOLATION: Hardcoded test data
Expect(result.Name).To(Equal("test-alert-name"))  // ‚ùå VIOLATION: Static assertion

config := Config{Endpoint: "http://test"}  // ‚ùå VIOLATION: Hardcoded config
Expect(client.endpoint).To(Equal("http://test"))  // ‚ùå VIOLATION: Static testing
```

**‚úÖ CORRECT DYNAMIC TESTING**:
```go
// DYNAMIC BUSINESS TESTING: Tests business logic with realistic data
alertData := testutil.GenerateRealisticAlert()  // ‚úÖ CORRECT: Dynamic test data
workflow, err := engine.CreateWorkflow(ctx, alertData)
Expect(workflow.Template.Actions).To(ContainElement(
    MatchFields(IgnoreExtras, Fields{
        "Type": Equal("scale-deployment"),
        "Target": Equal(alertData.Resource.Name),
    }),
))
```

**Automated Detection**:
```bash
# Detect STATIC DATA TESTING violations
grep -r ".*:= \".*\".*Expect(" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 3: LIBRARY TESTING**

**Definition**: Testing external libraries instead of business logic

**‚ùå VIOLATION EXAMPLES**:
```go
// LIBRARY TESTING: Tests external library behavior
logger := logrus.New()                   // ‚ùå VIOLATION: Testing logrus
logger.SetLevel(logrus.InfoLevel)
Expect(logger.Level).To(Equal(logrus.InfoLevel))  // ‚ùå VIOLATION: Library testing

ctx := context.WithTimeout(context.Background(), time.Second)  // ‚ùå VIOLATION
Expect(ctx.Err()).To(BeNil())           // ‚ùå VIOLATION: Testing context library
```

**‚úÖ CORRECT BUSINESS TESTING**:
```go
// BUSINESS LOGIC TESTING: Tests our business components
analyticsEngine := insights.NewAnalyticsEngine(config)  // ‚úÖ CORRECT: Business component
riskAssessment, err := analyticsEngine.AssessWorkflowRisk(workflow)
Expect(riskAssessment.RiskLevel).To(BeNumerically("<", 0.3))  // ‚úÖ CORRECT: Business outcome
```

**Automated Detection**:
```bash
# Detect LIBRARY TESTING violations
grep -r "logrus\.New()\|context\.With\|os\.Set\|time\.Now()" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 4: MOCK OVERUSE**

**Definition**: Mocking business logic instead of external dependencies

**‚ùå VIOLATION EXAMPLES**:
```go
// MOCK OVERUSE: Mocking business logic
mockWorkflowEngine := &MockWorkflowEngine{}  // ‚ùå VIOLATION: Business logic mocked
mockAnalytics := &MockAnalyticsEngine{}     // ‚ùå VIOLATION: Business logic mocked
mockSafety := &MockSafetyFramework{}        // ‚ùå VIOLATION: Business logic mocked
```

**‚úÖ CORRECT MOCK USAGE**:
```go
// CORRECT MOCKING: Mock external dependencies only
mockLLMClient := mocks.NewMockLLMClient()    // ‚úÖ CORRECT: External AI service
mockK8sClient := mocks.NewMockKubernetesClient()  // ‚úÖ CORRECT: External infrastructure

// Use REAL business logic
workflowEngine := engine.NewIntelligentWorkflowBuilder(mockLLMClient, mockK8sClient)
analyticsEngine := insights.NewAnalyticsEngine(realConfig)  // ‚úÖ CORRECT: Real business logic
```

**Automated Detection**:
```bash
# Detect MOCK OVERUSE violations
grep -r "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" test/ --include="*_test.go" | grep -v "LLM\|K8s\|Database"
# Any matches = IMMEDIATE REJECTION
```

---

## üîß **AUTOMATED VALIDATION SCRIPTS**

### **Master Validation Script**
```bash
#!/bin/bash
# scripts/cursor-rule-validator.sh

set -e

echo "üîç CURSOR RULE VALIDATION - TESTING ANTI-PATTERNS"

VIOLATIONS=0

# 1. NULL-TESTING DETECTION
echo "Checking for NULL-TESTING violations..."
NULL_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeNil())\|ToNot(BeEmpty())\|BeNumerically(\">\".*0)" {} \; | wc -l)
if [ "$NULL_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå NULL-TESTING violations found: $NULL_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeNil())\|ToNot(BeEmpty())" {} \;
    VIOLATIONS=$((VIOLATIONS + NULL_VIOLATIONS))
fi

# 2. STATIC DATA TESTING DETECTION
echo "Checking for STATIC DATA TESTING violations..."
STATIC_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \; | wc -l)
if [ "$STATIC_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå STATIC DATA TESTING violations found: $STATIC_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \;
    VIOLATIONS=$((VIOLATIONS + STATIC_VIOLATIONS))
fi

# 3. LIBRARY TESTING DETECTION
echo "Checking for LIBRARY TESTING violations..."
LIBRARY_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \; | wc -l)
if [ "$LIBRARY_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå LIBRARY TESTING violations found: $LIBRARY_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \;
    VIOLATIONS=$((VIOLATIONS + LIBRARY_VIOLATIONS))
fi

# 4. BUSINESS LOGIC INTEGRATION CHECK
echo "Checking for BUSINESS LOGIC integration..."
MISSING_BUSINESS_LOGIC=0
for file in $(find test/ -name "*_test.go"); do
    if ! grep -q "github.com/jordigilh/kubernaut/pkg/" "$file"; then
        echo "‚ùå MISSING BUSINESS LOGIC: $file"
        MISSING_BUSINESS_LOGIC=$((MISSING_BUSINESS_LOGIC + 1))
    fi
done
VIOLATIONS=$((VIOLATIONS + MISSING_BUSINESS_LOGIC))

# 5. MOCK OVERUSE DETECTION
echo "Checking for MOCK OVERUSE violations..."
MOCK_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" {} \; | grep -v "LLM\|K8s\|Database" | wc -l)
if [ "$MOCK_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå MOCK OVERUSE violations found: $MOCK_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" {} \; | grep -v "LLM\|K8s\|Database"
    VIOLATIONS=$((VIOLATIONS + MOCK_VIOLATIONS))
fi

# FINAL RESULT
if [ "$VIOLATIONS" -gt 0 ]; then
    echo ""
    echo "üö® TOTAL VIOLATIONS: $VIOLATIONS"
    echo "‚ùå CURSOR RULE VALIDATION FAILED"
    echo ""
    echo "üîß REMEDIATION REQUIRED:"
    echo "1. Replace NULL-TESTING with business outcome assertions"
    echo "2. Replace static data with dynamic test data generators"
    echo "3. Replace library testing with business logic testing"
    echo "4. Add business logic imports to all test files"
    echo "5. Replace business logic mocks with real components"
    echo ""
    exit 1
else
    echo "‚úÖ ALL CURSOR RULE VALIDATIONS PASSED"
    exit 0
fi
```

### **Pre-Commit Hook Installation**
```bash
#!/bin/bash
# scripts/install-cursor-rule-hooks.sh

echo "Installing cursor rule validation hooks..."

# Create pre-commit hook
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# Cursor rule validation pre-commit hook

echo "üîç Running cursor rule validation..."

# Run cursor rule validator
./scripts/cursor-rule-validator.sh
if [ $? -ne 0 ]; then
    echo "‚ùå Cursor rule violations detected. Commit blocked."
    echo "üîß Fix violations and try again."
    exit 1
fi

echo "‚úÖ Cursor rule validation passed"
EOF

# Make hook executable
chmod +x .git/hooks/pre-commit

echo "‚úÖ Cursor rule hooks installed successfully"
```

---

## üìã **ANTI-PATTERN REMEDIATION GUIDE**

### **NULL-TESTING ‚Üí BUSINESS OUTCOME TESTING**
```go
// ‚ùå BEFORE: NULL-TESTING
Expect(result).ToNot(BeNil())

// ‚úÖ AFTER: BUSINESS OUTCOME TESTING
Expect(result.WorkflowTemplate.SafetyChecks).To(ContainElement("resource-validation"))
Expect(result.ConfidenceScore).To(BeNumerically(">=", 0.8))
```

### **STATIC DATA ‚Üí DYNAMIC DATA**
```go
// ‚ùå BEFORE: STATIC DATA
input := "test-alert"
Expect(output.Name).To(Equal("test-alert"))

// ‚úÖ AFTER: DYNAMIC DATA
alertData := testutil.GenerateRealisticAlert()
workflow, err := engine.CreateWorkflow(ctx, alertData)
Expect(workflow.SourceAlert.ID).To(Equal(alertData.ID))
```

### **LIBRARY TESTING ‚Üí BUSINESS TESTING**
```go
// ‚ùå BEFORE: LIBRARY TESTING
logger := logrus.New()
Expect(logger.Level).To(Equal(logrus.InfoLevel))

// ‚úÖ AFTER: BUSINESS TESTING
analyticsEngine := insights.NewAnalyticsEngine(config)
metrics, err := analyticsEngine.CalculateEffectiveness(workflow)
Expect(metrics.SuccessRate).To(BeNumerically(">", 0.9))
```

### **MOCK OVERUSE ‚Üí REAL BUSINESS LOGIC**
```go
// ‚ùå BEFORE: MOCK OVERUSE
mockEngine := &MockWorkflowEngine{}

// ‚úÖ AFTER: REAL BUSINESS LOGIC
mockLLMClient := mocks.NewMockLLMClient()  // Mock external only
realEngine := engine.NewIntelligentWorkflowBuilder(mockLLMClient, realConfig)
```

---

## üéØ **QUALITY GATES**

### **Commit-Level Gates**
- **Gate 1**: No NULL-TESTING patterns allowed
- **Gate 2**: No static data testing allowed
- **Gate 3**: No library testing allowed
- **Gate 4**: Business logic integration required
- **Gate 5**: Proper mock usage enforced

### **CI/CD-Level Gates**
- **Pipeline Gate**: All cursor rule validations must pass
- **Coverage Gate**: Business logic coverage requirements met
- **Quality Gate**: Anti-pattern detection score = 0

### **Release-Level Gates**
- **Final Validation**: Complete anti-pattern scan
- **Business Logic Audit**: All tests validate business outcomes
- **Mock Usage Audit**: External dependencies only

---

## üîó **INTEGRATION WITH OTHER RULES**

**Enforces**: [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) pyramid testing approach
**Supports**: [00-core-development-methodology.mdc](mdc:.cursor/rules/00-core-development-methodology.mdc) TDD methodology
**Validates**: [12-ai-ml-development-methodology.mdc](mdc:.cursor/rules/12-ai-ml-development-methodology.mdc) AI testing patterns
**Priority**: ENFORCEMENT - Automated quality gates that prevent anti-pattern violations