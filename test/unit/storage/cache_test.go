package storage

import (
	"testing"
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/storage/vector"
	. "github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to storage_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Memory Embedding Cache Unit Tests", func() {
	var (
		cache  *vector.MemoryEmbeddingCache
		logger *logrus.Logger
		ctx    context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)
		cache = vector.NewMemoryEmbeddingCache(100, logger)
		ctx = context.Background()
	})

	AfterEach(func() {
		if cache != nil {
			Expect(cache.Close()).To(Succeed())
		}
	})

	Context("Cache Creation and Configuration", func() {
		It("should create cache with specified max size", func() {
			maxSize := 50
			testCache := vector.NewMemoryEmbeddingCache(maxSize, logger)
			defer Expect(testCache.Close()).To(Succeed())

			stats := testCache.GetStats(ctx)
			Expect(stats.CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cache creation must provide functional memory storage type for database caching operations")
		})

		It("should use default max size for invalid input", func() {
			testCache := vector.NewMemoryEmbeddingCache(0, logger)
			defer Expect(testCache.Close()).To(Succeed())

			Expect(testCache.GetStats(ctx).CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cache creation with zero size must default to functional memory storage for database operations")

			testCache2 := vector.NewMemoryEmbeddingCache(-10, logger)
			defer Expect(testCache.Close()).To(Succeed())

			Expect(testCache2.GetStats(ctx).CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cache creation with negative size must default to functional memory storage for database operations")
		})

		It("should initialize with zero statistics", func() {
			stats := cache.GetStats(ctx)
			Expect(stats.Hits).To(Equal(int64(0)), "Should start with zero hits")
			Expect(stats.Misses).To(Equal(int64(0)), "Should start with zero misses")
			Expect(stats.TotalKeys).To(Equal(int64(0)), "Should start with zero keys")
			Expect(stats.HitRate).To(Equal(0.0), "Should start with zero hit rate")
		})
	})

	Context("Basic Cache Operations", func() {
		var testEmbedding []float64

		BeforeEach(func() {
			testEmbedding = []float64{0.1, 0.2, 0.3, 0.4, 0.5}
		})

		It("should store and retrieve embeddings successfully", func() {
			key := "test-key-1"
			ttl := time.Hour

			err := cache.Set(ctx, key, testEmbedding, ttl)
			Expect(err).ToNot(HaveOccurred(), "Should store embedding without error")

			embedding, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred(), "Should retrieve embedding without error")
			Expect(found).To(BeTrue(), "Should find stored embedding")
			Expect(embedding).To(Equal(testEmbedding), "Should retrieve correct embedding")
		})

		It("should return not found for non-existent keys", func() {
			embedding, found, err := cache.Get(ctx, "non-existent-key")
			Expect(err).ToNot(HaveOccurred(), "Should not error for non-existent key")
			Expect(found).To(BeFalse(), "Should not find non-existent key")
			Expect(embedding).To(BeNil(), "Should return nil embedding for non-existent key")
		})

		It("should overwrite existing keys", func() {
			key := "overwrite-test"
			embedding1 := []float64{1.0, 2.0}
			embedding2 := []float64{3.0, 4.0}

			err := cache.Set(ctx, key, embedding1, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			err = cache.Set(ctx, key, embedding2, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			retrieved, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeTrue())
			Expect(retrieved).To(Equal(embedding2), "Should retrieve latest embedding")
		})

		It("should delete existing keys", func() {
			key := "delete-test"

			err := cache.Set(ctx, key, testEmbedding, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			err = cache.Delete(ctx, key)
			Expect(err).ToNot(HaveOccurred(), "Should delete existing key without error")

			_, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeFalse(), "Should not find deleted key")
		})

		It("should handle delete of non-existent keys gracefully", func() {
			err := cache.Delete(ctx, "non-existent-key")
			Expect(err).ToNot(HaveOccurred(), "Should handle delete of non-existent key gracefully")
		})

		It("should clear all cached entries", func() {
			// Store multiple entries
			for i := 0; i < 5; i++ {
				key := fmt.Sprintf("clear-test-%d", i)
				embedding := []float64{float64(i), float64(i + 1)}
				err := cache.Set(ctx, key, embedding, time.Hour)
				Expect(err).ToNot(HaveOccurred())
			}

			stats := cache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(5)), "Should have 5 keys before clear")

			err := cache.Clear(ctx)
			Expect(err).ToNot(HaveOccurred(), "Should clear cache without error")

			stats = cache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(0)), "Should have zero keys after clear")
		})
	})

	Context("TTL and Expiration", func() {
		It("should respect TTL for cache entries", func() {
			key := "ttl-test"
			embedding := []float64{0.1, 0.2}
			shortTTL := 100 * time.Millisecond

			err := cache.Set(ctx, key, embedding, shortTTL)
			Expect(err).ToNot(HaveOccurred())

			// Should be found immediately
			_, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeTrue(), "Should find entry immediately after setting")

			// Wait for expiration
			time.Sleep(150 * time.Millisecond)

			// Should be expired now
			_, found, err = cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeFalse(), "Should not find expired entry")
		})

		It("should handle zero TTL as no expiration", func() {
			key := "no-ttl-test"
			embedding := []float64{0.1, 0.2}

			err := cache.Set(ctx, key, embedding, 0)
			Expect(err).ToNot(HaveOccurred())

			// Wait a short time
			time.Sleep(50 * time.Millisecond)

			// Should still be found (no expiration)
			_, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeTrue(), "Should find entry with zero TTL")
		})

		It("should handle negative TTL gracefully", func() {
			key := "negative-ttl-test"
			embedding := []float64{0.1, 0.2}

			err := cache.Set(ctx, key, embedding, -time.Hour)
			Expect(err).ToNot(HaveOccurred(), "Should handle negative TTL")

			// Should be expired immediately
			_, found, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeFalse(), "Should not find entry with negative TTL")
		})
	})

	Context("Cache Size Limits", func() {
		var smallCache *vector.MemoryEmbeddingCache

		BeforeEach(func() {
			smallCache = vector.NewMemoryEmbeddingCache(3, logger) // Small cache for testing
		})

		AfterEach(func() {
			if smallCache != nil {
				Expect(smallCache.Close()).To(Succeed())
			}
		})

		It("should enforce maximum cache size", func() {
			// Fill cache to capacity
			for i := 0; i < 3; i++ {
				key := fmt.Sprintf("size-test-%d", i)
				embedding := []float64{float64(i)}
				err := smallCache.Set(ctx, key, embedding, time.Hour)
				Expect(err).ToNot(HaveOccurred())
			}

			stats := smallCache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(3)), "Should have 3 keys at capacity")

			// Add one more entry (should trigger eviction)
			err := smallCache.Set(ctx, "size-test-overflow", []float64{99.0}, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			stats = smallCache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(3)), "Should still have 3 keys after eviction")
		})

		It("should evict least recently used entries", func() {
			// Fill cache
			keys := []string{"lru-1", "lru-2", "lru-3"}
			for i, key := range keys {
				embedding := []float64{float64(i)}
				err := smallCache.Set(ctx, key, embedding, time.Hour)
				Expect(err).ToNot(HaveOccurred())
			}

			// Access middle entry to make it more recent
			_, _, err := smallCache.Get(ctx, "lru-2")
			Expect(err).ToNot(HaveOccurred())

			// Add new entry (should evict lru-1, not lru-2)
			err = smallCache.Set(ctx, "lru-new", []float64{99.0}, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			// lru-1 should be evicted, lru-2 should still exist
			_, found, err := smallCache.Get(ctx, "lru-1")
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeFalse(), "LRU entry should be evicted")

			_, found, err = smallCache.Get(ctx, "lru-2")
			Expect(err).ToNot(HaveOccurred())
			Expect(found).To(BeTrue(), "Recently accessed entry should remain")
		})
	})

	Context("Statistics Tracking", func() {
		It("should track hits and misses accurately", func() {
			key := "stats-test"
			embedding := []float64{0.1, 0.2}

			// Initial miss
			_, _, err := cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())

			stats := cache.GetStats(ctx)
			Expect(stats.Misses).To(Equal(int64(1)), "Should record miss")
			Expect(stats.Hits).To(Equal(int64(0)), "Should have no hits yet")

			// Store and retrieve for hit
			err = cache.Set(ctx, key, embedding, time.Hour)
			Expect(err).ToNot(HaveOccurred())

			_, _, err = cache.Get(ctx, key)
			Expect(err).ToNot(HaveOccurred())

			stats = cache.GetStats(ctx)
			Expect(stats.Hits).To(Equal(int64(1)), "Should record hit")
			Expect(stats.Misses).To(Equal(int64(1)), "Miss count should remain")
		})

		It("should calculate hit rate correctly", func() {
			key := "hit-rate-test"
			embedding := []float64{0.1, 0.2}

			// 2 misses
			_, _, _ = cache.Get(ctx, key)           // Intentionally ignoring all return values for stats test
			_, _, _ = cache.Get(ctx, "another-key") // Intentionally ignoring all return values for stats test

			// Store and get 3 hits
			_ = cache.Set(ctx, key, embedding, time.Hour) // Intentionally ignoring error for stats test
			_, _, _ = cache.Get(ctx, key)                 // Intentionally ignoring all return values for stats test
			_, _, _ = cache.Get(ctx, key)                 // Intentionally ignoring all return values for stats test
			_, _, _ = cache.Get(ctx, key)                 // Intentionally ignoring all return values for stats test

			stats := cache.GetStats(ctx)
			expectedHitRate := 3.0 / 5.0 // 3 hits out of 5 total attempts
			Expect(stats.HitRate).To(BeNumerically("~", expectedHitRate, 0.01), "Should calculate correct hit rate")
		})

		It("should track total key count", func() {
			initialStats := cache.GetStats(ctx)
			Expect(initialStats.TotalKeys).To(Equal(int64(0)), "Should start with zero keys")

			// Add keys
			for i := 0; i < 5; i++ {
				key := fmt.Sprintf("count-test-%d", i)
				embedding := []float64{float64(i)}
				_ = cache.Set(ctx, key, embedding, time.Hour) // Intentionally ignoring error for stats test
			}

			stats := cache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(5)), "Should track total keys correctly")

			// Delete one key
			_ = cache.Delete(ctx, "count-test-2") // Intentionally ignoring error for stats test

			stats = cache.GetStats(ctx)
			Expect(stats.TotalKeys).To(Equal(int64(4)), "Should update count after deletion")
		})
	})

	Context("Concurrent Access", func() {
		It("should handle concurrent read/write operations safely", func() {
			const goroutines = 10
			const operationsPerGoroutine = 20

			done := make(chan bool, goroutines)

			for g := 0; g < goroutines; g++ {
				go func(goroutineID int) {
					defer func() { done <- true }()

					for i := 0; i < operationsPerGoroutine; i++ {
						key := fmt.Sprintf("concurrent-%d-%d", goroutineID, i)
						embedding := []float64{float64(goroutineID), float64(i)}

						// Set
						err := cache.Set(ctx, key, embedding, time.Hour)
						Expect(err).ToNot(HaveOccurred())

						// Get
						retrieved, found, err := cache.Get(ctx, key)
						Expect(err).ToNot(HaveOccurred())
						Expect(found).To(BeTrue())
						Expect(retrieved).To(Equal(embedding))
					}
				}(g)
			}

			// Wait for all goroutines
			for i := 0; i < goroutines; i++ {
				<-done
			}

			// Verify final state
			stats := cache.GetStats(ctx)
			Expect(stats.TotalKeys).To(BeNumerically(">=", 0), "Should have non-negative key count")
		})

		It("should handle concurrent statistics updates", func() {
			const goroutines = 5

			done := make(chan bool, goroutines)

			for g := 0; g < goroutines; g++ {
				go func(goroutineID int) {
					defer func() { done <- true }()

					for i := 0; i < 10; i++ {
						// Mix of hits and misses
						if i%2 == 0 {
							key := fmt.Sprintf("stats-concurrent-%d", goroutineID)
							embedding := []float64{float64(goroutineID)}
							_ = cache.Set(ctx, key, embedding, time.Hour) // Intentionally ignoring error for stats test
							_, _, _ = cache.Get(ctx, key)                 // Hit - intentionally ignoring all return values for stats test
						} else {
							_, _, _ = cache.Get(ctx, "non-existent") // Miss - intentionally ignoring all return values for stats test
						}
					}
				}(g)
			}

			// Wait for all goroutines
			for i := 0; i < goroutines; i++ {
				<-done
			}

			// Verify statistics are consistent
			stats := cache.GetStats(ctx)
			totalOperations := stats.Hits + stats.Misses
			Expect(totalOperations).To(BeNumerically(">=", goroutines*10), "Should track all operations")
		})
	})

	Context("Cache Cleanup and Shutdown", func() {
		It("should stop cleanup goroutine on close", func() {
			testCache := vector.NewMemoryEmbeddingCache(10, logger)

			// Add entry with short TTL
			err := testCache.Set(ctx, "cleanup-test", []float64{1.0}, 50*time.Millisecond)
			Expect(err).ToNot(HaveOccurred())

			// Close cache
			err = testCache.Close()
			Expect(err).ToNot(HaveOccurred(), "Should close without error")

			// Wait for cleanup period
			time.Sleep(100 * time.Millisecond)

			// Cache should be closed successfully
			// (Testing mainly that no goroutine leak occurs)
		})

		It("should handle multiple close calls gracefully", func() {
			testCache := vector.NewMemoryEmbeddingCache(10, logger)

			err := testCache.Close()
			Expect(err).ToNot(HaveOccurred(), "First close should succeed")

			err = testCache.Close()
			Expect(err).ToNot(HaveOccurred(), "Second close should not error")
		})
	})
})

var _ = Describe("Cached Embedding Service Unit Tests", func() {
	var (
		mockService   *MockEmbeddingGenerator
		mockCache     *MockEmbeddingCache
		cachedService *vector.CachedEmbeddingService
		logger        *logrus.Logger
		ctx           context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)

		// Reset all global mock state to avoid test interference
		ResetGlobalMockState()

		mockService = NewMockEmbeddingGenerator(384)
		mockCache = NewMockEmbeddingCache()
		mockCache.Reset() // Clear any previous call tracking
		cachedService = vector.NewCachedEmbeddingService(mockService, mockCache, time.Hour, logger)
		ctx = context.Background()
	})

	Context("Service Creation and Configuration", func() {
		It("should create cached service with specified TTL", func() {
			ttl := 2 * time.Hour
			service := vector.NewCachedEmbeddingService(mockService, mockCache, ttl, logger)

			Expect(service.GetCacheStats(ctx).CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cached service creation must provide functional cache backend for database embedding operations")
		})

		It("should use default TTL for zero/negative values", func() {
			service1 := vector.NewCachedEmbeddingService(mockService, mockCache, 0, logger)
			Expect(service1.GetCacheStats(ctx).CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cached service with zero TTL must provide functional cache backend for database operations")

			service2 := vector.NewCachedEmbeddingService(mockService, mockCache, -time.Hour, logger)
			Expect(service2.GetCacheStats(ctx).CacheType).To(Equal("memory"), "BR-DATABASE-001-A: Cached service with negative TTL must provide functional cache backend for database operations")
		})

		It("should enable caching by default", func() {
			text := "test caching enabled"
			mockCache.SetGetResult(nil, false, nil) // Cache miss

			_, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Should have attempted cache get immediately
			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(1), "Should attempt cache get")

			// Cache set happens asynchronously, so we need to wait a bit
			time.Sleep(10 * time.Millisecond)
			setCalls := mockCache.GetSetCalls()
			Expect(len(setCalls)).To(Equal(1), "Should attempt cache set")
		})

		It("should allow disabling caching", func() {
			cachedService.SetCacheEnabled(false)

			text := "test caching disabled"
			_, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Should not have attempted cache operations
			getCalls := mockCache.GetGetCalls()
			setCalls := mockCache.GetSetCalls()
			Expect(len(getCalls)).To(Equal(0), "Should not attempt cache get when disabled")
			Expect(len(setCalls)).To(Equal(0), "Should not attempt cache set when disabled")
		})
	})

	Context("Text Embedding Caching", func() {
		It("should return cached embedding on cache hit", func() {
			text := "cached text embedding test"
			cachedEmbedding := []float64{0.9, 0.8, 0.7}

			mockCache.SetGetResult(cachedEmbedding, true, nil) // Cache hit

			embedding, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should return cached embedding without error")
			Expect(embedding).To(Equal(cachedEmbedding), "Should return cached embedding")

			// Should not call underlying service
			serviceCalls := mockService.GetTextEmbeddingCalls()
			Expect(len(serviceCalls)).To(Equal(0), "Should not call underlying service on cache hit")
		})

		It("should generate and cache embedding on cache miss", func() {
			text := "uncached text embedding test"
			serviceEmbedding := []float64{0.1, 0.2, 0.3}

			mockCache.SetGetResult(nil, false, nil) // Cache miss
			mockService.SetTextEmbeddingResult(serviceEmbedding, nil)

			embedding, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding without error")
			Expect(embedding).To(Equal(serviceEmbedding), "Should return service embedding")

			// Should call underlying service and cache result
			serviceCalls := mockService.GetTextEmbeddingCalls()
			Expect(len(serviceCalls)).To(Equal(1), "Should call underlying service")

			// Cache set happens asynchronously, wait for it
			time.Sleep(10 * time.Millisecond)
			setCalls := mockCache.GetSetCalls()
			Expect(len(setCalls)).To(Equal(1), "Should cache the result")
		})

		It("should handle cache get errors gracefully", func() {
			text := "cache error test"
			serviceEmbedding := []float64{0.1, 0.2, 0.3}

			mockCache.SetGetResult(nil, false, fmt.Errorf("cache get error"))
			mockService.SetTextEmbeddingResult(serviceEmbedding, nil)

			embedding, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should handle cache error gracefully")
			Expect(embedding).To(Equal(serviceEmbedding), "Should return service embedding despite cache error")
		})

		It("should handle cache set errors gracefully", func() {
			text := "cache set error test"
			serviceEmbedding := []float64{0.1, 0.2, 0.3}

			mockCache.SetGetResult(nil, false, nil) // Cache miss
			mockCache.SetSetResult(fmt.Errorf("cache set error"))
			mockService.SetTextEmbeddingResult(serviceEmbedding, nil)

			embedding, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should handle cache set error gracefully")
			Expect(embedding).To(Equal(serviceEmbedding), "Should return service embedding despite cache set error")
		})

		It("should handle service errors properly", func() {
			text := "service error test"
			serviceError := fmt.Errorf("embedding service error")

			mockCache.SetGetResult(nil, false, nil) // Cache miss
			mockService.SetTextEmbeddingResult(nil, serviceError)

			_, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).To(HaveOccurred(), "Should propagate service error")
			Expect(err).To(Equal(serviceError), "Should return original service error")
		})
	})

	Context("Action Embedding Caching", func() {
		It("should cache action embeddings", func() {
			actionType := "scale"
			parameters := map[string]interface{}{"replicas": 5}
			cachedEmbedding := []float64{0.5, 0.6, 0.7}

			mockCache.SetGetResult(cachedEmbedding, true, nil)

			embedding, err := cachedService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred())
			Expect(embedding).To(Equal(cachedEmbedding))

			// Verify cache was checked
			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(1), "Should check cache for action embedding")
		})

		It("should generate action embeddings on cache miss", func() {
			actionType := "restart"
			parameters := map[string]interface{}{"timeout": 30}
			serviceEmbedding := []float64{0.3, 0.4, 0.5}

			mockCache.SetGetResult(nil, false, nil)
			mockService.SetActionEmbeddingResult(serviceEmbedding, nil)

			embedding, err := cachedService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred())
			Expect(embedding).To(Equal(serviceEmbedding))

			serviceCalls := mockService.GetActionEmbeddingCalls()
			Expect(len(serviceCalls)).To(Equal(1), "Should call service")

			// Cache set happens asynchronously, wait for it
			time.Sleep(10 * time.Millisecond)
			setCalls := mockCache.GetSetCalls()
			Expect(len(setCalls)).To(Equal(1), "Should cache result")
		})
	})

	Context("Context Embedding Caching", func() {
		It("should cache context embeddings", func() {
			labels := map[string]string{"app": "test"}
			metadata := map[string]interface{}{"cpu": 50}
			cachedEmbedding := []float64{0.7, 0.8, 0.9}

			mockCache.SetGetResult(cachedEmbedding, true, nil)

			embedding, err := cachedService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred())
			Expect(embedding).To(Equal(cachedEmbedding))
		})

		It("should generate context embeddings on cache miss", func() {
			labels := map[string]string{"tier": "production"}
			metadata := map[string]interface{}{"memory": 1024}
			serviceEmbedding := []float64{0.4, 0.5, 0.6}

			mockCache.SetGetResult(nil, false, nil)
			mockService.SetContextEmbeddingResult(serviceEmbedding, nil)

			embedding, err := cachedService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred())
			Expect(embedding).To(Equal(serviceEmbedding))
		})
	})

	Context("Cache Key Generation", func() {
		It("should generate consistent cache keys for same input", func() {
			text := "consistent key test"

			mockCache.SetGetResult(nil, false, nil)

			// Generate embedding twice
			_, _ = cachedService.GenerateTextEmbedding(ctx, text) // Intentionally ignoring return for cache behavior test
			_, _ = cachedService.GenerateTextEmbedding(ctx, text) // Intentionally ignoring return for cache behavior test

			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(2), "Should have two get calls")
			Expect(getCalls[0].Key).To(Equal(getCalls[1].Key), "Should use same cache key for same input")
		})

		It("should generate different cache keys for different inputs", func() {
			text1 := "first text"
			text2 := "second text"

			mockCache.SetGetResult(nil, false, nil)

			_, _ = cachedService.GenerateTextEmbedding(ctx, text1) // Intentionally ignoring return for cache behavior test
			_, _ = cachedService.GenerateTextEmbedding(ctx, text2) // Intentionally ignoring return for cache behavior test

			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(2), "Should have two get calls")
			Expect(getCalls[0].Key).ToNot(Equal(getCalls[1].Key), "Should use different cache keys for different inputs")
		})

		It("should generate different cache keys for different embedding types", func() {
			mockCache.SetGetResult(nil, false, nil)

			// Generate different types of embeddings with similar content
			_, _ = cachedService.GenerateTextEmbedding(ctx, "test")                                    // Intentionally ignoring return for cache behavior test
			_, _ = cachedService.GenerateActionEmbedding(ctx, "test", nil)                             // Intentionally ignoring return for cache behavior test
			_, _ = cachedService.GenerateContextEmbedding(ctx, map[string]string{"test": "test"}, nil) // Intentionally ignoring return for cache behavior test

			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(3), "Should have three get calls")

			// All keys should be different
			keys := make(map[string]bool)
			for _, call := range getCalls {
				Expect(keys[call.Key]).To(BeFalse(), "Cache keys should be unique")
				keys[call.Key] = true
			}
		})
	})

	Context("Cache Bypass Scenarios", func() {
		It("should bypass cache when nil cache provided", func() {
			serviceWithoutCache := vector.NewCachedEmbeddingService(mockService, nil, time.Hour, logger)
			text := "no cache test"

			_, err := serviceWithoutCache.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Should call service directly
			serviceCalls := mockService.GetTextEmbeddingCalls()
			Expect(len(serviceCalls)).To(Equal(1), "Should call service directly when no cache")
		})

		It("should bypass cache when disabled", func() {
			cachedService.SetCacheEnabled(false)
			text := "disabled cache test"

			_, err := cachedService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Should not attempt cache operations
			getCalls := mockCache.GetGetCalls()
			Expect(len(getCalls)).To(Equal(0), "Should not attempt cache get when disabled")
		})
	})

	Context("Delegation Methods", func() {
		It("should delegate combination to underlying service", func() {
			embedding1 := []float64{1.0, 2.0}
			embedding2 := []float64{3.0, 4.0}

			combined := cachedService.CombineEmbeddings(embedding1, embedding2)

			// Should delegate to underlying service
			expectedCombined := mockService.CombineEmbeddings(embedding1, embedding2)
			Expect(combined).To(Equal(expectedCombined), "Should delegate to underlying service")
		})

		It("should delegate dimension to underlying service", func() {
			dimension := cachedService.GetEmbeddingDimension()
			expectedDimension := mockService.GetEmbeddingDimension()

			Expect(dimension).To(Equal(expectedDimension), "Should delegate dimension to underlying service")
		})
	})

	Context("TTL Handling", func() {
		It("should use configured TTL for cache entries", func() {
			ttl := 30 * time.Minute
			serviceWithCustomTTL := vector.NewCachedEmbeddingService(mockService, mockCache, ttl, logger)

			text := "custom ttl test"
			mockCache.SetGetResult(nil, false, nil)

			_, err := serviceWithCustomTTL.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Cache set happens asynchronously, wait for it
			time.Sleep(10 * time.Millisecond)
			setCalls := mockCache.GetSetCalls()
			Expect(len(setCalls)).To(Equal(1), "Should set cache entry")
			Expect(setCalls[0].TTL).To(Equal(ttl), "Should use configured TTL")
		})
	})
})

// TestRunner bootstraps the Ginkgo test suite
func TestUcache(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Ucache Suite")
}
