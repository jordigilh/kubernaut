// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
)

// Handler handles operations described by OpenAPI v3 specification.
type Handler interface {
	// CreateAuditEvent implements createAuditEvent operation.
	//
	// Persists a unified audit event to the audit_events table (ADR-034).
	// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
	// **Behavior**:
	// - Success: Returns 201 Created with event_id
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
	//
	// POST /api/v1/audit/events
	CreateAuditEvent(ctx context.Context, req *AuditEventRequest) (CreateAuditEventRes, error)
	// CreateAuditEventsBatch implements createAuditEventsBatch operation.
	//
	// Write multiple audit events in a single request.
	//
	// POST /api/v1/audit/events/batch
	CreateAuditEventsBatch(ctx context.Context, req []AuditEventRequest) (*BatchAuditEventResponse, error)
	// CreateNotificationAudit implements createNotificationAudit operation.
	//
	// Persists a notification delivery attempt audit record.
	// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
	// **Behavior**:
	// - Success: Returns 201 Created with created record
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Duplicate: Returns 409 Conflict (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
	// **Metrics Emitted** (GAP-10):
	// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
	// - `datastorage_audit_lag_seconds{service="notification"}`
	// - `datastorage_write_duration_seconds{table="notification_audit"}`
	// - `datastorage_validation_failures_total{field="...", reason="..."}`.
	//
	// POST /api/v1/audit/notifications
	CreateNotificationAudit(ctx context.Context, req *NotificationAudit) (CreateNotificationAuditRes, error)
	// CreateWorkflow implements createWorkflow operation.
	//
	// Register a new workflow by providing an OCI image pullspec.
	// Data Storage pulls the image, extracts /workflow-schema.yaml (ADR-043),
	// validates the schema, and populates all catalog fields from it.
	// **Business Requirement**: BR-WORKFLOW-017-001 (OCI-based workflow registration)
	// **Design Decision**: DD-WORKFLOW-017 (Workflow Lifecycle Component Interactions).
	//
	// POST /api/v1/workflows
	CreateWorkflow(ctx context.Context, req *CreateWorkflowFromOCIRequest) (CreateWorkflowRes, error)
	// DeprecateWorkflow implements deprecateWorkflow operation.
	//
	// Mark a workflow as deprecated. Deprecated workflows are excluded from
	// discovery results but remain in the catalog for audit history.
	// **Design Decision**: DD-WORKFLOW-017 Phase 4.4 (Lifecycle PATCH endpoints).
	//
	// PATCH /api/v1/workflows/{workflow_id}/deprecate
	DeprecateWorkflow(ctx context.Context, req *WorkflowLifecycleRequest, params DeprecateWorkflowParams) (DeprecateWorkflowRes, error)
	// DisableWorkflow implements disableWorkflow operation.
	//
	// Convenience endpoint to disable a workflow (soft delete).
	// Sets status to 'disabled' with timestamp and reason.
	// **Design Decision**: DD-WORKFLOW-012, DD-WORKFLOW-017 Phase 4.4.
	//
	// PATCH /api/v1/workflows/{workflow_id}/disable
	DisableWorkflow(ctx context.Context, req *WorkflowLifecycleRequest, params DisableWorkflowParams) (DisableWorkflowRes, error)
	// EnableWorkflow implements enableWorkflow operation.
	//
	// Re-enable a previously disabled or deprecated workflow.
	// Sets status to 'active' with timestamp and reason.
	// **Design Decision**: DD-WORKFLOW-017 Phase 4.4 (Lifecycle PATCH endpoints).
	//
	// PATCH /api/v1/workflows/{workflow_id}/enable
	EnableWorkflow(ctx context.Context, req *WorkflowLifecycleRequest, params EnableWorkflowParams) (EnableWorkflowRes, error)
	// ExportAuditEvents implements exportAuditEvents operation.
	//
	// Exports audit events matching the specified filters with cryptographic signatures
	// for tamper detection and compliance verification.
	// **Business Requirement**: BR-AUDIT-007 (Audit Export)
	// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
	// **Behavior**:
	// - Success: Returns 200 OK with signed export (JSON or CSV)
	// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
	// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
	// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
	// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
	// **Export Formats**:
	// - JSON: Complete event data with hash chain verification
	// - CSV: Flattened tabular format for spreadsheet analysis
	// **Hash Chain Verification**:
	// - Each export includes hash chain integrity status
	// - Tampered events flagged with `hash_chain_valid: false`
	// - Chain verification performed at export time
	// **Digital Signature**:
	// - Export signed with service x509 certificate
	// - Signature included in `export_metadata.signature` field
	// - Detached signature available via `include_detached_signature=true`
	// **Pagination**:
	// - Use `offset` and `limit` for large result sets
	// - Maximum limit: 10,000 events per export
	// - Signature covers ALL pages (use same query for verification)
	// **Metrics Emitted**:
	// - `datastorage_export_successes_total{format="json|csv"}`
	// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
	//
	// GET /api/v1/audit/export
	ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (ExportAuditEventsRes, error)
	// GetEffectivenessScore implements getEffectivenessScore operation.
	//
	// Computes the weighted effectiveness score for a given remediation lifecycle
	// from component audit events in the audit trail.
	// **Architecture**: Per ADR-EM-001 Principle 5, DataStorage computes the overall score.
	// The Effectiveness Monitor emits raw component assessment events; this endpoint
	// aggregates them and applies the DD-017 v2.1 scoring formula:
	// score = (health_score * 0.40 + alert_score * 0.35 + metrics_score * 0.25) / total_weight
	// **Business Requirements**: BR-EM-001 to BR-EM-004
	// **Response includes**:
	// - Weighted overall score (0.0 to 1.0)
	// - Individual component scores (health, alert, metrics)
	// - Hash comparison data (pre/post remediation spec hash per DD-EM-002)
	// - Assessment status (no_data, in_progress, EffectivenessAssessed)
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	//
	// GET /api/v1/effectiveness/{correlation_id}
	GetEffectivenessScore(ctx context.Context, params GetEffectivenessScoreParams) (GetEffectivenessScoreRes, error)
	// GetMetrics implements getMetrics operation.
	//
	// Exposes Prometheus metrics in text format.
	// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
	// - `datastorage_audit_traces_total{service,status}` - Audit write operations
	// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
	// - `datastorage_write_duration_seconds{table}` - Database write latency
	// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
	//
	// GET /metrics
	GetMetrics(ctx context.Context) (GetMetricsOK, error)
	// GetRemediationHistoryContext implements getRemediationHistoryContext operation.
	//
	// Returns structured remediation history context for LLM prompt enrichment.
	// **Business Requirements**: BR-HAPI-016 (Remediation history context)
	// **Design Document**: DD-HAPI-016
	// **Behavior**:
	// Aggregates `remediation.workflow_created` (RO) and `effectiveness.assessment.completed` (EM)
	// audit events into structured remediation chains for a target resource.
	// **Two-Tier Query Design**:
	// - **Tier 1** (default 24h): Detailed remediation chain with health checks, metric deltas,
	// and full effectiveness data for the target resource.
	// - **Tier 2** (default 90d): Summary chain activated when `currentSpecHash` matches a
	// historical `preRemediationSpecHash` beyond the Tier 1 window, indicating configuration
	// regression.
	// **Hash Comparison**: For each entry, performs three-way comparison of `currentSpecHash`
	// against `preRemediationSpecHash` and `postRemediationSpecHash`.
	// **Regression Detection**: Sets `regressionDetected: true` if any entry's
	// `preRemediationSpecHash` matches `currentSpecHash`.
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	// Integration tests use mock X-Auth-Request-User header.
	//
	// GET /api/v1/remediation-history/context
	GetRemediationHistoryContext(ctx context.Context, params GetRemediationHistoryContextParams) (GetRemediationHistoryContextRes, error)
	// GetWorkflowByID implements getWorkflowByID operation.
	//
	// Retrieve a specific workflow by its UUID.
	// Step 3 of the three-step workflow discovery protocol when context filters are provided.
	// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key)
	// **Security Gate**: DD-WORKFLOW-016, DD-HAPI-017
	// **Without context filters**: Returns workflow by ID (existing behavior).
	// **With context filters**: Returns workflow only if it matches the signal context.
	// Returns 404 if the workflow exists but does not match the context filters
	// (security gate - prevents info leakage by not distinguishing "not found" from "filtered out").
	// Emits `workflow.catalog.workflow_retrieved` audit event when context filters are present.
	//
	// GET /api/v1/workflows/{workflow_id}
	GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (GetWorkflowByIDRes, error)
	// HealthCheck implements healthCheck operation.
	//
	// Returns 200 if service is healthy (database and Redis reachable).
	// Used by Kubernetes liveness probe (DD-007).
	//
	// GET /health
	HealthCheck(ctx context.Context) (HealthCheckRes, error)
	// ListAvailableActions implements listAvailableActions operation.
	//
	// Step 1 of the three-step workflow discovery protocol.
	// Returns action types from the taxonomy that have active workflows matching
	// the provided signal context filters.
	// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
	// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
	// **Behavior**:
	// - Queries action_type_taxonomy joined with remediation_workflow_catalog
	// - Filters by active workflows matching signal context (severity, component, environment, priority)
	// - Returns action types with descriptions and workflow counts
	// - Paginated (default 10 per page)
	// - Emits `workflow.catalog.actions_listed` audit event (DD-WORKFLOW-014 v3.0).
	//
	// GET /api/v1/workflows/actions
	ListAvailableActions(ctx context.Context, params ListAvailableActionsParams) (ListAvailableActionsRes, error)
	// ListLegalHolds implements listLegalHolds operation.
	//
	// Returns a list of all active legal holds across all audit events.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with array of active legal holds
	// - No holds: Returns empty array
	// **Authorization**: No authentication required (read-only operation)
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="list"}`.
	//
	// GET /api/v1/audit/legal-hold
	ListLegalHolds(ctx context.Context) (*ListLegalHoldsOK, error)
	// ListWorkflows implements listWorkflows operation.
	//
	// List workflows with optional filters and pagination.
	// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
	//
	// GET /api/v1/workflows
	ListWorkflows(ctx context.Context, params ListWorkflowsParams) (ListWorkflowsRes, error)
	// ListWorkflowsByActionType implements listWorkflowsByActionType operation.
	//
	// Step 2 of the three-step workflow discovery protocol.
	// Returns all active workflows matching the specified action type and
	// signal context filters.
	// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
	// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
	// **LLM Instruction**: The LLM MUST review ALL workflows (across all pages)
	// before selecting one. Do not select from an incomplete list.
	// **Behavior**:
	// - Filters by action_type + signal context (severity, component, environment, priority)
	// - Excludes disabled and deprecated workflows
	// - Returns workflow metadata including effectiveness data
	// - Paginated (default 10 per page)
	// - Emits `workflow.catalog.workflows_listed` audit event (DD-WORKFLOW-014 v3.0).
	//
	// GET /api/v1/workflows/actions/{action_type}
	ListWorkflowsByActionType(ctx context.Context, params ListWorkflowsByActionTypeParams) (ListWorkflowsByActionTypeRes, error)
	// LivenessCheck implements livenessCheck operation.
	//
	// Returns 200 if service process is alive.
	// Does not check dependencies.
	// Used by Kubernetes liveness probe.
	//
	// GET /health/live
	LivenessCheck(ctx context.Context) error
	// PlaceLegalHold implements placeLegalHold operation.
	//
	// Places a legal hold on all audit events for a given correlation_id.
	// Events with legal hold cannot be deleted (enforced by database trigger).
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
	// **Behavior**:
	// - Success: Returns 200 OK with legal hold metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who placed the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="place"}`
	// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
	//
	// POST /api/v1/audit/legal-hold
	PlaceLegalHold(ctx context.Context, req *PlaceLegalHoldReq) (PlaceLegalHoldRes, error)
	// QueryAuditEvents implements queryAuditEvents operation.
	//
	// Query audit events with filters and pagination.
	//
	// GET /api/v1/audit/events
	QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (*AuditEventsQueryResponse, error)
	// ReadinessCheck implements readinessCheck operation.
	//
	// Returns 200 if service is ready to accept traffic.
	// Returns 503 during graceful shutdown (DD-007 4-step pattern).
	// Used by Kubernetes readiness probe.
	//
	// GET /health/ready
	ReadinessCheck(ctx context.Context) (ReadinessCheckRes, error)
	// ReconstructRemediationRequest implements reconstructRemediationRequest operation.
	//
	// Reconstructs a complete RemediationRequest CRD from audit trail events.
	// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
	// **Workflow**:
	// 1. Query audit events for given correlation_id
	// 2. Parse gateway and orchestrator events
	// 3. Map audit data to RR Spec/Status fields
	// 4. Build complete Kubernetes-compliant CRD
	// 5. Validate completeness and quality
	// **Use Cases**:
	// - Disaster recovery (recreate lost RRs from audit trail)
	// - Compliance audits (prove RR state at any point in time)
	// - Debugging (understand RR evolution from audit events)
	// **Returns**:
	// - Reconstructed RR in YAML format
	// - Validation result (completeness percentage, warnings, errors)
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	// Integration tests use mock X-Auth-Request-User header.
	//
	// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
	ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (ReconstructRemediationRequestRes, error)
	// ReleaseLegalHold implements releaseLegalHold operation.
	//
	// Releases a legal hold on all audit events for a given correlation_id.
	// Events can be deleted after legal hold is released.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with release metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if legal hold doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who released the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="release"}`
	// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
	//
	// DELETE /api/v1/audit/legal-hold/{correlation_id}
	ReleaseLegalHold(ctx context.Context, req *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (ReleaseLegalHoldRes, error)
	// UpdateWorkflow implements updateWorkflow operation.
	//
	// Update mutable workflow fields (status, metrics).
	// Immutable fields (description, content, labels) require creating a new version.
	// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
	//
	// PATCH /api/v1/workflows/{workflow_id}
	UpdateWorkflow(ctx context.Context, req *WorkflowUpdateRequest, params UpdateWorkflowParams) (UpdateWorkflowRes, error)
}

// Server implements http server based on OpenAPI v3 specification and
// calls Handler to handle requests.
type Server struct {
	h Handler
	baseServer
}

// NewServer creates new Server.
func NewServer(h Handler, opts ...ServerOption) (*Server, error) {
	s, err := newServerConfig(opts...).baseServer()
	if err != nil {
		return nil, err
	}
	return &Server{
		h:          h,
		baseServer: s,
	}, nil
}
