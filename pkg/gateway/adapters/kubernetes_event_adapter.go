/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package adapters

import (
	"context"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/jordigilh/kubernaut/pkg/gateway/types"
)

// KubernetesEventAdapter converts Kubernetes Event API signals to NormalizedSignal
//
// Kubernetes Events are generated by the K8s control plane and controllers to record
// state changes and issues. This adapter handles:
// - Warning events (OOMKilled, FailedScheduling, BackOff, etc.)
// - Error-level events (container crashes, resource conflicts)
// - Normal events are FILTERED OUT (informational only, no remediation needed)
//
// Business Value:
// - Complements Prometheus alerts with cluster-internal failures
// - Provides immediate notification (no scrape interval delay)
// - Enables remediation for events Prometheus doesn't detect (scheduler issues, API server errors)
//
// Design Decision: Event API vs Watch
// - V1: HTTP POST endpoint /api/v1/signals/kubernetes-event (consistent with Prometheus adapter)
// - V2: Consider watch-based ingestion if needed (more complex, real-time)
type KubernetesEventAdapter struct {
	name        string
	version     string
	description string
}

// kubernetesEvent represents the minimal K8s Event structure we need to parse
//
// Full Event API structure is large (~30 fields). We only extract what's needed
// for signal normalization and remediation targeting.
type kubernetesEvent struct {
	Type    string `json:"type"`    // "Normal", "Warning", "Error"
	Reason  string `json:"reason"`  // "OOMKilled", "FailedScheduling", etc.
	Message string `json:"message"` // Human-readable description

	// InvolvedObject identifies which resource triggered the event
	InvolvedObject struct {
		Kind            string `json:"kind"`            // "Pod", "Node", "Deployment", etc.
		Namespace       string `json:"namespace"`       // Namespace (empty for cluster-scoped)
		Name            string `json:"name"`            // Resource name
		UID             string `json:"uid"`             // Resource UID
		APIVersion      string `json:"apiVersion"`      // API version
		ResourceVersion string `json:"resourceVersion"` // Resource version
	} `json:"involvedObject"`

	// Timestamps
	FirstTimestamp time.Time `json:"firstTimestamp"` // First occurrence
	LastTimestamp  time.Time `json:"lastTimestamp"`  // Most recent occurrence
	Count          int       `json:"count"`          // Number of occurrences

	// Source information
	Source struct {
		Component string `json:"component"` // "kubelet", "scheduler", etc.
		Host      string `json:"host"`      // Node name
	} `json:"source"`
}

// NewKubernetesEventAdapter creates a new Kubernetes Event adapter
func NewKubernetesEventAdapter() *KubernetesEventAdapter {
	return &KubernetesEventAdapter{
		name:        "kubernetes-event",
		version:     "1.0",
		description: "Handles Kubernetes Event API signals (Warning/Error types)",
	}
}

// Name returns the adapter identifier
func (a *KubernetesEventAdapter) Name() string {
	return a.name
}

// GetRoute returns the HTTP route for Kubernetes Events
//
// Kubernetes Event sources can POST events to this endpoint:
// - Event watchers (custom controllers observing Event API)
// - Event forwarders (tools that convert watch to webhook)
// - Test/integration scenarios
func (a *KubernetesEventAdapter) GetRoute() string {
	return "/api/v1/signals/kubernetes-event"
}

// GetSourceService returns the monitoring system name (BR-GATEWAY-027)
//
// Returns "kubernetes-events" (the monitoring system) instead of "k8s-event-adapter" (the adapter name).
// The LLM uses this to select appropriate investigation tools:
// - signal_source="kubernetes-events" → LLM uses kubectl for investigation
//
// This is the SOURCE MONITORING SYSTEM, not the adapter implementation name.
func (a *KubernetesEventAdapter) GetSourceService() string {
	return "kubernetes-events"
}

// GetSourceType returns the signal type identifier
//
// Returns "kubernetes-event" to distinguish Kubernetes events from other signal types.
// Used for metrics, logging, and signal classification.
func (a *KubernetesEventAdapter) GetSourceType() string {
	return SourceTypeWebhook // K8s events arrive via webhook/API
}

// Parse converts Kubernetes Event JSON to NormalizedSignal
//
// Parsing flow:
// 1. Unmarshal JSON to kubernetesEvent struct
// 2. Validate required fields (type, reason, involvedObject)
// 3. Filter event types (only Warning/Error, skip Normal)
// 4. Map event severity (Warning → warning, Error → critical)
// 5. Extract resource information for remediation targeting
// 6. Generate fingerprint for deduplication
// 7. Populate NormalizedSignal
//
// Returns:
// - NormalizedSignal: Unified format for Gateway processing
// - error: Parse/validation errors
func (a *KubernetesEventAdapter) Parse(ctx context.Context, rawData []byte) (*types.NormalizedSignal, error) {
	// 1. Unmarshal JSON
	var event kubernetesEvent
	if err := json.Unmarshal(rawData, &event); err != nil {
		return nil, fmt.Errorf("invalid JSON: %w", err)
	}

	// 2. Validate required fields
	if event.Reason == "" {
		return nil, fmt.Errorf("missing reason field")
	}
	if event.InvolvedObject.Kind == "" {
		return nil, fmt.Errorf("missing involvedObject.kind field")
	}
	if event.InvolvedObject.Name == "" {
		return nil, fmt.Errorf("missing involvedObject.name field")
	}

	// 3. Filter event types (business logic: only Warning/Error need remediation)
	if event.Type == "Normal" {
		return nil, fmt.Errorf("normal events not processed (informational only)")
	}
	if event.Type != "Warning" && event.Type != "Error" {
		return nil, fmt.Errorf("unsupported event type: %s (expected Warning or Error)", event.Type)
	}

	// 4. Map event severity
	severity := a.mapSeverity(event.Type, event.Reason)

	// 5. Extract resource information
	resource := types.ResourceIdentifier{
		Kind:      event.InvolvedObject.Kind,
		Name:      event.InvolvedObject.Name,
		Namespace: event.InvolvedObject.Namespace,
	}

	// 6. Generate fingerprint for deduplication
	// Format: SHA256(reason:namespace:kind:name)
	// Same resource + same reason = same fingerprint = deduplicated
	fingerprint := a.generateFingerprint(event.Reason, event.InvolvedObject.Namespace,
		event.InvolvedObject.Kind, event.InvolvedObject.Name)

	// 7. Populate NormalizedSignal
	signal := &types.NormalizedSignal{
		Fingerprint:  fingerprint,
		AlertName:    event.Reason, // "OOMKilled", "FailedScheduling", etc.
		Severity:     severity,
		Namespace:    event.InvolvedObject.Namespace,
		Resource:     resource,
		Labels:       a.extractLabels(event),
		Annotations:  a.extractAnnotations(event),
		FiringTime:   event.FirstTimestamp,
		ReceivedTime: time.Now(),
		SourceType:   a.GetSourceType(),
		Source:       a.GetSourceService(),
		RawPayload:   rawData, // Preserve for audit trail
	}

	return signal, nil
}

// Validate checks if the parsed signal meets requirements
//
// Validation rules:
// - AlertName must be populated
// - Fingerprint must be populated
// - Severity must be valid (critical/warning/info)
// - Resource kind and name must be populated
func (a *KubernetesEventAdapter) Validate(signal *types.NormalizedSignal) error {
	if signal.AlertName == "" {
		return fmt.Errorf("alertName is required")
	}
	if signal.Fingerprint == "" {
		return fmt.Errorf("fingerprint is required")
	}
	if signal.Severity != "critical" && signal.Severity != "warning" && signal.Severity != "info" {
		return fmt.Errorf("invalid severity: %s (must be critical/warning/info)", signal.Severity)
	}
	if signal.Resource.Kind == "" {
		return fmt.Errorf("resource kind is required")
	}
	if signal.Resource.Name == "" {
		return fmt.Errorf("resource name is required")
	}

	return nil
}

// GetMetadata returns adapter information for observability
func (a *KubernetesEventAdapter) GetMetadata() AdapterMetadata {
	return AdapterMetadata{
		Name:                  a.name,
		Version:               a.version,
		Description:           a.description,
		SupportedContentTypes: []string{"application/json"},
		RequiredHeaders:       []string{"Authorization"}, // Bearer token required
	}
}

// mapSeverity maps Kubernetes Event types to normalized severity levels
//
// Mapping rules:
// - Error + critical reasons (OOMKilled, NodeNotReady) → "critical"
// - Warning + high-impact reasons (FailedScheduling) → "critical"
// - Warning + normal reasons (BackOff, Unhealthy) → "warning"
// - All other warnings → "warning"
func (a *KubernetesEventAdapter) mapSeverity(eventType, reason string) string {
	// Critical event reasons (require immediate attention)
	criticalReasons := map[string]bool{
		"OOMKilled":        true, // Pod killed due to memory
		"NodeNotReady":     true, // Node unavailable
		"FailedScheduling": true, // Pod cannot be scheduled
		"Evicted":          true, // Pod evicted from node
		"FailedMount":      true, // Volume mount failed
		"NetworkNotReady":  true, // Network plugin issue
	}

	// Check if reason is critical
	if criticalReasons[reason] {
		return "critical"
	}

	// Error events are critical by default
	if eventType == "Error" {
		return "critical"
	}

	// All other warnings
	return "warning"
}

// generateFingerprint creates a unique identifier for deduplication
//
// Fingerprint format: SHA256(reason:namespace:kind:name)
//
// Examples:
// - "OOMKilled:production:Pod:payment-api" → SHA256 hash
// - "DiskPressure::Node:worker-1" → SHA256 hash (empty namespace for cluster-scoped)
//
// Design Decision: Why include reason in fingerprint?
// - Same resource can have multiple failure types simultaneously
// - Example: Pod can be OOMKilled AND BackOff at same time
// - Different reasons = different remediation strategies
func (a *KubernetesEventAdapter) generateFingerprint(reason, namespace, kind, name string) string {
	// Build fingerprint string
	fingerprintStr := fmt.Sprintf("%s:%s:%s:%s", reason, namespace, kind, name)

	// Hash with SHA256
	hash := sha256.Sum256([]byte(fingerprintStr))
	return fmt.Sprintf("%x", hash)
}

// extractLabels extracts labels from Kubernetes Event for CRD propagation
//
// Labels enable:
// - Controller filtering (label selectors)
// - Team/ownership tracking
// - Environment classification
func (a *KubernetesEventAdapter) extractLabels(event kubernetesEvent) map[string]string {
	labels := make(map[string]string)

	// Add source component as label
	if event.Source.Component != "" {
		labels["kubernaut.ai/event-source"] = event.Source.Component
	}

	// Add event type as label
	labels["kubernaut.ai/event-type"] = strings.ToLower(event.Type)

	// Add resource kind as label (for filtering)
	labels["kubernaut.ai/resource-kind"] = strings.ToLower(event.InvolvedObject.Kind)

	return labels
}

// extractAnnotations extracts annotations from Kubernetes Event
//
// Annotations provide additional context:
// - Human-readable message
// - Event count (how many times fired)
// - Source host (which node)
func (a *KubernetesEventAdapter) extractAnnotations(event kubernetesEvent) map[string]string {
	annotations := make(map[string]string)

	// Add event message
	if event.Message != "" {
		annotations["kubernaut.ai/event-message"] = event.Message
	}

	// Add event count
	if event.Count > 0 {
		annotations["kubernaut.ai/event-count"] = fmt.Sprintf("%d", event.Count)
	}

	// Add source host
	if event.Source.Host != "" {
		annotations["kubernaut.ai/source-host"] = event.Source.Host
	}

	// Add timestamps
	if !event.FirstTimestamp.IsZero() {
		annotations["kubernaut.ai/first-timestamp"] = event.FirstTimestamp.Format(time.RFC3339)
	}
	if !event.LastTimestamp.IsZero() {
		annotations["kubernaut.ai/last-timestamp"] = event.LastTimestamp.Format(time.RFC3339)
	}

	return annotations
}
