---
alwaysApply: true
description: "Business code integration patterns and validation requirements for kubernaut"
---

# Business Code Integration Standards

## üéØ **Purpose & Scope**

This rule ensures that ALL business logic code is properly integrated into the main application flow, preventing orphaned business code that exists only in tests or unused functions.

**Business Impact**: Ensures 100% of developed business functionality is accessible to end users through main application workflows.

---

## üîó **Integration Requirements - MANDATORY**

### Definition of Integrated Business Code
Business code is considered **properly integrated** when:

1. **Main Application Entry**: Code is instantiated and used in main application entry points
2. **Runtime Execution**: Code executes during normal application workflows (not just tests)
3. **Dependency Chain**: All dependencies are properly wired in main application
4. **Interface Implementation**: Interfaces are implemented by real business code (not just mocks)
5. **Configuration Loading**: Business code configuration is loaded in main application
6. **Error Integration**: Business code errors are handled in main application flow
7. **Monitoring Integration**: Business code metrics are exposed in main application

### Integration Validation Matrix

| Integration Aspect | Validation Method | Required Evidence |
|-------------------|------------------|-------------------|
| **Main Entry Point** | Code tracing from `cmd/*/main.go` | Direct instantiation or factory usage |
| **Runtime Path** | Execution flow analysis | Normal workflow execution path |
| **Dependency Wiring** | Dependency injection validation | All deps available at runtime |
| **Interface Usage** | Implementation verification | Real implementations in main app |
| **Configuration** | Config loading verification | Business config loaded in main |
| **Error Handling** | Error flow analysis | Business errors handled in main |
| **Monitoring** | Metrics integration check | Business metrics exposed |

---

## üìã **Integration Verification Process**

### Step 1: Call Graph Analysis
```bash
# Trace business code usage from main applications
grep -r "YourBusinessCode" cmd/ --include="*.go"

# Verify business code is not test-only
find pkg/ -name "*.go" -not -name "*_test.go" -exec grep -l "YourBusinessCode" {} \;
```

### Step 2: Runtime Path Verification
```go
// Add integration validation to main application startup
func validateBusinessIntegration() error {
    // Verify each business component is properly integrated
    if businessComponent == nil {
        return fmt.Errorf("business component not integrated")
    }

    // Test business component can be invoked
    if err := businessComponent.HealthCheck(); err != nil {
        return fmt.Errorf("business component not functional: %w", err)
    }

    return nil
}
```

### Step 3: Dependency Chain Validation
```go
// Verify all business code dependencies are available
func validateDependencyChain() error {
    requiredDeps := []string{"database", "vectorDB", "llmClient", "k8sClient"}

    for _, dep := range requiredDeps {
        if !isDependencyAvailable(dep) {
            return fmt.Errorf("required dependency %s not available for business code", dep)
        }
    }

    return nil
}
```

---

## ‚úÖ **Integration Patterns - FOLLOW THESE**

### Pattern 1: Direct Main Application Integration
```go
// cmd/kubernaut/main.go
func main() {
    // Create business components
    analyticsEngine := insights.NewAnalyticsEngine(deps...)
    workflowBuilder := engine.NewIntelligentWorkflowBuilder(deps...)

    // Integrate into main application flow
    processor := processor.New(analyticsEngine, workflowBuilder)

    // Start main application with integrated business logic
    server.Start(processor)
}
```

### Pattern 2: Factory-Based Integration
```go
// cmd/dynamic-toolset-server/main.go
func createBusinessComponents(config *Config) (*BusinessComponents, error) {
    // Create all business components with proper dependency injection
    components := &BusinessComponents{
        Analytics:       createAnalyticsEngine(config),
        WorkflowBuilder: createWorkflowBuilder(config),
        PatternMatcher:  createPatternMatcher(config),
    }

    // Validate all components are properly created
    if err := components.Validate(); err != nil {
        return nil, fmt.Errorf("business component integration failed: %w", err)
    }

    return components, nil
}
```

### Pattern 3: Interface-Based Integration
```go
// pkg/workflow/engine/interfaces.go
type WorkflowEngine interface {
    SetAnalyticsEngine(engine AnalyticsEngine)
    SetPatternMatcher(matcher PatternMatcher)
}

// cmd/*/main.go - Integration point
func integrateBusinessLogic(engine WorkflowEngine, config *Config) {
    // Create real business implementations
    analytics := insights.NewAnalyticsEngine(config.Analytics)
    patterns := intelligence.NewPatternMatcher(config.Patterns)

    // Inject into main workflow engine
    engine.SetAnalyticsEngine(analytics)
    engine.SetPatternMatcher(patterns)
}
```

---

## ‚ùå **Integration Anti-Patterns - AVOID THESE**

### Anti-Pattern 1: Test-Only Business Code
```go
// ‚ùå WRONG: Business code only used in tests
func TestAnalytics(t *testing.T) {
    engine := insights.NewAnalyticsEngine() // Only used here!
    // ... test code
}

// ‚úÖ CORRECT: Business code used in main application
func main() {
    engine := insights.NewAnalyticsEngine() // Used in main app
    processor.SetAnalyticsEngine(engine)
}
```

### Anti-Pattern 2: Orphaned Instantiation
```go
// ‚ùå WRONG: Business code created but never used
func someHelperFunction() {
    engine := insights.NewAnalyticsEngine() // Created but not used!
    // No integration with main application flow
}

// ‚úÖ CORRECT: Business code integrated into main flow
func integrateAnalytics(processor *Processor) {
    engine := insights.NewAnalyticsEngine()
    processor.SetAnalyticsEngine(engine) // Properly integrated
}
```

### Anti-Pattern 3: Mock-Only Interfaces
```go
// ‚ùå WRONG: Interface only implemented by mocks
type BusinessService interface {
    Process() error
}

// Only mock implementation exists
type MockBusinessService struct{}
func (m *MockBusinessService) Process() error { return nil }

// ‚úÖ CORRECT: Real implementation used in main application
type RealBusinessService struct{}
func (r *RealBusinessService) Process() error { /* real logic */ }

// Used in main application
func main() {
    service := &RealBusinessService{} // Real implementation
    app.SetBusinessService(service)
}
```

---

## üîç **Automated Integration Validation**

## ü§ñ **AUTOMATED INTEGRATION VALIDATION - MANDATORY**

### **INTEGRATION VALIDATION COMMANDS - RUN AUTOMATICALLY**

#### **Command 1: Main Application Usage Check**
```bash
#!/bin/bash
# integration-check-main-usage.sh - Run after ANY business code creation
COMPONENT_NAME="$1"  # e.g., "ContextOptimizer"

echo "üîç Checking main application integration for $COMPONENT_NAME..."
MAIN_USAGE=$(grep -r "$COMPONENT_NAME" cmd/ --include="*.go" | wc -l)

if [ "$MAIN_USAGE" -eq 0 ]; then
    echo "‚ùå INTEGRATION FAILURE: $COMPONENT_NAME not found in main applications"
    echo "üìÅ Checked directories: cmd/"
    echo "üîß Required: Add instantiation in cmd/kubernaut/main.go or cmd/dynamic-toolset-server/main.go"
    exit 1
fi

echo "‚úÖ Integration verified: $COMPONENT_NAME found in $MAIN_USAGE main application files"
```

#### **Command 2: Constructor Integration Check**
```bash
#!/bin/bash
# integration-check-constructors.sh - Verify constructors used in main app
CONSTRUCTOR_PATTERN="$1"  # e.g., "NewContextOptimizer"

echo "üîç Checking constructor integration for $CONSTRUCTOR_PATTERN..."
CONSTRUCTOR_USAGE=$(grep -r "$CONSTRUCTOR_PATTERN" cmd/ --include="*.go" | wc -l)

if [ "$CONSTRUCTOR_USAGE" -eq 0 ]; then
    echo "‚ùå CONSTRUCTOR INTEGRATION FAILURE: $CONSTRUCTOR_PATTERN not called in main applications"
    echo "üîß Required: Add $CONSTRUCTOR_PATTERN() call in main application startup"
    exit 1
fi

echo "‚úÖ Constructor integration verified: $CONSTRUCTOR_PATTERN called in main applications"
```

#### **Command 3: Runtime Execution Path Check**
```bash
#!/bin/bash
# integration-check-runtime-path.sh - Verify code executes in normal workflows
INTERFACE_METHOD="$1"  # e.g., "AnalyzeContext"

echo "üîç Checking runtime execution path for $INTERFACE_METHOD..."
# Check if method is called in workflow processors
WORKFLOW_USAGE=$(grep -r "$INTERFACE_METHOD" pkg/workflow/ pkg/processor/ pkg/api/ --include="*.go" | wc -l)

if [ "$WORKFLOW_USAGE" -eq 0 ]; then
    echo "‚ùå RUNTIME PATH FAILURE: $INTERFACE_METHOD not found in workflow execution paths"
    echo "üîß Required: Ensure method is called during normal business workflows"
    exit 1
fi

echo "‚úÖ Runtime path verified: $INTERFACE_METHOD found in $WORKFLOW_USAGE workflow files"
```

### **MANDATORY INTEGRATION VALIDATION WORKFLOW**
```bash
#!/bin/bash
# run-integration-validation.sh - MANDATORY after any business code changes
set -e

echo "üö® Running MANDATORY integration validation..."

# Step 1: Check all new components
NEW_COMPONENTS=$(git diff --name-only HEAD~1 | xargs grep -l "^type.*struct" | grep -v "_test.go" | xargs grep -o "type [A-Za-z]*" | cut -d' ' -f2)

for component in $NEW_COMPONENTS; do
    echo "Validating component: $component"
    ./scripts/integration-check-main-usage.sh "$component"
    ./scripts/integration-check-constructors.sh "New$component"
done

# Step 2: Check all new interface methods
NEW_METHODS=$(git diff HEAD~1 | grep "^+.*func.*(" | grep -o "func [A-Za-z]*" | cut -d' ' -f2)

for method in $NEW_METHODS; do
    echo "Validating method: $method"
    ./scripts/integration-check-runtime-path.sh "$method"
done

echo "‚úÖ All integration validation passed"
```

### Static Analysis Validation
```bash
#!/bin/bash
# integration-check.sh - Add to CI/CD pipeline

echo "üîç Validating Business Code Integration..."

# Check 1: Business code used in main applications
MAIN_USAGE=$(grep -r "New.*Engine\|New.*Service\|New.*Builder" cmd/ --include="*.go" | wc -l)
if [ "$MAIN_USAGE" -eq 0 ]; then
    echo "‚ùå ERROR: No business code found in main applications"
    exit 1
fi

# Check 2: Detect test-only business code
TEST_ONLY=$(find pkg/ -name "*_test.go" -exec grep -l "New.*Engine\|New.*Service\|New.*Builder" {} \; | wc -l)
NON_TEST=$(find pkg/ -name "*.go" -not -name "*_test.go" -exec grep -l "New.*Engine\|New.*Service\|New.*Builder" {} \; | wc -l)

if [ "$TEST_ONLY" -gt "$NON_TEST" ]; then
    echo "‚ö†Ô∏è  WARNING: More business code usage in tests than main code"
fi

# Check 3: Verify interface implementations
echo "‚úÖ Business code integration validation passed"
```

### Runtime Integration Health Check
```go
// Add to main application startup
func init() {
    // Register integration health check
    http.HandleFunc("/health/integration", func(w http.ResponseWriter, r *http.Request) {
        if err := validateBusinessIntegration(); err != nil {
            http.Error(w, fmt.Sprintf("Integration check failed: %v", err), 500)
            return
        }

        w.WriteHeader(200)
        json.NewEncoder(w).Encode(map[string]string{
            "status": "healthy",
            "message": "All business components properly integrated"
        })
    })
}
```

---

## üìä **Integration Assessment Template**

Use this template for all business code integration assessments:

```
## Business Integration Assessment

**Component**: [Business component name]
**Business Requirement**: [BR-XXX-XXX]
**Integration Confidence**: [XX]%

### Integration Points
- **Main Entry**: [file:line where component is instantiated in main app]
- **Workflow Integration**: [specific workflow/processor that uses component]
- **Runtime Path**: [description of normal execution path]
- **Dependencies**: [list of properly wired dependencies]

### Validation Evidence
- [ ] Call path traced from main application: [specific path]
- [ ] Runtime execution verified: [how verified]
- [ ] Dependencies properly wired: [list of dependencies]
- [ ] Interface integration completed: [interface name and implementation]
- [ ] Configuration integration verified: [config section]
- [ ] Error handling integrated: [error handling approach]
- [ ] Monitoring integration completed: [metrics exposed]

### Integration Risks
- [List any identified integration risks]

### Validation Method
- [Describe how integration was validated - runtime testing, code tracing, etc.]

### Integration Health Check
```bash
# Command to verify integration
curl http://localhost:8080/health/integration
```
```

---

## üö® **Integration Failure Response**

If business code integration fails validation:

1. **STOP Development**: Do not proceed until integration is fixed
2. **Identify Root Cause**: Determine why integration failed
3. **Fix Integration**: Implement proper integration following patterns above
4. **Re-validate**: Run full integration validation again
5. **Document Fix**: Update integration assessment with fix details

### Common Integration Fixes

| Problem | Solution |
|---------|----------|
| Test-only usage | Add instantiation in main application |
| Missing dependencies | Wire dependencies in main application startup |
| Orphaned code | Connect to main application workflow |
| Mock-only interfaces | Create real implementation and use in main app |
| Configuration isolation | Load business config in main application |

---

## üîó **Integration with Other Rules**

This rule provides detailed implementation guidance for the integration requirements established in:
- [00-project-guidelines.mdc](mdc:.cursor/rules/00-project-guidelines.mdc) - Core integration mandate and TDD workflow
- [01-project-structure.mdc](mdc:.cursor/rules/01-project-structure.mdc) - Architecture patterns and main entry points
- [02-go-coding-standards.mdc](mdc:.cursor/rules/02-go-coding-standards.mdc) - Code organization and interface patterns
- [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) - Business requirement testing approach

**Priority**: Business code integration is MANDATORY per project guidelines - no exceptions allowed.

**Usage**: This rule should be consulted whenever implementing new business logic to ensure proper integration with main application workflows.