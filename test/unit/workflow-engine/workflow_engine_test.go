<<<<<<< HEAD
package workflowengine

import (
	"testing"
	"context"
	"fmt"
=======
/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package workflowengine

import (
	"context"
	"fmt"
	"testing"
>>>>>>> crd_implementation
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/shared/types"
	testconfig "github.com/jordigilh/kubernaut/pkg/testutil/config"
	"github.com/jordigilh/kubernaut/pkg/testutil/mocks"
	"github.com/jordigilh/kubernaut/pkg/workflow/engine"
)

// Suite structure moved to workflow_engine_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Workflow Engine - Business Requirements Testing", func() {
	var (
		ctx                context.Context
		workflowEngine     *engine.DefaultWorkflowEngine
		mockActionRepo     *mocks.MockActionRepository
		mockStateStorage   *mocks.MockStateStorage
		mockActionExecutor *mocks.MockActionExecutor
		mockAIEvaluator    *mocks.MockAIConditionEvaluator
		mockK8sClient      *mocks.MockKubernetesClient
		executionRepo      engine.ExecutionRepository
		testLogger         *logrus.Logger
	)

	BeforeEach(func() {
		ctx = context.Background()
		testLogger = logrus.New()
		testLogger.SetLevel(logrus.WarnLevel) // Reduce noise in tests

		// Initialize mocks
		mockActionRepo = mocks.NewMockActionRepository()
		mockStateStorage = mocks.NewMockStateStorage()
		mockActionExecutor = mocks.NewMockActionExecutor()
		mockAIEvaluator = mocks.NewMockAIConditionEvaluator()
		mockK8sClient = mocks.NewMockKubernetesClient()

		// Use real in-memory execution repository (no mocking needed)
		executionRepo = engine.NewInMemoryExecutionRepository(testLogger)

		// Create workflow engine with test configuration
		config := &engine.WorkflowEngineConfig{
			DefaultStepTimeout:    30 * time.Second,
			MaxRetryDelay:         1 * time.Second,
			EnableStateRecovery:   true,
			EnableDetailedLogging: false,
			MaxConcurrency:        5,
		}

		// Create workflow engine with test configuration
		// Note: Using mock k8s client for proper test isolation
		workflowEngine = engine.NewDefaultWorkflowEngine(
			mockK8sClient.AsK8sClient(), // Mock k8s client for testing
			mockActionRepo,
			nil, // monitoringClients - not needed for core engine logic tests
			mockStateStorage,
			executionRepo,
			config,
			testLogger,
		)

		// RULE 12 COMPLIANCE: AI condition evaluation now handled by enhanced llm.Client
		// SetAIConditionEvaluator method deprecated - using llm.Client integration instead

		// Register mock action executor for kubernetes actions
		// This ensures our mock is used instead of the real KubernetesActionExecutor
		workflowEngine.RegisterActionExecutor("kubernetes", mockActionExecutor)
	})

	// BR-WF-001: MUST execute complex multi-step remediation workflows reliably
	Context("BR-WF-001: Multi-Step Workflow Execution", func() {
		It("should execute a complete workflow with multiple sequential steps", func() {
			// Arrange: Create a multi-step workflow
			workflow := createMultiStepWorkflow("sequential-workflow", []engine.StepType{
				engine.StepTypeAction,
				engine.StepTypeCondition,
				engine.StepTypeAction,
			})

			// Configure mock responses for successful execution
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)
			mockAIEvaluator.SetConditionResult("cpu-check", true, nil)

			// Act: Execute the workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// **Business Requirement BR-WF-001**: Validate actual multi-step workflow orchestration
			Expect(err).ToNot(HaveOccurred(), "Should execute workflow successfully with mock k8s client")
			Expect(execution.ID).ToNot(BeEmpty(), "Should return execution with valid ID")
			Expect(execution.IsSuccessful()).To(BeTrue(), "Multi-step workflow should complete successfully")

			// **Business Value Validation**: Verify actual workflow orchestration occurred
			// 1. **Business Outcome**: Validate step execution sequence and flow integrity
			executionMetrics := mockActionExecutor.GetExecutionFlowMetrics()
			Expect(executionMetrics.TotalStepsExecuted).To(Equal(2),
				"BR-WF-001: Should execute 2 action steps (condition handled by AI evaluator)")
			Expect(executionMetrics.SuccessfulSteps).To(Equal(2),
				"BR-WF-001: All action steps should complete successfully")
			Expect(executionMetrics.FailedSteps).To(Equal(0),
				"BR-WF-001: No workflow steps should fail in successful execution")

			// 2. **Business Outcome**: Validate proper step sequencing
			stepResults := mockActionExecutor.GetStepResults()
			Expect(len(stepResults)).To(Equal(2), // 2 action steps (condition handled by AI evaluator)
				"BR-WF-001: Should track execution of action steps")
			Expect(mockActionExecutor.ValidateStepSequence()).To(BeTrue(),
				"BR-WF-001: Step execution should follow proper workflow sequence")

			// 3. **Business Outcome**: Validate state persistence and progression
			persistenceMetrics := mockStateStorage.GetStatePersistenceMetrics()
			testconfig.ExpectBusinessRequirement(persistenceMetrics.TotalSaves,
				"BR-WF-001-STATE-PERSISTENCE", "test",
				"workflow state persistence count for business continuity")
			Expect(mockStateStorage.ValidateStateProgression(execution.ID)).To(BeTrue(),
				"BR-WF-001: Workflow state should progress correctly through steps")
		})

		It("should handle step failure and stop execution gracefully", func() {
			// Arrange: Create workflow where second step fails
			workflow := createMultiStepWorkflow("failing-workflow", []engine.StepType{
				engine.StepTypeAction,
				engine.StepTypeAction, // This will fail
				engine.StepTypeAction, // Should not execute
			})

			// Configure first step to succeed, second to fail
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)
			mockActionExecutor.SetExecutionResultAtCall(1, "kubernetes", false, fmt.Errorf("simulated failure"))

			// Act: Execute the workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// Assert: Should handle failure gracefully - Business requirement compliance
			Expect(err).To(HaveOccurred(), "Should fail due to simulated step failure")
			Expect(execution.ID).ToNot(BeEmpty(),
				"BR-WF-001: Should return execution with valid ID even when failed for business tracking")
			Expect(execution.IsFailed()).To(BeTrue(),
				"BR-WF-001: Should mark execution as failed for business operations visibility")
		})

		It("should enforce step timeouts for business SLA compliance", func() {
			// Arrange: Create workflow with very short timeout
			workflow := createWorkflowWithTimeout("timeout-workflow", 50*time.Millisecond)

			// Configure action executor to take longer than timeout
			mockActionExecutor.SetExecutionDelay(100 * time.Millisecond)
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute the workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// Assert: Should timeout and fail
			Expect(err).To(HaveOccurred(), "Should timeout and return error")
			Expect(execution.IsFailed()).To(BeTrue(), "Execution should fail due to timeout")

			// **Business Requirement**: Verify timeout is enforced for SLA compliance
			Expect(execution.Error).To(ContainSubstring("context deadline exceeded"), "Error should indicate timeout occurred")
		})
	})

	// BR-WF-003: MUST implement parallel and sequential execution patterns
	Context("BR-WF-003: Parallel and Sequential Execution Patterns", func() {
		It("should execute sequential steps in correct order", func() {
			// Arrange: Create sequential workflow with order-dependent steps
			workflow := createSequentialWorkflow("ordered-workflow", []string{
				"step1-prepare",
				"step2-execute",
				"step3-cleanup",
			})

			var executionOrder []string
			mockActionExecutor.SetExecutionOrderCapture(&executionOrder)
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute the workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// Assert: Should execute steps in exact order
			Expect(err).ToNot(HaveOccurred(), "Sequential workflow should succeed")
			Expect(execution.IsSuccessful()).To(BeTrue(), "All sequential steps should complete")

			// **Business Value Validation**: Verify execution order
			Expect(executionOrder).To(HaveLen(3), "Should execute all three steps")
			Expect(executionOrder[0]).To(Equal("step1-prepare"), "First step should execute first")
			Expect(executionOrder[1]).To(Equal("step2-execute"), "Second step should execute after first")
			Expect(executionOrder[2]).To(Equal("step3-cleanup"), "Third step should execute last")
		})

		It("should execute parallel steps concurrently for improved performance", func() {
			// Arrange: Create parallel workflow with independent steps
			workflow := createParallelWorkflow("parallel-workflow", []string{
				"check-memory",
				"check-cpu",
				"check-disk",
			})

			// Track concurrent execution
			var concurrentExecutions []time.Time
			mockActionExecutor.SetConcurrentExecutionTracker(&concurrentExecutions)
			mockActionExecutor.SetExecutionDelay(100 * time.Millisecond) // Simulate work
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute the workflow
			startTime := time.Now()
			execution, err := workflowEngine.Execute(ctx, workflow)
			totalDuration := time.Since(startTime)

			// Assert: Should execute in parallel for performance
			Expect(err).ToNot(HaveOccurred(), "Parallel workflow should succeed")
			Expect(execution.IsSuccessful()).To(BeTrue(), "All parallel steps should complete")

			// **Business Requirement**: Verify parallel execution performance benefit
			Expect(concurrentExecutions).To(HaveLen(3), "Should track all parallel executions")
			Expect(totalDuration).To(BeNumerically("<", 250*time.Millisecond),
				"Parallel execution should be faster than sequential (3*100ms)")

			// **Business Value**: Verify parallel steps started within close time window
			maxTimeSpread := time.Duration(0)
			if len(concurrentExecutions) > 1 {
				for i := 1; i < len(concurrentExecutions); i++ {
					spread := concurrentExecutions[i].Sub(concurrentExecutions[0])
					if spread > maxTimeSpread {
						maxTimeSpread = spread
					}
				}
			}
			Expect(maxTimeSpread).To(BeNumerically("<", 50*time.Millisecond),
				"All parallel steps should start within 50ms of each other")
		})

		It("should handle mixed sequential and parallel patterns", func() {
			// Arrange: Create complex workflow with both patterns
			workflow := createMixedExecutionPatternWorkflow("mixed-workflow")

			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute the complex workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// **Business Requirement BR-WF-003**: Validate mixed execution pattern orchestration
			Expect(err).ToNot(HaveOccurred(), "Mixed pattern workflow should succeed")
			Expect(execution.IsSuccessful()).To(BeTrue(), "All steps should complete successfully")

			// **Business Value Validation**: Verify actual pattern execution behavior
			// 1. **Business Outcome**: Validate execution flow metrics for mixed patterns
			executionMetrics := mockActionExecutor.GetExecutionFlowMetrics()
			Expect(executionMetrics.TotalStepsExecuted).To(BeNumerically(">=", 1),
				"BR-WF-003: Should execute multiple workflow steps in mixed pattern")
			Expect(executionMetrics.SuccessfulSteps).To(Equal(executionMetrics.TotalStepsExecuted),
				"BR-WF-003: All mixed pattern steps should complete successfully")

			// 2. **Business Outcome**: Validate execution pattern analysis
			executionPattern := mockActionExecutor.GetExecutionPattern()
			Expect(executionPattern).To(BeElementOf([]string{"sequential_execution", "parallel_execution", "single_step"}),
				"BR-WF-003: Should identify execution pattern correctly")
			Expect(mockActionExecutor.ValidateStepSequence()).To(BeTrue(),
				"BR-WF-003: Mixed pattern execution should maintain logical step sequence")

			// 3. **Business Outcome**: Validate workflow completion status through actual state
			completionStatus := execution.GetCompletionStatus()
			Expect(completionStatus.IsSuccessful).To(BeTrue(),
				"BR-WF-003: Complex execution patterns should complete successfully")

			// Validate state persistence handled mixed patterns correctly
			persistenceMetrics := mockStateStorage.GetStatePersistenceMetrics()
			Expect(persistenceMetrics.StateIntegrityOK).To(BeTrue(),
				"BR-WF-003: State integrity should be maintained during mixed pattern execution")
		})
	})

	// BR-WF-004: MUST provide workflow state management and persistence
	Context("BR-WF-004: Workflow State Management and Persistence", func() {
		It("should persist workflow state throughout execution", func() {
			// Arrange: Create workflow that will trigger state saves
			workflow := createMultiStepWorkflow("stateful-workflow", []engine.StepType{
				engine.StepTypeAction,
				engine.StepTypeCondition,
				engine.StepTypeAction,
			})

			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)
			mockAIEvaluator.SetConditionResult("status-check", true, nil)

			// Act: Execute workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// **Business Requirement BR-WF-004**: Validate comprehensive state management and persistence
			Expect(err).ToNot(HaveOccurred(), "Stateful workflow should execute successfully")
			Expect(execution.IsSuccessful()).To(BeTrue(), "Workflow should complete successfully")

			// **Business Value Validation**: Verify actual state persistence behavior
			// 1. **Business Outcome**: Validate state persistence metrics and patterns
			persistenceMetrics := mockStateStorage.GetStatePersistenceMetrics()
			Expect(persistenceMetrics.TotalSaves).To(BeNumerically(">=", 1),
				"BR-WF-004: Should persist workflow state during execution lifecycle")
			Expect(persistenceMetrics.CompletionSaves).To(BeNumerically(">=", 1),
				"BR-WF-004: Should save state upon workflow completion")
			Expect(persistenceMetrics.StateIntegrityOK).To(BeTrue(),
				"BR-WF-004: State integrity should be maintained throughout execution")

			// 2. **Business Outcome**: Validate state progression tracking
			stateTransitions := mockStateStorage.GetStateTransitions()
			if len(stateTransitions) > 0 {
				// Verify state transitions show proper workflow progression
				Expect(mockStateStorage.ValidateStateProgression(execution.ID)).To(BeTrue(),
					"BR-WF-004: State transitions should show proper workflow step progression")

				lastTransition := stateTransitions[len(stateTransitions)-1]
				Expect(lastTransition.StepStatus).To(Equal("completed"),
					"BR-WF-004: Final state transition should indicate completion")
			}

			// 3. **Business Outcome**: Validate final state correctness
			savedState := mockStateStorage.GetLastSavedState()
			Expect(savedState.ID).To(Equal(execution.ID), "BR-WF-004: Saved state should match execution")
			Expect(savedState.IsCompleted()).To(BeTrue(), "BR-WF-004: Final state should reflect completion")
			Expect(persistenceMetrics.RecoveryCapable).To(BeTrue(),
				"BR-WF-004: State should support workflow recovery scenarios")
		})

		It("should support state recovery for interrupted workflows", func() {
			// Arrange: Create partially executed workflow state
			workflowID := "recoverable-workflow"
			interruptedExecution := createInterruptedExecution(workflowID, 2, 4) // Step 2 of 4

			// Store the interrupted state
			mockStateStorage.StoreState(interruptedExecution)

			// Act: Recover and continue execution
			recoveredExecution, err := mockStateStorage.LoadWorkflowState(ctx, interruptedExecution.ID)

			// Assert: Should recover state successfully
			Expect(err).ToNot(HaveOccurred(), "Should recover interrupted workflow state")
			Expect(recoveredExecution.ID).To(Equal(interruptedExecution.ID), "Should match original execution ID")
			Expect(recoveredExecution.ID).ToNot(BeEmpty(), "Should return recovered execution with valid ID")
			Expect(recoveredExecution.CurrentStep).To(Equal(2), "Should preserve execution progress")

			// **Business Value**: Verify recovery preserves execution context
			Expect(len(recoveredExecution.Context.Variables)).To(BeNumerically(">=", 0), "BR-WF-001-SUCCESS-RATE: Workflow recovery must preserve execution context variables for continued success")
			Expect(recoveredExecution.Steps).To(HaveLen(4), "Should preserve all workflow steps")

			completedSteps := 0
			for _, step := range recoveredExecution.Steps[:2] {
				if step.Status == engine.ExecutionStatusCompleted {
					completedSteps++
				}
			}
			Expect(completedSteps).To(Equal(2), "Should preserve completed step status")
		})

		It("should clean up workflow state after completion", func() {
			// Arrange: Create simple workflow for cleanup test
			workflow := createSingleStepWorkflow("cleanup-test")
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// Assert: Should complete successfully
			Expect(err).ToNot(HaveOccurred(), "Cleanup test workflow should succeed")
			Expect(execution.IsSuccessful()).To(BeTrue(), "Workflow should complete successfully")

			// **Business Requirement**: Verify state cleanup can be performed
			cleanupErr := mockStateStorage.DeleteWorkflowState(ctx, execution.ID)
			Expect(cleanupErr).ToNot(HaveOccurred(), "Should support state cleanup operations")

			// **Business Value**: Verify cleaned state is no longer accessible
			_, loadErr := mockStateStorage.LoadWorkflowState(ctx, execution.ID)
			Expect(loadErr).To(HaveOccurred(), "Cleaned up state should not be loadable")
		})
	})

	// BR-WF-002: MUST support conditional logic and branching within workflows
	Context("BR-WF-002: Conditional Logic and Branching", func() {
		It("should evaluate conditions and branch workflow execution", func() {
			// Arrange: Create branching workflow
			workflow := createBranchingWorkflow("conditional-workflow")

			// Configure condition to evaluate true (take success path)
			mockAIEvaluator.SetConditionResult("resource-healthy", true, nil)
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute conditional workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// **Business Requirement BR-WF-002**: Validate conditional logic and branching execution
			Expect(err).ToNot(HaveOccurred(), "Conditional workflow should execute successfully")
			Expect(execution.IsSuccessful()).To(BeTrue(), "Should complete successfully")

			// **Business Value Validation**: Verify actual conditional branching behavior
			// 1. **Business Outcome**: Validate that condition evaluation influenced execution path
			executionMetrics := mockActionExecutor.GetExecutionFlowMetrics()
			Expect(executionMetrics.TotalStepsExecuted).To(BeNumerically(">=", 1),
				"BR-WF-002: Conditional workflow should execute branch steps")
			Expect(executionMetrics.SuccessfulSteps).To(Equal(executionMetrics.TotalStepsExecuted),
				"BR-WF-002: Conditional branch execution should succeed")

			// 2. **Business Outcome**: Validate workflow made conditional decisions correctly
			stepResults := mockActionExecutor.GetStepResults()
			Expect(len(stepResults)).To(BeNumerically(">=", 1),
				"BR-WF-002: Should execute steps in chosen conditional branch")

			// Verify that condition-based execution occurred (business logic was applied)
			for _, stepResult := range stepResults {
				Expect(stepResult.BusinessOutcome).ToNot(BeEmpty(),
					"BR-WF-002: Each conditional step should have measurable business outcome")
				Expect(stepResult.Success).To(BeTrue(),
					"BR-WF-002: Conditional branch steps should complete successfully")
			}
		})

		It("should handle decision steps with multiple outcomes", func() {
			// Arrange: Create workflow with decision step
			workflow := createDecisionWorkflow("decision-workflow")

			// Configure decision evaluator
			mockAIEvaluator.SetDecisionResult("severity-assessment", "high", nil)
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Execute decision workflow
			execution, err := workflowEngine.Execute(ctx, workflow)

			// **Business Requirement BR-WF-002**: Validate decision-step workflow execution
			Expect(err).ToNot(HaveOccurred(), "Decision workflow should execute successfully")
			Expect(execution.IsSuccessful()).To(BeTrue(), "Should complete successfully")

			// **Business Value Validation**: Verify actual decision-based execution behavior
			// 1. **Business Outcome**: Validate decision workflow execution metrics
			executionMetrics := mockActionExecutor.GetExecutionFlowMetrics()
			Expect(executionMetrics.TotalStepsExecuted).To(BeNumerically(">=", 1),
				"BR-WF-002: Decision workflow should execute decision-based steps")
			Expect(executionMetrics.SuccessfulSteps).To(Equal(executionMetrics.TotalStepsExecuted),
				"BR-WF-002: Decision-based steps should complete successfully")

			// 2. **Business Outcome**: Validate decision step results contain business value
			stepResults := mockActionExecutor.GetStepResults()
			Expect(len(stepResults)).To(BeNumerically(">=", 1),
				"BR-WF-002: Should execute steps based on decision outcome")

			// Verify decision-based execution produced meaningful business outcomes
			hasDecisionBasedOutcome := false
			for _, stepResult := range stepResults {
				if stepResult.BusinessOutcome != "" {
					hasDecisionBasedOutcome = true
					break
				}
			}
			Expect(hasDecisionBasedOutcome).To(BeTrue(),
				"BR-WF-002: Decision workflow should produce business outcomes based on decision logic")
		})
	})

	// BR-WF-005: MUST support workflow pause, resume, and cancellation operations
	Context("BR-WF-005: Workflow Control Operations", func() {
		It("should support workflow cancellation during execution", func() {
			// Arrange: Create long-running workflow
			workflow := createLongRunningWorkflow("cancellable-workflow")
			mockActionExecutor.SetExecutionDelay(200 * time.Millisecond)
			mockActionExecutor.SetExecutionResult("kubernetes", true, nil)

			// Act: Start execution and cancel after short delay
			executionChan := make(chan *engine.RuntimeWorkflowExecution, 1)
			errChan := make(chan error, 1)

			go func() {
				execution, err := workflowEngine.Execute(ctx, workflow)
				executionChan <- execution
				errChan <- err
			}()

			// Give workflow time to start, then cancel would be handled by context cancellation
			time.Sleep(50 * time.Millisecond)
			// Note: In real implementation, cancellation would be handled through context

			// Wait for completion or timeout
			var execution *engine.RuntimeWorkflowExecution
			var err error
			select {
			case execution = <-executionChan:
				err = <-errChan
			case <-time.After(500 * time.Millisecond):
				err = fmt.Errorf("workflow did not respond to cancellation")
			}

			// Assert: Should handle cancellation gracefully
			if err != nil {
				// Cancellation during execution is acceptable
				Expect(execution.ID).ToNot(BeEmpty(), "Should return execution state with valid ID even when cancelled")
			}

			// **Business Value**: Verify cancellation is supported in design
			Expect(mockStateStorage.GetSaveCount()).To(BeNumerically(">=", 1),
				"Should save state before cancellation for recovery")
		})
	})
})

// **Enhanced Test Framework**: Using shared mocks from pkg/testutil/mocks

// **Test Data Factories**: Business-aligned workflow creation helpers

func createMultiStepWorkflow(workflowID string, stepTypes []engine.StepType) *engine.Workflow {
	steps := make([]*engine.ExecutableWorkflowStep, len(stepTypes))

	for i, stepType := range stepTypes {
		step := &engine.ExecutableWorkflowStep{
			BaseEntity: types.BaseEntity{
				ID:   fmt.Sprintf("step-%d", i+1),
				Name: fmt.Sprintf("Step %d", i+1),
			},
			Type:    stepType,
			Timeout: 30 * time.Second,
		}

		switch stepType {
		case engine.StepTypeAction:
			step.Action = &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"operation": "restart",
					"target":    fmt.Sprintf("resource-%d", i+1),
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      fmt.Sprintf("test-pod-%d", i+1),
				},
			}
		case engine.StepTypeCondition:
			step.Condition = &engine.ExecutableCondition{
				ID:         fmt.Sprintf("condition-%d", i+1),
				Name:       fmt.Sprintf("cpu-check-%d", i+1),
				Type:       engine.ConditionTypeMetric,
				Expression: "cpu_usage < 80",
			}
		}

		steps[i] = step
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Multi-Step Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Multi-Step Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createWorkflowWithTimeout(workflowID string, timeout time.Duration) *engine.Workflow {
	workflow := createMultiStepWorkflow(workflowID, []engine.StepType{engine.StepTypeAction})
	workflow.Template.Steps[0].Timeout = timeout
	return workflow
}

func createSequentialWorkflow(workflowID string, stepNames []string) *engine.Workflow {
	steps := make([]*engine.ExecutableWorkflowStep, len(stepNames))

	for i, stepName := range stepNames {
		// Create sequential dependencies - each step depends on the previous one
		var dependencies []string
		if i > 0 {
			dependencies = []string{stepNames[i-1]} // Depend on previous step
		}

		steps[i] = &engine.ExecutableWorkflowStep{
			BaseEntity: types.BaseEntity{
				ID:   stepName,
				Name: stepName,
			},
			Type:         engine.StepTypeAction,
			Timeout:      30 * time.Second,
			Dependencies: dependencies, // Set sequential dependencies
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"step_name": stepName,
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      fmt.Sprintf("test-pod-%s", stepName),
				},
			},
		}
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Sequential Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Sequential Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createParallelWorkflow(workflowID string, stepNames []string) *engine.Workflow {
	// Create individual action steps
	actionSteps := make([]*engine.ExecutableWorkflowStep, len(stepNames))
	for i, stepName := range stepNames {
		actionSteps[i] = &engine.ExecutableWorkflowStep{
			BaseEntity: types.BaseEntity{
				ID:   stepName,
				Name: stepName,
			},
			Type:    engine.StepTypeAction,
			Timeout: 30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"check_type": stepName,
				},
			},
		}
	}

	// Create step IDs for dependencies
	stepIDs := make([]string, len(stepNames))
	copy(stepIDs, stepNames)

	// Prepare substeps data for parallel execution as expected by executeParallel
	substepsData := make([]interface{}, len(stepNames))
	for i, stepName := range stepNames {
		substepsData[i] = map[string]interface{}{
			"id":   stepName,
			"name": stepName,
			"type": "action",
			"action": map[string]interface{}{
				"type": "kubernetes",
				"parameters": map[string]interface{}{
					"action":     "restart_pod",
					"check_type": stepName,
				},
				"target": map[string]interface{}{
					"type":      "kubernetes",
					"namespace": "default",
					"resource":  "pod",
					"name":      fmt.Sprintf("test-pod-%s", stepName),
				},
			},
		}
	}

	// Wrap in parallel step with proper substeps in Variables
	parallelStep := &engine.ExecutableWorkflowStep{
		BaseEntity: types.BaseEntity{
			ID:   "parallel-execution",
			Name: "Parallel Execution",
		},
		Type:    engine.StepTypeParallel,
		Timeout: 60 * time.Second,
		Variables: map[string]interface{}{
			"steps": substepsData, // This is what executeParallel expects
		},
	}

	// Only use the parallel step - the individual action steps are defined within it
	allSteps := []*engine.ExecutableWorkflowStep{parallelStep}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Parallel Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Parallel Template",
				},
			},
			Steps: allSteps,
		},
		Status: "draft",
	}
}

func createMixedExecutionPatternWorkflow(workflowID string) *engine.Workflow {
	steps := []*engine.ExecutableWorkflowStep{
		{
			BaseEntity: types.BaseEntity{ID: "prepare", Name: "Prepare"},
			Type:       engine.StepTypeAction,
			Timeout:    30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"operation": "prepare",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-prepare",
				},
			},
		},
		{
			BaseEntity: types.BaseEntity{ID: "parallel-checks", Name: "Parallel Checks"},
			Type:       engine.StepTypeParallel,
			Timeout:    60 * time.Second,
			Variables: map[string]interface{}{
				"steps": []interface{}{
					map[string]interface{}{
						"id":   "check-cpu",
						"name": "CPU Check",
						"type": "action",
						"action": map[string]interface{}{
							"type": "kubernetes",
							"parameters": map[string]interface{}{
								"action_type": "restart_pod",
								"check":       "cpu",
							},
							"target": map[string]interface{}{
								"type":      "kubernetes",
								"namespace": "default",
								"resource":  "pod",
								"name":      "test-pod-cpu",
							},
						},
					},
					map[string]interface{}{
						"id":   "check-memory",
						"name": "Memory Check",
						"type": "action",
						"action": map[string]interface{}{
							"type": "kubernetes",
							"parameters": map[string]interface{}{
								"action_type": "restart_pod",
								"check":       "memory",
							},
							"target": map[string]interface{}{
								"type":      "kubernetes",
								"namespace": "default",
								"resource":  "pod",
								"name":      "test-pod-memory",
							},
						},
					},
				},
			},
		},
		{
			BaseEntity: types.BaseEntity{ID: "finalize", Name: "Finalize"},
			Type:       engine.StepTypeAction,
			Timeout:    30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"operation": "finalize",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-finalize",
				},
			},
		},
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Mixed Pattern Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Mixed Pattern Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createSingleStepWorkflow(workflowID string) *engine.Workflow {
	return createMultiStepWorkflow(workflowID, []engine.StepType{engine.StepTypeAction})
}

func createBranchingWorkflow(workflowID string) *engine.Workflow {
	steps := []*engine.ExecutableWorkflowStep{
		{
			BaseEntity: types.BaseEntity{ID: "health-check", Name: "Health Check"},
			Type:       engine.StepTypeCondition,
			Timeout:    30 * time.Second,
			Condition: &engine.ExecutableCondition{
				ID:         "resource-health",
				Name:       "resource-healthy",
				Type:       engine.ConditionTypeResource,
				Expression: "status == 'healthy'",
			},
			OnSuccess: []string{"monitor-resource"},
			OnFailure: []string{"restart-resource"},
		},
		{
			BaseEntity: types.BaseEntity{ID: "monitor-resource", Name: "Monitor Resource"},
			Type:       engine.StepTypeAction,
			Timeout:    30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"operation": "monitor",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-monitor",
				},
			},
		},
		{
			BaseEntity: types.BaseEntity{ID: "restart-resource", Name: "Restart Resource"},
			Type:       engine.StepTypeAction,
			Timeout:    30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":    "restart_pod",
					"operation": "restart",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-restart",
				},
			},
		},
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Branching Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Branching Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createDecisionWorkflow(workflowID string) *engine.Workflow {
	steps := []*engine.ExecutableWorkflowStep{
		{
			BaseEntity: types.BaseEntity{ID: "severity-decision", Name: "Severity Assessment"},
			Type:       engine.StepTypeDecision,
			Timeout:    30 * time.Second,
			Condition: &engine.ExecutableCondition{
				ID:         "severity-assessment",
				Name:       "severity-assessment",
				Type:       engine.ConditionTypeCustom,
				Expression: "alert.severity == 'high'",
			},
		},
		{
			BaseEntity: types.BaseEntity{ID: "immediate-action", Name: "Immediate Action"},
			Type:       engine.StepTypeAction,
			Timeout:    30 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":   "restart_pod",
					"priority": "high",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-high-priority",
				},
			},
		},
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Decision Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Decision Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createLongRunningWorkflow(workflowID string) *engine.Workflow {
	steps := []*engine.ExecutableWorkflowStep{
		{
			BaseEntity: types.BaseEntity{ID: "long-task-1", Name: "Long Task 1"},
			Type:       engine.StepTypeAction,
			Timeout:    5 * time.Second, // Longer than delay in tests
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":   "restart_pod",
					"duration": "long",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-long",
				},
			},
		},
		{
			BaseEntity: types.BaseEntity{ID: "long-task-2", Name: "Long Task 2"},
			Type:       engine.StepTypeAction,
			Timeout:    5 * time.Second,
			Action: &engine.StepAction{
				Type: "kubernetes",
				Parameters: map[string]interface{}{
					"action":   "restart_pod",
					"duration": "long",
				},
				Target: &engine.ActionTarget{
					Type:      "kubernetes",
					Namespace: "default",
					Resource:  "pod",
					Name:      "test-pod-long",
				},
			},
		},
	}

	return &engine.Workflow{
		BaseVersionedEntity: types.BaseVersionedEntity{
			BaseEntity: types.BaseEntity{
				ID:   workflowID,
				Name: "Long Running Test Workflow",
			},
		},
		Template: &engine.ExecutableTemplate{
			BaseVersionedEntity: types.BaseVersionedEntity{
				BaseEntity: types.BaseEntity{
					ID:   workflowID + "-template",
					Name: "Long Running Template",
				},
			},
			Steps: steps,
		},
		Status: "draft",
	}
}

func createInterruptedExecution(workflowID string, currentStep, totalSteps int) *engine.RuntimeWorkflowExecution {
	steps := make([]*engine.StepExecution, totalSteps)

	for i := 0; i < totalSteps; i++ {
		status := engine.ExecutionStatusPending
		if i < currentStep {
			status = engine.ExecutionStatusCompleted
		} else if i == currentStep {
			status = engine.ExecutionStatusRunning
		}

		steps[i] = &engine.StepExecution{
			StepID:    fmt.Sprintf("step-%d", i+1),
			Status:    status,
			StartTime: time.Now().Add(time.Duration(-i) * time.Minute),
		}
	}

	return &engine.RuntimeWorkflowExecution{
		WorkflowExecutionRecord: types.WorkflowExecutionRecord{
			ID:         fmt.Sprintf("execution-%s", workflowID),
			WorkflowID: workflowID,
			StartTime:  time.Now().Add(-10 * time.Minute),
		},
		OperationalStatus: engine.ExecutionStatusRunning,
		Context: &engine.ExecutionContext{
			BaseContext: types.BaseContext{
				Environment: "test",
				Cluster:     "test-cluster",
				Timestamp:   time.Now(),
				Metadata:    make(map[string]interface{}),
			},
			Variables:     make(map[string]interface{}),
			Configuration: make(map[string]interface{}),
		},
		Steps:       steps,
		CurrentStep: currentStep,
	}
}

// TestRunner bootstraps the Ginkgo test suite
func TestUworkflowUengine(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "UworkflowUengine Suite")
}
