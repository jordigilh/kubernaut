/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package middleware

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	authv1 "k8s.io/api/authentication/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes/fake"
	k8stesting "k8s.io/client-go/testing"

	"github.com/jordigilh/kubernaut/pkg/gateway/middleware"
)

func TestAuthMiddleware(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "TokenReview Authentication Middleware Suite (VULN-GATEWAY-001)")
}

var _ = Describe("TokenReview Authentication (VULN-GATEWAY-001)", func() {
	var (
		k8sClient *fake.Clientset
		handler   http.Handler
		recorder  *httptest.ResponseRecorder
	)

	BeforeEach(func() {
		k8sClient = fake.NewSimpleClientset()
		recorder = httptest.NewRecorder()
	})

	Context("Valid ServiceAccount Token", func() {
		It("should allow request with valid token", func() {
			// Arrange: Configure fake K8s client to return authenticated TokenReview
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: true,
						User: authv1.UserInfo{
							Username: "system:serviceaccount:monitoring:prometheus",
						},
					},
				}, nil
			})

			// Create middleware with fake client
			authMiddleware := TokenReviewAuth(k8sClient)
			
			// Create test handler that verifies request reaches it
			reached := false
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				reached = true
				w.WriteHeader(http.StatusOK)
			})
			handler = authMiddleware(testHandler)

			// Act: Send request with valid Bearer token
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			handler.ServeHTTP(recorder, req)

			// Assert: Request should reach handler (200 OK)
			Expect(recorder.Code).To(Equal(http.StatusOK))
			Expect(reached).To(BeTrue(), "handler should be reached with valid token")
		})

		It("should extract ServiceAccount identity and store in context", func() {
			// Arrange
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: true,
						User: authv1.UserInfo{
							Username: "system:serviceaccount:monitoring:prometheus",
						},
					},
				}, nil
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			
			var capturedContext context.Context
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				capturedContext = r.Context()
				w.WriteHeader(http.StatusOK)
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			handler.ServeHTTP(recorder, req)

			// Assert: Context should contain ServiceAccount identity
			Expect(capturedContext).ToNot(BeNil())
			serviceAccount := capturedContext.Value("serviceaccount")
			Expect(serviceAccount).To(Equal("system:serviceaccount:monitoring:prometheus"))
		})

		It("should store identity in request context for authorization", func() {
			// Arrange
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: true,
						User: authv1.UserInfo{
							Username: "system:serviceaccount:kube-system:admin",
						},
					},
				}, nil
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			
			var contextValue interface{}
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				contextValue = r.Context().Value("serviceaccount")
				w.WriteHeader(http.StatusOK)
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer admin-token")
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(contextValue).To(Equal("system:serviceaccount:kube-system:admin"))
		})
	})

	Context("Invalid Token", func() {
		It("should reject expired token with 401", func() {
			// Arrange: TokenReview returns authenticated=false
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: false,
					},
				}, nil
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				Fail("handler should not be reached with invalid token")
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer expired-token")
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(recorder.Code).To(Equal(http.StatusUnauthorized))
			Expect(recorder.Body.String()).To(ContainSubstring("invalid token"))
		})

		It("should reject malformed token with 401", func() {
			// Arrange
			authMiddleware := TokenReviewAuth(k8sClient)
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				Fail("handler should not be reached with malformed token")
			})
			handler = authMiddleware(testHandler)

			// Act: Send malformed Authorization header (not "Bearer <token>")
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "InvalidFormat token")
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(recorder.Code).To(Equal(http.StatusUnauthorized))
			Expect(recorder.Body.String()).To(ContainSubstring("invalid Authorization header format"))
		})

		It("should reject missing token with 401", func() {
			// Arrange
			authMiddleware := TokenReviewAuth(k8sClient)
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				Fail("handler should not be reached without token")
			})
			handler = authMiddleware(testHandler)

			// Act: Send request without Authorization header
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(recorder.Code).To(Equal(http.StatusUnauthorized))
			Expect(recorder.Body.String()).To(ContainSubstring("missing Authorization header"))
		})
	})

	Context("TokenReview API Failures", func() {
		It("should return 503 if TokenReview API unavailable", func() {
			// Arrange: Simulate K8s API error
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, nil, fmt.Errorf("API server unavailable")
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				Fail("handler should not be reached when API unavailable")
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(recorder.Code).To(Equal(http.StatusServiceUnavailable))
			Expect(recorder.Body.String()).To(ContainSubstring("TokenReview API unavailable"))
		})

		It("should return 500 if TokenReview returns unexpected error", func() {
			// Arrange: Simulate unexpected error
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, nil, fmt.Errorf("Internal server error")
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				Fail("handler should not be reached on error")
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer valid-token")
			handler.ServeHTTP(recorder, req)

			// Assert: Should return 503 (service unavailable) for any TokenReview API error
			Expect(recorder.Code).To(Equal(http.StatusServiceUnavailable))
		})
	})

	Context("ServiceAccount Extraction", func() {
		It("should extract namespace from token", func() {
			// Arrange
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: true,
						User: authv1.UserInfo{
							Username: "system:serviceaccount:test-namespace:test-sa",
						},
					},
				}, nil
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			
			var username string
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				username = r.Context().Value("serviceaccount").(string)
				w.WriteHeader(http.StatusOK)
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer test-token")
			handler.ServeHTTP(recorder, req)

			// Assert: Full username should be stored (namespace extraction happens in authorization layer)
			Expect(username).To(Equal("system:serviceaccount:test-namespace:test-sa"))
		})

		It("should extract ServiceAccount name from token", func() {
			// Arrange
			k8sClient.PrependReactor("create", "tokenreviews", func(action k8stesting.Action) (bool, runtime.Object, error) {
				return true, &authv1.TokenReview{
					Status: authv1.TokenReviewStatus{
						Authenticated: true,
						User: authv1.UserInfo{
							Username: "system:serviceaccount:monitoring:prometheus-server",
						},
					},
				}, nil
			})

			authMiddleware := TokenReviewAuth(k8sClient)
			
			var username string
			testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				username = r.Context().Value("serviceaccount").(string)
				w.WriteHeader(http.StatusOK)
			})
			handler = authMiddleware(testHandler)

			// Act
			req := httptest.NewRequest("POST", "/webhook/prometheus", nil)
			req.Header.Set("Authorization", "Bearer prometheus-token")
			handler.ServeHTTP(recorder, req)

			// Assert
			Expect(username).To(Equal("system:serviceaccount:monitoring:prometheus-server"))
		})
	})
})

