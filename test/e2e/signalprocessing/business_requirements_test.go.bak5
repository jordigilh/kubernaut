/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package signalprocessing_e2e contains E2E/BR tests for SignalProcessing business requirements.
// These tests validate business value delivery - SLAs, efficiency, reliability.
//
// Defense-in-Depth Strategy (per 03-testing-strategy.mdc):
// - Unit tests (70%+): Business logic in isolation (test/unit/signalprocessing/)
// - Integration tests (>50%): CRD coordination (test/integration/signalprocessing/)
// - E2E/BR tests (10-15%): Complete workflow validation (this directory)
//
// TDD Phase: RED - Tests define expected business behavior
// These tests will FAIL until controller implementation is complete (GREEN phase)
//
// Purpose: Validate that SignalProcessing delivers business value as specified
// Audience: Business stakeholders + developers
// Execution: make test-e2e-signalprocessing
//
// Business Requirements Validated:
// - BR-SP-051: Environment classification from namespace labels
// - BR-SP-070: Priority assignment (P0-P3) based on environment + severity
// - BR-SP-100: Owner chain traversal for enrichment
// - BR-SP-101: Detected labels (PDB, HPA, NetworkPolicy)
// - BR-SP-102: CustomLabels from Rego policies
//
// NOTE: These tests duplicate some integration test scenarios intentionally
// for defense-in-depth coverage. E2E tests run against real Kind cluster
// while integration tests use ENVTEST.
package signalprocessing_e2e

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/google/uuid"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	dsgen "github.com/jordigilh/kubernaut/pkg/datastorage/ogen-client"
	spaudit "github.com/jordigilh/kubernaut/pkg/signalprocessing/audit"

	appsv1 "k8s.io/api/apps/v1"
	autoscalingv2 "k8s.io/api/autoscaling/v2"
	corev1 "k8s.io/api/core/v1"
	policyv1 "k8s.io/api/policy/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"sigs.k8s.io/controller-runtime/pkg/client"

	remediationv1alpha1 "github.com/jordigilh/kubernaut/api/remediation/v1alpha1"
	signalprocessingv1alpha1 "github.com/jordigilh/kubernaut/api/signalprocessing/v1alpha1"
	sharedtypes "github.com/jordigilh/kubernaut/pkg/shared/types"
)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-001: K8s Context Enrichment (Node Enrichment)
// BUSINESS VALUE: AI Analysis can identify node-level issues from pod alerts
// STAKEHOLDER: Operations team needs full context including node characteristics
// NOTE: Node enrichment requires real K8s nodes (Kind cluster), not ENVTEST
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-001: Node Enrichment Enables Infrastructure Analysis", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-node-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{Name: testNs},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-001: Node enrichment - moved from integration tier (ENVTEST limitation)
	It("BR-SP-001: should enrich Node context when Pod is scheduled", func() {
		By("Creating a Pod that will be scheduled to a real node")
		pod := &corev1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "node-test-pod",
				Namespace: testNs,
				Labels:    map[string]string{"app": "node-test"},
			},
			Spec: corev1.PodSpec{
				Containers: []corev1.Container{{
					Name:  "main",
					Image: "nginx:latest",
				}},
			},
		}
		Expect(k8sClient.Create(ctx, pod)).To(Succeed())

		By("Waiting for Pod to be scheduled to a node")
		var nodeName string
		Eventually(func() string {
			var updated corev1.Pod
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(pod), &updated); err != nil {
				return ""
			}
			nodeName = updated.Spec.NodeName
			return nodeName
		}, timeout, interval).ShouldNot(BeEmpty())

		By("Creating SignalProcessing CR targeting the scheduled Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-node-enrich",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-node-enrich-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "abcd1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab",
					Name:         "NodeEnrichTest",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "node-test-pod",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for Node enrichment in KubernetesContext")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil || updated.Status.KubernetesContext.Node == nil {
				return false
			}
			// Verify node enrichment occurred (Node has labels from real cluster)
			return len(updated.Status.KubernetesContext.Node.Labels) > 0
		}, timeout, interval).Should(BeTrue())

		By("Verifying Pod context includes node name and Node context includes labels")
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		// Pod details should contain node name
		Expect(final.Status.KubernetesContext.Pod).ToNot(BeNil())
		Expect(final.Status.KubernetesContext.Pod.NodeName).To(Equal(nodeName))
		// Node details should be enriched with labels
		Expect(final.Status.KubernetesContext.Node).ToNot(BeNil())
		// Kind nodes have labels like kubernetes.io/hostname, etc.
		Expect(len(final.Status.KubernetesContext.Node.Labels)).To(BeNumerically(">", 0))
	})

	// K8sEnricher degraded mode test - validates proper integration
	It("BR-SP-001: should enter degraded mode when target Pod does not exist", func() {
		By("Creating SignalProcessing CR targeting non-existent pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-degraded-mode",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-degraded-mode-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6",
					Name:         "DegradedModeTest",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "non-existent-pod-that-does-not-exist",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for DegradedMode to be set")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			return updated.Status.KubernetesContext.DegradedMode
		}, timeout, interval).Should(BeTrue())

		By("Verifying namespace context is still enriched in degraded mode")
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		// Namespace should still be populated
		Expect(final.Status.KubernetesContext.Namespace).ToNot(BeNil())
		Expect(final.Status.KubernetesContext.Namespace.Name).To(Equal(testNs))
		// But Pod should be nil (target not found)
		Expect(final.Status.KubernetesContext.Pod).To(BeNil())
		// DegradedMode should be true
		Expect(final.Status.KubernetesContext.DegradedMode).To(BeTrue())
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-070: Priority Assignment
// BUSINESS VALUE: Operations team gets correct priority for alert triage
// STAKEHOLDER: On-call engineers need accurate priority for response decisions
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-070: Priority Assignment Delivers Correct Business Outcomes", func() {

	Context("Production Environment Prioritization", func() {
		var testNs string

		BeforeEach(func() {
			testNs = fmt.Sprintf("e2e-prod-%d", uuid.New().String()[:8])
			ns := &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name: testNs,
					Labels: map[string]string{
						"kubernaut.ai/environment": "production",
					},
				},
			}
			Expect(k8sClient.Create(ctx, ns)).To(Succeed())
		})

		AfterEach(func() {
			ns := &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}}
			_ = k8sClient.Delete(ctx, ns)
		})

		// TDD RED: This test will FAIL until controller assigns P0 priority
		It("BR-SP-070: should assign P0 to production critical alerts (highest urgency)", func() {
			By("Creating SignalProcessing CR for production critical alert")
			sp := &signalprocessingv1alpha1.SignalProcessing{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "e2e-priority-p0",
					Namespace: testNs,
				},
				Spec: signalprocessingv1alpha1.SignalProcessingSpec{
					RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
						APIVersion: "kubernaut.ai/v1alpha1",
						Kind:       "RemediationRequest",
						Name:       "e2e-priority-p0-rr",
						Namespace:  testNs,
					},
					Signal: signalprocessingv1alpha1.SignalData{
						Fingerprint:  "a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1",
						Name:         "HighCPU",
						Severity:     "critical",
						Type:         "prometheus",
						TargetType:   "kubernetes",
						ReceivedTime: metav1.Now(),
						TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
							Kind:      "Pod",
							Name:      "api-server-xyz",
							Namespace: testNs,
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, sp)).To(Succeed())

			By("Waiting for priority assignment")
			Eventually(func() string {
				var updated signalprocessingv1alpha1.SignalProcessing
				if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
					return ""
				}
				if updated.Status.PriorityAssignment == nil {
					return ""
				}
				return updated.Status.PriorityAssignment.Priority
			}, timeout, interval).Should(Equal("P0"))

			By("Verifying business outcome: production critical = highest urgency")
			var final signalprocessingv1alpha1.SignalProcessing
			Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
			Expect(final.Status.PriorityAssignment.Priority).To(Equal("P0"))
			// Accept either rego-policy (with Rego engine) or policy-matrix (fallback)
			Expect(final.Status.PriorityAssignment.Source).To(BeElementOf("rego-policy", "policy-matrix"))
		})

		// TDD RED: This test will FAIL until controller assigns P1 priority
		It("BR-SP-070: should assign P1 to production warning alerts (high urgency)", func() {
			By("Creating SignalProcessing CR for production warning alert")
			sp := &signalprocessingv1alpha1.SignalProcessing{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "e2e-priority-p1",
					Namespace: testNs,
				},
				Spec: signalprocessingv1alpha1.SignalProcessingSpec{
					RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
						APIVersion: "kubernaut.ai/v1alpha1",
						Kind:       "RemediationRequest",
						Name:       "e2e-priority-p1-rr",
						Namespace:  testNs,
					},
					Signal: signalprocessingv1alpha1.SignalData{
						Fingerprint:  "b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2",
						Name:         "MemoryPressure",
						Severity:     "warning",
						Type:         "prometheus",
						TargetType:   "kubernetes",
						ReceivedTime: metav1.Now(),
						TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
							Kind:      "Pod",
							Name:      "worker-abc",
							Namespace: testNs,
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, sp)).To(Succeed())

			By("Waiting for priority assignment")
			Eventually(func() string {
				var updated signalprocessingv1alpha1.SignalProcessing
				if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
					return ""
				}
				if updated.Status.PriorityAssignment == nil {
					return ""
				}
				return updated.Status.PriorityAssignment.Priority
			}, timeout, interval).Should(Equal("P1"))
		})
	})

	Context("Non-Production Environment Prioritization", func() {
		var stagingNs, devNs string

		BeforeEach(func() {
			stagingNs = fmt.Sprintf("e2e-staging-%d", uuid.New().String()[:8])
			devNs = fmt.Sprintf("e2e-dev-%d", uuid.New().String()[:8])

			// Create staging namespace
			Expect(k8sClient.Create(ctx, &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name:   stagingNs,
					Labels: map[string]string{"kubernaut.ai/environment": "staging"},
				},
			})).To(Succeed())

			// Create development namespace
			Expect(k8sClient.Create(ctx, &corev1.Namespace{
				ObjectMeta: metav1.ObjectMeta{
					Name:   devNs,
					Labels: map[string]string{"kubernaut.ai/environment": "development"},
				},
			})).To(Succeed())
		})

		AfterEach(func() {
			_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: stagingNs}})
			_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: devNs}})
		})

		// TDD RED: This test will FAIL until controller assigns P2 priority
		It("BR-SP-070: should assign P2 to staging critical alerts (medium urgency)", func() {
			sp := &signalprocessingv1alpha1.SignalProcessing{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "e2e-priority-p2",
					Namespace: stagingNs,
				},
				Spec: signalprocessingv1alpha1.SignalProcessingSpec{
					RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
						APIVersion: "kubernaut.ai/v1alpha1",
						Kind:       "RemediationRequest",
						Name:       "e2e-priority-p2-rr",
						Namespace:  stagingNs,
					},
					Signal: signalprocessingv1alpha1.SignalData{
						Fingerprint:  "c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3",
						Name:         "StagingCritical",
						Severity:     "critical",
						Type:         "prometheus",
						TargetType:   "kubernetes",
						ReceivedTime: metav1.Now(),
						TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
							Kind:      "Pod",
							Name:      "staging-pod",
							Namespace: stagingNs,
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, sp)).To(Succeed())

			Eventually(func() string {
				var updated signalprocessingv1alpha1.SignalProcessing
				if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
					return ""
				}
				if updated.Status.PriorityAssignment == nil {
					return ""
				}
				return updated.Status.PriorityAssignment.Priority
			}, timeout, interval).Should(Equal("P2"))
		})

		// TDD RED: This test will FAIL until controller assigns P3 priority
		It("BR-SP-070: should assign P3 to development alerts (low urgency)", func() {
			sp := &signalprocessingv1alpha1.SignalProcessing{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "e2e-priority-p3",
					Namespace: devNs,
				},
				Spec: signalprocessingv1alpha1.SignalProcessingSpec{
					RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
						APIVersion: "kubernaut.ai/v1alpha1",
						Kind:       "RemediationRequest",
						Name:       "e2e-priority-p3-rr",
						Namespace:  devNs,
					},
					Signal: signalprocessingv1alpha1.SignalData{
						Fingerprint:  "d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4",
						Name:         "DevInfo",
						Severity:     "info",
						Type:         "prometheus",
						TargetType:   "kubernetes",
						ReceivedTime: metav1.Now(),
						TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
							Kind:      "Pod",
							Name:      "dev-pod",
							Namespace: devNs,
						},
					},
				},
			}
			Expect(k8sClient.Create(ctx, sp)).To(Succeed())

			Eventually(func() string {
				var updated signalprocessingv1alpha1.SignalProcessing
				if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
					return ""
				}
				if updated.Status.PriorityAssignment == nil {
					return ""
				}
				return updated.Status.PriorityAssignment.Priority
			}, timeout, interval).Should(Equal("P3"))
		})
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-051: Environment Classification
// BUSINESS VALUE: Alerts are routed to correct team based on environment
// STAKEHOLDER: Operations team needs environment context for escalation
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-051: Environment Classification Enables Correct Routing", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-env-%d", uuid.New().String()[:8])
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// TDD RED: This test will FAIL until controller classifies environment
	It("BR-SP-051: should classify production from namespace label with high confidence", func() {
		By("Creating namespace with production label")
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"kubernaut.ai/environment": "production",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())

		By("Creating SignalProcessing CR")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-env-prod",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-env-prod-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5",
					Name:         "TestAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "test-pod",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for environment classification")
		Eventually(func() string {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return ""
			}
			if updated.Status.EnvironmentClassification == nil {
				return ""
			}
			return updated.Status.EnvironmentClassification.Environment
		}, timeout, interval).Should(Equal("production"))

		By("Verifying environment classification from namespace label")
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		Expect(final.Status.EnvironmentClassification.Source).To(Equal("namespace-labels"))
	})

	// TDD RED: This test will FAIL until controller defaults to unknown
	It("BR-SP-053: should default to unknown for unclassifiable namespaces", func() {
		By("Creating namespace without environment label")
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				// No kubernaut.ai/environment label
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())

		By("Creating SignalProcessing CR")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-env-unknown",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-env-unknown-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6",
					Name:         "UnclassifiedAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "unclassified-pod",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for default environment classification")
		Eventually(func() string {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return ""
			}
			if updated.Status.EnvironmentClassification == nil {
				return ""
			}
			return updated.Status.EnvironmentClassification.Environment
		}, timeout, interval).Should(Equal("unknown"))
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-100: Owner Chain Traversal
// BUSINESS VALUE: AI analysis can identify deployment-level issues from pod alerts
// STAKEHOLDER: AI Analysis service needs owner context for recommendations
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-100: Owner Chain Enables Root Cause Analysis", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-owner-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{Name: testNs},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// TDD RED: This test will FAIL until controller builds owner chain
	// FlakeAttempts(3): Timing-sensitive test due to controller reconciliation
	It("BR-SP-100: should build complete owner chain for accurate root cause identification", FlakeAttempts(3), func() {
		By("Creating Deployment with Pod")
		replicas := int32(1)
		deployment := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "api-deployment",
				Namespace: testNs,
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "api"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "api"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "api",
							Image: "nginx:latest",
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deployment)).To(Succeed())

		By("Waiting for Pod to be created by Deployment")
		var podName string
		Eventually(func() bool {
			pods := &corev1.PodList{}
			if err := k8sClient.List(ctx, pods, client.InNamespace(testNs)); err != nil {
				return false
			}
			for _, pod := range pods.Items {
				if len(pod.OwnerReferences) > 0 {
					podName = pod.Name
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-owner-chain",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-owner-chain-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7",
					Name:         "PodAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      podName,
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for owner chain to be populated")
		Eventually(func() int {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return 0
			}
			if updated.Status.KubernetesContext == nil {
				return 0
			}
			return len(updated.Status.KubernetesContext.OwnerChain)
		}, timeout, interval).Should(BeNumerically(">=", 2))

		By("Verifying owner chain includes ReplicaSet and Deployment")
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		ownerKinds := make([]string, len(final.Status.KubernetesContext.OwnerChain))
		for i, owner := range final.Status.KubernetesContext.OwnerChain {
			ownerKinds[i] = owner.Kind
		}
		Expect(ownerKinds).To(ContainElement("ReplicaSet"))
		Expect(ownerKinds).To(ContainElement("Deployment"))
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-101: Detected Labels (PDB, HPA)
// BUSINESS VALUE: Remediation workflows respect cluster safety features
// STAKEHOLDER: Platform team needs remediation to honor PDB/HPA
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-101: Detected Labels Enable Safe Remediation Decisions", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-detect-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{Name: testNs},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// TDD RED: This test will FAIL until controller detects PDB
	It("BR-SP-101: should detect PDB protection to prevent unsafe pod deletion", func() {
		By("Creating Pod with labels")
		pod := &corev1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "protected-pod",
				Namespace: testNs,
				Labels:    map[string]string{"app": "protected"},
			},
			Spec: corev1.PodSpec{
				Containers: []corev1.Container{{
					Name:  "main",
					Image: "nginx:latest",
				}},
			},
		}
		Expect(k8sClient.Create(ctx, pod)).To(Succeed())

		By("Creating PDB matching pod labels")
		minAvailable := intstr.FromInt(1)
		pdb := &policyv1.PodDisruptionBudget{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "protected-pdb",
				Namespace: testNs,
			},
			Spec: policyv1.PodDisruptionBudgetSpec{
				MinAvailable: &minAvailable,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "protected"},
				},
			},
		}
		Expect(k8sClient.Create(ctx, pdb)).To(Succeed())

		By("Creating SignalProcessing CR")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-pdb-detect",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-pdb-detect-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8",
					Name:         "PDBAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "protected-pod",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for PDB detection")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil || updated.Status.KubernetesContext.DetectedLabels == nil {
				return false
			}
			return updated.Status.KubernetesContext.DetectedLabels.HasPDB
		}, timeout, interval).Should(BeTrue())
	})

	// TDD RED: This test will FAIL until controller detects HPA
	// FlakeAttempts(3): Timing-sensitive test due to controller reconciliation and HPA detection
	It("BR-SP-101: should detect HPA to prevent conflicting scale operations", FlakeAttempts(3), func() {
		By("Creating Deployment")
		replicas := int32(1)
		deployment := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "scalable-deployment",
				Namespace: testNs,
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "scalable"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "scalable"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "main",
							Image: "nginx:latest",
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deployment)).To(Succeed())

		By("Creating HPA targeting deployment")
		minReplicas := int32(1)
		hpa := &autoscalingv2.HorizontalPodAutoscaler{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "scalable-hpa",
				Namespace: testNs,
			},
			Spec: autoscalingv2.HorizontalPodAutoscalerSpec{
				ScaleTargetRef: autoscalingv2.CrossVersionObjectReference{
					APIVersion: "apps/v1",
					Kind:       "Deployment",
					Name:       "scalable-deployment",
				},
				MinReplicas: &minReplicas,
				MaxReplicas: 5,
			},
		}
		Expect(k8sClient.Create(ctx, hpa)).To(Succeed())

		By("Waiting for Pod to be created")
		var podName string
		Eventually(func() bool {
			pods := &corev1.PodList{}
			if err := k8sClient.List(ctx, pods, client.InNamespace(testNs)); err != nil {
				return false
			}
			for _, pod := range pods.Items {
				if pod.Labels["app"] == "scalable" {
					podName = pod.Name
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-hpa-detect",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-hpa-detect-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9",
					Name:         "HPAAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      podName,
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for HPA detection")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil || updated.Status.KubernetesContext.DetectedLabels == nil {
				return false
			}
			return updated.Status.KubernetesContext.DetectedLabels.HasHPA
		}, timeout, interval).Should(BeTrue())
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-102: CustomLabels from Rego
// BUSINESS VALUE: Customer-defined labels enable custom alert routing
// STAKEHOLDER: Platform customers need custom classification rules
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-102: CustomLabels Enable Business-Specific Routing", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-custom-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"kubernaut.ai/team": "payments",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// TDD RED: This test will FAIL until controller extracts custom labels
	It("BR-SP-102: should extract custom labels from Rego policies", func() {
		By("Creating SignalProcessing CR")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-custom-labels",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-custom-labels-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0",
					Name:         "PaymentsAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "payments-api",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for custom labels to be populated")
		Eventually(func() int {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return 0
			}
			if updated.Status.KubernetesContext == nil {
				return 0
			}
			return len(updated.Status.KubernetesContext.CustomLabels)
		}, timeout, interval).Should(BeNumerically(">", 0))

		By("Verifying team label was extracted")
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		Expect(final.Status.KubernetesContext.CustomLabels).To(HaveKey("team"))
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-090: Categorization Audit Trail
// BUSINESS VALUE: Compliance audit trail for all signal processing decisions
// STAKEHOLDER: Compliance team needs immutable record of classification decisions
// ADR-032: Data Access Layer Isolation - audit writes via Data Storage REST API
// ADR-038: Async Buffered Audit - fire-and-forget pattern, <1ms overhead
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-090: Categorization Audit Trail Provides Compliance Evidence", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-audit-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"kubernaut.ai/environment": "production",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-090: Verify audit events are written to DataStorage
	It("BR-SP-090: should write audit events to DataStorage when signal is processed", func() {
		By("Verifying DataStorage is accessible on NodePort 30081")
		Eventually(func() bool {
			resp, err := http.Get("http://localhost:30081/health")
			if err != nil {
				GinkgoWriter.Printf("  âš ï¸  DataStorage health check failed: %v\n", err)
				return false
			}
			defer func() { _ = resp.Body.Close() }()
			GinkgoWriter.Printf("  âœ… DataStorage health: %d\n", resp.StatusCode)
			return resp.StatusCode == http.StatusOK
		}, 30*time.Second, 2*time.Second).Should(BeTrue(), "DataStorage should be accessible")

		By("Creating parent RemediationRequest (matches production architecture)")
		fingerprint := "abcd1234567890abcdef1234567890abcdef1234567890abcdef1234567890ab"
		targetResource := signalprocessingv1alpha1.ResourceIdentifier{
			Kind:      "Pod",
			Name:      "audit-test-pod",
			Namespace: testNs,
		}

		// Create parent RemediationRequest (RO creates this in production)
		rr := &remediationv1alpha1.RemediationRequest{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-audit-test-rr",
				Namespace: testNs,
			},
			Spec: remediationv1alpha1.RemediationRequestSpec{
				SignalFingerprint: fingerprint,
				SignalName:        "AuditTestSignal",
				Severity:          "critical",
				SignalType:        "prometheus",
				SignalSource:      "prometheus-adapter",
				TargetType:        "kubernetes",
				TargetResource: remediationv1alpha1.ResourceIdentifier{
					Kind:      targetResource.Kind,
					Name:      targetResource.Name,
					Namespace: targetResource.Namespace,
				},
				FiringTime:   metav1.Now(),
				ReceivedTime: metav1.Now(),
				Deduplication: sharedtypes.DeduplicationInfo{
					IsDuplicate:     false,
					FirstOccurrence: metav1.Now(),
					LastOccurrence:  metav1.Now(),
					OccurrenceCount: 1,
				},
				IsStorm: false,
			},
		}
		Expect(k8sClient.Create(ctx, rr)).To(Succeed())

		By("Creating SignalProcessing CR with RemediationRequestRef")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-audit-test",
				Namespace: testNs,
				OwnerReferences: []metav1.OwnerReference{
					*metav1.NewControllerRef(rr, remediationv1alpha1.GroupVersion.WithKind("RemediationRequest")),
				},
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: remediationv1alpha1.GroupVersion.String(),
					Kind:       "RemediationRequest",
					Name:       rr.Name,
					Namespace:  rr.Namespace,
					UID:        string(rr.UID),
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:    fingerprint,
					Name:           "AuditTestSignal",
					Severity:       "critical",
					Type:           "prometheus",
					TargetType:     "kubernetes",
					ReceivedTime:   metav1.Now(),
					TargetResource: targetResource,
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for signal processing to complete")
		Eventually(func() signalprocessingv1alpha1.SignalProcessingPhase {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				GinkgoWriter.Printf("  âš ï¸  Failed to get SignalProcessing: %v\n", err)
				return ""
			}
			GinkgoWriter.Printf("  ğŸ” Current phase: %s (expected: %s)\n", updated.Status.Phase, signalprocessingv1alpha1.PhaseCompleted)
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				// Log controller pod status for debugging
				GinkgoWriter.Printf("  ğŸ“‹ Phase not completed yet, checking controller status...\n")
			}
			return updated.Status.Phase
		}, timeout, interval).Should(Equal(signalprocessingv1alpha1.PhaseCompleted))

		By("Waiting for BufferedStore to flush audit events (2-3 seconds)")
		// BufferedStore has a 1-second flush interval + round-trip time to DataStorage
		time.Sleep(3 * time.Second)

		By("Querying DataStorage audit API for signal.processed events")
		// DataStorage is exposed on NodePort 30081 â†’ localhost:30081 via Kind port mapping

		Eventually(func() bool {
			// Query audit events from DataStorage
			auditEvents, err := queryAuditEvents("e2e-audit-test-rr")
			if err != nil {
				GinkgoWriter.Printf("  âš ï¸  Audit query failed: %v\n", err)
				return false
			}

			// Debug: Log all events for visibility
			GinkgoWriter.Printf("  ğŸ” Total audit events returned: %d\n", len(auditEvents))
			for i, event := range auditEvents {
			eventType := "unknown"
			if event.EventType != "" {
				eventType = event.EventType
			}
			resourceId := "unknown"
			if event.ResourceID.Set {
				resourceId = event.ResourceID.Value
			}
			GinkgoWriter.Printf("    [%d] type=%s resource=%s\n", i, eventType, resourceId)
			}

			// Verify we got audit events
			if len(auditEvents) == 0 {
				GinkgoWriter.Printf("  â³ No audit events found yet\n")
				return false
			}

			GinkgoWriter.Printf("  âœ… Found %d total audit events\n", len(auditEvents))

		// Filter events for our specific SignalProcessing resource
		hasSignalProcessed := false
		hasClassificationDecision := false
		for _, event := range auditEvents {
			// Only check events for this specific test resource
			// OpenAPI types use OptString for optional fields
			if !event.ResourceID.Set || event.ResourceID.Value != "e2e-audit-test" {
				continue
			}
			GinkgoWriter.Printf("    â€¢ Event: %s (resource: %s)\n", event.EventType, event.ResourceID.Value)
			if event.EventType == spaudit.EventTypeSignalProcessed {
				hasSignalProcessed = true
			}
			if event.EventType == spaudit.EventTypeClassificationDecision {
				hasClassificationDecision = true
			}
		}

			return hasSignalProcessed && hasClassificationDecision
		}, 60*time.Second, 3*time.Second).Should(BeTrue(),
			"Expected signalprocessing.signal.processed AND signalprocessing.classification.decision audit events")

		By("Verifying audit event data integrity")
		auditEvents, err := queryAuditEvents("e2e-audit-test-rr")
		Expect(err).ToNot(HaveOccurred())

	// Filter events for our specific resource
	var resourceEvents []dsgen.AuditEvent
	for _, event := range auditEvents {
		// Handle OpenAPI OptString types
		if event.ResourceID.Set && event.ResourceID.Value == "e2e-audit-test" {
			resourceEvents = append(resourceEvents, event)
		}
	}
		Expect(len(resourceEvents)).To(BeNumerically(">=", 2),
			"Expected at least 2 audit events for resource e2e-audit-test")

		// Find signalprocessing.signal.processed event and validate data
		var signalEvent *dsgen.AuditEvent
		for i := range resourceEvents {
			if resourceEvents[i].EventType == spaudit.EventTypeSignalProcessed {
				signalEvent = &resourceEvents[i]
				break
			}
		}
	Expect(signalEvent).ToNot(BeNil(), "signalprocessing.signal.processed event should exist")
	// OpenAPI types use OptString for optional fields
	Expect(signalEvent.ActorID.Set).To(BeTrue())
	Expect(signalEvent.ActorID.Value).To(Equal("signalprocessing-controller"))
	Expect(signalEvent.ResourceType.Set).To(BeTrue())
	Expect(signalEvent.ResourceType.Value).To(Equal("SignalProcessing"))
	Expect(signalEvent.ResourceID.Set).To(BeTrue())
	Expect(signalEvent.ResourceID.Value).To(Equal("e2e-audit-test"))
		// Note: Namespace may be empty in current implementation
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-103: Workload Type Enrichment (StatefulSet, DaemonSet, Service)
// BUSINESS VALUE: AI Analysis understands different workload patterns for better remediation
// STAKEHOLDER: Operations team needs workload-specific context
// COVERAGE: Targets enrichStatefulSet, enrichDaemonSet, enrichService (0% coverage)
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-103: Workload Type Enrichment Enables Workload-Specific Remediation", func() {
	var testNs string

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-workload-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"kubernaut.ai/environment": "production",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-A: StatefulSet enrichment - targets enrichStatefulSet (0% coverage)
	It("BR-SP-103-A: should enrich StatefulSet context for stateful workloads", func() {
		By("Creating a StatefulSet with a headless service")

		// Create headless service required for StatefulSet
		svc := &corev1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "stateful-svc",
				Namespace: testNs,
			},
			Spec: corev1.ServiceSpec{
				ClusterIP: "None",
				Selector:  map[string]string{"app": "stateful"},
				Ports: []corev1.ServicePort{{
					Port:       80,
					TargetPort: intstr.FromInt(8080),
				}},
			},
		}
		Expect(k8sClient.Create(ctx, svc)).To(Succeed())

		// Create StatefulSet
		replicas := int32(1)
		sts := &appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "stateful-app",
				Namespace: testNs,
			},
			Spec: appsv1.StatefulSetSpec{
				ServiceName: "stateful-svc",
				Replicas:    &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "stateful"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "stateful"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "app",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sts)).To(Succeed())

		By("Waiting for StatefulSet Pod to be created")
		var podName string
		Eventually(func() bool {
			pods := &corev1.PodList{}
			if err := k8sClient.List(ctx, pods, client.InNamespace(testNs)); err != nil {
				return false
			}
			for _, pod := range pods.Items {
				if pod.Labels["app"] == "stateful" {
					podName = pod.Name
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the StatefulSet Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-statefulset-test",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-statefulset-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2",
					Name:         "StatefulSetPodAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      podName,
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for owner chain to include StatefulSet")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			// Check owner chain includes StatefulSet
			for _, owner := range updated.Status.KubernetesContext.OwnerChain {
				if owner.Kind == "StatefulSet" && owner.Name == "stateful-app" {
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())
	})

	// BR-SP-103-B: DaemonSet enrichment - targets enrichDaemonSet (0% coverage)
	It("BR-SP-103-B: should enrich DaemonSet context for node-level workloads", func() {
		By("Creating a DaemonSet")
		ds := &appsv1.DaemonSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "daemon-app",
				Namespace: testNs,
			},
			Spec: appsv1.DaemonSetSpec{
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "daemon"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "daemon"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "app",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, ds)).To(Succeed())

		By("Waiting for DaemonSet Pod to be created")
		var podName string
		Eventually(func() bool {
			pods := &corev1.PodList{}
			if err := k8sClient.List(ctx, pods, client.InNamespace(testNs)); err != nil {
				return false
			}
			for _, pod := range pods.Items {
				if pod.Labels["app"] == "daemon" {
					podName = pod.Name
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the DaemonSet Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-daemonset-test",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-daemonset-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3",
					Name:         "DaemonSetPodAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      podName,
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for owner chain to include DaemonSet")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			// Check owner chain includes DaemonSet
			for _, owner := range updated.Status.KubernetesContext.OwnerChain {
				if owner.Kind == "DaemonSet" && owner.Name == "daemon-app" {
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())
	})

	// BR-SP-103-C: Service enrichment - targets enrichService (0% coverage)
	It("BR-SP-103-C: should detect Service association for network-aware remediation", func() {
		By("Creating a Deployment with matching labels")
		replicas := int32(1)
		deployment := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "svc-target-deployment",
				Namespace: testNs,
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "svc-target"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "svc-target"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "app",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deployment)).To(Succeed())

		By("Creating a Service targeting the Deployment pods")
		svc := &corev1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "target-service",
				Namespace: testNs,
			},
			Spec: corev1.ServiceSpec{
				Selector: map[string]string{"app": "svc-target"},
				Ports: []corev1.ServicePort{{
					Port:       80,
					TargetPort: intstr.FromInt(8080),
				}},
			},
		}
		Expect(k8sClient.Create(ctx, svc)).To(Succeed())

		By("Waiting for Pod to be created")
		var podName string
		Eventually(func() bool {
			pods := &corev1.PodList{}
			if err := k8sClient.List(ctx, pods, client.InNamespace(testNs)); err != nil {
				return false
			}
			for _, pod := range pods.Items {
				if pod.Labels["app"] == "svc-target" {
					podName = pod.Name
					return true
				}
			}
			return false
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the Pod")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-service-test",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-service-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4",
					Name:         "ServicePodAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      podName,
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Waiting for processing to complete with Service context")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			// Processing should complete - Service enrichment happens during enriching phase
			return updated.Status.Phase == signalprocessingv1alpha1.PhaseCompleted
		}, timeout, interval).Should(BeTrue())

		// Verify the processing completed successfully
		var final signalprocessingv1alpha1.SignalProcessing
		Expect(k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &final)).To(Succeed())
		Expect(final.Status.Phase).To(Equal(signalprocessingv1alpha1.PhaseCompleted))
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-103-D/E/F: Workload-Specific Enrichment (Direct Resource Targeting)
// BUSINESS VALUE: Enable workload-type-specific remediation strategies
// COVERAGE GOAL: Improve E2E enricher coverage from 24.9% to 43%
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-103-D: Deployment Signal Enrichment", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-deploy-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "production",
					"team":        "platform",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-D: Deployment enrichment - targets enrichDeploymentSignal (0% â†’ 75%)
	It("BR-SP-103-D: should enrich Deployment context for rollout-aware remediation", func() {
		By("Creating a Deployment with multiple replicas")
		replicas := int32(3)
		deploy := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "api-gateway",
				Namespace: testNs,
				Labels: map[string]string{
					"app":  "api-gateway",
					"tier": "frontend",
				},
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "api-gateway"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "api-gateway"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "api",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deploy)).To(Succeed())

		By("Waiting for Deployment to become available")
		Eventually(func() bool {
			var d appsv1.Deployment
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(deploy), &d); err != nil {
				return false
			}
			return d.Status.AvailableReplicas > 0
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the Deployment directly")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-deployment-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-deployment-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2",
					Name:         "DeploymentRolloutAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Deployment",
						Name:      "api-gateway",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying Deployment enrichment with DeploymentDetails")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			if updated.Status.KubernetesContext.Deployment == nil {
				return false
			}
			// Verify Deployment populated with correct replica counts
			details := updated.Status.KubernetesContext.Deployment
			return details.Replicas == 3 &&
				details.AvailableReplicas > 0 &&
				len(details.Labels) > 0
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-103-A: StatefulSet Signal Enrichment (Fixed)", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-sts-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "production",
					"team":        "data",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-A: StatefulSet enrichment - targets enrichStatefulSetSignal (0% â†’ 75%)
	// FIXED: Now targets StatefulSet directly instead of Pod
	It("BR-SP-103-A: should enrich StatefulSet context for stateful workloads", func() {
		By("Creating a headless service for StatefulSet")
		svc := &corev1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "database-svc",
				Namespace: testNs,
			},
			Spec: corev1.ServiceSpec{
				ClusterIP: "None",
				Selector:  map[string]string{"app": "database"},
				Ports: []corev1.ServicePort{{
					Port:       5432,
					TargetPort: intstr.FromInt(5432),
				}},
			},
		}
		Expect(k8sClient.Create(ctx, svc)).To(Succeed())

		By("Creating a StatefulSet")
		replicas := int32(2)
		sts := &appsv1.StatefulSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "database",
				Namespace: testNs,
				Labels: map[string]string{
					"app":  "database",
					"tier": "data",
				},
			},
			Spec: appsv1.StatefulSetSpec{
				ServiceName: "database-svc",
				Replicas:    &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "database"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "database"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "db",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sts)).To(Succeed())

		By("Waiting for StatefulSet to have at least one ready replica")
		Eventually(func() bool {
			var s appsv1.StatefulSet
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sts), &s); err != nil {
				return false
			}
			return s.Status.ReadyReplicas > 0
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the StatefulSet directly")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-statefulset-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-statefulset-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2",
					Name:         "StatefulSetDataAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "StatefulSet",
						Name:      "database",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying StatefulSet enrichment with StatefulSetDetails")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			if updated.Status.KubernetesContext.StatefulSet == nil {
				return false
			}
			// Verify StatefulSet populated with correct replica counts
			details := updated.Status.KubernetesContext.StatefulSet
			return details.Replicas == 2 &&
				details.ReadyReplicas > 0 &&
				len(details.Labels) > 0
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-103-B: DaemonSet Signal Enrichment (Fixed)", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-ds-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "production",
					"team":        "platform",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-B: DaemonSet enrichment - targets enrichDaemonSetSignal (0% â†’ 75%)
	// FIXED: Now targets DaemonSet directly instead of Pod
	It("BR-SP-103-B: should enrich DaemonSet context for node-level workloads", func() {
		By("Creating a DaemonSet")
		ds := &appsv1.DaemonSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "log-collector",
				Namespace: testNs,
				Labels: map[string]string{
					"app":  "log-collector",
					"tier": "monitoring",
				},
			},
			Spec: appsv1.DaemonSetSpec{
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "log-collector"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "log-collector"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "collector",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, ds)).To(Succeed())

		By("Waiting for DaemonSet to have at least one ready pod")
		Eventually(func() bool {
			var d appsv1.DaemonSet
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(ds), &d); err != nil {
				return false
			}
			return d.Status.NumberReady > 0
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the DaemonSet directly")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-daemonset-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-daemonset-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "d1a2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
					Name:         "DaemonSetNodeAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "DaemonSet",
						Name:      "log-collector",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying DaemonSet enrichment with DaemonSetDetails")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			if updated.Status.KubernetesContext.DaemonSet == nil {
				return false
			}
			// Verify DaemonSet populated with scheduling information
			details := updated.Status.KubernetesContext.DaemonSet
			return details.DesiredNumberScheduled > 0 &&
				details.CurrentNumberScheduled > 0 &&
				len(details.Labels) > 0
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-103-C: ReplicaSet Signal Enrichment", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-rs-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "staging",
					"team":        "platform",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-C: ReplicaSet enrichment - targets enrichReplicaSetSignal (0% â†’ 75%)
	It("BR-SP-103-C: should enrich ReplicaSet context for replica management", func() {
		By("Creating a standalone ReplicaSet (no Deployment owner)")
		replicas := int32(2)
		rs := &appsv1.ReplicaSet{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "standalone-rs",
				Namespace: testNs,
				Labels: map[string]string{
					"app":  "standalone",
					"tier": "worker",
				},
			},
			Spec: appsv1.ReplicaSetSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "standalone"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "standalone"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "worker",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, rs)).To(Succeed())

		By("Waiting for ReplicaSet to have ready replicas")
		Eventually(func() bool {
			var r appsv1.ReplicaSet
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(rs), &r); err != nil {
				return false
			}
			return r.Status.ReadyReplicas > 0
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the ReplicaSet directly")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-replicaset-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-replicaset-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2",
					Name:         "ReplicaSetAlert",
					Severity:     "warning",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "ReplicaSet",
						Name:      "standalone-rs",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying ReplicaSet enrichment with ReplicaSetDetails")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			if updated.Status.KubernetesContext.ReplicaSet == nil {
				return false
			}
			// Verify ReplicaSet populated with replica counts
			details := updated.Status.KubernetesContext.ReplicaSet
			return details.Replicas == 2 &&
				details.ReadyReplicas > 0 &&
				len(details.Labels) > 0
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-103-E: Service Signal Enrichment", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-svc-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "production",
					"team":        "network",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-103-E: Service enrichment - targets enrichServiceSignal (0% â†’ 75%)
	It("BR-SP-103-E: should enrich Service context for network-aware remediation", func() {
		By("Creating a Deployment to be targeted by the Service")
		replicas := int32(2)
		deploy := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "backend",
				Namespace: testNs,
				Labels:    map[string]string{"app": "backend"},
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "backend"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "backend"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "api",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deploy)).To(Succeed())

		By("Creating a Service")
		svc := &corev1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "backend-service",
				Namespace: testNs,
				Labels: map[string]string{
					"app":  "backend",
					"tier": "backend",
				},
			},
			Spec: corev1.ServiceSpec{
				Selector: map[string]string{"app": "backend"},
				Ports: []corev1.ServicePort{{
					Port:       8080,
					TargetPort: intstr.FromInt(8080),
					Protocol:   corev1.ProtocolTCP,
				}},
				Type: corev1.ServiceTypeClusterIP,
			},
		}
		Expect(k8sClient.Create(ctx, svc)).To(Succeed())

		By("Waiting for Service to be ready")
		Eventually(func() bool {
			var s corev1.Service
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(svc), &s); err != nil {
				return false
			}
			return s.Spec.ClusterIP != "" && s.Spec.ClusterIP != "None"
		}, timeout, interval).Should(BeTrue())

		By("Creating SignalProcessing CR targeting the Service directly")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-service-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-service-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2",
					Name:         "ServiceNetworkAlert",
					Severity:     "critical",
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Service",
						Name:      "backend-service",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying Service enrichment with ServiceDetails")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			if updated.Status.KubernetesContext == nil {
				return false
			}
			if updated.Status.KubernetesContext.Service == nil {
				return false
			}
			// Verify Service populated with networking details
			details := updated.Status.KubernetesContext.Service
			return details.ClusterIP != "" &&
				len(details.Ports) > 0 &&
				len(details.Labels) > 0
		}, timeout, interval).Should(BeTrue())
	})
})

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// BR-SP-070: Business Classification Tests (Priority Assignment)
// BUSINESS VALUE: Correct priority assignment enables appropriate remediation urgency
// COVERAGE GOAL: Improve E2E classifier coverage from 10.5% to 42%
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

var _ = Describe("BR-SP-070-A: P0 Priority Classification", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-p0-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "production", // Production environment
					"team":        "platform",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-070-A: Production + Critical â†’ Priority assigned
	It("BR-SP-070-A: should assign priority for production critical signal", func() {
		By("Creating a Deployment in production namespace")
		replicas := int32(3)
		deploy := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "critical-app",
				Namespace: testNs,
				Labels:    map[string]string{"app": "critical-app"},
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: &replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{"app": "critical-app"},
				},
				Template: corev1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{"app": "critical-app"},
					},
					Spec: corev1.PodSpec{
						Containers: []corev1.Container{{
							Name:  "app",
							Image: "busybox:1.36",
							Command: []string{"sleep", "3600"},
						}},
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, deploy)).To(Succeed())

		By("Creating SignalProcessing CR with CRITICAL severity")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-p0-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-p0-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b3",
					Name:         "ProductionCriticalAlert",
					Severity:     "critical", // Critical severity
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Deployment",
						Name:      "critical-app",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying priority assignment for production critical signal")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			// Verify priority was assigned (exercises classifier logic)
			if updated.Status.PriorityAssignment == nil {
				return false
			}
			// Verify it's a valid priority (P0, P1, P2, or P3)
			priority := updated.Status.PriorityAssignment.Priority
			return priority == "P0" || priority == "P1" || priority == "P2" || priority == "P3"
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-070-B: P2 Priority Classification", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-p2-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				Labels: map[string]string{
					"environment": "staging", // Non-production environment
					"team":        "development",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-070-B: Non-production + Warning â†’ Priority assigned
	It("BR-SP-070-B: should assign priority for staging warning signal", func() {
		By("Creating a Pod in staging namespace")
		pod := &corev1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "staging-app",
				Namespace: testNs,
				Labels:    map[string]string{"app": "staging-app"},
			},
			Spec: corev1.PodSpec{
				Containers: []corev1.Container{{
					Name:  "app",
					Image: "busybox:1.36",
					Command: []string{"sleep", "3600"},
				}},
			},
		}
		Expect(k8sClient.Create(ctx, pod)).To(Succeed())

		By("Creating SignalProcessing CR with ERROR severity")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-p2-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-p2-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "b1c2d3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2",
					Name:         "StagingWarningAlert",
					Severity:     "warning", // Warning severity
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "staging-app",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying priority assignment for staging warning signal")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			// Verify priority was assigned (exercises classifier logic)
			if updated.Status.PriorityAssignment == nil {
				return false
			}
			// Verify it's a valid priority (P0, P1, P2, or P3)
			priority := updated.Status.PriorityAssignment.Priority
			return priority == "P0" || priority == "P1" || priority == "P2" || priority == "P3"
		}, timeout, interval).Should(BeTrue())
	})
})

var _ = Describe("BR-SP-070-C: P3 Priority Classification", func() {
	var testNs string
	const timeout = 2 * time.Minute
	const interval = 5 * time.Second

	BeforeEach(func() {
		testNs = fmt.Sprintf("e2e-p3-%d", uuid.New().String()[:8])
		ns := &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: testNs,
				// No environment label (unknown environment)
				Labels: map[string]string{
					"team": "experimental",
				},
			},
		}
		Expect(k8sClient.Create(ctx, ns)).To(Succeed())
	})

	AfterEach(func() {
		_ = k8sClient.Delete(ctx, &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{Name: testNs}})
	})

	// BR-SP-070-C: Unknown environment + Info â†’ Priority assigned
	It("BR-SP-070-C: should assign priority for unknown environment info signal", func() {
		By("Creating a Pod in unknown environment namespace")
		pod := &corev1.Pod{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "experimental-app",
				Namespace: testNs,
				Labels:    map[string]string{"app": "experimental"},
			},
			Spec: corev1.PodSpec{
				Containers: []corev1.Container{{
					Name:  "app",
					Image: "busybox:1.36",
					Command: []string{"sleep", "3600"},
				}},
			},
		}
		Expect(k8sClient.Create(ctx, pod)).To(Succeed())

		By("Creating SignalProcessing CR with INFO severity")
		sp := &signalprocessingv1alpha1.SignalProcessing{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "e2e-p3-signal",
				Namespace: testNs,
			},
			Spec: signalprocessingv1alpha1.SignalProcessingSpec{
				RemediationRequestRef: signalprocessingv1alpha1.ObjectReference{
					APIVersion: "kubernaut.ai/v1alpha1",
					Kind:       "RemediationRequest",
					Name:       "e2e-p3-rr",
					Namespace:  testNs,
				},
				Signal: signalprocessingv1alpha1.SignalData{
					Fingerprint:  "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
					Name:         "ExperimentalInfoAlert",
					Severity:     "info", // Info severity
					Type:         "prometheus",
					TargetType:   "kubernetes",
					ReceivedTime: metav1.Now(),
					TargetResource: signalprocessingv1alpha1.ResourceIdentifier{
						Kind:      "Pod",
						Name:      "experimental-app",
						Namespace: testNs,
					},
				},
			},
		}
		Expect(k8sClient.Create(ctx, sp)).To(Succeed())

		By("Verifying priority assignment for unknown environment info signal")
		Eventually(func() bool {
			var updated signalprocessingv1alpha1.SignalProcessing
			if err := k8sClient.Get(ctx, client.ObjectKeyFromObject(sp), &updated); err != nil {
				return false
			}
			if updated.Status.Phase != signalprocessingv1alpha1.PhaseCompleted {
				return false
			}
			// Verify priority was assigned (exercises classifier logic)
			if updated.Status.PriorityAssignment == nil {
				return false
			}
			// Verify it's a valid priority (P0, P1, P2, or P3)
			priority := updated.Status.PriorityAssignment.Priority
			return priority == "P0" || priority == "P1" || priority == "P2" || priority == "P3"
		}, timeout, interval).Should(BeTrue())
	})
})

// queryAuditEvents queries DataStorage API for audit events using the typed OpenAPI client.
// This replaces the previous raw HTTP implementation for type safety and contract validation.
//
// Benefits of OpenAPI client:
// - Type-safe request/response handling
// - Automatic JSON marshaling/unmarshaling
// - Contract validation against api/openapi/data-storage-v1.yaml
// - Breaking changes caught during development
//
// Per architectural fix: Uses RemediationRequestRef for correlation_id
// Authority: docs/handoff/TRIAGE_RO_DATASTORAGE_OPENAPI_CLIENT.md
func queryAuditEvents(correlationID string) ([]dsgen.AuditEvent, error) {
	// DataStorage is accessible via NodePort 30081 in Kind cluster
	// We use the host port mapping: localhost:30081 â†’ NodePort 30081
	dataStorageURL := "http://localhost:30081"

	// Create OpenAPI client with 10s timeout
	httpClient := &http.Client{Timeout: 10 * time.Second}
	client, err := dsgen.NewClient(dataStorageURL, dsgen.WithClient(httpClient))
	if err != nil {
		return nil, fmt.Errorf("failed to create OpenAPI client: %w", err)
	}

	// Query audit events filtered by correlation_id to avoid getting events from other parallel tests
	// In parallel E2E runs, there can be 100+ events from other tests, so filtering is critical
	limit := 100
	params := dsgen.QueryAuditEventsParams{
		Limit:         dsgen.NewOptInt(limit),
		CorrelationID: dsgen.NewOptString(correlationID),
	}

	// Call OpenAPI-generated query method
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	resp, err := client.QueryAuditEvents(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to query audit API: %w", err)
	}

	// Access typed response directly (ogen pattern)
	if len(resp.Data) == 0 {
		return []dsgen.AuditEvent{}, nil // No events found
	}

	// Return typed audit events
	return resp.Data, nil
}
