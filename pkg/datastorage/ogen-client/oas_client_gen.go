// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateAuditEvent invokes createAuditEvent operation.
	//
	// Persists a unified audit event to the audit_events table (ADR-034).
	// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
	// **Behavior**:
	// - Success: Returns 201 Created with event_id
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
	//
	// POST /api/v1/audit/events
	CreateAuditEvent(ctx context.Context, request *AuditEventRequest) (CreateAuditEventRes, error)
	// CreateAuditEventsBatch invokes createAuditEventsBatch operation.
	//
	// Write multiple audit events in a single request.
	//
	// POST /api/v1/audit/events/batch
	CreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (*BatchAuditEventResponse, error)
	// CreateNotificationAudit invokes createNotificationAudit operation.
	//
	// Persists a notification delivery attempt audit record.
	// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
	// **Behavior**:
	// - Success: Returns 201 Created with created record
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Duplicate: Returns 409 Conflict (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
	// **Metrics Emitted** (GAP-10):
	// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
	// - `datastorage_audit_lag_seconds{service="notification"}`
	// - `datastorage_write_duration_seconds{table="notification_audit"}`
	// - `datastorage_validation_failures_total{field="...", reason="..."}`.
	//
	// POST /api/v1/audit/notifications
	CreateNotificationAudit(ctx context.Context, request *NotificationAudit) (CreateNotificationAuditRes, error)
	// CreateWorkflow invokes createWorkflow operation.
	//
	// Create a new workflow in the catalog.
	// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management)
	// **Design Decision**: DD-WORKFLOW-005 v1.0 (Direct REST API workflow registration).
	//
	// POST /api/v1/workflows
	CreateWorkflow(ctx context.Context, request *RemediationWorkflow) (CreateWorkflowRes, error)
	// DisableWorkflow invokes disableWorkflow operation.
	//
	// Convenience endpoint to disable a workflow (soft delete).
	// Sets status to 'disabled' with timestamp and reason.
	// **Design Decision**: DD-WORKFLOW-012 (Convenience endpoint for soft-delete).
	//
	// PATCH /api/v1/workflows/{workflow_id}/disable
	DisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (DisableWorkflowRes, error)
	// ExportAuditEvents invokes exportAuditEvents operation.
	//
	// Exports audit events matching the specified filters with cryptographic signatures
	// for tamper detection and compliance verification.
	// **Business Requirement**: BR-AUDIT-007 (Audit Export)
	// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
	// **Behavior**:
	// - Success: Returns 200 OK with signed export (JSON or CSV)
	// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
	// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
	// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
	// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
	// **Export Formats**:
	// - JSON: Complete event data with hash chain verification
	// - CSV: Flattened tabular format for spreadsheet analysis
	// **Hash Chain Verification**:
	// - Each export includes hash chain integrity status
	// - Tampered events flagged with `hash_chain_valid: false`
	// - Chain verification performed at export time
	// **Digital Signature**:
	// - Export signed with service x509 certificate
	// - Signature included in `export_metadata.signature` field
	// - Detached signature available via `include_detached_signature=true`
	// **Pagination**:
	// - Use `offset` and `limit` for large result sets
	// - Maximum limit: 10,000 events per export
	// - Signature covers ALL pages (use same query for verification)
	// **Metrics Emitted**:
	// - `datastorage_export_successes_total{format="json|csv"}`
	// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
	//
	// GET /api/v1/audit/export
	ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (ExportAuditEventsRes, error)
	// GetMetrics invokes getMetrics operation.
	//
	// Exposes Prometheus metrics in text format.
	// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
	// - `datastorage_audit_traces_total{service,status}` - Audit write operations
	// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
	// - `datastorage_write_duration_seconds{table}` - Database write latency
	// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
	//
	// GET /metrics
	GetMetrics(ctx context.Context) (GetMetricsOK, error)
	// GetWorkflowByID invokes getWorkflowByID operation.
	//
	// Retrieve a specific workflow by its UUID.
	// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key).
	//
	// GET /api/v1/workflows/{workflow_id}
	GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (GetWorkflowByIDRes, error)
	// HealthCheck invokes healthCheck operation.
	//
	// Returns 200 if service is healthy (database and Redis reachable).
	// Used by Kubernetes liveness probe (DD-007).
	//
	// GET /health
	HealthCheck(ctx context.Context) (HealthCheckRes, error)
	// ListLegalHolds invokes listLegalHolds operation.
	//
	// Returns a list of all active legal holds across all audit events.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with array of active legal holds
	// - No holds: Returns empty array
	// **Authorization**: No authentication required (read-only operation)
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="list"}`.
	//
	// GET /api/v1/audit/legal-hold
	ListLegalHolds(ctx context.Context) (*ListLegalHoldsOK, error)
	// ListWorkflows invokes listWorkflows operation.
	//
	// List workflows with optional filters and pagination.
	// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
	//
	// GET /api/v1/workflows
	ListWorkflows(ctx context.Context, params ListWorkflowsParams) (ListWorkflowsRes, error)
	// LivenessCheck invokes livenessCheck operation.
	//
	// Returns 200 if service process is alive.
	// Does not check dependencies.
	// Used by Kubernetes liveness probe.
	//
	// GET /health/live
	LivenessCheck(ctx context.Context) error
	// PlaceLegalHold invokes placeLegalHold operation.
	//
	// Places a legal hold on all audit events for a given correlation_id.
	// Events with legal hold cannot be deleted (enforced by database trigger).
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
	// **Behavior**:
	// - Success: Returns 200 OK with legal hold metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who placed the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="place"}`
	// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
	//
	// POST /api/v1/audit/legal-hold
	PlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (PlaceLegalHoldRes, error)
	// QueryAuditEvents invokes queryAuditEvents operation.
	//
	// Query audit events with filters and pagination.
	//
	// GET /api/v1/audit/events
	QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (*AuditEventsQueryResponse, error)
	// ReadinessCheck invokes readinessCheck operation.
	//
	// Returns 200 if service is ready to accept traffic.
	// Returns 503 during graceful shutdown (DD-007 4-step pattern).
	// Used by Kubernetes readiness probe.
	//
	// GET /health/ready
	ReadinessCheck(ctx context.Context) (ReadinessCheckRes, error)
	// ReconstructRemediationRequest invokes reconstructRemediationRequest operation.
	//
	// Reconstructs a complete RemediationRequest CRD from audit trail events.
	// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
	// **Workflow**:
	// 1. Query audit events for given correlation_id
	// 2. Parse gateway and orchestrator events
	// 3. Map audit data to RR Spec/Status fields
	// 4. Build complete Kubernetes-compliant CRD
	// 5. Validate completeness and quality
	// **Use Cases**:
	// - Disaster recovery (recreate lost RRs from audit trail)
	// - Compliance audits (prove RR state at any point in time)
	// - Debugging (understand RR evolution from audit events)
	// **Returns**:
	// - Reconstructed RR in YAML format
	// - Validation result (completeness percentage, warnings, errors)
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	// Integration tests use mock X-Auth-Request-User header.
	//
	// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
	ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (ReconstructRemediationRequestRes, error)
	// ReleaseLegalHold invokes releaseLegalHold operation.
	//
	// Releases a legal hold on all audit events for a given correlation_id.
	// Events can be deleted after legal hold is released.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with release metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if legal hold doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who released the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="release"}`
	// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
	//
	// DELETE /api/v1/audit/legal-hold/{correlation_id}
	ReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (ReleaseLegalHoldRes, error)
	// SearchWorkflows invokes searchWorkflows operation.
	//
	// Search workflows using label-based matching with wildcard support and weighted scoring.
	// **V1.0 Implementation**: Pure SQL label matching (no embeddings/semantic search)
	// **Business Requirement**: BR-STORAGE-013 (Label-Based Workflow Search)
	// **Design Decision**: DD-WORKFLOW-004 v1.5 (Label-Only Scoring with Wildcard Weighting)
	// **Behavior**:
	// - Mandatory filters: signal_type, severity, component, environment, priority
	// - Optional filters: custom_labels, detected_labels
	// - Wildcard support: "*" matches any non-null value
	// - Weighted scoring: Exact matches > Wildcard matches
	// - Returns top_k results sorted by confidence score (0.0-1.0).
	//
	// POST /api/v1/workflows/search
	SearchWorkflows(ctx context.Context, request *WorkflowSearchRequest) (SearchWorkflowsRes, error)
	// UpdateWorkflow invokes updateWorkflow operation.
	//
	// Update mutable workflow fields (status, metrics).
	// Immutable fields (description, content, labels) require creating a new version.
	// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
	//
	// PATCH /api/v1/workflows/{workflow_id}
	UpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (UpdateWorkflowRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateAuditEvent invokes createAuditEvent operation.
//
// Persists a unified audit event to the audit_events table (ADR-034).
// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
// **Behavior**:
// - Success: Returns 201 Created with event_id
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
//
// POST /api/v1/audit/events
func (c *Client) CreateAuditEvent(ctx context.Context, request *AuditEventRequest) (CreateAuditEventRes, error) {
	res, err := c.sendCreateAuditEvent(ctx, request)
	return res, err
}

func (c *Client) sendCreateAuditEvent(ctx context.Context, request *AuditEventRequest) (res CreateAuditEventRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAuditEvent"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/events"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAuditEventOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAuditEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAuditEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAuditEventsBatch invokes createAuditEventsBatch operation.
//
// Write multiple audit events in a single request.
//
// POST /api/v1/audit/events/batch
func (c *Client) CreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (*BatchAuditEventResponse, error) {
	res, err := c.sendCreateAuditEventsBatch(ctx, request)
	return res, err
}

func (c *Client) sendCreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (res *BatchAuditEventResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAuditEventsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/events/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAuditEventsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAuditEventsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAuditEventsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNotificationAudit invokes createNotificationAudit operation.
//
// Persists a notification delivery attempt audit record.
// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
// **Behavior**:
// - Success: Returns 201 Created with created record
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Duplicate: Returns 409 Conflict (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
// **Metrics Emitted** (GAP-10):
// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
// - `datastorage_audit_lag_seconds{service="notification"}`
// - `datastorage_write_duration_seconds{table="notification_audit"}`
// - `datastorage_validation_failures_total{field="...", reason="..."}`.
//
// POST /api/v1/audit/notifications
func (c *Client) CreateNotificationAudit(ctx context.Context, request *NotificationAudit) (CreateNotificationAuditRes, error) {
	res, err := c.sendCreateNotificationAudit(ctx, request)
	return res, err
}

func (c *Client) sendCreateNotificationAudit(ctx context.Context, request *NotificationAudit) (res CreateNotificationAuditRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createNotificationAudit"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/notifications"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateNotificationAuditOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNotificationAuditRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateNotificationAuditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWorkflow invokes createWorkflow operation.
//
// Create a new workflow in the catalog.
// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management)
// **Design Decision**: DD-WORKFLOW-005 v1.0 (Direct REST API workflow registration).
//
// POST /api/v1/workflows
func (c *Client) CreateWorkflow(ctx context.Context, request *RemediationWorkflow) (CreateWorkflowRes, error) {
	res, err := c.sendCreateWorkflow(ctx, request)
	return res, err
}

func (c *Client) sendCreateWorkflow(ctx context.Context, request *RemediationWorkflow) (res CreateWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createWorkflow"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/workflows"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisableWorkflow invokes disableWorkflow operation.
//
// Convenience endpoint to disable a workflow (soft delete).
// Sets status to 'disabled' with timestamp and reason.
// **Design Decision**: DD-WORKFLOW-012 (Convenience endpoint for soft-delete).
//
// PATCH /api/v1/workflows/{workflow_id}/disable
func (c *Client) DisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (DisableWorkflowRes, error) {
	res, err := c.sendDisableWorkflow(ctx, request, params)
	return res, err
}

func (c *Client) sendDisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (res DisableWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("disableWorkflow"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}/disable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DisableWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/disable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDisableWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDisableWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportAuditEvents invokes exportAuditEvents operation.
//
// Exports audit events matching the specified filters with cryptographic signatures
// for tamper detection and compliance verification.
// **Business Requirement**: BR-AUDIT-007 (Audit Export)
// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
// **Behavior**:
// - Success: Returns 200 OK with signed export (JSON or CSV)
// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
// **Export Formats**:
// - JSON: Complete event data with hash chain verification
// - CSV: Flattened tabular format for spreadsheet analysis
// **Hash Chain Verification**:
// - Each export includes hash chain integrity status
// - Tampered events flagged with `hash_chain_valid: false`
// - Chain verification performed at export time
// **Digital Signature**:
// - Export signed with service x509 certificate
// - Signature included in `export_metadata.signature` field
// - Detached signature available via `include_detached_signature=true`
// **Pagination**:
// - Use `offset` and `limit` for large result sets
// - Maximum limit: 10,000 events per export
// - Signature covers ALL pages (use same query for verification)
// **Metrics Emitted**:
// - `datastorage_export_successes_total{format="json|csv"}`
// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
//
// GET /api/v1/audit/export
func (c *Client) ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (ExportAuditEventsRes, error) {
	res, err := c.sendExportAuditEvents(ctx, params)
	return res, err
}

func (c *Client) sendExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (res ExportAuditEventsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exportAuditEvents"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/export"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExportAuditEventsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/export"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "correlation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "correlation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CorrelationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Format.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_detached_signature" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_detached_signature",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeDetachedSignature.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "redact_pii" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redact_pii",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RedactPii.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExportAuditEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMetrics invokes getMetrics operation.
//
// Exposes Prometheus metrics in text format.
// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
// - `datastorage_audit_traces_total{service,status}` - Audit write operations
// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
// - `datastorage_write_duration_seconds{table}` - Database write latency
// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
//
// GET /metrics
func (c *Client) GetMetrics(ctx context.Context) (GetMetricsOK, error) {
	res, err := c.sendGetMetrics(ctx)
	return res, err
}

func (c *Client) sendGetMetrics(ctx context.Context) (res GetMetricsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMetrics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/metrics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMetricsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowByID invokes getWorkflowByID operation.
//
// Retrieve a specific workflow by its UUID.
// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key).
//
// GET /api/v1/workflows/{workflow_id}
func (c *Client) GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (GetWorkflowByIDRes, error) {
	res, err := c.sendGetWorkflowByID(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (res GetWorkflowByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWorkflowByID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkflowByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthCheck invokes healthCheck operation.
//
// Returns 200 if service is healthy (database and Redis reachable).
// Used by Kubernetes liveness probe (DD-007).
//
// GET /health
func (c *Client) HealthCheck(ctx context.Context) (HealthCheckRes, error) {
	res, err := c.sendHealthCheck(ctx)
	return res, err
}

func (c *Client) sendHealthCheck(ctx context.Context) (res HealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("healthCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLegalHolds invokes listLegalHolds operation.
//
// Returns a list of all active legal holds across all audit events.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with array of active legal holds
// - No holds: Returns empty array
// **Authorization**: No authentication required (read-only operation)
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="list"}`.
//
// GET /api/v1/audit/legal-hold
func (c *Client) ListLegalHolds(ctx context.Context) (*ListLegalHoldsOK, error) {
	res, err := c.sendListLegalHolds(ctx)
	return res, err
}

func (c *Client) sendListLegalHolds(ctx context.Context) (res *ListLegalHoldsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLegalHolds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListLegalHoldsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/legal-hold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLegalHoldsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflows invokes listWorkflows operation.
//
// List workflows with optional filters and pagination.
// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
//
// GET /api/v1/workflows
func (c *Client) ListWorkflows(ctx context.Context, params ListWorkflowsParams) (ListWorkflowsRes, error) {
	res, err := c.sendListWorkflows(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflows(ctx context.Context, params ListWorkflowsParams) (res ListWorkflowsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listWorkflows"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWorkflowsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Environment.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "priority" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "priority",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Priority.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Component.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "workflow_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "workflow_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WorkflowName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWorkflowsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LivenessCheck invokes livenessCheck operation.
//
// Returns 200 if service process is alive.
// Does not check dependencies.
// Used by Kubernetes liveness probe.
//
// GET /health/live
func (c *Client) LivenessCheck(ctx context.Context) error {
	_, err := c.sendLivenessCheck(ctx)
	return err
}

func (c *Client) sendLivenessCheck(ctx context.Context) (res *LivenessCheckOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("livenessCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/live"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LivenessCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/live"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLivenessCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PlaceLegalHold invokes placeLegalHold operation.
//
// Places a legal hold on all audit events for a given correlation_id.
// Events with legal hold cannot be deleted (enforced by database trigger).
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
// **Behavior**:
// - Success: Returns 200 OK with legal hold metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who placed the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="place"}`
// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
//
// POST /api/v1/audit/legal-hold
func (c *Client) PlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (PlaceLegalHoldRes, error) {
	res, err := c.sendPlaceLegalHold(ctx, request)
	return res, err
}

func (c *Client) sendPlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (res PlaceLegalHoldRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("placeLegalHold"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PlaceLegalHoldOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/legal-hold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePlaceLegalHoldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePlaceLegalHoldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// QueryAuditEvents invokes queryAuditEvents operation.
//
// Query audit events with filters and pagination.
//
// GET /api/v1/audit/events
func (c *Client) QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (*AuditEventsQueryResponse, error) {
	res, err := c.sendQueryAuditEvents(ctx, params)
	return res, err
}

func (c *Client) sendQueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (res *AuditEventsQueryResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("queryAuditEvents"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/events"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, QueryAuditEventsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "event_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_outcome" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_outcome",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventOutcome.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "severity" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "severity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Severity.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "correlation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "correlation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CorrelationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeQueryAuditEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadinessCheck invokes readinessCheck operation.
//
// Returns 200 if service is ready to accept traffic.
// Returns 503 during graceful shutdown (DD-007 4-step pattern).
// Used by Kubernetes readiness probe.
//
// GET /health/ready
func (c *Client) ReadinessCheck(ctx context.Context) (ReadinessCheckRes, error) {
	res, err := c.sendReadinessCheck(ctx)
	return res, err
}

func (c *Client) sendReadinessCheck(ctx context.Context) (res ReadinessCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readinessCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/ready"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReadinessCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/ready"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReadinessCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReconstructRemediationRequest invokes reconstructRemediationRequest operation.
//
// Reconstructs a complete RemediationRequest CRD from audit trail events.
// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
// **Workflow**:
// 1. Query audit events for given correlation_id
// 2. Parse gateway and orchestrator events
// 3. Map audit data to RR Spec/Status fields
// 4. Build complete Kubernetes-compliant CRD
// 5. Validate completeness and quality
// **Use Cases**:
// - Disaster recovery (recreate lost RRs from audit trail)
// - Compliance audits (prove RR state at any point in time)
// - Debugging (understand RR evolution from audit events)
// **Returns**:
// - Reconstructed RR in YAML format
// - Validation result (completeness percentage, warnings, errors)
// **Authentication**: Protected by OAuth-proxy in production/E2E.
// Integration tests use mock X-Auth-Request-User header.
//
// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
func (c *Client) ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (ReconstructRemediationRequestRes, error) {
	res, err := c.sendReconstructRemediationRequest(ctx, params)
	return res, err
}

func (c *Client) sendReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (res ReconstructRemediationRequestRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reconstructRemediationRequest"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/remediation-requests/{correlation_id}/reconstruct"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReconstructRemediationRequestOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/audit/remediation-requests/"
	{
		// Encode "correlation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "correlation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CorrelationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reconstruct"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReconstructRemediationRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReleaseLegalHold invokes releaseLegalHold operation.
//
// Releases a legal hold on all audit events for a given correlation_id.
// Events can be deleted after legal hold is released.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with release metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if legal hold doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who released the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="release"}`
// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
//
// DELETE /api/v1/audit/legal-hold/{correlation_id}
func (c *Client) ReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (ReleaseLegalHoldRes, error) {
	res, err := c.sendReleaseLegalHold(ctx, request, params)
	return res, err
}

func (c *Client) sendReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (res ReleaseLegalHoldRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("releaseLegalHold"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold/{correlation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReleaseLegalHoldOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/audit/legal-hold/"
	{
		// Encode "correlation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "correlation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CorrelationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReleaseLegalHoldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReleaseLegalHoldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchWorkflows invokes searchWorkflows operation.
//
// Search workflows using label-based matching with wildcard support and weighted scoring.
// **V1.0 Implementation**: Pure SQL label matching (no embeddings/semantic search)
// **Business Requirement**: BR-STORAGE-013 (Label-Based Workflow Search)
// **Design Decision**: DD-WORKFLOW-004 v1.5 (Label-Only Scoring with Wildcard Weighting)
// **Behavior**:
// - Mandatory filters: signal_type, severity, component, environment, priority
// - Optional filters: custom_labels, detected_labels
// - Wildcard support: "*" matches any non-null value
// - Weighted scoring: Exact matches > Wildcard matches
// - Returns top_k results sorted by confidence score (0.0-1.0).
//
// POST /api/v1/workflows/search
func (c *Client) SearchWorkflows(ctx context.Context, request *WorkflowSearchRequest) (SearchWorkflowsRes, error) {
	res, err := c.sendSearchWorkflows(ctx, request)
	return res, err
}

func (c *Client) sendSearchWorkflows(ctx context.Context, request *WorkflowSearchRequest) (res SearchWorkflowsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("searchWorkflows"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/workflows/search"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SearchWorkflowsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows/search"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSearchWorkflowsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchWorkflowsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkflow invokes updateWorkflow operation.
//
// Update mutable workflow fields (status, metrics).
// Immutable fields (description, content, labels) require creating a new version.
// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
//
// PATCH /api/v1/workflows/{workflow_id}
func (c *Client) UpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (UpdateWorkflowRes, error) {
	res, err := c.sendUpdateWorkflow(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (res UpdateWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateWorkflow"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
