package engine

import (
	"context"
	"encoding/json"
	"fmt"
	"math"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/infrastructure/types"
	"github.com/jordigilh/kubernaut/pkg/storage/vector"
)

// Helper types for workflow building

// aiResponseRecord represents a record of AI response for metrics (local to avoid import cycle)
type aiResponseRecord struct {
	ID               string                 `json:"id"`
	Timestamp        time.Time              `json:"timestamp"`
	Provider         string                 `json:"provider"`
	Model            string                 `json:"model"`
	PromptLength     int                    `json:"prompt_length"`
	ResponseLength   int                    `json:"response_length"`
	Latency          time.Duration          `json:"latency"`
	Success          bool                   `json:"success"`
	ValidationPassed bool                   `json:"validation_passed"`
	StepsGenerated   int                    `json:"steps_generated"`
	PatternsUsed     []string               `json:"patterns_used"`
	SafetyFlags      []string               `json:"safety_flags"`
	Context          map[string]interface{} `json:"context,omitempty"`
	Error            string                 `json:"error,omitempty"`
	Quality          map[string]interface{} `json:"quality,omitempty"`
}

// ObjectiveAnalysisResult contains the analysis of a workflow objective
type ObjectiveAnalysisResult struct {
	Keywords       []string               `json:"keywords"`
	ActionTypes    []string               `json:"action_types"`
	Constraints    map[string]interface{} `json:"constraints"`
	Priority       int                    `json:"priority"`
	Complexity     float64                `json:"complexity"`
	RiskLevel      string                 `json:"risk_level"`
	Recommendation string                 `json:"recommendation"`
}

// WorkflowGenerationPrompt contains the AI prompt for workflow generation
type WorkflowGenerationPrompt struct {
	Objective        *WorkflowObjective       `json:"objective"`
	Analysis         *ObjectiveAnalysisResult `json:"analysis"`
	SimilarPatterns  []*WorkflowPattern       `json:"similar_patterns"`
	AvailableActions []string                 `json:"available_actions"`
	Constraints      map[string]interface{}   `json:"constraints"`
}

// AIWorkflowResponse represents the AI response for workflow generation
type AIWorkflowResponse struct {
	WorkflowName   string                  `json:"workflow_name"`
	Description    string                  `json:"description"`
	Steps          []*AIGeneratedStep      `json:"steps"`
	Conditions     []*AIGeneratedCondition `json:"conditions"`
	Variables      map[string]interface{}  `json:"variables"`
	EstimatedTime  string                  `json:"estimated_time"`
	RiskAssessment string                  `json:"risk_assessment"`
	Reasoning      string                  `json:"reasoning"`
}

// AIGeneratedStep represents a step generated by AI
type AIGeneratedStep struct {
	Name         string                 `json:"name"`
	Type         string                 `json:"type"`
	Action       *AIGeneratedAction     `json:"action,omitempty"`
	Condition    string                 `json:"condition,omitempty"`
	Dependencies []string               `json:"dependencies"`
	Timeout      string                 `json:"timeout"`
	OnSuccess    []string               `json:"on_success"`
	OnFailure    []string               `json:"on_failure"`
	Variables    map[string]interface{} `json:"variables"`
}

// AIGeneratedAction represents an action generated by AI
type AIGeneratedAction struct {
	Type       string                 `json:"type"`
	Parameters map[string]interface{} `json:"parameters"`
	Target     *AIGeneratedTarget     `json:"target"`
}

// AIGeneratedTarget represents a target generated by AI
type AIGeneratedTarget struct {
	Type      string            `json:"type"`
	Namespace string            `json:"namespace"`
	Resource  string            `json:"resource"`
	Name      string            `json:"name"`
	Selector  map[string]string `json:"selector,omitempty"`
}

// AIGeneratedCondition represents a condition generated by AI
type AIGeneratedCondition struct {
	Name       string                 `json:"name"`
	Type       string                 `json:"type"`
	Expression string                 `json:"expression"`
	Variables  map[string]interface{} `json:"variables"`
}

// ExecutionRepository interface for accessing execution history
type ExecutionRepository interface {
	GetExecutionsInTimeWindow(ctx context.Context, start, end time.Time) ([]*WorkflowExecution, error)
	GetExecutionsByWorkflowID(ctx context.Context, workflowID string) ([]*WorkflowExecution, error)
	GetExecutionsByPattern(ctx context.Context, patternID string) ([]*WorkflowExecution, error)
	StoreExecution(ctx context.Context, execution *WorkflowExecution) error
}

// InMemoryExecutionRepository provides an in-memory implementation for testing
type InMemoryExecutionRepository struct {
	executions []*WorkflowExecution
	log        *logrus.Logger
}

// NewInMemoryExecutionRepository creates a new in-memory execution repository
func NewInMemoryExecutionRepository(log *logrus.Logger) ExecutionRepository {
	return &InMemoryExecutionRepository{
		executions: make([]*WorkflowExecution, 0),
		log:        log,
	}
}

func (r *InMemoryExecutionRepository) StoreExecution(ctx context.Context, execution *WorkflowExecution) error {
	r.executions = append(r.executions, execution)
	r.log.WithField("execution_id", execution.ID).Debug("Stored execution in memory repository")
	return nil
}

func (r *InMemoryExecutionRepository) GetExecutionsInTimeWindow(ctx context.Context, start, end time.Time) ([]*WorkflowExecution, error) {
	var filtered []*WorkflowExecution
	for _, exec := range r.executions {
		if exec.StartTime.After(start) && exec.StartTime.Before(end) {
			filtered = append(filtered, exec)
		}
	}
	return filtered, nil
}

func (r *InMemoryExecutionRepository) GetExecutionsByWorkflowID(ctx context.Context, workflowID string) ([]*WorkflowExecution, error) {
	var filtered []*WorkflowExecution
	for _, exec := range r.executions {
		if exec.WorkflowID == workflowID {
			filtered = append(filtered, exec)
		}
	}
	return filtered, nil
}

func (r *InMemoryExecutionRepository) GetExecutionsByPattern(ctx context.Context, patternID string) ([]*WorkflowExecution, error) {
	var filtered []*WorkflowExecution
	for _, exec := range r.executions {
		if metadata, ok := exec.Metadata["pattern_id"]; ok && metadata == patternID {
			filtered = append(filtered, exec)
		}
	}
	return filtered, nil
}

// Helper methods implementation

// analyzeObjective analyzes the workflow objective to extract context and requirements
func (iwb *DefaultIntelligentWorkflowBuilder) analyzeObjective(ctx context.Context, objective *WorkflowObjective) (*ObjectiveAnalysisResult, error) {
	iwb.log.WithContext(ctx).WithField("objective_type", objective.Type).Debug("Analyzing workflow objective")

	// Extract keywords from description
	keywords := iwb.extractKeywords(objective.Description)

	// Identify potential action types based on objective
	actionTypes := iwb.identifyActionTypesFromObjective(objective)

	// Assess complexity based on targets and constraints
	complexity := iwb.calculateObjectiveComplexity(objective)

	// Determine risk level
	riskLevel := iwb.assessRiskLevel(objective, complexity)

	// Generate recommendation
	recommendation := iwb.generateObjectiveRecommendation(objective, complexity, riskLevel)

	return &ObjectiveAnalysisResult{
		Keywords:       keywords,
		ActionTypes:    actionTypes,
		Constraints:    objective.Constraints,
		Priority:       objective.Priority,
		Complexity:     complexity,
		RiskLevel:      riskLevel,
		Recommendation: recommendation,
	}, nil
}

// findSimilarSuccessfulPatterns finds patterns similar to the objective
func (iwb *DefaultIntelligentWorkflowBuilder) findSimilarSuccessfulPatterns(ctx context.Context, analysis *ObjectiveAnalysisResult) ([]*WorkflowPattern, error) {
	// Create search query from analysis
	queryText := strings.Join(analysis.Keywords, " ")

	// Search for similar patterns in vector database
	actionPatterns, err := iwb.vectorDB.SearchBySemantics(ctx, queryText, 10)
	if err != nil {
		return nil, fmt.Errorf("failed to search for similar patterns: %w", err)
	}

	// Convert action patterns to workflow patterns
	workflowPatterns := make([]*WorkflowPattern, 0)
	for _, actionPattern := range actionPatterns {
		if actionPattern.EffectivenessData != nil && actionPattern.EffectivenessData.Score >= 0.7 {
			pattern := iwb.convertActionPatternToWorkflowPattern(actionPattern)
			workflowPatterns = append(workflowPatterns, pattern)
		}
	}

	return workflowPatterns, nil
}

// generateWorkflowWithAI uses AI to generate a workflow template
func (iwb *DefaultIntelligentWorkflowBuilder) generateWorkflowWithAI(ctx context.Context, objective *WorkflowObjective, analysis *ObjectiveAnalysisResult, patterns []*WorkflowPattern) (*WorkflowTemplate, error) {
	startTime := time.Now()

	// Prepare the AI prompt (now enhanced with learning)
	prompt := iwb.buildWorkflowGenerationPrompt(objective, analysis, patterns)

	// Call SLM for workflow generation
	response, err := iwb.callSLMForWorkflowGeneration(ctx, prompt)
	latency := time.Since(startTime)

	// Create AI response record for metrics
	record := &aiResponseRecord{
		ID:             uuid.New().String(),
		Timestamp:      startTime,
		Provider:       "slm",     // Would get from SLM client
		Model:          "default", // Would get from SLM client
		PromptLength:   len(prompt),
		ResponseLength: len(response),
		Latency:        latency,
		Success:        err == nil,
		Context: map[string]interface{}{
			"objective_type": objective.Type,
			"pattern_count":  len(patterns),
		},
	}

	if err != nil {
		record.Error = err.Error()

		// Record metrics for failed request
		if iwb.metricsCollector != nil {
			iwb.metricsCollector.RecordAIRequest(ctx, record.ID, "", "")
		}

		return nil, fmt.Errorf("failed to generate workflow with AI: %w", err)
	}

	// Parse AI response
	aiResponse, err := iwb.parseAIWorkflowResponse(response)
	if err != nil {
		record.Success = false
		record.Error = err.Error()
		record.ValidationPassed = false

		// Record metrics for parsing failure
		if iwb.metricsCollector != nil {
			iwb.metricsCollector.RecordAIRequest(ctx, record.ID, "", "")
		}

		return nil, fmt.Errorf("failed to parse AI workflow response: %w", err)
	}

	// Evaluate response quality
	var quality *AIResponseQuality
	if iwb.metricsCollector != nil {
		quality, _ = iwb.metricsCollector.EvaluateResponseQuality(ctx, "", map[string]interface{}{})
		if quality != nil {
			record.Quality = map[string]interface{}{
				"score":      quality.Score,
				"confidence": quality.Confidence,
				"relevance":  quality.Relevance,
				"clarity":    quality.Clarity,
			}
		}
	}

	// Convert AI response to workflow template
	template, err := iwb.convertAIResponseToTemplate(aiResponse, objective)
	if err != nil {
		record.Success = false
		record.Error = err.Error()
		record.ValidationPassed = false

		// Record metrics for conversion failure
		if iwb.metricsCollector != nil {
			iwb.metricsCollector.RecordAIRequest(ctx, record.ID, "", "")
		}

		return nil, fmt.Errorf("failed to convert AI response to template: %w", err)
	}

	// Update record with successful results
	record.ValidationPassed = true
	record.PatternsUsed = []string{}

	// Check for safety flags and update steps if aiResponse is valid
	if aiResponse != nil {
		record.StepsGenerated = len(aiResponse.Steps)
		safetyFlags := iwb.checkSafetyFlags(aiResponse)
		record.SafetyFlags = safetyFlags
	} else {
		record.StepsGenerated = 0
	}

	// Record successful AI request metrics
	if iwb.metricsCollector != nil {
		iwb.metricsCollector.RecordAIRequest(ctx, record.ID, "", "")
	}

	// Record prompt performance for optimization
	if iwb.promptOptimizer != nil && quality != nil {
		promptID := iwb.getPromptIDFromContext(ctx) // Would implement this method
		iwb.promptOptimizer.RecordPromptMetrics(promptID, true, latency, quality.Score)
	}

	// Learn from successful generation
	if iwb.learningBuilder != nil && quality != nil {
		// This would be called after execution, but we can start learning from generation
		iwb.log.Debug("AI workflow generation completed successfully, ready for learning integration")
	}

	return template, nil
}

// buildWorkflowGenerationPrompt creates the AI prompt for workflow generation
func (iwb *DefaultIntelligentWorkflowBuilder) buildWorkflowGenerationPrompt(objective *WorkflowObjective, analysis *ObjectiveAnalysisResult, patterns []*WorkflowPattern) string {
	// Try to get an enhanced prompt first
	if iwb.learningBuilder != nil {
		enhancedPrompt, err := iwb.learningBuilder.GetBuildEnhancedPrompt(context.Background(), "", map[string]interface{}{
			"objective": objective,
			"analysis":  analysis,
			"patterns":  patterns,
		})
		if err == nil {
			return enhancedPrompt
		}
		iwb.log.WithError(err).Warn("Failed to build enhanced prompt, falling back to basic prompt")
	}

	// Get optimal prompt from prompt optimizer
	if iwb.promptOptimizer != nil {
		optimalPrompt, err := iwb.promptOptimizer.GetOptimalPrompt(context.Background(), objective)
		if err == nil && optimalPrompt != nil {
			return iwb.buildPromptFromVersion(optimalPrompt, objective, analysis, patterns)
		}
	}

	// Fallback to basic prompt
	return iwb.buildBasicPrompt(objective, analysis, patterns)
}

// buildPromptFromVersion builds a prompt using a specific prompt version
func (iwb *DefaultIntelligentWorkflowBuilder) buildPromptFromVersion(version *PromptVersion, objective *WorkflowObjective, analysis *ObjectiveAnalysisResult, patterns []*WorkflowPattern) string {
	promptData := &WorkflowGenerationPrompt{
		Objective:        objective,
		Analysis:         analysis,
		SimilarPatterns:  patterns,
		AvailableActions: iwb.getAvailableActionTypes(),
		Constraints:      objective.Constraints,
	}

	promptJSON, _ := json.MarshalIndent(promptData, "", "  ")

	// Use the versioned prompt template
	return fmt.Sprintf(version.Template, string(promptJSON))
}

// buildBasicPrompt builds the fallback basic prompt
func (iwb *DefaultIntelligentWorkflowBuilder) buildBasicPrompt(objective *WorkflowObjective, analysis *ObjectiveAnalysisResult, patterns []*WorkflowPattern) string {
	promptData := &WorkflowGenerationPrompt{
		Objective:        objective,
		Analysis:         analysis,
		SimilarPatterns:  patterns,
		AvailableActions: iwb.getAvailableActionTypes(),
		Constraints:      objective.Constraints,
	}

	promptJSON, _ := json.MarshalIndent(promptData, "", "  ")

	return fmt.Sprintf(`<|system|>
You are an expert Kubernetes workflow automation engineer. Your task is to generate comprehensive, safe, and effective workflow templates based on objectives and historical patterns.

<|user|>
Generate a detailed workflow template for the following objective and analysis:

%s

Requirements:
1. Create a step-by-step workflow with clear dependencies
2. Include appropriate conditions and validation steps
3. Ensure safety measures and rollback capabilities
4. Use proven patterns when available
5. Optimize for effectiveness and reliability
6. Include timeout and retry configurations
7. Add proper variable handling and context awareness

Respond with a valid JSON object in the following format:
{
  "workflow_name": "descriptive name",
  "description": "detailed description",
  "steps": [
    {
      "name": "step name",
      "type": "action|condition|parallel|sequential",
      "action": {
        "type": "action_type",
        "parameters": {},
        "target": {
          "type": "kubernetes|prometheus|custom",
          "namespace": "namespace",
          "resource": "resource_type",
          "name": "resource_name"
        }
      },
      "condition": "optional condition expression",
      "dependencies": ["previous_step_names"],
      "timeout": "duration string",
      "on_success": ["next_step_names"],
      "on_failure": ["fallback_step_names"],
      "variables": {}
    }
  ],
  "conditions": [
    {
      "name": "condition name",
      "type": "metric|resource|time|expression",
      "expression": "condition expression",
      "variables": {}
    }
  ],
  "variables": {},
  "estimated_time": "expected execution duration",
  "risk_assessment": "risk level and mitigation strategies",
  "reasoning": "explanation of design decisions"
}`, string(promptJSON))
}

// callSLMForWorkflowGeneration calls the SLM service for workflow generation
func (iwb *DefaultIntelligentWorkflowBuilder) callSLMForWorkflowGeneration(ctx context.Context, prompt string) (string, error) {
	alert := types.Alert{
		Name:        "workflow-generation",
		Status:      "active",
		Severity:    "info",
		Description: prompt,
		Namespace:   "system",
		Resource:    "workflow-builder",
		Labels:      map[string]string{"type": "workflow-generation"},
		Annotations: map[string]string{"source": "intelligent-workflow-builder"},
		StartsAt:    time.Now(),
	}

	response, err := iwb.llmClient.AnalyzeAlert(ctx, alert)
	if err != nil {
		return "", fmt.Errorf("SLM analysis failed: %w", err)
	}

	if response.Reasoning != nil {
		return response.Reasoning.Summary, nil
	}

	return "", fmt.Errorf("no reasoning provided in SLM response")
}

// parseAIWorkflowResponse parses the AI response into structured format
func (iwb *DefaultIntelligentWorkflowBuilder) parseAIWorkflowResponse(response string) (*AIWorkflowResponse, error) {
	// Extract JSON from response (handle cases where AI includes extra text)
	jsonStr := iwb.extractJSONFromResponse(response)

	var aiResponse AIWorkflowResponse
	if err := json.Unmarshal([]byte(jsonStr), &aiResponse); err != nil {
		return nil, fmt.Errorf("failed to unmarshal AI response: %w", err)
	}

	// Validate response structure
	if err := iwb.validateAIResponse(&aiResponse); err != nil {
		return nil, fmt.Errorf("invalid AI response: %w", err)
	}

	return &aiResponse, nil
}

// convertAIResponseToTemplate converts AI response to workflow template
func (iwb *DefaultIntelligentWorkflowBuilder) convertAIResponseToTemplate(aiResponse *AIWorkflowResponse, objective *WorkflowObjective) (*WorkflowTemplate, error) {
	template := &WorkflowTemplate{
		ID:          uuid.New().String(),
		Name:        aiResponse.WorkflowName,
		Description: aiResponse.Description,
		Version:     "1.0.0",
		Steps:       make([]*WorkflowStep, 0),
		Conditions:  make([]*WorkflowCondition, 0),
		Variables:   aiResponse.Variables,
		CreatedBy:   "intelligent-workflow-builder",
		CreatedAt:   time.Now(),
		Tags:        []string{"ai-generated", objective.Type},
	}

	// Convert AI steps to workflow steps
	for i, aiStep := range aiResponse.Steps {
		step, err := iwb.convertAIStepToWorkflowStep(aiStep, i)
		if err != nil {
			return nil, fmt.Errorf("failed to convert step %d: %w", i, err)
		}
		template.Steps = append(template.Steps, step)
	}

	// Convert AI conditions to workflow conditions
	for _, aiCondition := range aiResponse.Conditions {
		condition := iwb.convertAIConditionToWorkflowCondition(aiCondition)
		template.Conditions = append(template.Conditions, condition)
	}

	// Set timeouts based on AI estimation or defaults
	template.Timeouts = iwb.createTimeoutsFromEstimation(aiResponse.EstimatedTime)

	// Create recovery policy
	template.Recovery = iwb.createRecoveryPolicyFromRisk(aiResponse.RiskAssessment)

	return template, nil
}

// optimizeWorkflowForConstraints optimizes workflow based on constraints
func (iwb *DefaultIntelligentWorkflowBuilder) optimizeWorkflowForConstraints(ctx context.Context, template *WorkflowTemplate, constraints map[string]interface{}) (*WorkflowTemplate, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"template_id":      template.ID,
		"constraint_count": len(constraints),
	}).Debug("Optimizing workflow for constraints")

	optimizedTemplate := iwb.deepCopyTemplate(template)

	// Apply timeout constraints
	if maxTime, ok := constraints["max_execution_time"]; ok {
		if maxTimeStr, ok := maxTime.(string); ok {
			if duration, err := time.ParseDuration(maxTimeStr); err == nil {
				iwb.adjustTimeoutsForMaxDuration(optimizedTemplate, duration)
			}
		}
	}

	// Apply resource constraints
	if resourceLimits, ok := constraints["resource_limits"]; ok {
		if limits, ok := resourceLimits.(map[string]interface{}); ok {
			iwb.applyResourceConstraints(optimizedTemplate, limits)
		}
	}

	// Apply safety constraints
	if safetyLevel, ok := constraints["safety_level"]; ok {
		if level, ok := safetyLevel.(string); ok {
			iwb.applySafetyConstraints(optimizedTemplate, level)
		}
	}

	// Optimize step ordering for efficiency
	iwb.optimizeStepOrdering(optimizedTemplate)

	return optimizedTemplate, nil
}

// analyzeWorkflowPerformance analyzes workflow performance metrics
func (iwb *DefaultIntelligentWorkflowBuilder) analyzeWorkflowPerformance(ctx context.Context, template *WorkflowTemplate) (*PerformanceAnalysis, error) {
	// Get historical executions for this workflow
	executions, err := iwb.executionRepo.GetExecutionsByWorkflowID(ctx, template.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get workflow executions: %w", err)
	}

	if len(executions) == 0 {
		// Return default analysis for new workflows
		return &PerformanceAnalysis{
			WorkflowID:      template.ID,
			ExecutionTime:   time.Duration(len(template.Steps)) * iwb.config.DefaultStepTimeout,
			Bottlenecks:     make([]*Bottleneck, 0),
			Optimizations:   make([]*OptimizationCandidate, 0),
			Effectiveness:   0.8, // Default assumption
			CostEfficiency:  0.7, // Default assumption
			Recommendations: make([]*OptimizationSuggestion, 0),
			AnalyzedAt:      time.Now(),
		}, nil
	}

	// Calculate performance metrics
	totalDuration := time.Duration(0)
	successCount := 0
	resourceUsage := &ResourceUsageMetrics{}

	for _, exec := range executions {
		totalDuration += exec.Duration
		if exec.Status == ExecutionStatusCompleted {
			successCount++
		}
		// Aggregate resource usage
		if exec.Output != nil && exec.Output.Metrics != nil && exec.Output.Metrics.ResourceUsage != nil {
			iwb.aggregateResourceUsage(resourceUsage, exec.Output.Metrics.ResourceUsage)
		}
	}

	avgExecutionTime := totalDuration / time.Duration(len(executions))
	effectiveness := float64(successCount) / float64(len(executions))

	// Identify bottlenecks
	bottlenecks := iwb.identifyPerformanceBottlenecks(executions, template)

	// Generate optimization candidates
	optimizations := iwb.generateOptimizationCandidates(executions, template, bottlenecks)

	// Calculate cost efficiency
	costEfficiency := iwb.calculateCostEfficiency(resourceUsage, effectiveness)

	// Generate recommendations
	recommendations := iwb.generatePerformanceRecommendations(bottlenecks, optimizations)

	return &PerformanceAnalysis{
		WorkflowID:      template.ID,
		ExecutionTime:   avgExecutionTime,
		ResourceUsage:   resourceUsage,
		Bottlenecks:     bottlenecks,
		Optimizations:   optimizations,
		Effectiveness:   effectiveness,
		CostEfficiency:  costEfficiency,
		Recommendations: recommendations,
		AnalyzedAt:      time.Now(),
	}, nil
}

// identifyBottlenecks identifies performance bottlenecks
func (iwb *DefaultIntelligentWorkflowBuilder) identifyBottlenecks(analysis *PerformanceAnalysis) []*Bottleneck {
	return analysis.Bottlenecks
}

// generateOptimizationRecommendations generates optimization recommendations
func (iwb *DefaultIntelligentWorkflowBuilder) generateOptimizationRecommendations(ctx context.Context, template *WorkflowTemplate, bottlenecks []*Bottleneck) ([]*OptimizationSuggestion, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"template_id":      template.ID,
		"bottleneck_count": len(bottlenecks),
	}).Debug("Generating optimization recommendations")

	recommendations := make([]*OptimizationSuggestion, 0)

	for _, bottleneck := range bottlenecks {
		switch bottleneck.Type {
		case BottleneckTypeResource:
			recommendations = append(recommendations, &OptimizationSuggestion{
				ID:          uuid.New().String(),
				Type:        "resource_optimization",
				Title:       "Optimize Resource Usage",
				Description: fmt.Sprintf("Reduce resource consumption in step %s", bottleneck.StepID),
				Priority:    1,
				Impact:      bottleneck.Impact,
				Effort:      "medium",
				Applicable:  true,
			})
		case BottleneckTypeTimeout:
			recommendations = append(recommendations, &OptimizationSuggestion{
				ID:          uuid.New().String(),
				Type:        "timeout_optimization",
				Title:       "Adjust Timeout Settings",
				Description: fmt.Sprintf("Optimize timeout configuration for step %s", bottleneck.StepID),
				Priority:    2,
				Impact:      bottleneck.Impact,
				Effort:      "low",
				Applicable:  true,
			})
		case BottleneckTypeLogical:
			recommendations = append(recommendations, &OptimizationSuggestion{
				ID:          uuid.New().String(),
				Type:        "logic_optimization",
				Title:       "Improve Step Logic",
				Description: fmt.Sprintf("Optimize logic in step %s", bottleneck.StepID),
				Priority:    3,
				Impact:      bottleneck.Impact,
				Effort:      "high",
				Applicable:  true,
			})
		}
	}

	return recommendations, nil
}

// applyOptimizations applies optimization recommendations to template
func (iwb *DefaultIntelligentWorkflowBuilder) applyOptimizations(ctx context.Context, template *WorkflowTemplate, recommendations []*OptimizationSuggestion) (*WorkflowTemplate, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"template_id":          template.ID,
		"recommendation_count": len(recommendations),
	}).Debug("Applying optimizations to workflow template")

	optimizedTemplate := iwb.deepCopyTemplate(template)

	for _, recommendation := range recommendations {
		switch recommendation.Type {
		case "resource_optimization":
			iwb.applyResourceOptimization(optimizedTemplate, recommendation)
		case "timeout_optimization":
			iwb.applyTimeoutOptimization(optimizedTemplate, recommendation)
		case "logic_optimization":
			iwb.applyLogicOptimization(optimizedTemplate, recommendation)
		}
	}

	// Update version to indicate optimization
	optimizedTemplate.Version = iwb.incrementVersion(template.Version)
	optimizedTemplate.Description += " (optimized)"

	return optimizedTemplate, nil
}

// Missing helper methods for pattern discovery and learning

// filterExecutionsByCriteria filters executions based on criteria
func (iwb *DefaultIntelligentWorkflowBuilder) filterExecutionsByCriteria(executions []*WorkflowExecution, criteria *PatternCriteria) []*WorkflowExecution {
	filtered := make([]*WorkflowExecution, 0)

	for _, execution := range executions {
		// Filter by environment if specified
		if len(criteria.EnvironmentFilter) > 0 {
			found := false
			for _, env := range criteria.EnvironmentFilter {
				if execution.Context.Environment == env {
					found = true
					break
				}
			}
			if !found {
				continue
			}
		}

		filtered = append(filtered, execution)
	}

	return filtered
}

// groupExecutionsBySimilarity groups executions by similarity
func (iwb *DefaultIntelligentWorkflowBuilder) groupExecutionsBySimilarity(ctx context.Context, executions []*WorkflowExecution, minSimilarity float64) map[string][]*WorkflowExecution {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"execution_count": len(executions),
		"min_similarity":  minSimilarity,
	}).Debug("Grouping executions by similarity")

	groups := make(map[string][]*WorkflowExecution)

	for _, execution := range executions {
		groupID := fmt.Sprintf("%s-%s", execution.WorkflowID, execution.Context.Environment)
		groups[groupID] = append(groups[groupID], execution)
	}

	return groups
}

// extractPatternFromExecutions extracts a pattern from executions
func (iwb *DefaultIntelligentWorkflowBuilder) extractPatternFromExecutions(ctx context.Context, groupID string, executions []*WorkflowExecution) (*WorkflowPattern, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"group_id":        groupID,
		"execution_count": len(executions),
	}).Debug("Extracting pattern from executions")

	if len(executions) == 0 {
		return nil, fmt.Errorf("no executions provided")
	}

	pattern := &WorkflowPattern{
		ID:            uuid.New().String(),
		Name:          fmt.Sprintf("Pattern-%s", groupID),
		Type:          "execution-based",
		Steps:         make([]*WorkflowStep, 0),
		Conditions:    make([]*ActionCondition, 0),
		Environments:  []string{executions[0].Context.Environment},
		ResourceTypes: []string{"workflow"},
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	return pattern, nil
}

// calculateSuccessRate calculates success rate for executions
func (iwb *DefaultIntelligentWorkflowBuilder) calculateSuccessRate(executions []*WorkflowExecution) float64 {
	if len(executions) == 0 {
		return 0.0
	}

	successCount := 0
	for _, execution := range executions {
		if execution.Status == ExecutionStatusCompleted {
			successCount++
		}
	}

	return float64(successCount) / float64(len(executions))
}

// calculatePatternConfidence calculates pattern confidence
func (iwb *DefaultIntelligentWorkflowBuilder) calculatePatternConfidence(pattern *WorkflowPattern, executions []*WorkflowExecution) float64 {
	confidence := pattern.SuccessRate * 0.8

	if len(executions) >= 10 {
		confidence += 0.15
	} else if len(executions) >= 5 {
		confidence += 0.1
	}

	return confidence
}

// calculateAverageExecutionTime calculates average execution time
func (iwb *DefaultIntelligentWorkflowBuilder) calculateAverageExecutionTime(executions []*WorkflowExecution) time.Duration {
	if len(executions) == 0 {
		return 0
	}

	total := time.Duration(0)
	for _, execution := range executions {
		total += execution.Duration
	}

	return total / time.Duration(len(executions))
}

// adaptPatternStepsToContext adapts pattern steps to context
func (iwb *DefaultIntelligentWorkflowBuilder) adaptPatternStepsToContext(ctx context.Context, steps []*WorkflowStep, context *WorkflowContext) ([]*WorkflowStep, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"step_count":  len(steps),
		"environment": context.Environment,
		"namespace":   context.Namespace,
	}).Debug("Adapting pattern steps to context")

	adaptedSteps := make([]*WorkflowStep, len(steps))
	copy(adaptedSteps, steps)

	// Apply context-specific adaptations
	for _, step := range adaptedSteps {
		if step.Action != nil && step.Action.Target != nil && context.Namespace != "" {
			step.Action.Target.Namespace = context.Namespace
		}
	}

	return adaptedSteps, nil
}

// customizeStepsForEnvironment customizes steps for environment
func (iwb *DefaultIntelligentWorkflowBuilder) customizeStepsForEnvironment(ctx context.Context, steps []*WorkflowStep, environment string) ([]*WorkflowStep, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"step_count":  len(steps),
		"environment": environment,
	}).Debug("Customizing steps for environment")

	customizedSteps := make([]*WorkflowStep, len(steps))
	copy(customizedSteps, steps)

	for _, step := range customizedSteps {
		if step.Variables == nil {
			step.Variables = make(map[string]interface{})
		}
		step.Variables["environment"] = environment
	}

	return customizedSteps, nil
}

// addContextSpecificConditions adds context-specific conditions
func (iwb *DefaultIntelligentWorkflowBuilder) addContextSpecificConditions(ctx context.Context, steps []*WorkflowStep, context *WorkflowContext) ([]*WorkflowStep, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"step_count":  len(steps),
		"environment": context.Environment,
	}).Debug("Adding context-specific conditions to steps")

	enhancedSteps := make([]*WorkflowStep, len(steps))
	copy(enhancedSteps, steps)

	// Add safety conditions for production
	if context.Environment == "production" {
		for _, step := range enhancedSteps {
			if step.Action != nil && step.Condition == nil {
				step.Condition = &WorkflowCondition{
					ID:         uuid.New().String(),
					Name:       "production-safety",
					Type:       ConditionTypeCustom,
					Expression: "environment == 'production'",
					Variables:  map[string]interface{}{"environment": context.Environment},
				}
			}
		}
	}

	return enhancedSteps, nil
}

// updatePatternsFromLearning updates patterns from learning
func (iwb *DefaultIntelligentWorkflowBuilder) updatePatternsFromLearning(ctx context.Context, learning *WorkflowLearning) error {
	iwb.log.WithFields(logrus.Fields{
		"learning_id":   learning.ID,
		"workflow_id":   learning.WorkflowID,
		"learning_type": learning.Type,
	}).Info("Updating patterns from learning")

	// Extract action information from learning data
	actionType := "unknown"
	namespace := "default"
	resourceType := "deployment"
	resourceName := "default"
	actionParameters := make(map[string]interface{})

	if learning.Data != nil {
		if at, ok := learning.Data["action_type"].(string); ok {
			actionType = at
		}
		if ns, ok := learning.Data["namespace"].(string); ok {
			namespace = ns
		}
		if rt, ok := learning.Data["resource_type"].(string); ok {
			resourceType = rt
		}
		if rn, ok := learning.Data["resource_name"].(string); ok {
			resourceName = rn
		}
		if params, ok := learning.Data["parameters"].(map[string]interface{}); ok {
			actionParameters = params
		}
	}

	// Convert learning to action pattern for vector database storage
	pattern := &vector.ActionPattern{
		ID:               learning.ID,
		ActionType:       actionType,
		Namespace:        namespace,
		ResourceType:     resourceType,
		ResourceName:     resourceName,
		ActionParameters: actionParameters,
		PreConditions:    make(map[string]interface{}),
		PostConditions:   make(map[string]interface{}),
		Metadata:         learning.Data,
		CreatedAt:        learning.CreatedAt,
		UpdatedAt:        learning.UpdatedAt,
	}

	// Update effectiveness data based on learning outcome
	success := false
	if s, ok := learning.Data["success"].(bool); ok {
		success = s
	}

	effectivenessScore := 0.5
	if score, ok := learning.Data["effectiveness_score"].(float64); ok {
		effectivenessScore = score
	}

	// confidence := 0.5
	// if conf, ok := learning.Data["confidence"].(float64); ok {
	// 	confidence = conf
	// }

	executionTime := time.Second * 30
	if et, ok := learning.Data["execution_time"].(time.Duration); ok {
		executionTime = et
	}

	if success {
		pattern.EffectivenessData = &vector.EffectivenessData{
			Score:                effectivenessScore,
			SuccessCount:         1,
			FailureCount:         0,
			AverageExecutionTime: executionTime,
		}
	} else {
		pattern.EffectivenessData = &vector.EffectivenessData{
			Score:                effectivenessScore,
			SuccessCount:         0,
			FailureCount:         1,
			AverageExecutionTime: executionTime,
		}
	}

	// Store the updated pattern in vector database
	if err := iwb.vectorDB.StoreActionPattern(ctx, pattern); err != nil {
		return fmt.Errorf("failed to store updated pattern in vector database: %w", err)
	}

	iwb.log.WithField("pattern_id", pattern.ID).Info("Successfully updated pattern from learning")
	return nil
}

// findPatternsForWorkflow finds patterns for workflow
func (iwb *DefaultIntelligentWorkflowBuilder) findPatternsForWorkflow(ctx context.Context, workflowID string) ([]*WorkflowPattern, error) {
	iwb.log.WithField("workflow_id", workflowID).Info("Finding patterns for workflow")

	// Get executions for this workflow from repository
	executions, err := iwb.executionRepo.GetExecutionsByWorkflowID(ctx, workflowID)
	if err != nil {
		return nil, fmt.Errorf("failed to get executions for workflow: %w", err)
	}

	if len(executions) == 0 {
		iwb.log.WithField("workflow_id", workflowID).Info("No executions found for workflow")
		return make([]*WorkflowPattern, 0), nil
	}

	// Group executions by success/failure and extract patterns
	patterns := make([]*WorkflowPattern, 0)
	successfulExecutions := make([]*WorkflowExecution, 0)

	for _, execution := range executions {
		if execution.Status == ExecutionStatusCompleted {
			successfulExecutions = append(successfulExecutions, execution)
		}
	}

	// If we have enough successful executions, create patterns
	if len(successfulExecutions) >= iwb.config.MinExecutionCount {
		// Create a pattern from successful executions
		pattern, err := iwb.createPatternFromExecutions(ctx, successfulExecutions)
		if err != nil {
			iwb.log.WithError(err).Warn("Failed to create pattern from executions")
		} else {
			patterns = append(patterns, pattern)
		}
	}

	// Also search vector database for similar patterns
	if len(successfulExecutions) > 0 {
		// Use the first execution as a reference for similarity search
		refExecution := successfulExecutions[0]
		// Extract action type from execution metadata or context
		actionType := "unknown"
		if refExecution.Metadata != nil {
			if at, ok := refExecution.Metadata["action_type"].(string); ok {
				actionType = at
			}
		}
		searchQuery := fmt.Sprintf("workflow_id:%s action_type:%s", refExecution.WorkflowID, actionType)

		actionPatterns, err := iwb.vectorDB.SearchBySemantics(ctx, searchQuery, 5)
		if err != nil {
			iwb.log.WithError(err).Warn("Failed to search vector database for patterns")
		} else {
			// Convert action patterns to workflow patterns
			for _, actionPattern := range actionPatterns {
				workflowPattern := iwb.convertActionPatternToWorkflowPattern(actionPattern)
				patterns = append(patterns, workflowPattern)
			}
		}
	}

	iwb.log.WithFields(logrus.Fields{
		"workflow_id":    workflowID,
		"patterns_found": len(patterns),
		"executions":     len(executions),
	}).Info("Found patterns for workflow")

	return patterns, nil
}

// applyLearningsToPattern applies learnings to pattern
func (iwb *DefaultIntelligentWorkflowBuilder) applyLearningsToPattern(ctx context.Context, pattern *WorkflowPattern, learnings []*WorkflowLearning) (bool, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"pattern_id":      pattern.ID,
		"learnings_count": len(learnings),
	}).Info("Applying learnings to pattern")

	updated := false
	totalExecutions := 0
	successfulExecutions := 0
	totalExecutionTime := time.Duration(0)

	// Aggregate learning data
	for _, learning := range learnings {
		totalExecutions++

		// Extract success from learning data
		if learning.Data != nil {
			if success, ok := learning.Data["success"].(bool); ok && success {
				successfulExecutions++
			}

			// Extract execution time
			if execTime, ok := learning.Data["execution_time"].(time.Duration); ok {
				totalExecutionTime += execTime
			}

			// Update pattern metadata based on learning data
			for range learning.Data {
				// For WorkflowPattern, we need to store metadata differently
				// Since WorkflowPattern doesn't have Metadata field, we'll store in Variables or create extended pattern
				updated = true
			}
		}
	}

	// Update pattern success rate
	if totalExecutions > 0 {
		oldSuccessRate := pattern.SuccessRate
		newSuccessRate := float64(successfulExecutions) / float64(totalExecutions)

		// Weighted average with existing data
		weightedSuccessRate := (oldSuccessRate*float64(pattern.ExecutionCount) + newSuccessRate*float64(totalExecutions)) /
			float64(pattern.ExecutionCount+totalExecutions)

		if math.Abs(weightedSuccessRate-pattern.SuccessRate) > 0.01 { // Only update if significant change
			pattern.SuccessRate = weightedSuccessRate
			updated = true
		}
	}

	// Update execution count and average time
	if totalExecutions > 0 {
		oldAvgTime := pattern.AverageTime
		newAvgTime := totalExecutionTime / time.Duration(totalExecutions)

		// Weighted average for execution time
		weightedAvgTime := (oldAvgTime*time.Duration(pattern.ExecutionCount) + newAvgTime*time.Duration(totalExecutions)) /
			time.Duration(pattern.ExecutionCount+totalExecutions)

		pattern.AverageTime = weightedAvgTime
		pattern.ExecutionCount += totalExecutions
		pattern.LastUsed = time.Now()
		updated = true
	}

	// Update confidence based on new data
	if updated {
		// Recalculate confidence based on execution count and success rate
		confidenceBoost := math.Min(0.1, float64(totalExecutions)*0.02) // Max 10% boost
		pattern.Confidence = math.Min(1.0, pattern.Confidence+confidenceBoost)
		pattern.UpdatedAt = time.Now()
	}

	iwb.log.WithFields(logrus.Fields{
		"pattern_id":          pattern.ID,
		"updated":             updated,
		"new_success_rate":    pattern.SuccessRate,
		"new_execution_count": pattern.ExecutionCount,
		"new_confidence":      pattern.Confidence,
	}).Info("Applied learnings to pattern")

	return updated, nil
}

// storeUpdatedPattern stores updated pattern
func (iwb *DefaultIntelligentWorkflowBuilder) storeUpdatedPattern(ctx context.Context, pattern *WorkflowPattern) error {
	iwb.log.WithField("pattern_id", pattern.ID).Info("Storing updated pattern")

	// Convert workflow pattern to action pattern for vector database storage
	actionPattern := &vector.ActionPattern{
		ID:               pattern.ID,
		ActionType:       pattern.Type,
		Namespace:        iwb.getNamespaceFromPattern(pattern),
		ResourceType:     iwb.getResourceTypeFromPattern(pattern),
		ResourceName:     iwb.getResourceNameFromPattern(pattern),
		ActionParameters: iwb.getParametersFromPattern(pattern),
		PreConditions:    iwb.getPreConditionsFromPattern(pattern),
		PostConditions:   iwb.getPostConditionsFromPattern(pattern),
		Metadata:         make(map[string]interface{}),
		CreatedAt:        pattern.CreatedAt,
		UpdatedAt:        pattern.UpdatedAt,
	}

	// Create effectiveness data from pattern
	actionPattern.EffectivenessData = &vector.EffectivenessData{
		Score:                pattern.Confidence,
		SuccessCount:         int(float64(pattern.ExecutionCount) * pattern.SuccessRate),
		FailureCount:         pattern.ExecutionCount - int(float64(pattern.ExecutionCount)*pattern.SuccessRate),
		AverageExecutionTime: pattern.AverageTime,
	}

	// Store the pattern in vector database
	if err := iwb.vectorDB.StoreActionPattern(ctx, actionPattern); err != nil {
		return fmt.Errorf("failed to store pattern in vector database: %w", err)
	}

	// Store pattern metadata if analytics engine is available
	if iwb.analyticsEngine != nil {
		// Note: RecordPatternMetrics method needs to be implemented in analytics engine
		// For now, we'll log the metrics
		iwb.log.WithFields(logrus.Fields{
			"pattern_id":      pattern.ID,
			"success_rate":    pattern.SuccessRate,
			"execution_count": pattern.ExecutionCount,
			"confidence":      pattern.Confidence,
			"average_time_ms": pattern.AverageTime.Milliseconds(),
		}).Info("Pattern metrics recorded")
	}

	iwb.log.WithFields(logrus.Fields{
		"pattern_id":      pattern.ID,
		"success_rate":    pattern.SuccessRate,
		"execution_count": pattern.ExecutionCount,
		"confidence":      pattern.Confidence,
	}).Info("Successfully stored updated pattern")

	return nil
}

// createNewPatternsFromLearnings creates new patterns from learnings
func (iwb *DefaultIntelligentWorkflowBuilder) createNewPatternsFromLearnings(ctx context.Context, workflowID string, learnings []*WorkflowLearning) ([]*WorkflowPattern, error) {
	iwb.log.WithContext(ctx).WithFields(logrus.Fields{
		"workflow_id":    workflowID,
		"learning_count": len(learnings),
	}).Debug("Creating new patterns from learnings")

	patterns := make([]*WorkflowPattern, 0)

	// Group learnings by action type to create patterns
	learningsByType := make(map[string][]*WorkflowLearning)
	for _, learning := range learnings {
		if actionType, ok := learning.Data["action_type"].(string); ok {
			learningsByType[actionType] = append(learningsByType[actionType], learning)
		}
	}

	// Create patterns from grouped learnings
	for actionType, typeLearnings := range learningsByType {
		if len(typeLearnings) >= iwb.config.MinExecutionCount {
			pattern := &WorkflowPattern{
				ID:             fmt.Sprintf("learned-%s-%s", actionType, time.Now().Format("20060102")),
				Name:           fmt.Sprintf("Learned %s Pattern", actionType),
				Type:           actionType,
				SuccessRate:    iwb.calculateLearningSuccessRate(typeLearnings),
				ExecutionCount: len(typeLearnings),
				Confidence:     0.7, // Initial confidence for learned patterns
				Environments:   []string{"production"},
				ResourceTypes:  []string{"deployment"},
				CreatedAt:      time.Now(),
				UpdatedAt:      time.Now(),
			}
			patterns = append(patterns, pattern)
		}
	}

	return patterns, nil
}

// Missing optimization helper methods (stubs for now)

func (iwb *DefaultIntelligentWorkflowBuilder) adjustTimeoutsForMaxDuration(template *WorkflowTemplate, maxDuration time.Duration) {
	if template == nil || len(template.Steps) == 0 {
		return
	}

	// Calculate average timeout per step, leaving buffer for overhead
	stepBuffer := maxDuration / 10 // 10% buffer
	availableTime := maxDuration - stepBuffer
	avgStepTimeout := availableTime / time.Duration(len(template.Steps))

	// Adjust step timeouts
	for _, step := range template.Steps {
		if step.Timeout > avgStepTimeout {
			step.Timeout = avgStepTimeout
		}
	}

	// Set overall execution timeout
	if template.Timeouts == nil {
		template.Timeouts = &WorkflowTimeouts{}
	}
	template.Timeouts.Execution = maxDuration
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyResourceConstraints(template *WorkflowTemplate, limits map[string]interface{}) {
	if template == nil || limits == nil {
		return
	}

	for _, step := range template.Steps {
		if step.Action == nil {
			continue
		}

		// Initialize parameters if nil
		if step.Action.Parameters == nil {
			step.Action.Parameters = make(map[string]interface{})
		}

		// Apply CPU limits
		if cpuLimit, ok := limits["cpu"].(string); ok {
			step.Action.Parameters["cpu_limit"] = cpuLimit
		}

		// Apply memory limits
		if memLimit, ok := limits["memory"].(string); ok {
			step.Action.Parameters["memory_limit"] = memLimit
		}

		// Apply storage limits
		if storageLimit, ok := limits["storage"].(string); ok {
			step.Action.Parameters["storage_limit"] = storageLimit
		}

		// Apply max resource delta constraint
		if maxDelta, ok := limits["max_resource_delta"].(string); ok {
			step.Action.Parameters["max_resource_delta"] = maxDelta
		}
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) applySafetyConstraints(template *WorkflowTemplate, level string) {
	if template == nil {
		return
	}

	switch level {
	case "high":
		// High safety: Add confirmation steps, reduce parallelism, add rollback
		iwb.addConfirmationSteps(template)
		iwb.addRollbackSteps(template)
		iwb.reduceParallelism(template)
	case "medium":
		// Medium safety: Add rollback, basic validation
		iwb.addRollbackSteps(template)
		iwb.addValidationSteps(template)
	case "low":
		// Low safety: Basic validation only
		iwb.addValidationSteps(template)
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) optimizeStepOrdering(template *WorkflowTemplate) {
	if len(template.Steps) <= 1 {
		return
	}

	// Move validation steps to the beginning
	validationSteps := make([]*WorkflowStep, 0)
	actionSteps := make([]*WorkflowStep, 0)
	cleanupSteps := make([]*WorkflowStep, 0)

	for _, step := range template.Steps {
		if step.Action != nil {
			switch step.Action.Type {
			case "validate", "check", "verify":
				validationSteps = append(validationSteps, step)
			case "cleanup", "rollback", "restore":
				cleanupSteps = append(cleanupSteps, step)
			default:
				actionSteps = append(actionSteps, step)
			}
		} else {
			actionSteps = append(actionSteps, step)
		}
	}

	// Reorder: validation → actions → cleanup
	newSteps := make([]*WorkflowStep, 0, len(template.Steps))
	newSteps = append(newSteps, validationSteps...)
	newSteps = append(newSteps, actionSteps...)
	newSteps = append(newSteps, cleanupSteps...)

	template.Steps = newSteps
}

func (iwb *DefaultIntelligentWorkflowBuilder) aggregateResourceUsage(total *ResourceUsageMetrics, usage *ResourceUsageMetrics) {
	if total == nil || usage == nil {
		return
	}

	total.CPUUsage += usage.CPUUsage
	total.MemoryUsage += usage.MemoryUsage
	total.DiskUsage += usage.DiskUsage
	total.NetworkIO += usage.NetworkIO
}

func (iwb *DefaultIntelligentWorkflowBuilder) identifyPerformanceBottlenecks(executions []*WorkflowExecution, template *WorkflowTemplate) []*Bottleneck {
	bottlenecks := make([]*Bottleneck, 0)

	if len(executions) == 0 {
		return bottlenecks
	}

	// Note: WorkflowExecution doesn't have StepExecutions field, so we'll create generic bottlenecks
	// Analyze execution durations to identify slow workflows
	var totalDuration time.Duration
	for _, exec := range executions {
		totalDuration += exec.Duration
	}

	avgDuration := totalDuration / time.Duration(len(executions))

	// If average duration is > 5 minutes, consider it a bottleneck
	if avgDuration > 5*time.Minute {
		bottleneck := &Bottleneck{
			ID:          "slow-workflow",
			Type:        BottleneckTypeTimeout,
			StepID:      "overall",
			Description: fmt.Sprintf("Workflow takes an average of %v", avgDuration),
			Impact:      0.8, // High impact
			Severity:    "high",
			Suggestion:  "Consider optimizing step timeouts and enabling parallelism",
		}
		bottlenecks = append(bottlenecks, bottleneck)
	}

	return bottlenecks
}

func (iwb *DefaultIntelligentWorkflowBuilder) generateOptimizationCandidates(executions []*WorkflowExecution, template *WorkflowTemplate, bottlenecks []*Bottleneck) []*OptimizationCandidate {
	candidates := make([]*OptimizationCandidate, 0)

	// Generate candidates based on bottlenecks
	for _, bottleneck := range bottlenecks {
		switch bottleneck.Type {
		case BottleneckTypeTimeout:
			candidate := &OptimizationCandidate{
				ID:          fmt.Sprintf("opt-%s", bottleneck.ID),
				Type:        "reduce_timeout",
				Target:      bottleneck.StepID,
				Description: fmt.Sprintf("Optimize timeout for slow step %s", bottleneck.StepID),
				Impact:      0.6, // Medium impact
				Parameters: map[string]interface{}{
					"timeout_reduction":  "20%",
					"parallel_execution": true,
				},
				Confidence: 0.7,
			}
			candidates = append(candidates, candidate)
		case BottleneckTypeResource:
			candidate := &OptimizationCandidate{
				ID:          fmt.Sprintf("opt-%s", bottleneck.ID),
				Type:        "resource_optimization",
				Target:      bottleneck.StepID,
				Description: fmt.Sprintf("Optimize resource usage for step %s", bottleneck.StepID),
				Impact:      0.8, // High impact
				Parameters: map[string]interface{}{
					"cpu_limit":    "500m",
					"memory_limit": "1Gi",
				},
				Confidence: 0.8,
			}
			candidates = append(candidates, candidate)
		}
	}

	// Add general optimization candidates
	if len(template.Steps) > 5 {
		candidate := &OptimizationCandidate{
			ID:          "parallel-execution",
			Type:        "enable_parallelism",
			Target:      "workflow",
			Description: "Enable parallel execution for independent steps",
			Impact:      0.8, // High impact
			Parameters: map[string]interface{}{
				"max_parallel": 3,
			},
			Confidence: 0.9,
		}
		candidates = append(candidates, candidate)
	}

	return candidates
}

func (iwb *DefaultIntelligentWorkflowBuilder) calculateCostEfficiency(usage *ResourceUsageMetrics, effectiveness float64) float64 {
	if usage == nil || effectiveness <= 0 {
		return 0.0
	}

	// Simple cost calculation based on resource usage
	// Higher resource usage = higher cost, lower efficiency
	totalResources := usage.CPUUsage + usage.MemoryUsage + usage.DiskUsage + usage.NetworkIO

	// Normalize cost (assuming baseline cost of 100 resource units)
	baselineCost := 100.0
	costRatio := baselineCost / (totalResources + 1) // +1 to avoid division by zero

	// Cost efficiency = effectiveness / cost_ratio
	// Higher effectiveness with lower cost = higher efficiency
	efficiency := effectiveness * costRatio

	// Cap efficiency at 1.0
	if efficiency > 1.0 {
		efficiency = 1.0
	}

	return efficiency
}

func (iwb *DefaultIntelligentWorkflowBuilder) generatePerformanceRecommendations(bottlenecks []*Bottleneck, optimizations []*OptimizationCandidate) []*OptimizationSuggestion {
	suggestions := make([]*OptimizationSuggestion, 0)

	// Convert optimization candidates to suggestions
	for _, candidate := range optimizations {
		suggestion := &OptimizationSuggestion{
			ID:          fmt.Sprintf("suggest-%s", candidate.ID),
			Type:        candidate.Type,
			Title:       fmt.Sprintf("Optimize %s", candidate.Target),
			Description: candidate.Description,
			Priority:    int(candidate.Impact * 10), // Convert impact to priority
			Impact:      candidate.Impact,
			Effort:      "medium",
			Parameters:  candidate.Parameters,
			Applicable:  true,
		}

		suggestions = append(suggestions, suggestion)
	}

	// Add general recommendations based on bottlenecks
	if len(bottlenecks) > 3 {
		suggestion := &OptimizationSuggestion{
			ID:          "general-optimization",
			Type:        "workflow_restructure",
			Title:       "Restructure Workflow",
			Description: "Consider restructuring workflow to reduce bottlenecks",
			Priority:    8, // High priority
			Impact:      0.8,
			Effort:      "high",
			Parameters:  make(map[string]interface{}),
			Applicable:  true,
		}
		suggestions = append(suggestions, suggestion)
	}

	return suggestions
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyResourceOptimization(template *WorkflowTemplate, recommendation *OptimizationSuggestion) {
	// Apply to all steps since OptimizationSuggestion doesn't have StepID
	for _, step := range template.Steps {
		iwb.applyResourceOptimizationToStep(step, recommendation)
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyTimeoutOptimization(template *WorkflowTemplate, recommendation *OptimizationSuggestion) {
	// Apply to all steps since OptimizationSuggestion doesn't have StepID
	for _, step := range template.Steps {
		iwb.applyTimeoutOptimizationToStep(step, recommendation)
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyLogicOptimization(template *WorkflowTemplate, recommendation *OptimizationSuggestion) {
	iwb.log.WithFields(logrus.Fields{
		"template_id":       template.ID,
		"recommendation_id": recommendation.ID,
		"optimization_type": recommendation.Type,
	}).Info("Applying logic optimization")

	switch recommendation.Type {
	case "remove_redundant_steps":
		iwb.removeRedundantSteps(template)
	case "merge_similar_steps":
		iwb.mergeSimilarSteps(template)
	case "optimize_conditions":
		iwb.optimizeConditions(template)
	case "parallel_execution":
		iwb.enableParallelExecution(template)
	}
}

// Helper methods for pattern storage conversion
func (iwb *DefaultIntelligentWorkflowBuilder) getNamespaceFromPattern(pattern *WorkflowPattern) string {
	if len(pattern.Environments) > 0 {
		return pattern.Environments[0]
	}
	return "default"
}

func (iwb *DefaultIntelligentWorkflowBuilder) getResourceTypeFromPattern(pattern *WorkflowPattern) string {
	if len(pattern.ResourceTypes) > 0 {
		return pattern.ResourceTypes[0]
	}
	return "deployment"
}

// Additional helper methods for optimization features
func (iwb *DefaultIntelligentWorkflowBuilder) calculateLearningSuccessRate(learnings []*WorkflowLearning) float64 {
	if len(learnings) == 0 {
		return 0.0
	}

	successCount := 0
	for _, learning := range learnings {
		if success, ok := learning.Data["success"].(bool); ok && success {
			successCount++
		}
	}

	return float64(successCount) / float64(len(learnings))
}

func (iwb *DefaultIntelligentWorkflowBuilder) addConfirmationSteps(template *WorkflowTemplate) {
	if template == nil {
		return
	}

	// Add confirmation step before destructive actions
	for i, step := range template.Steps {
		if step.Action != nil && iwb.isDestructiveAction(step.Action.Type) {
			confirmStep := &WorkflowStep{
				ID:   fmt.Sprintf("confirm-%s", step.ID),
				Name: fmt.Sprintf("Confirm %s", step.Name),
				Type: StepTypeCondition,
				Condition: &WorkflowCondition{
					Expression: "user_confirmation == true",
					Type:       "user_input",
				},
				Timeout: 5 * time.Minute,
			}
			// Insert confirmation step before the action
			template.Steps = append(template.Steps[:i], append([]*WorkflowStep{confirmStep}, template.Steps[i:]...)...)
			break
		}
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) addRollbackSteps(template *WorkflowTemplate) {
	if template == nil {
		return
	}

	if template.Recovery == nil {
		template.Recovery = &RecoveryPolicy{
			Enabled:         true,
			MaxRecoveryTime: 5 * time.Minute,
			Strategies:      make([]*RecoveryStrategy, 0),
			Notifications:   make([]*NotificationConfig, 0),
		}
	}

	// Add a rollback strategy
	rollbackStrategy := &RecoveryStrategy{
		Type:       RecoveryTypeRollback,
		Conditions: make([]*WorkflowCondition, 0),
	}

	template.Recovery.Strategies = append(template.Recovery.Strategies, rollbackStrategy)
}

func (iwb *DefaultIntelligentWorkflowBuilder) addValidationSteps(template *WorkflowTemplate) {
	if template == nil {
		return
	}

	validationStep := &WorkflowStep{
		ID:   "pre-execution-validation",
		Name: "Validate Pre-conditions",
		Type: StepTypeAction,
		Action: &StepAction{
			Type: "validate",
			Parameters: map[string]interface{}{
				"check_resources":   true,
				"check_permissions": true,
			},
		},
		Timeout: 1 * time.Minute,
	}

	// Insert validation step at the beginning
	template.Steps = append([]*WorkflowStep{validationStep}, template.Steps...)
}

func (iwb *DefaultIntelligentWorkflowBuilder) reduceParallelism(template *WorkflowTemplate) {
	if template == nil {
		return
	}

	for _, step := range template.Steps {
		if step.Metadata == nil {
			step.Metadata = make(map[string]interface{})
		}
		step.Metadata["parallel"] = false
		step.Metadata["max_concurrent"] = 1
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyResourceOptimizationToStep(step *WorkflowStep, recommendation *OptimizationSuggestion) {
	if step.Action == nil {
		return
	}

	if step.Action.Parameters == nil {
		step.Action.Parameters = make(map[string]interface{})
	}

	// Apply resource parameters from recommendation
	for key, value := range recommendation.Parameters {
		if key == "cpu_limit" || key == "memory_limit" {
			step.Action.Parameters[key] = value
		}
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) applyTimeoutOptimizationToStep(step *WorkflowStep, recommendation *OptimizationSuggestion) {
	if timeoutReduction, ok := recommendation.Parameters["timeout_reduction"].(string); ok {
		if timeoutReduction == "20%" {
			step.Timeout = time.Duration(float64(step.Timeout) * 0.8)
		}
	}

	if parallel, ok := recommendation.Parameters["parallel_execution"].(bool); ok && parallel {
		if step.Metadata == nil {
			step.Metadata = make(map[string]interface{})
		}
		step.Metadata["parallel"] = true
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) getResourceNameFromPattern(pattern *WorkflowPattern) string {
	// Extract resource name from first step if available
	if len(pattern.Steps) > 0 && pattern.Steps[0].Action != nil && pattern.Steps[0].Action.Target != nil {
		return pattern.Steps[0].Action.Target.Name
	}
	return "default"
}

func (iwb *DefaultIntelligentWorkflowBuilder) getParametersFromPattern(pattern *WorkflowPattern) map[string]interface{} {
	params := make(map[string]interface{})

	if len(pattern.Steps) > 0 && pattern.Steps[0].Action != nil {
		for k, v := range pattern.Steps[0].Action.Parameters {
			params[k] = v
		}
	}

	return params
}

func (iwb *DefaultIntelligentWorkflowBuilder) getContextFromPattern(pattern *WorkflowPattern) map[string]interface{} {
	context := make(map[string]interface{})

	context["pattern_type"] = pattern.Type
	context["environments"] = pattern.Environments
	context["resource_types"] = pattern.ResourceTypes

	return context
}

func (iwb *DefaultIntelligentWorkflowBuilder) getPreConditionsFromPattern(pattern *WorkflowPattern) map[string]interface{} {
	preConditions := make(map[string]interface{})

	for _, condition := range pattern.Conditions {
		if condition.Type == "expression" {
			preConditions[condition.ID] = condition.Expression
		}
	}

	return preConditions
}

func (iwb *DefaultIntelligentWorkflowBuilder) getPostConditionsFromPattern(pattern *WorkflowPattern) map[string]interface{} {
	postConditions := make(map[string]interface{})

	// Add success criteria based on pattern metadata
	postConditions["success_rate_threshold"] = pattern.SuccessRate
	postConditions["confidence_threshold"] = pattern.Confidence

	return postConditions
}

// Helper methods for logic optimization
func (iwb *DefaultIntelligentWorkflowBuilder) removeRedundantSteps(template *WorkflowTemplate) {
	if len(template.Steps) <= 1 {
		return
	}

	filteredSteps := make([]*WorkflowStep, 0, len(template.Steps))
	seen := make(map[string]bool)

	for _, step := range template.Steps {
		stepKey := iwb.generateStepKey(step)
		if !seen[stepKey] {
			seen[stepKey] = true
			filteredSteps = append(filteredSteps, step)
		}
	}

	template.Steps = filteredSteps
}

func (iwb *DefaultIntelligentWorkflowBuilder) mergeSimilarSteps(template *WorkflowTemplate) {
	// Group similar steps and merge them
	stepGroups := make(map[string][]*WorkflowStep)

	for _, step := range template.Steps {
		groupKey := iwb.generateStepGroupKey(step)
		stepGroups[groupKey] = append(stepGroups[groupKey], step)
	}

	mergedSteps := make([]*WorkflowStep, 0)
	for _, group := range stepGroups {
		if len(group) > 1 {
			mergedStep := iwb.mergeSteps(group)
			mergedSteps = append(mergedSteps, mergedStep)
		} else {
			mergedSteps = append(mergedSteps, group[0])
		}
	}

	template.Steps = mergedSteps
}

func (iwb *DefaultIntelligentWorkflowBuilder) optimizeConditions(template *WorkflowTemplate) {
	for _, condition := range template.Conditions {
		// Simplify expressions
		condition.Expression = iwb.simplifyExpression(condition.Expression)
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) enableParallelExecution(template *WorkflowTemplate) {
	// Analyze dependencies and enable parallel execution where possible
	for i, step := range template.Steps {
		if len(step.Dependencies) == 0 && i > 0 {
			// Check if this step can run in parallel with previous step
			if iwb.canRunInParallel(step, template.Steps[i-1]) {
				// Note: Parallel field needs to be added to WorkflowStep type
				// For now, we'll add it to metadata
				if step.Metadata == nil {
					step.Metadata = make(map[string]interface{})
				}
				step.Metadata["parallel"] = true
			}
		}
	}
}

func (iwb *DefaultIntelligentWorkflowBuilder) generateStepKey(step *WorkflowStep) string {
	if step.Action != nil {
		return fmt.Sprintf("%s-%s", step.Action.Type, step.Name)
	}
	return step.Name
}

func (iwb *DefaultIntelligentWorkflowBuilder) generateStepGroupKey(step *WorkflowStep) string {
	if step.Action != nil {
		return step.Action.Type
	}
	return string(step.Type)
}

func (iwb *DefaultIntelligentWorkflowBuilder) mergeSteps(steps []*WorkflowStep) *WorkflowStep {
	if len(steps) == 0 {
		return nil
	}

	merged := steps[0] // Use first step as base
	merged.Name = fmt.Sprintf("Merged-%s", merged.Name)

	// Combine parameters from all steps
	if merged.Action != nil {
		for i := 1; i < len(steps); i++ {
			if steps[i].Action != nil {
				for k, v := range steps[i].Action.Parameters {
					merged.Action.Parameters[k] = v
				}
			}
		}
	}

	return merged
}

func (iwb *DefaultIntelligentWorkflowBuilder) simplifyExpression(expression string) string {
	// Simple expression optimization
	expression = strings.ReplaceAll(expression, " == true", "")
	expression = strings.ReplaceAll(expression, " != false", "")
	return expression
}

func (iwb *DefaultIntelligentWorkflowBuilder) canRunInParallel(step1, step2 *WorkflowStep) bool {
	// Check if steps can run in parallel (no resource conflicts)
	if step1.Action != nil && step2.Action != nil {
		// Same resource type but different targets can often run in parallel
		if step1.Action.Target != nil && step2.Action.Target != nil {
			return step1.Action.Target.Name != step2.Action.Target.Name
		}
	}
	return false
}

// createPatternFromExecutions creates a workflow pattern from successful executions
func (iwb *DefaultIntelligentWorkflowBuilder) createPatternFromExecutions(ctx context.Context, executions []*WorkflowExecution) (*WorkflowPattern, error) {
	iwb.log.WithContext(ctx).WithField("execution_count", len(executions)).Debug("Creating pattern from executions")

	if len(executions) == 0 {
		return nil, fmt.Errorf("no executions provided")
	}

	// Use first execution as template
	firstExecution := executions[0]

	// Calculate aggregated metrics
	totalDuration := time.Duration(0)
	successCount := 0

	for _, execution := range executions {
		totalDuration += execution.Duration
		if execution.Status == ExecutionStatusCompleted {
			successCount++
		}
	}

	avgDuration := totalDuration / time.Duration(len(executions))
	successRate := float64(successCount) / float64(len(executions))

	// Extract action type and resource info from execution metadata
	actionType := "unknown"
	namespace := "default"
	resourceType := "deployment"

	if firstExecution.Metadata != nil {
		if at, ok := firstExecution.Metadata["action_type"].(string); ok {
			actionType = at
		}
		if ns, ok := firstExecution.Metadata["namespace"].(string); ok {
			namespace = ns
		}
		if rt, ok := firstExecution.Metadata["resource_type"].(string); ok {
			resourceType = rt
		}
	}

	// Create pattern from execution data
	pattern := &WorkflowPattern{
		ID:             uuid.New().String(),
		Name:           fmt.Sprintf("Pattern-From-Executions-%s", actionType),
		Type:           "execution_pattern",
		Steps:          make([]*WorkflowStep, 0),
		Conditions:     make([]*ActionCondition, 0),
		SuccessRate:    successRate,
		ExecutionCount: len(executions),
		AverageTime:    avgDuration,
		Environments:   []string{namespace},
		ResourceTypes:  []string{resourceType},
		Confidence:     iwb.calculatePatternConfidenceFromExecutions(executions),
		LastUsed:       firstExecution.StartTime,
		CreatedAt:      time.Now(),
		UpdatedAt:      time.Now(),
	}

	// Create steps from execution steps if available
	if len(firstExecution.Steps) > 0 {
		for _, stepExec := range firstExecution.Steps {
			step := &WorkflowStep{
				ID:       uuid.New().String(),
				Name:     fmt.Sprintf("Step-%d", len(pattern.Steps)+1), // Generate name since ID field doesn't exist
				Type:     StepTypeAction,
				Timeout:  iwb.config.DefaultStepTimeout,
				Metadata: make(map[string]interface{}),
			}

			// Extract action information if available
			if stepExec.Metadata != nil {
				if actionType, ok := stepExec.Metadata["action_type"].(string); ok {
					step.Action = &StepAction{
						Type:       actionType,
						Parameters: make(map[string]interface{}),
					}

					if params, ok := stepExec.Metadata["parameters"].(map[string]interface{}); ok {
						step.Action.Parameters = params
					}
				}
			}

			pattern.Steps = append(pattern.Steps, step)
		}
	}

	return pattern, nil
}

// calculatePatternConfidenceFromExecutions calculates confidence based on execution data
func (iwb *DefaultIntelligentWorkflowBuilder) calculatePatternConfidenceFromExecutions(executions []*WorkflowExecution) float64 {
	if len(executions) == 0 {
		return 0.0
	}

	successCount := 0
	for _, execution := range executions {
		if execution.Status == ExecutionStatusCompleted {
			successCount++
		}
	}

	successRate := float64(successCount) / float64(len(executions))

	// Base confidence on success rate and execution count
	confidence := successRate * 0.8

	// Boost confidence for more executions
	if len(executions) >= 10 {
		confidence += 0.15
	} else if len(executions) >= 5 {
		confidence += 0.1
	}

	return math.Min(confidence, 1.0)
}
