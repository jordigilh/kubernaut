---
alwaysApply: true
---

# AI Assistant Behavioral Constraints for TDD Enforcement

## ü§ñ **MANDATORY AI ASSISTANT PROTOCOL**

### **REAL-TIME PREVENTION SYSTEM**

**AI must execute validation BEFORE generating any code, not after:**

#### **IMMEDIATE VALIDATION REQUIREMENTS**
1. **BEFORE referencing any struct field**: Validate field exists in type definition
2. **BEFORE creating test code**: Search for existing implementations
3. **BEFORE using testutil types**: Confirm they exist in codebase
4. **BEFORE generating business logic**: Verify main application integration
5. **BEFORE fixing undefined symbols**: Execute comprehensive build error analysis (CHECKPOINT D)

### **CRITICAL DECISION CHECKPOINTS**

**These are BLOCKING checkpoints - AI must STOP and validate:**

#### **CHECKPOINT A: Type Reference Validation**
**TRIGGER**: About to reference any struct field (e.g., `object.FieldName`)
**MANDATORY ACTION**:
```bash
# HALT: Validate type definition exists
grep -r "type.*ObjectType.*struct" pkg/ --include="*.go"
# RULE: If field not found in type definition, STOP and fix type definition first
```

#### **CHECKPOINT B: Test Creation Validation**
**TRIGGER**: About to create test file with business logic references
**MANDATORY ACTION**:
```bash
# HALT: Search for existing implementations
codebase_search "existing [ComponentType] implementations"
# RULE: If creating new types, must follow TDD RED-GREEN-REFACTOR sequence
```

#### **CHECKPOINT C: Business Integration Validation**
**TRIGGER**: Creating new business types or interfaces
**MANDATORY ACTION**:
```bash
# HALT: Check main application integration
grep -r "NewComponentType" cmd/ --include="*.go"
# RULE: If ZERO results, integration is required before proceeding
```

#### **CHECKPOINT D: Build Error Investigation**
**TRIGGER**: User reports build errors or undefined symbols
**MANDATORY ACTION**:
```bash
# HALT: Execute comprehensive symbol analysis
codebase_search "[undefined_symbol] usage patterns and dependencies"
grep -r "[undefined_symbol]" . --include="*.go" -n
# RULE: NO implementation without user approval after complete analysis
```
**REQUIRED REPORT FORMAT**:
```
üö® UNDEFINED SYMBOL ANALYSIS:
Symbol: [undefined_symbol]
References found: [N files]
Dependent infrastructure: [list missing types/functions]
Scope: [minimal/medium/extensive]

OPTIONS:
A) Implement complete infrastructure ([X] files affected)
B) Create minimal stub (may break [Y] files)  
C) Alternative approach: [suggest]

Which approach should I take?
```

### **MANDATORY TOOL USAGE PATTERN**

**AI must ALWAYS use tools in this sequence for any code generation:**

#### **Step 1: Discovery (REQUIRED)**
```
codebase_search "existing [ComponentType] implementations"
# OR
grep -r "[TypeName]" pkg/ --include="*.go"
```

#### **Step 2: Type Validation (REQUIRED)**
```
read_file pkg/path/to/type_definition.go
# Verify all referenced fields exist in struct definitions
```

#### **Step 3: Integration Check (REQUIRED)**
```
grep -r "[NewType]" cmd/ --include="*.go"
# Verify business code is used in main applications
```

### **FORBIDDEN AI ACTIONS**

#### **Immediate Failure Conditions - NEVER DO THESE:**
1. **NEVER** reference struct fields without first reading the type definition file
2. **NEVER** assume testutil types exist - always validate with `read_file` or `grep`
3. **NEVER** create test code without first using `codebase_search` for existing implementations
4. **NEVER** generate business types without confirming main application usage
5. **NEVER** proceed if any validation step fails
6. **NEVER** implement missing types without full dependency analysis (CHECKPOINT D)

### **MANDATORY VALIDATION SEQUENCE**

**AI must execute these steps IN ORDER before any code generation:**

#### **Validation Step 1: Existence Check**
```bash
# For struct field references (e.g., node.Name)
read_file pkg/workflow/engine/workflow_simulator.go
# RULE: Verify field exists in struct definition before referencing

# For testutil types (e.g., testutil.TDDConversionHelper)
grep -r "TDDConversionHelper" pkg/testutil/ --include="*.go"
# RULE: Confirm type exists before using
```

#### **Validation Step 2: Implementation Discovery**
```bash
# Before creating new test structures
codebase_search "existing WorkflowSimulator test patterns"
# RULE: Enhance existing patterns instead of creating new ones
```

#### **Validation Step 3: Integration Verification**
```bash
# For new business types
grep -r "NewBusinessType" cmd/ --include="*.go"
# RULE: Business code must be integrated in main applications
```

#### **Validation Step 4: Build Error Analysis (CHECKPOINT D)**
```bash
# For any undefined symbol error
codebase_search "[undefined_symbol] usage patterns across codebase"
grep -r "[undefined_symbol]" . --include="*.go" -n
# Find constructor patterns
grep -r "New[SymbolName]\|Create[SymbolName]" . --include="*.go"
# Test compilation impact
go build [dependent_file.go] 2>&1
# RULE: Present complete analysis before implementation
```

#### **MANDATORY DECISION GATES**

AI must answer YES to ALL questions before proceeding:

**For Type References:**
- ‚úÖ Have I read the actual type definition file?
- ‚úÖ Do all referenced fields exist in the struct?
- ‚úÖ Are there no empty struct{} definitions?

**For Test Creation:**
- ‚úÖ Have I searched for existing test patterns?
- ‚úÖ Am I following TDD RED-GREEN-REFACTOR sequence?
- ‚úÖ Do all testutil dependencies actually exist?

**For Business Code:**
- ‚úÖ Is this integrated into main applications?
- ‚úÖ Are all interfaces implemented by real code?
- ‚úÖ Have I verified the complete dependency chain?

**For Build Error Fixes (CHECKPOINT D):**
- ‚úÖ Have I analyzed ALL references to the undefined symbol?
- ‚úÖ Have I mapped the complete dependency chain?
- ‚úÖ Have I presented options A/B/C to the user?
- ‚úÖ Have I received explicit approval before implementing?

### **TOOL CALL ENFORCEMENT**

#### **BLOCKING TOOL REQUIREMENTS**

**AI MUST use these tool calls BEFORE any code generation. No exceptions:**

**For ANY struct field reference (object.FieldName):**
```xml
<function_calls>
<invoke name="read_file">
<parameter name="target_file">pkg/workflow/engine/types.go</parameter>
</invoke>
</function_calls>
```

**For ANY undefined symbol error:**
```xml
<function_calls>
<invoke name="codebase_search">
<parameter name="query">[symbol_name] usage patterns and dependencies</parameter>
<parameter name="target_directories">[]</parameter>
</invoke>
</function_calls>
```

#### **Error Prevention Protocol**
1. **ALWAYS** run `codebase_search` before assuming types exist
2. **ALWAYS** check type definitions before referencing fields
3. **ALWAYS** validate testutil dependencies before use
4. **ALWAYS** confirm main application integration
5. **ALWAYS** execute CHECKPOINT D for undefined symbols

#### **Recovery Actions**
When validation fails:
1. **STOP** code generation immediately
2. **REPORT** specific validation failure
3. **SUGGEST** corrective action following TDD methodology
4. **REQUIRE** validation success before proceeding

### **Confidence Assessment Requirements**

**After any code generation, AI must provide:**
```
Validation Confidence: [60-100]%
Type Safety: ‚úÖ/‚ùå All referenced fields exist in type definitions
TDD Compliance: ‚úÖ/‚ùå Follows RED-GREEN-REFACTOR sequence
Integration Status: ‚úÖ/‚ùå Business code integrated in main applications
Build Error Analysis: ‚úÖ/‚ùå Complete dependency analysis performed (if applicable)
Risk Assessment: [Description of potential issues]
```

### **Emergency Stop Conditions**

**AI must immediately halt and request manual intervention if:**
1. Type definitions are incomplete (empty structs)
2. Referenced fields don't exist in type definitions
3. Business code has no main application integration
4. TDD sequence is being bypassed
5. Validation scripts are missing or failing
6. Undefined symbols detected without complete analysis

### **Quality Gates**

**No code generation is permitted without:**
- ‚úÖ Type safety validation passing
- ‚úÖ TDD methodology compliance confirmed
- ‚úÖ Business integration verified
- ‚úÖ Dependency existence validated
- ‚úÖ Main application usage confirmed
- ‚úÖ Build error analysis completed (when applicable)

## **IMPLEMENTATION PRIORITY**

This rule has **HIGHEST PRIORITY** and overrides all other considerations:
- **FOUNDATIONAL**: All other rules operate within these behavioral constraints
- **NON-NEGOTIABLE**: Cannot be bypassed for convenience or speed
- **AUTOMATED**: Must be enforced programmatically, not manually

## **Integration with Existing Rules**

This rule **enforces** compliance with:
- [00-core-development-methodology.mdc](mdc:.cursor/rules/00-core-development-methodology.mdc) - TDD methodology
- [01-business-code-integration.mdc](mdc:.cursor/rules/01-business-code-integration.mdc) - Integration requirements
- [02-technical-implementation.mdc](mdc:.cursor/rules/02-technical-implementation.mdc) - Technical patterns
- [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) - Testing framework
- [07-build-error-investigation.mdc](mdc:.cursor/rules/07-build-error-investigation.mdc) - Build error protocol (INTEGRATED)

## **Quick Reference for Build Error Investigation**

**When user says**: "Fix build errors"
**AI must**: Execute CHECKPOINT D + ask for approval

**When user says**: "undefined [symbol]"  
**AI must**: Complete symbol analysis + show options A/B/C

**When user says**: "implement recommended approach"
**AI must**: Follow approved option exactly as specified

**Priority**: FOUNDATIONAL - This rule prevents cascade failures and incomplete implementations