/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platform

import (
	"testing"
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes/fake"

	"github.com/jordigilh/kubernaut/internal/actionhistory"
	"github.com/jordigilh/kubernaut/internal/config"
	"github.com/jordigilh/kubernaut/pkg/platform/executor"
	"github.com/jordigilh/kubernaut/pkg/platform/testutil"
	"github.com/jordigilh/kubernaut/pkg/shared/types"
	"github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to platform_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Safety Framework - Business Requirements Testing", func() {
	var (
		ctx               context.Context
		safetyValidator   *MockSafetyValidator
		actionExecutor    executor.Executor
		fakeK8sClient     *fake.Clientset
		mockK8sClient     *mocks.MockK8sClient
		mockActionHistory *mocks.MockActionHistoryRepository
		logger            *logrus.Logger
		testSuite         *testutil.PlatformTestSuiteComponents
		executorConfig    config.ActionsConfig
	)

	BeforeEach(func() {
		testSuite = testutil.ExecutorTestSuite("SafetyFrameworkTests")
		ctx = testSuite.Context
		logger = testSuite.Logger
		fakeK8sClient = testSuite.FakeClientset

		executorConfig = config.ActionsConfig{
			DryRun:         false,
			MaxConcurrent:  3,
			CooldownPeriod: 5 * time.Minute,
		}

		mockK8sClient = mocks.NewMockK8sClient(fakeK8sClient)
		mockActionHistory = mocks.NewMockActionHistoryRepository()

		var err error
		actionExecutor, err = executor.NewExecutor(mockK8sClient, executorConfig, mockActionHistory, logger)
		Expect(err).ToNot(HaveOccurred())

		// Initialize safety validator
		safetyValidator = NewMockSafetyValidator(logger)
	})

	// BR-SAFE-001: MUST validate cluster connectivity and access permissions
	Context("BR-SAFE-001: Pre-Execution Cluster Validation", func() {
		It("should validate cluster connectivity before action execution", func() {
			// Arrange: Create healthy cluster state
			node := &corev1.Node{
				ObjectMeta: metav1.ObjectMeta{
					Name: "test-node",
				},
				Status: corev1.NodeStatus{
					Conditions: []corev1.NodeCondition{
						{
							Type:   corev1.NodeReady,
							Status: corev1.ConditionTrue,
						},
					},
				},
			}
			_, err := fakeK8sClient.CoreV1().Nodes().Create(ctx, node, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			alert := types.Alert{
				Name:      "HighLoad",
				Severity:  "warning",
				Namespace: "production",
				Resource:  "web-app",
			}

			// Act: Validate cluster connectivity
			validationResult := safetyValidator.ValidateClusterAccess(ctx, alert.Namespace)

			// **Business Requirement BR-SAFE-001**: Validate cluster connectivity
			Expect(validationResult.IsValid).To(BeTrue(),
				"BR-SAFE-001: Should successfully validate cluster connectivity")
			Expect(validationResult.ConnectivityCheck).To(BeTrue(),
				"BR-SAFE-001: Cluster should be accessible for safe operations")
			Expect(validationResult.PermissionLevel).To(Equal("admin"),
				"BR-SAFE-001: Should have appropriate permissions for action execution")
		})

		It("should reject actions when cluster connectivity fails", func() {
			// Arrange: Simulate cluster connectivity issues
			alert := types.Alert{
				Name:     "NodeIssue",
				Severity: "critical",
				Resource: "unreachable-node",
			}

			// Simulate connectivity failure
			mockK8sClient.SetClusterConnectivityResult(false, fmt.Errorf("cluster unreachable"))
			safetyValidator.SetClusterAccessResult(&ClusterValidationResult{
				IsValid:           false,
				ConnectivityCheck: false,
				PermissionLevel:   "none",
				ErrorMessage:      "cluster unreachable",
				RiskLevel:         "CRITICAL",
			})

			// Act: Attempt validation with failed connectivity
			validationResult := safetyValidator.ValidateClusterAccess(ctx, alert.Namespace)

			// **Business Requirement BR-SAFE-001**: Validate connectivity failure handling
			Expect(validationResult.IsValid).To(BeFalse(),
				"BR-SAFE-001: Should reject actions when cluster is unreachable")
			Expect(validationResult.ErrorMessage).To(ContainSubstring("cluster unreachable"),
				"BR-SAFE-001: Should provide specific connectivity error details")
			Expect(validationResult.RiskLevel).To(Equal("CRITICAL"),
				"BR-SAFE-001: Connectivity failures should be classified as critical risk")
		})
	})

	// BR-SAFE-002: MUST verify resource existence and current state
	Context("BR-SAFE-002: Resource State Validation", func() {
		It("should validate resource existence before executing actions", func() {
			// Arrange: Create deployment for validation
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "validation-test-deployment",
					Namespace: "production",
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: safetyInt32Ptr(2),
				},
				Status: appsv1.DeploymentStatus{
					ReadyReplicas:     2,
					AvailableReplicas: 2,
					Conditions: []appsv1.DeploymentCondition{
						{
							Type:   appsv1.DeploymentAvailable,
							Status: corev1.ConditionTrue,
						},
					},
				},
			}
			_, err := fakeK8sClient.AppsV1().Deployments("production").Create(ctx, deployment, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			alert := types.Alert{
				Name:      "LoadIncrease",
				Namespace: "production",
				Resource:  "validation-test-deployment",
			}

			// Act: Validate resource existence and state
			validationResult := safetyValidator.ValidateResourceState(ctx, alert.Namespace, alert.Resource, "Deployment")

			// **Business Requirement BR-SAFE-002**: Validate resource state
			Expect(validationResult.IsValid).To(BeTrue(),
				"BR-SAFE-002: Should successfully validate existing resource")
			Expect(validationResult.ResourceExists).To(BeTrue(),
				"BR-SAFE-002: Should confirm resource existence")
			Expect(validationResult.CurrentState).To(Equal("Available"),
				"BR-SAFE-002: Should accurately report current resource state")
			Expect(validationResult.HealthStatus).To(Equal("Healthy"),
				"BR-SAFE-002: Should validate resource health before action execution")
		})

		It("should prevent actions on non-existent resources", func() {
			// Arrange: Reference non-existent resource
			alert := types.Alert{
				Name:      "PodCrash",
				Namespace: "production",
				Resource:  "non-existent-pod",
			}

			// Act: Validate non-existent resource
			validationResult := safetyValidator.ValidateResourceState(ctx, alert.Namespace, alert.Resource, "Pod")

			// **Business Requirement BR-SAFE-002**: Validate non-existence handling
			Expect(validationResult.IsValid).To(BeFalse(),
				"BR-SAFE-002: Should reject actions on non-existent resources")
			Expect(validationResult.ResourceExists).To(BeFalse(),
				"BR-SAFE-002: Should accurately detect resource non-existence")
			Expect(validationResult.ErrorMessage).To(ContainSubstring("resource not found"),
				"BR-SAFE-002: Should provide clear error for missing resources")
		})
	})

	// BR-SAFE-006: MUST assess action risk levels (Low, Medium, High, Critical)
	Context("BR-SAFE-006: Risk Assessment Framework", func() {
		It("should assess risk levels for different action types", func() {
			// Test different actions with varying risk levels
			riskTestCases := []struct {
				actionName   string
				expectedRisk string
				riskFactors  []string
			}{
				{
					actionName:   "scale_deployment",
					expectedRisk: "LOW",
					riskFactors:  []string{"reversible", "gradual_impact"},
				},
				{
					actionName:   "restart_pod",
					expectedRisk: "MEDIUM",
					riskFactors:  []string{"service_interruption", "potential_data_loss"},
				},
				{
					actionName:   "drain_node",
					expectedRisk: "HIGH",
					riskFactors:  []string{"multiple_workloads_affected", "capacity_reduction"},
				},
				{
					actionName:   "quarantine_pod",
					expectedRisk: "CRITICAL",
					riskFactors:  []string{"security_isolation", "immediate_service_impact"},
				},
			}

			for _, testCase := range riskTestCases {
				// Act: Assess risk for each action type
				riskAssessment := safetyValidator.AssessActionRisk(testCase.actionName, "production", map[string]interface{}{})

				// **Business Requirement BR-SAFE-006**: Validate risk assessment
				Expect(riskAssessment.RiskLevel).To(Equal(testCase.expectedRisk),
					"BR-SAFE-006: Action %s should have risk level %s", testCase.actionName, testCase.expectedRisk)

				Expect(riskAssessment.RiskFactors).To(ContainElements(testCase.riskFactors),
					"BR-SAFE-006: Should identify specific risk factors for %s", testCase.actionName)

				// Validate risk score is appropriate for level
				switch testCase.expectedRisk {
				case "LOW":
					Expect(riskAssessment.RiskScore).To(BeNumerically("<=", 3.0),
						"BR-SAFE-006: Low risk actions should have score ≤ 3.0")
				case "MEDIUM":
					Expect(riskAssessment.RiskScore).To(BeNumerically(">=", 3.0),
						"BR-SAFE-006: Medium risk actions should have score ≥ 3.0")
					Expect(riskAssessment.RiskScore).To(BeNumerically("<=", 6.0),
						"BR-SAFE-006: Medium risk actions should have score ≤ 6.0")
				case "HIGH":
					Expect(riskAssessment.RiskScore).To(BeNumerically(">=", 6.0),
						"BR-SAFE-006: High risk actions should have score ≥ 6.0")
					Expect(riskAssessment.RiskScore).To(BeNumerically("<=", 9.0),
						"BR-SAFE-006: High risk actions should have score ≤ 9.0")
				case "CRITICAL":
					Expect(riskAssessment.RiskScore).To(BeNumerically(">=", 9.0),
						"BR-SAFE-006: Critical risk actions should have score ≥ 9.0")
				}
			}
		})

		It("should implement risk mitigation strategies for high-risk actions", func() {
			// Arrange: High-risk action requiring mitigation
			action := &types.ActionRecommendation{
				Action: "drain_node",
				Parameters: map[string]interface{}{
					"ignore_daemonsets": false,
					"timeout":           600.0,
				},
				Confidence: 0.87,
			}

			alert := types.Alert{
				Name:     "NodeMaintenanceRequired",
				Severity: "warning",
				Resource: "production-node-1",
			}

			// Act: Assess risk and apply mitigation
			riskAssessment := safetyValidator.AssessActionRisk(action.Action, "production", action.Parameters)
			mitigationPlan := safetyValidator.GenerateMitigationPlan(riskAssessment)

			// **Business Requirement BR-SAFE-007**: Validate risk mitigation
			Expect(riskAssessment.RiskLevel).To(Equal("HIGH"),
				"BR-SAFE-007: Node drain should be classified as high risk")
			Expect(mitigationPlan.RequiredApprovals).To(BeNumerically(">=", 1),
				"BR-SAFE-007: High-risk actions should require approval")
			Expect(mitigationPlan.SafetyMeasures).To(ContainElement("pre_validation_required"),
				"BR-SAFE-007: Should implement pre-validation safety measure")
			Expect(mitigationPlan.RollbackPlan).ToNot(BeEmpty(),
				"BR-SAFE-007: Should provide rollback plan for high-risk actions")

			// Use alert to avoid unused variable warning
			Expect(alert.Name).To(Equal("NodeMaintenanceRequired"))
		})
	})

	// BR-SAFE-011: MUST support automatic rollback for failed actions
	Context("BR-SAFE-011: Automatic Rollback Capabilities", func() {
		It("should execute automatic rollback when actions fail", func() {
			// Arrange: Create deployment for rollback testing
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "rollback-test-deployment",
					Namespace: "production",
					Annotations: map[string]string{
						"deployment.kubernetes.io/revision": "5",
					},
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: safetyInt32Ptr(3),
				},
			}
			_, err := fakeK8sClient.AppsV1().Deployments("production").Create(ctx, deployment, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			action := &types.ActionRecommendation{
				Action: "scale_deployment",
				Parameters: map[string]interface{}{
					"replicas": 10.0, // Potentially problematic scale-up
				},
				Confidence: 0.78,
			}

			alert := types.Alert{
				Name:      "LoadSpike",
				Namespace: "production",
				Resource:  "rollback-test-deployment",
			}

			// Setup mock to simulate scaling failure requiring rollback
			mockK8sClient.SetScaleDeploymentResult(false, fmt.Errorf("insufficient cluster capacity"))
			mockK8sClient.SetRollbackValidationResult(true, nil)

			// Act: Execute action with automatic rollback enabled
			// Note: AutoRollback would be part of executor configuration in real implementation
			actionTrace := createSafetyTestActionTrace()
			err = actionExecutor.Execute(ctx, action, alert, actionTrace)

			// **Business Requirement BR-SAFE-011**: Validate automatic rollback
			Expect(err).To(HaveOccurred(), "Action should fail due to insufficient capacity")

			// Verify rollback was triggered
			rollbackCalls := mockK8sClient.GetRollbackDeploymentCalls()
			Expect(len(rollbackCalls)).To(Equal(1),
				"BR-SAFE-011: Should automatically trigger rollback on action failure")

			rollbackCall := rollbackCalls[0]
			Expect(rollbackCall.Namespace).To(Equal("production"))
			Expect(rollbackCall.Deployment).To(Equal("rollback-test-deployment"))
			Expect(rollbackCall.Reason).To(ContainSubstring("automatic_rollback"),
				"BR-SAFE-011: Should clearly identify automatic rollback operations")
		})

		It("should maintain rollback state information for all actions", func() {
			// Arrange: Create stateful deployment
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "stateful-deployment",
					Namespace: "production",
					Annotations: map[string]string{
						"deployment.kubernetes.io/revision": "3",
					},
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: safetyInt32Ptr(2),
				},
			}
			_, err := fakeK8sClient.AppsV1().Deployments("production").Create(ctx, deployment, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			action := &types.ActionRecommendation{
				Action: "scale_deployment",
				Parameters: map[string]interface{}{
					"replicas": 4.0,
				},
				Confidence: 0.91,
			}

			alert := types.Alert{
				Name:      "TrafficIncrease",
				Namespace: "production",
				Resource:  "stateful-deployment",
			}

			// Act: Execute action and capture rollback state
			rollbackState := safetyValidator.CaptureRollbackState(ctx, alert.Namespace, alert.Resource, action.Action)

			// **Business Requirement BR-SAFE-012**: Validate rollback state capture
			Expect(rollbackState.ActionID).ToNot(BeEmpty(),
				"BR-SAFE-012: Should generate unique action ID for rollback tracking")
			Expect(rollbackState.PreviousState).To(HaveKey("replicas"),
				"BR-SAFE-012: Should capture previous replica count")
			Expect(rollbackState.PreviousState["replicas"]).To(Equal(2),
				"BR-SAFE-012: Should accurately capture previous state values")
			Expect(rollbackState.Timestamp).To(BeTemporally("~", time.Now(), 5*time.Second),
				"BR-SAFE-012: Should record accurate timestamp for rollback reference")
			Expect(rollbackState.RollbackCapability).To(BeTrue(),
				"BR-SAFE-012: Should confirm rollback capability for reversible actions")
		})
	})

	// BR-SAFE-013: MUST implement rollback validation and verification
	Context("BR-SAFE-013: Rollback Validation Framework", func() {
		It("should validate rollback operations before execution", func() {
			// Arrange: Create deployment with rollback history
			deployment := &appsv1.Deployment{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "rollback-validation-deployment",
					Namespace: "production",
					Annotations: map[string]string{
						"deployment.kubernetes.io/revision": "4",
					},
				},
				Spec: appsv1.DeploymentSpec{
					Replicas: safetyInt32Ptr(5),
				},
			}
			_, err := fakeK8sClient.AppsV1().Deployments("production").Create(ctx, deployment, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			rollbackRequest := RollbackRequest{
				Namespace:      "production",
				ResourceName:   "rollback-validation-deployment",
				ResourceType:   "Deployment",
				TargetRevision: 3,
				Reason:         "Performance regression in current version",
			}

			// Act: Validate rollback request
			rollbackValidation := safetyValidator.ValidateRollbackRequest(ctx, rollbackRequest)

			// **Business Requirement BR-SAFE-013**: Validate rollback validation
			Expect(rollbackValidation.IsValid).To(BeTrue(),
				"BR-SAFE-013: Should successfully validate legitimate rollback request")
			Expect(rollbackValidation.TargetRevisionExists).To(BeTrue(),
				"BR-SAFE-013: Should confirm target revision exists")
			Expect(rollbackValidation.RollbackImpactAssessment.AffectedReplicas).To(Equal(5),
				"BR-SAFE-013: Should assess impact on current replica count")
			Expect(rollbackValidation.EstimatedDowntime).To(BeNumerically("<=", 30*time.Second),
				"BR-SAFE-013: Should estimate minimal downtime for rollback")
		})

		It("should prevent invalid rollback operations", func() {
			// Arrange: Invalid rollback scenario
			rollbackRequest := RollbackRequest{
				Namespace:      "production",
				ResourceName:   "non-existent-deployment",
				ResourceType:   "Deployment",
				TargetRevision: 1,
				Reason:         "Test invalid rollback",
			}

			// Act: Validate invalid rollback request
			rollbackValidation := safetyValidator.ValidateRollbackRequest(ctx, rollbackRequest)

			// **Business Requirement BR-SAFE-013**: Validate invalid rollback prevention
			Expect(rollbackValidation.IsValid).To(BeFalse(),
				"BR-SAFE-013: Should reject rollback for non-existent resources")
			Expect(rollbackValidation.ValidationErrors).To(ContainElement("resource_not_found"),
				"BR-SAFE-013: Should identify specific validation errors")
			Expect(rollbackValidation.RiskLevel).To(Equal("BLOCKED"),
				"BR-SAFE-013: Should block risky or invalid rollback operations")
		})
	})

	// BR-SAFE-016: MUST implement policy-based action filtering
	Context("BR-SAFE-016: Policy-Based Action Filtering", func() {
		It("should enforce policy-based action filtering", func() {
			// Arrange: Define production environment policies
			policies := []SafetyPolicy{
				{
					Name:        "production_scaling_limit",
					Environment: "production",
					ActionType:  "scale_deployment",
					Rules: map[string]interface{}{
						"max_replicas":     10,
						"max_scale_factor": 3.0,
						"require_approval": true,
					},
				},
				{
					Name:        "production_node_operations",
					Environment: "production",
					ActionType:  "drain_node",
					Rules: map[string]interface{}{
						"require_maintenance_window": true,
						"min_healthy_nodes":          3,
						"approval_required":          true,
					},
				},
			}

			safetyValidator.LoadPolicies(policies)

			// Test allowed action within policy limits
			allowedAction := &types.ActionRecommendation{
				Action: "scale_deployment",
				Parameters: map[string]interface{}{
					"replicas": 8.0, // Within limit of 10
				},
				Confidence: 0.94,
			}

			// Act: Apply policy filtering
			policyResult := safetyValidator.ApplyPolicyFiltering("production", allowedAction)

			// **Business Requirement BR-SAFE-016**: Validate policy enforcement
			Expect(policyResult.Allowed).To(BeTrue(),
				"BR-SAFE-016: Should allow actions within policy limits")
			Expect(policyResult.RequiredApprovals).To(Equal(1),
				"BR-SAFE-016: Should require approval as specified by policy")
			Expect(policyResult.PolicyViolations).To(BeEmpty(),
				"BR-SAFE-016: Should not report violations for compliant actions")

			// Test blocked action exceeding policy limits
			blockedAction := &types.ActionRecommendation{
				Action: "scale_deployment",
				Parameters: map[string]interface{}{
					"replicas": 15.0, // Exceeds limit of 10
				},
				Confidence: 0.89,
			}

			blockedResult := safetyValidator.ApplyPolicyFiltering("production", blockedAction)

			// Validate policy violation handling
			Expect(blockedResult.Allowed).To(BeFalse(),
				"BR-SAFE-016: Should block actions violating policy limits")
			Expect(blockedResult.PolicyViolations).To(ContainElement("max_replicas_exceeded"),
				"BR-SAFE-016: Should identify specific policy violations")
		})
	})

	// BR-SAFE-018: MUST maintain audit trails for all safety decisions
	Context("BR-SAFE-018: Safety Decision Audit Trail", func() {
		It("should maintain comprehensive audit trail for safety decisions", func() {
			// Arrange: Execute multiple safety-sensitive actions
			safetyDecisions := []struct {
				actionType string
				decision   string
				reason     string
			}{
				{"scale_deployment", "APPROVED", "Within policy limits"},
				{"drain_node", "REJECTED", "Insufficient healthy nodes"},
				{"rollback_deployment", "APPROVED_WITH_CONDITIONS", "Requires validation period"},
			}

			for _, testCase := range safetyDecisions {
				// Act: Record safety decision
				auditEntry := SafetyAuditEntry{
					Timestamp:     time.Now(),
					ActionType:    testCase.actionType,
					Decision:      testCase.decision,
					DecisionBy:    "safety_framework",
					Reason:        testCase.reason,
					Environment:   "production",
					RiskLevel:     "MEDIUM",
					PolicyApplied: "production_safety_policy",
				}

				safetyValidator.RecordSafetyDecision(auditEntry)
			}

			// Retrieve audit trail
			auditTrail := safetyValidator.GetSafetyAuditTrail(time.Now().Add(-1*time.Hour), time.Now())

			// **Business Requirement BR-SAFE-018**: Validate audit trail maintenance
			Expect(len(auditTrail)).To(BeNumerically(">=", len(safetyDecisions)),
				"BR-SAFE-018: Should maintain complete audit trail for all safety decisions")

			for _, entry := range auditTrail {
				Expect(entry.Timestamp).ToNot(BeZero(),
					"BR-SAFE-018: Should record accurate timestamps")
				Expect(entry.ActionType).ToNot(BeEmpty(),
					"BR-SAFE-018: Should record action type for all decisions")
				Expect(entry.Decision).To(MatchRegexp("APPROVED|REJECTED|APPROVED_WITH_CONDITIONS"),
					"BR-SAFE-018: Should record standardized decision outcomes")
				Expect(entry.Reason).ToNot(BeEmpty(),
					"BR-SAFE-018: Should provide justification for all safety decisions")
			}

			// Validate audit trail completeness for compliance
			approvedCount := 0
			rejectedCount := 0
			for _, entry := range auditTrail {
				switch entry.Decision {
				case "APPROVED", "APPROVED_WITH_CONDITIONS":
					approvedCount++
				case "REJECTED":
					rejectedCount++
				}
			}

			Expect(approvedCount+rejectedCount).To(Equal(len(auditTrail)),
				"BR-SAFE-018: All audit entries should have valid decision outcomes")
		})
	})
})

// Helper functions for safety framework testing
func createSafetyTestActionTrace() *actionhistory.ResourceActionTrace {
	return &actionhistory.ResourceActionTrace{
		ID:                 456,
		ActionID:           "safety-test-789",
		AlertName:          "SafetyTestAlert",
		ActionType:         "safety_test_action",
		ExecutionStatus:    "pending",
		ExecutionStartTime: nil,
		ExecutionEndTime:   nil,
	}
}

func safetyInt32Ptr(i int32) *int32 {
	return &i
}

// TestRunner bootstraps the Ginkgo test suite
func TestUsafetyUframework(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "UsafetyUframework Suite")
}
