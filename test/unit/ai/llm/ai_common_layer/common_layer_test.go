/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package ai_common_layer

import (
	"context"
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/ai/common"
	"github.com/jordigilh/kubernaut/pkg/shared/types"
	testconfig "github.com/jordigilh/kubernaut/pkg/testutil/config"
	"github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to common_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("AI Common Layer - Business Requirements Testing", func() {
	var (
		logger                     *logrus.Logger
		ctx                        context.Context
		mockAnalysisProvider       *mocks.MockAnalysisProvider
		mockRecommendationProvider *mocks.MockRecommendationProvider
		mockInvestigationProvider  *mocks.MockInvestigationProvider
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)
		ctx = context.Background()

		// Note: Factory methods for AI providers not yet available
		// TODO-MOCK-MIGRATION: Add CreateAnalysisProvider, CreateRecommendationProvider, CreateInvestigationProvider to factory
		mockAnalysisProvider = mocks.NewMockAnalysisProvider()
		mockRecommendationProvider = mocks.NewMockRecommendationProvider()
		mockInvestigationProvider = mocks.NewMockInvestigationProvider()
	})

	// BR-AI-001: MUST provide contextual analysis of Kubernetes alerts and system state
	Context("BR-AI-001: Contextual Analysis Provider", func() {
		It("should provide contextual analysis of Kubernetes alerts with confidence scoring", func() {
			// Arrange: Create analysis request for alert context
			request := &common.AnalysisRequest{
				AIRequest: &common.AIRequest{
					ID:        "analysis-001",
					CreatedAt: time.Now(),
					Context: map[string]interface{}{
						"namespace": "production",
						"cluster":   "main",
					},
				},
				Subject:      "HighCPUUsage",
				Data:         createAlertData("HighCPUUsage", "production"),
				AnalysisType: "diagnostic",
			}

			// Setup mock to return contextual analysis
			mockAnalysisProvider.SetAnalysisResult(&common.AnalysisResult{
				ID:         "analysis-001",
				Subject:    "HighCPUUsage",
				Summary:    "High CPU usage detected in production workload",
				Confidence: 0.87,
				Findings: []common.Finding{
					{
						Type:        "performance_degradation",
						Description: "CPU usage exceeds 80% threshold",
						Severity:    "high",
						Confidence:  0.85,
					},
				},
				ProcessingTime: 3 * time.Second,
				GeneratedAt:    time.Now(),
			})

			// Act: Perform contextual analysis
			result, err := mockAnalysisProvider.Analyze(ctx, request)

			// **Business Requirement BR-AI-001**: Validate contextual analysis capabilities
			Expect(err).ToNot(HaveOccurred(), "Should successfully analyze alert context")
			Expect(result.ID).To(Equal("analysis-001"), "Should maintain request correlation")
			Expect(result.Confidence).To(BeNumerically(">=", 0.8),
				"BR-AI-001: Contextual analysis should provide high confidence (≥80%)")
			Expect(len(result.Findings)).To(BeNumerically(">", 0),
				"BR-AI-001: Should provide actionable findings from context analysis")
			Expect(result.ProcessingTime).To(BeNumerically("<=", 10*time.Second),
				"BR-AI-001: Analysis should complete within 10 seconds")

			// **Business Value Validation**: Verify analysis quality
			Expect(result.Subject).To(Equal("HighCPUUsage"),
				"BR-AI-001: Should correctly identify analysis subject")
			for _, finding := range result.Findings {
				Expect(finding.Confidence).To(BeNumerically(">=", 0.7),
					"BR-AI-001: Individual findings should have high confidence (≥70%)")
			}
		})

		It("should correlate analysis results across multiple data sources", func() {
			// Arrange: Create analysis request with multiple data sources
			request := &common.AnalysisRequest{
				AIRequest: &common.AIRequest{
					ID:        "analysis-002",
					CreatedAt: time.Now(),
					Context: map[string]interface{}{
						"data_sources": []string{"metrics", "logs", "events", "historical"},
					},
				},
				Subject:      "SystemPerformance",
				Data:         createMultiSourceData(),
				AnalysisType: "predictive",
			}

			// Setup mock with correlated analysis
			mockAnalysisProvider.SetAnalysisResult(&common.AnalysisResult{
				ID:         "analysis-002",
				Subject:    "SystemPerformance",
				Summary:    "Correlated analysis across metrics, logs, and events indicates memory pressure",
				Confidence: 0.92,
				Findings: []common.Finding{
					{
						Type:        "resource_correlation",
						Description: "Memory metrics and OOM events show correlation",
						Severity:    "high",
						Confidence:  0.90,
						Evidence: []common.Evidence{
							{Type: "metric", Source: "prometheus", Description: "Memory usage 85%"},
							{Type: "event", Source: "kubernetes", Description: "OOMKilled events detected"},
							{Type: "log", Source: "application", Description: "Memory allocation failures"},
						},
					},
				},
				Metadata: map[string]interface{}{
					"correlation_score": 0.89,
					"data_sources":      4,
				},
			})

			// Act: Perform correlated analysis
			result, err := mockAnalysisProvider.Analyze(ctx, request)

			// **Business Requirement BR-AI-004**: Validate cross-source correlation
			Expect(err).ToNot(HaveOccurred(), "Should successfully correlate multiple data sources")
			Expect(result.Confidence).To(BeNumerically(">=", 0.85),
				"BR-AI-004: Multi-source correlation should increase confidence (≥85%)")

			// **Business Value Validation**: Verify correlation quality
			correlationScore, exists := result.Metadata["correlation_score"]
			Expect(exists).To(BeTrue(), "BR-AI-004: Should provide correlation metrics")
			Expect(correlationScore).To(BeNumerically(">=", 0.8),
				"BR-AI-004: Correlation score should indicate strong relationships (≥80%)")

			// Validate evidence across sources
			for _, finding := range result.Findings {
				if finding.Type == "resource_correlation" {
					Expect(len(finding.Evidence)).To(BeNumerically(">=", 2),
						"BR-AI-004: Correlated findings should include evidence from multiple sources")
				}
			}
		})
	})

	// BR-AI-006: MUST generate actionable remediation recommendations based on alert context
	Context("BR-AI-006: Recommendation Provider", func() {
		It("should generate actionable remediation recommendations with effectiveness probability", func() {
			// Arrange: Create recommendation context for high CPU alert
			recContext := &common.RecommendationContext{
				Alert: &types.Alert{
					Name:        "HighCPUUsage",
					Severity:    "critical",
					Namespace:   "production",
					Labels:      map[string]string{"app": "web-server"},
					Annotations: map[string]string{"runbook": "cpu-troubleshooting"},
				},
				HistoricalData: map[string]interface{}{
					"similar_alerts": 15,
					"success_rate":   0.78,
				},
				ConstraintSet: map[string]interface{}{
					"max_cpu_increase": "200%",
					"budget_limit":     1000,
				},
				Priority:       "high",
				MaxSuggestions: 3,
			}

			// Setup mock recommendations with effectiveness scoring
			mockRecommendationProvider.SetRecommendations([]common.Recommendation{
				{
					ID:          "rec-001",
					Type:        "resource_adjustment",
					Title:       "Increase CPU Limits",
					Description: "Increase CPU limits to 2000m based on usage patterns",
					Priority:    "high",
					Confidence:  0.89,
					Actions: []common.RecommendedAction{
						{
							Type:        "increase_resources",
							Description: "Set CPU request: 1500m, limit: 2000m",
							Parameters: map[string]interface{}{
								"cpu_request":          "1500m",
								"cpu_limit":            "2000m",
								"expected_improvement": 0.75,
							},
						},
					},
					Metadata: map[string]interface{}{
						"effectiveness_probability": 0.85,
						"estimated_cost":            45.50,
					},
				},
				{
					ID:          "rec-002",
					Type:        "scaling_adjustment",
					Title:       "Horizontal Pod Autoscaling",
					Description: "Enable HPA to automatically scale based on CPU usage",
					Priority:    "medium",
					Confidence:  0.76,
					Actions: []common.RecommendedAction{
						{
							Type:        "scale_deployment",
							Description: "Create HPA with target CPU utilization 70%",
							Parameters: map[string]interface{}{
								"min_replicas":    2,
								"max_replicas":    10,
								"target_cpu_util": 70,
							},
						},
					},
					Metadata: map[string]interface{}{
						"effectiveness_probability": 0.78,
						"estimated_cost":            25.30,
					},
				},
			})

			// Act: Generate recommendations
			recommendations, err := mockRecommendationProvider.GenerateRecommendations(ctx, recContext)

			// **Business Requirement BR-AI-006**: Validate actionable recommendations
			Expect(err).ToNot(HaveOccurred(), "Should successfully generate recommendations")
			Expect(len(recommendations)).To(BeNumerically(">=", 1),
				"BR-AI-006: Should provide at least one actionable recommendation")
			Expect(len(recommendations)).To(BeNumerically("<=", 3),
				"BR-AI-006: Should respect MaxSuggestions constraint")

			// **Business Value Validation**: Verify recommendation quality - Configuration-driven
			for _, rec := range recommendations {
				testconfig.ExpectBusinessRequirement(rec.Confidence,
					"BR-AI-006-RECOMMENDATION-CONFIDENCE", "test",
					"AI recommendation confidence for business decision making")
				Expect(len(rec.Actions)).To(BeNumerically(">", 0),
					"BR-AI-006: Each recommendation should include specific actions for business execution")

				// Validate effectiveness probability - Business requirement driven
				effectivenessProbability, exists := rec.Metadata["effectiveness_probability"]
				Expect(exists).To(BeTrue(), "BR-AI-006: Should provide effectiveness probability")
				testconfig.ExpectBusinessRequirement(effectivenessProbability,
					"BR-AI-006-EFFECTIVENESS-PROBABILITY", "test",
					"recommendation effectiveness probability for business value assessment")
			}

			// **BR-AI-007**: Validate ranking by effectiveness probability
			if len(recommendations) > 1 {
				firstEffectiveness := recommendations[0].Metadata["effectiveness_probability"].(float64)
				secondEffectiveness := recommendations[1].Metadata["effectiveness_probability"].(float64)
				Expect(firstEffectiveness).To(BeNumerically(">=", secondEffectiveness),
					"BR-AI-007: Recommendations should be ranked by effectiveness probability for business priority optimization")
			}
		})
	})

	// BR-AI-011: MUST conduct intelligent alert investigation using historical patterns
	Context("BR-AI-011: Investigation Provider", func() {
		It("should conduct intelligent investigation using historical patterns and evidence", func() {
			// Arrange: Create investigation context with historical data
			alert := &types.Alert{
				Name:      "DatabaseConnectionFailure",
				Severity:  "critical",
				Namespace: "production",
				Labels: map[string]string{
					"service": "api-backend",
					"db":      "postgresql",
				},
			}

			invContext := &common.InvestigationContext{
				HistoricalData: map[string]interface{}{
					"similar_incidents": []map[string]interface{}{
						{
							"timestamp":  "2024-01-15T10:30:00Z",
							"resolution": "restart_database_pod",
							"success":    true,
							"duration":   "5m",
						},
						{
							"timestamp":  "2024-01-10T14:20:00Z",
							"resolution": "increase_connection_pool",
							"success":    true,
							"duration":   "10m",
						},
					},
					"pattern_confidence": 0.83,
				},
				TimeWindow: &common.AITimeRange{
					Start: time.Now().Add(-1 * time.Hour),
					End:   time.Now(),
				},
				Scope: []string{"database", "network", "application"},
			}

			// Setup mock investigation result with historical pattern analysis
			mockInvestigationProvider.SetInvestigationResult(&common.InvestigationResult{
				Alert: alert,
				Analysis: &common.AnalysisResult{
					ID:         "inv-001",
					Subject:    "DatabaseConnectionFailure",
					Summary:    "Connection pool exhaustion due to high load, similar to previous incidents",
					Confidence: 0.91,
					Findings: []common.Finding{
						{
							Type:        "pattern_match",
							Description: "Current incident matches historical pattern with 83% confidence",
							Severity:    "high",
							Confidence:  0.83,
							Evidence: []common.Evidence{
								{
									Type:        "historical",
									Source:      "incident_database",
									Description: "2 similar incidents resolved successfully",
									Timestamp:   time.Now().Add(-5 * time.Minute),
								},
								{
									Type:        "metric",
									Source:      "prometheus",
									Description: "Database connection count exceeded threshold",
									Timestamp:   time.Now().Add(-2 * time.Minute),
								},
							},
						},
					},
				},
				Recommendations: []common.Recommendation{
					{
						ID:          "inv-rec-001",
						Type:        "proven_solution",
						Title:       "Restart Database Pod",
						Description: "Based on 100% success rate in similar historical incidents",
						Priority:    "high",
						Confidence:  0.95,
						Actions: []common.RecommendedAction{
							{
								Type:        "restart_pod",
								Description: "Restart PostgreSQL pod to clear connection pool",
								Parameters: map[string]interface{}{
									"pod_selector": "app=postgresql",
									"namespace":    "production",
									"wait_ready":   true,
								},
							},
						},
						Metadata: map[string]interface{}{
							"historical_success_rate": 1.0,
							"pattern_match_score":     0.83,
						},
					},
				},
				Evidence: []common.Evidence{
					{
						Type:        "pattern_correlation",
						Source:      "ai_investigation",
						Description: "Strong correlation with historical incidents",
						Data: map[string]interface{}{
							"correlation_score": 0.89,
							"matching_patterns": 2,
						},
						Timestamp: time.Now(),
					},
				},
				ProcessingTime: 8 * time.Second,
			})

			// Act: Conduct investigation
			result, err := mockInvestigationProvider.Investigate(ctx, alert, invContext)

			// **Business Requirement BR-AI-011**: Validate intelligent investigation
			Expect(err).ToNot(HaveOccurred(), "Should successfully conduct investigation")
			Expect(result.Analysis.Confidence).To(BeNumerically(">=", 0.8),
				"BR-AI-011: Investigation should leverage historical patterns for high confidence (≥80%)")
			Expect(result.ProcessingTime).To(BeNumerically("<=", 15*time.Second),
				"BR-AI-011: Investigation should complete within 15 seconds")

			// **Business Value Validation**: Verify pattern-based investigation
			Expect(len(result.Analysis.Findings)).To(BeNumerically(">", 0),
				"BR-AI-011: Should provide findings based on historical patterns")

			hasPatternMatch := false
			for _, finding := range result.Analysis.Findings {
				if finding.Type == "pattern_match" {
					hasPatternMatch = true
					Expect(finding.Confidence).To(BeNumerically(">=", 0.7),
						"BR-AI-011: Pattern matches should have high confidence (≥70%)")
				}
			}
			Expect(hasPatternMatch).To(BeTrue(),
				"BR-AI-011: Investigation should identify historical pattern matches")

			// **BR-AI-012**: Validate root cause identification with evidence
			Expect(len(result.Evidence)).To(BeNumerically(">", 0),
				"BR-AI-012: Should provide supporting evidence for root cause analysis")

			// **BR-AI-013**: Validate correlation across time windows
			for _, evidence := range result.Evidence {
				if evidence.Type == "pattern_correlation" {
					Expect(evidence.Data).To(HaveKey("correlation_score"), "BR-AI-001-CONFIDENCE: Evidence data must contain correlation score for business pattern analysis validation")
					correlationScore := evidence.Data["correlation_score"]
					testconfig.ExpectBusinessRequirement(correlationScore,
						"BR-AI-013-CORRELATION-SCORE", "test",
						"cross-time pattern correlation for business insight reliability")
				}
			}

			// Validate proven solution recommendations
			if len(result.Recommendations) > 0 {
				rec := result.Recommendations[0]
				if rec.Type == "proven_solution" {
					successRate, exists := rec.Metadata["historical_success_rate"]
					Expect(exists).To(BeTrue(),
						"BR-AI-008: Should consider historical success rates for business recommendation reliability")
					testconfig.ExpectBusinessRequirement(successRate,
						"BR-AI-008-HISTORICAL-SUCCESS-RATE", "test",
						"proven solution historical success rate for business confidence")
				}
			}
		})
	})

	// BR-AI-016: MUST provide real-time health status for all AI services
	Context("BR-AI-016: Service Health & Monitoring", func() {
		It("should provide comprehensive health status with dependency monitoring", func() {
			// Arrange: Create service health checkers
			analysisHealth := &common.HealthStatus{
				Healthy:      true,
				LastCheck:    time.Now(),
				ResponseTime: 150 * time.Millisecond,
				ErrorRate:    0.02,
				Details: map[string]interface{}{
					"active_analyses": 5,
					"queue_depth":     2,
				},
				Dependencies: []common.DependencyStatus{
					{
						Name:     "llm_service",
						Healthy:  true,
						LastPing: time.Now().Add(-30 * time.Second),
						Latency:  500 * time.Millisecond,
					},
					{
						Name:     "vector_database",
						Healthy:  true,
						LastPing: time.Now().Add(-10 * time.Second),
						Latency:  50 * time.Millisecond,
					},
				},
			}

			// **Business Requirement BR-AI-016**: Validate real-time health monitoring
			Expect(analysisHealth.Healthy).To(BeTrue(),
				"BR-AI-016: Service should report healthy status when operational")
			Expect(analysisHealth.ResponseTime).To(BeNumerically("<=", 200*time.Millisecond),
				"BR-AI-016: Response time should be within acceptable limits (≤200ms)")
			Expect(analysisHealth.ErrorRate).To(BeNumerically("<=", 0.05),
				"BR-AI-016: Error rate should be low (≤5%)")
			Expect(time.Since(analysisHealth.LastCheck)).To(BeNumerically("<=", 1*time.Minute),
				"BR-AI-016: Health checks should be recent (≤1 minute)")

			// **Business Value Validation**: Verify dependency health monitoring
			Expect(len(analysisHealth.Dependencies)).To(BeNumerically(">", 0),
				"BR-AI-018: Should monitor dependencies for health status")

			for _, dep := range analysisHealth.Dependencies {
				Expect(dep.Healthy).To(BeTrue(),
					"BR-AI-018: All dependencies should be healthy for service health")
				Expect(time.Since(dep.LastPing)).To(BeNumerically("<=", 1*time.Minute),
					"BR-AI-018: Dependency health checks should be recent")
			}

			// **BR-AI-017**: Validate performance metrics tracking
			activeAnalyses, exists := analysisHealth.Details["active_analyses"]
			Expect(exists).To(BeTrue(), "BR-AI-017: Should track performance metrics")
			Expect(activeAnalyses).To(BeNumerically(">=", 0),
				"BR-AI-017: Active analyses count should be valid")
		})
	})
})

// Helper functions for test data creation
func createAlertData(alertName, namespace string) map[string]interface{} {
	return map[string]interface{}{
		"alert_name": alertName,
		"namespace":  namespace,
		"labels": map[string]string{
			"severity": "critical",
			"app":      "web-server",
		},
		"annotations": map[string]string{
			"description": "CPU usage exceeded 80% for 5 minutes",
			"runbook":     "https://runbooks.kubernaut.io/cpu-high",
		},
		"metrics": map[string]float64{
			"cpu_usage":    0.85,
			"memory_usage": 0.65,
		},
	}
}

func createMultiSourceData() map[string]interface{} {
	return map[string]interface{}{
		"metrics": map[string]float64{
			"memory_usage":     0.85,
			"cpu_usage":        0.60,
			"disk_usage":       0.45,
			"network_rx_bytes": 1024000,
		},
		"logs": []map[string]interface{}{
			{
				"timestamp": time.Now().Add(-5 * time.Minute),
				"level":     "ERROR",
				"message":   "OutOfMemoryError in application thread",
			},
			{
				"timestamp": time.Now().Add(-3 * time.Minute),
				"level":     "WARN",
				"message":   "Memory allocation failure, retrying",
			},
		},
		"events": []map[string]interface{}{
			{
				"type":      "Warning",
				"reason":    "OOMKilled",
				"timestamp": time.Now().Add(-4 * time.Minute),
				"object":    "pod/web-server-xyz",
			},
		},
		"historical": map[string]interface{}{
			"similar_patterns": 3,
			"last_occurrence":  time.Now().Add(-24 * time.Hour),
		},
	}
}

// TestRunner bootstraps the Ginkgo test suite
func TestUcommonUlayer(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "UcommonUlayer Suite")
}
