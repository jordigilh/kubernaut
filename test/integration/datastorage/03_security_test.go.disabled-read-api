package datastorage

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

var _ = Describe("BR-STORAGE-025: SQL Injection Prevention with Real Database", func() {
	var testBaseURL string

	BeforeEach(func() {
		testBaseURL = baseURL

		// Ensure we have some test data
		_, err := db.Exec("DELETE FROM resource_action_traces WHERE alert_name LIKE 'test-security-%'")
		Expect(err).ToNot(HaveOccurred())

		_, err = db.Exec(`
			INSERT INTO resource_action_traces
			(action_history_id, action_id, alert_name, alert_severity, action_type, action_timestamp, model_used, model_confidence, execution_status)
			VALUES (1, gen_random_uuid()::text, 'test-security-normal', 'high', 'scale', NOW(), 'test-model', 0.9, 'completed')
		`)
		Expect(err).ToNot(HaveOccurred())
	})

	AfterEach(func() {
		// Cleanup
		_, err := db.Exec("DELETE FROM resource_action_traces WHERE alert_name LIKE 'test-security-%'")
		Expect(err).ToNot(HaveOccurred())
	})

	Context("SQL Injection Attempts - Query Parameters", func() {
		DescribeTable("should block SQL injection attempts in query parameters",
			func(paramName, maliciousValue string) {
				// BR-STORAGE-025: SQL injection prevention
				// All malicious input should be safely handled via parameterized queries

				escapedValue := url.QueryEscape(maliciousValue)
				requestURL := fmt.Sprintf("%s/api/v1/incidents?%s=%s", testBaseURL, paramName, escapedValue)

				resp, err := http.Get(requestURL)
				Expect(err).ToNot(HaveOccurred())
				defer resp.Body.Close()

				// Request should either succeed (treating injection as literal string)
				// or return 400 for invalid input - but NEVER execute SQL injection
				Expect(resp.StatusCode).To(BeNumerically(">=", 200))
				Expect(resp.StatusCode).To(BeNumerically("<", 500), "Should not cause server error")

				if resp.StatusCode == http.StatusOK {
					var response map[string]interface{}
					err = json.NewDecoder(resp.Body).Decode(&response)
					Expect(err).ToNot(HaveOccurred())

					data, ok := response["data"].([]interface{})
					Expect(ok).To(BeTrue(), "Response should have valid data array")

					// SQL injection should NOT return all records or drop tables
					// It should be treated as a literal search string (likely returning 0 results)
					// We verify this by ensuring we don't get unexpected large result sets
					Expect(len(data)).To(BeNumerically("<=", 100), "SQL injection should not bypass filters")
				}
			},
			Entry("UNION attack - alert_name", "alert_name", "' OR '1'='1' UNION SELECT * FROM resource_action_traces--"),
			Entry("UNION attack - severity", "severity", "' OR '1'='1' UNION SELECT * FROM resource_action_traces--"),
			Entry("Boolean-based attack", "alert_name", "' OR '1'='1"),
			Entry("Comment injection", "alert_name", "'; DROP TABLE resource_action_traces--"),
			Entry("Stacked queries", "alert_name", "'; DELETE FROM resource_action_traces WHERE '1'='1"),
			Entry("Time-based blind injection", "alert_name", "' OR SLEEP(5)--"),
			Entry("Hex encoding attack", "alert_name", "0x27204f52202731273d2731"),
		)

		It("should handle malicious special characters safely", func() {
			// BR-STORAGE-025: Special character handling

			maliciousInputs := []string{
				"'",  // Single quote
				"\"", // Double quote
				"`;", // Semicolon
				"--", // SQL comment
				"/*", // Block comment start
				"*/", // Block comment end
				"\\", // Backslash
				"%",  // Wildcard
				"_",  // Wildcard single char
				"$",  // Dollar sign
				"@",  // At sign
			}

			for _, maliciousInput := range maliciousInputs {
				escapedInput := url.QueryEscape(maliciousInput)
				resp, err := http.Get(fmt.Sprintf("%s/api/v1/incidents?alert_name=%s", testBaseURL, escapedInput))
				Expect(err).ToNot(HaveOccurred())
				defer resp.Body.Close()

				// Should handle gracefully (not cause 500 error)
				Expect(resp.StatusCode).To(BeNumerically("<", 500),
					fmt.Sprintf("Special character '%s' should be handled safely", maliciousInput))
			}
		})
	})

	Context("SQL Injection Attempts - Path Parameters", func() {
		It("should handle malicious ID values safely", func() {
			// BR-STORAGE-025: SQL injection in path parameters

			maliciousIDs := []string{
				"1' OR '1'='1",
				"1; DROP TABLE resource_action_traces",
				"1 UNION SELECT * FROM resource_action_traces",
				"1 OR 1=1",
			}

			for _, maliciousID := range maliciousIDs {
				resp, err := http.Get(fmt.Sprintf("%s/api/v1/incidents/%s", testBaseURL, url.PathEscape(maliciousID)))
				Expect(err).ToNot(HaveOccurred())
				defer resp.Body.Close()

				// Should either return 400 (invalid ID) or 404 (not found)
				// but NEVER execute SQL injection
				Expect(resp.StatusCode).To(Or(
					Equal(http.StatusBadRequest),
					Equal(http.StatusNotFound),
				), fmt.Sprintf("Malicious ID '%s' should not cause server error", maliciousID))

				// Should NOT return multiple records (sign of SQL injection success)
				if resp.StatusCode == http.StatusOK {
					var result map[string]interface{}
					err = json.NewDecoder(resp.Body).Decode(&result)
					Expect(err).ToNot(HaveOccurred())

					// Should be a single incident, not an array (sign of UNION attack)
					_, isArray := result["data"]
					Expect(isArray).To(BeFalse(), "SQL injection should not return array of all records")
				}
			}
		})
	})

	Context("Database Integrity Verification", func() {
		It("should verify database tables still exist after injection attempts", func() {
			// BR-STORAGE-025: Verify SQL injection didn't execute destructive commands

			// Attempt various DROP/DELETE attacks
			maliciousAttempts := []string{
				"'; DROP TABLE resource_action_traces--",
				"'; DELETE FROM resource_action_traces WHERE 1=1--",
				"'; TRUNCATE TABLE resource_action_traces--",
				"'; ALTER TABLE resource_action_traces DROP COLUMN alert_name--",
			}

			for _, attempt := range maliciousAttempts {
				escapedAttempt := url.QueryEscape(attempt)
				resp, err := http.Get(fmt.Sprintf("%s/api/v1/incidents?alert_name=%s", testBaseURL, escapedAttempt))
				Expect(err).ToNot(HaveOccurred())
				resp.Body.Close()
			}

			// Verify table still exists and has data
			var count int
			err := db.QueryRow("SELECT COUNT(*) FROM resource_action_traces WHERE alert_name = 'test-security-normal'").Scan(&count)
			Expect(err).ToNot(HaveOccurred(), "Table should still exist after injection attempts")
			Expect(count).To(Equal(1), "Test data should not be deleted by injection attempts")

			// Verify table structure intact
			var columnExists bool
			err = db.QueryRow(`
				SELECT EXISTS (
					SELECT 1
					FROM information_schema.columns
					WHERE table_name = 'resource_action_traces'
					AND column_name = 'alert_name'
				)
			`).Scan(&columnExists)
			Expect(err).ToNot(HaveOccurred())
			Expect(columnExists).To(BeTrue(), "Table structure should be intact after injection attempts")
		})

		It("should not leak database schema information", func() {
			// BR-STORAGE-025: Prevent information disclosure via error messages

			// Attempt to trigger database errors that might leak schema info
			maliciousInputs := []string{
				"' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--",
				"' UNION SELECT table_schema, table_name FROM information_schema.tables--",
			}

			for _, maliciousInput := range maliciousInputs {
				escapedInput := url.QueryEscape(maliciousInput)
				resp, err := http.Get(fmt.Sprintf("%s/api/v1/incidents?alert_name=%s", testBaseURL, escapedInput))
				Expect(err).ToNot(HaveOccurred())
				defer resp.Body.Close()

				// Read response body
				var result map[string]interface{}
				err = json.NewDecoder(resp.Body).Decode(&result)
				Expect(err).ToNot(HaveOccurred())

				// Error messages should not contain SQL error details or schema information
				if detail, ok := result["detail"].(string); ok {
					Expect(detail).ToNot(ContainSubstring("syntax error"), "Should not leak SQL syntax errors")
					Expect(detail).ToNot(ContainSubstring("relation"), "Should not leak database relation names")
					Expect(detail).ToNot(ContainSubstring("column"), "Should not leak column information")
					Expect(detail).ToNot(ContainSubstring("table"), "Should not leak table information")
				}
			}
		})
	})

	Context("Parameterized Query Validation", func() {
		It("should use parameterized queries for all filters", func() {
			// BR-STORAGE-025: Verify parameterized queries are used
			// This is a positive test - legitimate queries should work

			legitimateQueries := map[string]string{
				"alert_name":  "test-security-normal",
				"severity":    "high",
				"action_type": "scale",
			}

			for param, value := range legitimateQueries {
				resp, err := http.Get(fmt.Sprintf("%s/api/v1/incidents?%s=%s", testBaseURL, param, url.QueryEscape(value)))
				Expect(err).ToNot(HaveOccurred())
				defer resp.Body.Close()

				Expect(resp.StatusCode).To(Equal(http.StatusOK),
					fmt.Sprintf("Legitimate query with %s should succeed", param))

				var response map[string]interface{}
				err = json.NewDecoder(resp.Body).Decode(&response)
				Expect(err).ToNot(HaveOccurred())

				data, ok := response["data"].([]interface{})
				Expect(ok).To(BeTrue())

				// Should return results when filter matches
				if param == "alert_name" && value == "test-security-normal" {
					Expect(data).To(HaveLen(1), "Should find the test record")
				}
			}
		})
	})
})
