/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package datastorage

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"sort"
	"time"

	"github.com/go-logr/logr"
	_ "github.com/jackc/pgx/v5/stdlib"
	dsgen "github.com/jordigilh/kubernaut/pkg/datastorage/ogen-client"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/jordigilh/kubernaut/pkg/datastorage/audit"
)

// Scenario 1: Happy Path - Complete Remediation Audit Trail (P0)
//
// Business Requirements:
// - BR-STORAGE-001: Audit persistence
// - BR-STORAGE-021: REST API Read Endpoints
// - BR-STORAGE-022: Query Filtering
//
// Business Value: Verify complete audit trail across all services
//
// Test Flow:
// 1. Deploy Data Storage Service in isolated namespace
// 2. Simulate audit events from 5 services (Gateway, AIAnalysis, Workflow, Orchestrator, Monitor)
// 3. Verify all events persisted to audit_events table (ADR-034 unified table)
// 4. Query by correlation_id and verify complete timeline
// 5. Verify chronological order
//
// Expected Results:
// - 5 audit records created in audit_events table
// - All audit writes complete <1s (p95 latency)
// - Zero DLQ fallbacks
// - Query API retrieves complete timeline by correlation_id
//
// Parallel Execution: âœ… ENABLED
// - Each test gets unique namespace (datastorage-e2e-p{N}-{timestamp})
// - Complete infrastructure isolation
// - No data pollution between tests

var _ = Describe("BR-DS-001: Audit Event Persistence - Complete Remediation Audit Trail (DD-AUDIT-003)", Label("e2e", "happy-path", "p0"), Ordered, func() {
	var (
		testCancel    context.CancelFunc
		testLogger    logr.Logger
		httpClient    *http.Client
		testNamespace string
		serviceURL    string
		db            *sql.DB
		correlationID string
	)

	BeforeAll(func() {
		_, testCancel = context.WithTimeout(ctx, 15*time.Minute)
		testLogger = logger.WithValues("test", "happy-path")
		httpClient = &http.Client{Timeout: 10 * time.Second}

		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
		testLogger.Info("Scenario 1: Happy Path - Setup")
		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

		// Use shared deployment from SynchronizedBeforeSuite (no per-test deployment)
		// Services are deployed ONCE and shared via NodePort (no port-forwarding needed)
		testNamespace = sharedNamespace
		serviceURL = dataStorageURL
		testLogger.Info("Using shared deployment", "namespace", testNamespace, "url", serviceURL)

		// Wait for Data Storage Service HTTP endpoint to be responsive
		testLogger.Info("â³ Waiting for Data Storage Service HTTP endpoint...")
		Eventually(func() error {
			resp, err := httpClient.Get(serviceURL + "/health")
			if err != nil {
				testLogger.V(1).Info("Health check failed, retrying...", "error", err)
				return err
			}
			defer func() {
				if err := resp.Body.Close(); err != nil {
					testLogger.Error(err, "failed to close response body")
				}
			}()
			if resp.StatusCode != http.StatusOK {
				return fmt.Errorf("health check returned status %d", resp.StatusCode)
			}
			return nil
		}, 60*time.Second, 2*time.Second).Should(Succeed(), "Data Storage Service should be healthy")
		testLogger.Info("âœ… Data Storage Service is responsive")

		// Connect to PostgreSQL for verification (using shared NodePort - no port-forward needed)
		testLogger.Info("ğŸ”Œ Connecting to PostgreSQL via NodePort...")
		connStr := fmt.Sprintf("host=localhost port=25433 user=slm_user password=test_password dbname=action_history sslmode=disable") // Per DD-TEST-001
		var err error
		db, err = sql.Open("pgx", connStr)
		Expect(err).ToNot(HaveOccurred())

		Eventually(func() error {
			return db.Ping()
		}, 30*time.Second, 2*time.Second).Should(Succeed(), "PostgreSQL should be connectable")
		testLogger.Info("âœ… PostgreSQL connected")

		// Generate unique correlation ID for this test
		correlationID = fmt.Sprintf("remediation-%s", testNamespace)

		testLogger.Info("âœ… Test services ready", "namespace", testNamespace)
		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	})

	AfterAll(func() {
		testLogger.Info("ğŸ§¹ Cleaning up test resources...")
		if db != nil {
			if err := db.Close(); err != nil {
				testLogger.Info("warning: failed to close database connection", "error", err)
			}
		}
		if testCancel != nil {
			testCancel()
		}
		// Note: Shared namespace is NOT cleaned up here - it's managed by SynchronizedAfterSuite
	})

	It("should create complete audit trail across all services", func() {
		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
		testLogger.Info("Test: Complete Audit Trail")
		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

		// Step 1: Gateway - Signal Received
		testLogger.Info("ğŸ“¨ Step 1: Gateway processes signal...")
		gatewayEventData, err := audit.NewGatewayEvent("signal.received").
			WithSignalType("prometheus").
			WithAlertName("PodCrashLooping").
			Build()
		Expect(err).ToNot(HaveOccurred())

		// DD-API-001: Use typed OpenAPI struct for type safety
		gatewayEvent := dsgen.AuditEventRequest{
			Version:        "1.0",
			EventCategory:  dsgen.AuditEventRequestEventCategoryGateway,
			EventAction:    "signal_processing",
			EventType:      "gateway.signal.received",
			EventTimestamp: time.Now().UTC(),
			CorrelationID:  correlationID,
			EventOutcome:   dsgen.AuditEventRequestEventOutcomeSuccess,
			EventData:      gatewayEventData,
		}

		resp := createAuditEventOpenAPI(ctx, dsClient, gatewayEvent)
		Expect(resp.StatusCode()).To(Equal(http.StatusCreated), "Gateway audit event should be created")
		testLogger.Info("âœ… Gateway audit event created")

		// Step 2: AIAnalysis - Analysis Completed
		testLogger.Info("ğŸ¤– Step 2: AIAnalysis generates RCA...")
		aiEventData, err := audit.NewAIAnalysisEvent("analysis.completed").
			WithAnalysisID(fmt.Sprintf("analysis-%s", testNamespace)).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// DD-API-001: Use typed OpenAPI struct
		aiEvent := dsgen.AuditEventRequest{
			Version:        "1.0",
			EventCategory:  dsgen.AuditEventRequestEventCategoryAnalysis,
			EventAction:    "rca_generation",
			EventType:      "analysis.analysis.completed",
			EventTimestamp: time.Now().UTC(),
			CorrelationID:  correlationID,
			EventOutcome:   dsgen.AuditEventRequestEventOutcomeSuccess,
			EventData:      aiEventData,
		}

		resp = createAuditEventOpenAPI(ctx, dsClient, aiEvent)
		Expect(resp.StatusCode()).To(Equal(http.StatusCreated), "AIAnalysis audit event should be created")
		testLogger.Info("âœ… AIAnalysis audit event created")

		// Step 3: Workflow - Workflow Completed
		testLogger.Info("âš™ï¸  Step 3: Workflow executes remediation...")
		workflowEventData, err := audit.NewWorkflowEvent("workflow.completed").
			WithWorkflowID(fmt.Sprintf("workflow-%s", testNamespace)).
			Build()
		Expect(err).ToNot(HaveOccurred())

		// DD-API-001: Use typed OpenAPI struct
		workflowEvent := dsgen.AuditEventRequest{
			Version:        "1.0",
			EventCategory:  dsgen.AuditEventRequestEventCategoryWorkflow,
			EventAction:    "remediation_execution",
			EventType:      "workflow.workflow.completed",
			EventTimestamp: time.Now().UTC(),
			CorrelationID:  correlationID,
			EventOutcome:   dsgen.AuditEventRequestEventOutcomeSuccess,
			EventData:      workflowEventData,
		}

		resp = createAuditEventOpenAPI(ctx, dsClient, workflowEvent)
		Expect(resp.StatusCode()).To(Equal(http.StatusCreated), "Workflow audit event should be created")
		testLogger.Info("âœ… Workflow audit event created")

		// Step 4: Orchestrator - Remediation Completed
		testLogger.Info("ğŸ¯ Step 4: Orchestrator completes...")
		// DD-API-001: Use typed OpenAPI struct
		orchestratorEvent := dsgen.AuditEventRequest{
			Version:        "1.0",
			EventCategory:  dsgen.AuditEventRequestEventCategoryOrchestration, // ADR-034 v1.2 valid category
			EventAction:    "orchestration",
			EventType:      "orchestration.remediation.completed",
			EventTimestamp: time.Now().UTC(),
			CorrelationID:  correlationID,
			EventOutcome:   dsgen.AuditEventRequestEventOutcomeSuccess,
			EventData:      map[string]interface{}{}, // Empty event data
		}

		resp = createAuditEventOpenAPI(ctx, dsClient, orchestratorEvent)
		Expect(resp.StatusCode()).To(Equal(http.StatusCreated), "Orchestrator audit event should be created")
		testLogger.Info("âœ… Orchestrator audit event created")

		// Step 5: EffectivenessMonitor - Assessment Completed
		testLogger.Info("ğŸ“Š Step 5: EffectivenessMonitor assesses...")
		// DD-API-001: Use typed OpenAPI struct
		monitorEvent := dsgen.AuditEventRequest{
			Version:        "1.0",
			EventCategory:  dsgen.AuditEventRequestEventCategoryAnalysis, // ADR-034 v1.2: effectiveness assessment = analysis category
			EventAction:    "effectiveness_assessment",
			EventType:      "analysis.assessment.completed",
			EventTimestamp: time.Now().UTC(),
			CorrelationID:  correlationID,
			EventOutcome:   dsgen.AuditEventRequestEventOutcomeSuccess,
			EventData:      map[string]interface{}{}, // Empty event data
		}

		resp = createAuditEventOpenAPI(ctx, dsClient, monitorEvent)
		Expect(resp.StatusCode()).To(Equal(http.StatusCreated), "Monitor audit event should be created")
		testLogger.Info("âœ… Monitor audit event created")

		// Verification: Query database directly
		testLogger.Info("ğŸ” Verifying audit events in database...")
		var count int
		err = db.QueryRow(`
			SELECT COUNT(*) FROM audit_events
			WHERE correlation_id = $1
		`, correlationID).Scan(&count)
		Expect(err).ToNot(HaveOccurred())
		// Self-auditing creates additional events (datastorage.audit.written)
		// We expect at least 5 events (the ones we created), but may have more
		Expect(count).To(BeNumerically(">=", 5), "Should have at least 5 audit events in database")
		testLogger.Info("âœ… All audit events persisted to database", "count", count)

		// Verification: Query via REST API using OpenAPI client
		testLogger.Info("ğŸ” Querying audit trail via REST API...")
		queryResp, err := dsClient.QueryAuditEvents(ctx, &dsgen.QueryAuditEventsParams{
			CorrelationID: &correlationID,
		})
		Expect(err).ToNot(HaveOccurred())
		Expect(queryResp.StatusCode()).To(Equal(http.StatusOK), "Query API should return 200 OK")
		Expect(queryResp.JSON200).ToNot(BeNil(), "Query response should have JSON200 body")
		Expect(queryResp.JSON200.Data).ToNot(BeNil(), "Query response should have data array")

		// Self-auditing creates additional events, so we expect at least 5
		data := *queryResp.JSON200.Data
		Expect(len(data)).To(BeNumerically(">=", 5), "Query API should return at least 5 events")
		testLogger.Info("âœ… Query API returned complete audit trail", "event_count", len(data))

		// Verification: Chronological order (sort events first since API doesn't guarantee order)
		testLogger.Info("ğŸ” Verifying chronological order...")

		// Sort events by timestamp
		sort.Slice(data, func(i, j int) bool {
			return data[i].EventTimestamp.Before(data[j].EventTimestamp)
		})

		var previousTimestamp time.Time
		for i, event := range data {
			if i > 0 {
				Expect(event.EventTimestamp.After(previousTimestamp) || event.EventTimestamp.Equal(previousTimestamp)).To(BeTrue(),
					"Events should be in chronological order")
			}
			previousTimestamp = event.EventTimestamp
		}
		testLogger.Info("âœ… Events are in chronological order")

		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
		testLogger.Info("âœ… Scenario 1: Happy Path - PASSED")
		testLogger.Info("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	})
})

// DD-API-001: postAuditEvent helper function removed
// Replaced by createAuditEventFromMap() in helpers.go (OpenAPI client-based)
