---
globs: "*_test.go,test/**/*"
description: "Critical testing anti-patterns to avoid in kubernaut development"
---

# Testing Anti-Patterns - CRITICAL REFERENCE WITH AUTOMATED DETECTION

## ðŸ¤– **AUTOMATED ANTI-PATTERN DETECTION - MANDATORY**

### Detection Scripts - MANDATORY
Run these checks before ANY test commit:

```bash
# Run comprehensive cursor rule validation
./scripts/cursor-rule-validator.sh

# Individual pattern checks:
# 1. NULL-TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeEmpty())\|ToNot(BeNil())" {} \;
# VIOLATION: Any matches = immediate rejection

# 2. STATIC DATA TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \;
# VIOLATION: Testing hardcoded strings = immediate rejection

# 3. LIBRARY TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \;
# VIOLATION: Testing libraries instead of business logic = immediate rejection

# 4. BUSINESS LOGIC INTEGRATION CHECK
for file in $(find test/ -name "*_test.go"); do
  if ! grep -q "github.com/jordigilh/kubernaut/pkg/" "$file"; then
    echo "VIOLATION: $file - No business logic imports"
  fi
done
```

### Enforcement Levels - MANDATORY
- **LEVEL 1 - BLOCK COMPILATION**: Tests with anti-patterns MUST NOT compile
- **LEVEL 2 - PRE-COMMIT GATE**: Git hooks prevent commits with violations
- **LEVEL 3 - CI/CD GATE**: Pipeline fails on cursor rule violations

### Git Hook Integration - MANDATORY
```bash
#!/bin/bash
# .git/hooks/pre-commit (MANDATORY)

# Run cursor rule validation
./scripts/cursor-rule-validator.sh
if [ $? -ne 0 ]; then
    echo "âŒ Cursor rule violations detected - commit blocked"
    exit 1
fi
```

## ðŸš¨ **MOST DANGEROUS: Panic-Only Testing Anti-Pattern**

### **The Problem**
Testing only that functions don't crash without validating actual business outcomes.

### **âŒ WRONG - Panic-Only Testing**
```go
// DANGEROUS: This test provides NO business validation
It("should track events reliably", func() {
    Expect(func() {
        serviceDiscovery.TrackEventMetrics(eventType, processingTime, successful)
    }).NotTo(Panic(), "Event tracking should not crash")
})
```

**Why This is Dangerous:**
- âŒ **False Confidence**: Test passes even if business requirement completely fails
- âŒ **No Business Value**: Operations team gets no monitoring data, but test shows "green"
- âŒ **Production Risk**: Critical business functionality can be broken with passing tests
- âŒ **Cursor Rules Violation**: Violates mandatory business outcome focus

### **âœ… CORRECT - Business Outcome Testing**
```go
// SAFE: This test validates actual business requirements
It("should provide operational visibility through event tracking", func() {
    // Business Scenario: Operations team needs monitoring data
    // Business Impact: Enable proactive troubleshooting and capacity planning

    // Get baseline state
    initialMetrics := serviceDiscovery.GetEventMetrics()

    // Execute business logic
    serviceDiscovery.TrackEventMetrics(eventType, processingTime, successful)

    // Validate business outcomes
    finalMetrics := serviceDiscovery.GetEventMetrics()

    // Business Requirement Validation: Operations team must see increased counts
    Expect(finalMetrics.TotalEventsProcessed).To(BeNumerically(">", initialMetrics.TotalEventsProcessed),
        "BR-HOLMES-029: Operations team should see increased total events for business visibility")

    Expect(finalMetrics.SuccessfulEvents).To(BeNumerically(">", initialMetrics.SuccessfulEvents),
        "BR-HOLMES-029: Operations team should see successful events for performance monitoring")

    // Business Requirement Validation: Event type breakdown for targeted troubleshooting
    Expect(len(finalMetrics.EventTypeCounts)).To(BeNumerically(">=", 1),
        "BR-HOLMES-029: Operations team should see event type breakdown for targeted analysis")
})
```

---

## ðŸ” **Other Critical Anti-Patterns**

### **Null-Testing Anti-Pattern**
```go
// âŒ WRONG: Weak validation
Expect(result).NotTo(BeNil())
Expect(len(items)).To(BeNumerically(">", 0))

// âœ… CORRECT: Business-meaningful validation
Expect(result.BusinessOutcome).To(BeTrue(), "BR-XXX-XXX: Specific business requirement")
Expect(items).To(ContainElement(expectedBusinessValue), "BR-XXX-XXX: Business requirement description")
```

### **Implementation Testing Anti-Pattern**
```go
// âŒ WRONG: Tests how code works
Expect(mockService.CallCount()).To(Equal(3))

// âœ… CORRECT: Tests what business value is delivered
Expect(businessMetrics.CustomerSatisfaction).To(BeNumerically(">=", 0.9), "BR-XXX-XXX: Customer satisfaction target")
```

### **Skip() Anti-Pattern**
```go
// âŒ WRONG: Avoiding test failures
It("should handle edge case", func() {
    Skip("TODO: Fix this later")
})

// âœ… CORRECT: Fix tests properly or remove them
It("should handle edge case for business continuity", func() {
    // Proper test implementation with business validation
})
```

### **Empty BeforeSuite/BeforeEach Anti-Pattern**
```go
// âŒ WRONG: Empty setup functions with only comments
var _ = BeforeSuite(func() {
    // Business Scenario: Executive stakeholders need confidence...
    // Business Impact: Ensures all components deliver...
    // Business Outcome: Test suite framework enables...
})

// âœ… CORRECT: Business documentation at package level, setup only when needed
// BR-SUITE-001: Business Intelligence Test Suite Organization
// Business Impact: Ensures comprehensive validation of business logic
// Stakeholder Value: Provides executive confidence in testing and business continuity
//
// Business Scenario: Executive stakeholders need confidence in capabilities
// Business Impact: Ensures all components deliver measurable system reliability
// Business Outcome: Test suite framework enables validation

var _ = Describe("Business Value Validation", func() {
    // Only add BeforeSuite if actual setup is required
    // var _ = BeforeSuite(func() {
    //     // Actual setup code here
    //     setupDatabase()
    //     initializeTestEnvironment()
    // })
})
```

**Why Empty Setup Functions Are Problematic:**
- âŒ **Runtime Overhead**: Ginkgo executes empty functions during test runs
- âŒ **Misleading Structure**: Suggests setup will happen when none is needed
- âŒ **Framework Confusion**: Developers expect setup functions to contain actual setup logic
- âŒ **Maintenance Burden**: Empty functions require mental overhead to understand
- âŒ **Documentation Misplacement**: Business documentation belongs at package level

---

## ðŸ“‹ **Detection Checklist**

### **Red Flags in Test Code**
- [ ] Tests only check functions don't panic/crash
- [ ] Tests only validate not nil, > 0, empty checks
- [ ] Tests focus on mock call counts instead of business outcomes
- [ ] Tests use Skip() to avoid failures
- [ ] Tests have no BR-XXX-XXX business requirement references
- [ ] Tests validate implementation details instead of business value
- [ ] Empty BeforeSuite/BeforeEach functions with only comments
- [ ] Business documentation inside empty setup functions instead of package level

### **Green Flags in Test Code**
- [ ] Tests validate specific business requirements (BR-XXX-XXX)
- [ ] Tests use before/after state comparison for business outcomes
- [ ] Tests include realistic business scenarios and data
- [ ] Tests validate end-user or operations team value
- [ ] Tests include clear business impact descriptions
- [ ] Tests map to actual business workflows
- [ ] Business documentation at package level, not inside empty functions
- [ ] Setup functions only exist when actual setup code is needed

---

## ðŸ›  **Conversion Pattern**

### **Step 1: Identify the Business Requirement**
```go
// What business value does this function provide?
// Who benefits from this functionality?
// What specific outcome should be achieved?
```

### **Step 2: Measure Business State**
```go
// Get baseline business state
initialState := getBusinessState()
```

### **Step 3: Execute Business Logic**
```go
// Execute the business function
businessFunction.Execute(parameters)
```

### **Step 4: Validate Business Outcomes**
```go
// Measure final business state
finalState := getBusinessState()

// Validate specific business requirements
Expect(finalState.BusinessMetric).To(BeNumerically(">", initialState.BusinessMetric),
    "BR-XXX-XXX: Specific business requirement description")
```

---

## ðŸŽ¯ **Business Validation Examples**

### **Operations Team Value**
```go
// Validate operations team gets monitoring data
Expect(metrics.EventCount).To(BeNumerically(">", 0), "BR-OPS-001: Operations visibility")
Expect(metrics.LastUpdate).To(BeTemporally("~", time.Now(), 5*time.Second), "BR-OPS-002: Real-time data")
```

### **Customer Experience Value**
```go
// Validate customer experience improvements
Expect(response.LoadTime).To(BeNumerically("<", 200*time.Millisecond), "BR-UX-001: Fast response times")
Expect(response.Accuracy).To(BeNumerically(">=", 0.95), "BR-UX-002: High accuracy results")
```

### **Business Continuity Value**
```go
// Validate business continuity assurance
Expect(system.Availability).To(BeNumerically(">=", 0.999), "BR-BC-001: High availability")
Expect(system.FailoverTime).To(BeNumerically("<", 30*time.Second), "BR-BC-002: Fast recovery")
```

---

## ðŸš¨ **Emergency Response**

### **If You Find Panic-Only Tests:**
1. **STOP**: Do not merge code with panic-only tests
2. **IDENTIFY**: Determine the business requirement being tested
3. **CONVERT**: Use the conversion pattern above
4. **VALIDATE**: Ensure business outcomes are actually tested
5. **DOCUMENT**: Reference specific BR-XXX-XXX requirements

### **If Tests Are Failing After Conversion:**
1. **GOOD**: This means the business requirement wasn't being met
2. **INVESTIGATE**: Determine why business logic isn't working
3. **FIX**: Implement proper business logic to satisfy requirements
4. **VERIFY**: Ensure business outcomes are achieved

---

## ðŸ“š **Related Documentation**
- [00-project-guidelines.mdc](mdc:.cursor/rules/00-project-guidelines.mdc) - Core testing principles
- [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) - Testing framework and strategy
- [07-business-code-integration.mdc](mdc:.cursor/rules/07-business-code-integration.mdc) - Business integration patterns

**Remember**: Tests that only check functions don't crash provide dangerous false confidence. Always validate actual business outcomes and requirements.