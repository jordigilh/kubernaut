# coding: utf-8

"""
    Data Storage Service API

    Data Storage Service provides REST API access to audit trail persistence.  **Business Requirements**: - BR-STORAGE-001 to BR-STORAGE-020: Audit write API - BR-STORAGE-021: Incident query API (READ) - BR-STORAGE-024: RFC 7807 error responses - BR-AUDIT-006: Legal hold capability (SOC2 Gap #8)  **Design Decisions**: - ADR-031: OpenAPI 3.0+ specification for all stateless REST APIs - ADR-032: Data Access Layer Isolation (only Data Storage connects to PostgreSQL) - DD-009: Dead Letter Queue fallback on database errors - DD-AUTH-004: OAuth-proxy sidecar for authentication/authorization - DD-AUTH-005: Client authentication pattern (ServiceAccount tokens)  **Architecture**: This service is the **ONLY** service that directly accesses PostgreSQL. All other services (Context API, Effectiveness Monitor, etc.) access data through this REST API Gateway.  **Authentication & Authorization (Production/E2E)**: All requests to DataStorage are protected by an OAuth-proxy sidecar:  1. **Client Authentication**: Services authenticate with Kubernetes ServiceAccount tokens    - Token mounted at: `/var/run/secrets/kubernetes.io/serviceaccount/token`    - Clients inject: `Authorization: Bearer <token>` header    - See DD-AUTH-005 for client implementation patterns  2. **OAuth-Proxy Validation**: The sidecar validates requests    - Validates JWT token signature and expiration    - Performs Subject Access Review (SAR) to check RBAC permissions    - Injects `X-Auth-Request-User` header with authenticated user identity    - Returns HTTP 401 if token invalid, HTTP 403 if SAR fails  3. **Handler Enforcement**: DataStorage handlers extract user identity    - Legal hold operations REQUIRE `X-Auth-Request-User` header    - HTTP 401 returned if header missing (authentication failed)    - User identity stored in audit events for SOC2 compliance  **Routing Flow**: ``` Client → data-storage-service:8080 (Service)        ↓      oauth-proxy:8080 (validates token + SAR)        ↓      DataStorage:8081 (X-Auth-Request-User header) ```  **Integration Tests**: Integration tests run without oauth-proxy. Use `testutil.NewMockUserTransport()` to inject mock `X-Auth-Request-User` headers directly.  **SOC2 Compliance**: - All legal hold operations attributed to authenticated users - Audit trail captures placed_by/released_by from X-Auth-Request-User - Unauthorized access blocked at oauth-proxy layer (defense-in-depth) 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from datetime import datetime

from pydantic import StrictBool, StrictStr, field_validator

from typing import List, Optional

from datastorage.models.audit_event_request import AuditEventRequest
from datastorage.models.audit_event_response import AuditEventResponse
from datastorage.models.audit_events_query_response import AuditEventsQueryResponse
from datastorage.models.audit_export_response import AuditExportResponse
from datastorage.models.batch_audit_event_response import BatchAuditEventResponse
from datastorage.models.list_legal_holds200_response import ListLegalHolds200Response
from datastorage.models.list_legal_holds200_response_holds_inner import ListLegalHolds200ResponseHoldsInner
from datastorage.models.notification_audit import NotificationAudit
from datastorage.models.notification_audit_response import NotificationAuditResponse
from datastorage.models.place_legal_hold_request import PlaceLegalHoldRequest
from datastorage.models.release_legal_hold200_response import ReleaseLegalHold200Response
from datastorage.models.release_legal_hold_request import ReleaseLegalHoldRequest

from datastorage.api_client import ApiClient
from datastorage.api_response import ApiResponse
from datastorage.rest import RESTResponseType


class AuditWriteAPIApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_audit_event(
        self,
        audit_event_request: AuditEventRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditEventResponse:
        """Create unified audit event

        Persists a unified audit event to the audit_events table (ADR-034).  **Business Requirement**: BR-STORAGE-033 (Unified audit trail)  **Behavior**: - Success: Returns 201 Created with event_id - Validation Error: Returns 400 Bad Request (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009) 

        :param audit_event_request: (required)
        :type audit_event_request: AuditEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_event_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AuditEventResponse",
            '202': "AuditEventResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '403': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_audit_event_with_http_info(
        self,
        audit_event_request: AuditEventRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditEventResponse]:
        """Create unified audit event

        Persists a unified audit event to the audit_events table (ADR-034).  **Business Requirement**: BR-STORAGE-033 (Unified audit trail)  **Behavior**: - Success: Returns 201 Created with event_id - Validation Error: Returns 400 Bad Request (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009) 

        :param audit_event_request: (required)
        :type audit_event_request: AuditEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_event_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AuditEventResponse",
            '202': "AuditEventResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '403': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_audit_event_without_preload_content(
        self,
        audit_event_request: AuditEventRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create unified audit event

        Persists a unified audit event to the audit_events table (ADR-034).  **Business Requirement**: BR-STORAGE-033 (Unified audit trail)  **Behavior**: - Success: Returns 201 Created with event_id - Validation Error: Returns 400 Bad Request (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009) 

        :param audit_event_request: (required)
        :type audit_event_request: AuditEventRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_event_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "AuditEventResponse",
            '202': "AuditEventResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '403': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_audit_event_serialize(
        self,
        audit_event_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if audit_event_request is not None:
            _body_params = audit_event_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/problem+json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/audit/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_audit_events_batch(
        self,
        audit_event_request: List[AuditEventRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BatchAuditEventResponse:
        """Create audit events batch

        Write multiple audit events in a single request

        :param audit_event_request: (required)
        :type audit_event_request: List[AuditEventRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_events_batch_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAuditEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_audit_events_batch_with_http_info(
        self,
        audit_event_request: List[AuditEventRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BatchAuditEventResponse]:
        """Create audit events batch

        Write multiple audit events in a single request

        :param audit_event_request: (required)
        :type audit_event_request: List[AuditEventRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_events_batch_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAuditEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_audit_events_batch_without_preload_content(
        self,
        audit_event_request: List[AuditEventRequest],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create audit events batch

        Write multiple audit events in a single request

        :param audit_event_request: (required)
        :type audit_event_request: List[AuditEventRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_events_batch_serialize(
            audit_event_request=audit_event_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "BatchAuditEventResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_audit_events_batch_serialize(
        self,
        audit_event_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
            'AuditEventRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if audit_event_request is not None:
            _body_params = audit_event_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/audit/events/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_notification_audit(
        self,
        notification_audit: NotificationAudit,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationAuditResponse:
        """Create notification audit record

        Persists a notification delivery attempt audit record.  **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)  **Behavior**: - Success: Returns 201 Created with created record - Validation Error: Returns 400 Bad Request (RFC 7807) - Duplicate: Returns 409 Conflict (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)  **Metrics Emitted** (GAP-10): - `datastorage_audit_traces_total{service=\"notification\", status=\"success|failure|dlq_fallback\"}` - `datastorage_audit_lag_seconds{service=\"notification\"}` - `datastorage_write_duration_seconds{table=\"notification_audit\"}` - `datastorage_validation_failures_total{field=\"...\", reason=\"...\"}` 

        :param notification_audit: (required)
        :type notification_audit: NotificationAudit
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_audit_serialize(
            notification_audit=notification_audit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NotificationAuditResponse",
            '202': "CreateNotificationAudit202Response",
            '400': "RFC7807Problem",
            '409': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_notification_audit_with_http_info(
        self,
        notification_audit: NotificationAudit,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationAuditResponse]:
        """Create notification audit record

        Persists a notification delivery attempt audit record.  **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)  **Behavior**: - Success: Returns 201 Created with created record - Validation Error: Returns 400 Bad Request (RFC 7807) - Duplicate: Returns 409 Conflict (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)  **Metrics Emitted** (GAP-10): - `datastorage_audit_traces_total{service=\"notification\", status=\"success|failure|dlq_fallback\"}` - `datastorage_audit_lag_seconds{service=\"notification\"}` - `datastorage_write_duration_seconds{table=\"notification_audit\"}` - `datastorage_validation_failures_total{field=\"...\", reason=\"...\"}` 

        :param notification_audit: (required)
        :type notification_audit: NotificationAudit
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_audit_serialize(
            notification_audit=notification_audit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NotificationAuditResponse",
            '202': "CreateNotificationAudit202Response",
            '400': "RFC7807Problem",
            '409': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_notification_audit_without_preload_content(
        self,
        notification_audit: NotificationAudit,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create notification audit record

        Persists a notification delivery attempt audit record.  **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)  **Behavior**: - Success: Returns 201 Created with created record - Validation Error: Returns 400 Bad Request (RFC 7807) - Duplicate: Returns 409 Conflict (RFC 7807) - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)  **Metrics Emitted** (GAP-10): - `datastorage_audit_traces_total{service=\"notification\", status=\"success|failure|dlq_fallback\"}` - `datastorage_audit_lag_seconds{service=\"notification\"}` - `datastorage_write_duration_seconds{table=\"notification_audit\"}` - `datastorage_validation_failures_total{field=\"...\", reason=\"...\"}` 

        :param notification_audit: (required)
        :type notification_audit: NotificationAudit
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_audit_serialize(
            notification_audit=notification_audit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "NotificationAuditResponse",
            '202': "CreateNotificationAudit202Response",
            '400': "RFC7807Problem",
            '409': "RFC7807Problem",
            '500': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_notification_audit_serialize(
        self,
        notification_audit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if notification_audit is not None:
            _body_params = notification_audit


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/problem+json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/audit/notifications',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def export_audit_events(
        self,
        start_time: Annotated[Optional[datetime], Field(description="Start of time range (ISO 8601)")] = None,
        end_time: Annotated[Optional[datetime], Field(description="End of time range (ISO 8601)")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Export format (json or csv)")] = None,
        include_detached_signature: Annotated[Optional[StrictBool], Field(description="Include detached signature file in response")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Pagination offset")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Maximum records per export")] = None,
        redact_pii: Annotated[Optional[StrictBool], Field(description="Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditExportResponse:
        """Export audit events with digital signature

        Exports audit events matching the specified filters with cryptographic signatures for tamper detection and compliance verification.  **Business Requirement**: BR-AUDIT-007 (Audit Export) **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)  **Behavior**: - Success: Returns 200 OK with signed export (JSON or CSV) - Validation Error: Returns 400 Bad Request (invalid date range, etc.) - Unauthorized: Returns 401 if X-Auth-Request-User header missing - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)  **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)  **Export Formats**: - JSON: Complete event data with hash chain verification - CSV: Flattened tabular format for spreadsheet analysis  **Hash Chain Verification**: - Each export includes hash chain integrity status - Tampered events flagged with `hash_chain_valid: false` - Chain verification performed at export time  **Digital Signature**: - Export signed with service x509 certificate - Signature included in `export_metadata.signature` field - Detached signature available via `include_detached_signature=true`  **Pagination**: - Use `offset` and `limit` for large result sets - Maximum limit: 10,000 events per export - Signature covers ALL pages (use same query for verification)  **Metrics Emitted**: - `datastorage_export_successes_total{format=\"json|csv\"}` - `datastorage_export_failures_total{reason=\"unauthorized|validation|...\"}` 

        :param start_time: Start of time range (ISO 8601)
        :type start_time: datetime
        :param end_time: End of time range (ISO 8601)
        :type end_time: datetime
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param event_category: Filter by event category
        :type event_category: str
        :param format: Export format (json or csv)
        :type format: str
        :param include_detached_signature: Include detached signature file in response
        :type include_detached_signature: bool
        :param offset: Pagination offset
        :type offset: int
        :param limit: Maximum records per export
        :type limit: int
        :param redact_pii: Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. 
        :type redact_pii: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_audit_events_serialize(
            start_time=start_time,
            end_time=end_time,
            correlation_id=correlation_id,
            event_category=event_category,
            format=format,
            include_detached_signature=include_detached_signature,
            offset=offset,
            limit=limit,
            redact_pii=redact_pii,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditExportResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '413': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def export_audit_events_with_http_info(
        self,
        start_time: Annotated[Optional[datetime], Field(description="Start of time range (ISO 8601)")] = None,
        end_time: Annotated[Optional[datetime], Field(description="End of time range (ISO 8601)")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Export format (json or csv)")] = None,
        include_detached_signature: Annotated[Optional[StrictBool], Field(description="Include detached signature file in response")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Pagination offset")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Maximum records per export")] = None,
        redact_pii: Annotated[Optional[StrictBool], Field(description="Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditExportResponse]:
        """Export audit events with digital signature

        Exports audit events matching the specified filters with cryptographic signatures for tamper detection and compliance verification.  **Business Requirement**: BR-AUDIT-007 (Audit Export) **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)  **Behavior**: - Success: Returns 200 OK with signed export (JSON or CSV) - Validation Error: Returns 400 Bad Request (invalid date range, etc.) - Unauthorized: Returns 401 if X-Auth-Request-User header missing - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)  **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)  **Export Formats**: - JSON: Complete event data with hash chain verification - CSV: Flattened tabular format for spreadsheet analysis  **Hash Chain Verification**: - Each export includes hash chain integrity status - Tampered events flagged with `hash_chain_valid: false` - Chain verification performed at export time  **Digital Signature**: - Export signed with service x509 certificate - Signature included in `export_metadata.signature` field - Detached signature available via `include_detached_signature=true`  **Pagination**: - Use `offset` and `limit` for large result sets - Maximum limit: 10,000 events per export - Signature covers ALL pages (use same query for verification)  **Metrics Emitted**: - `datastorage_export_successes_total{format=\"json|csv\"}` - `datastorage_export_failures_total{reason=\"unauthorized|validation|...\"}` 

        :param start_time: Start of time range (ISO 8601)
        :type start_time: datetime
        :param end_time: End of time range (ISO 8601)
        :type end_time: datetime
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param event_category: Filter by event category
        :type event_category: str
        :param format: Export format (json or csv)
        :type format: str
        :param include_detached_signature: Include detached signature file in response
        :type include_detached_signature: bool
        :param offset: Pagination offset
        :type offset: int
        :param limit: Maximum records per export
        :type limit: int
        :param redact_pii: Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. 
        :type redact_pii: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_audit_events_serialize(
            start_time=start_time,
            end_time=end_time,
            correlation_id=correlation_id,
            event_category=event_category,
            format=format,
            include_detached_signature=include_detached_signature,
            offset=offset,
            limit=limit,
            redact_pii=redact_pii,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditExportResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '413': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def export_audit_events_without_preload_content(
        self,
        start_time: Annotated[Optional[datetime], Field(description="Start of time range (ISO 8601)")] = None,
        end_time: Annotated[Optional[datetime], Field(description="End of time range (ISO 8601)")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Export format (json or csv)")] = None,
        include_detached_signature: Annotated[Optional[StrictBool], Field(description="Include detached signature file in response")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Pagination offset")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Maximum records per export")] = None,
        redact_pii: Annotated[Optional[StrictBool], Field(description="Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export audit events with digital signature

        Exports audit events matching the specified filters with cryptographic signatures for tamper detection and compliance verification.  **Business Requirement**: BR-AUDIT-007 (Audit Export) **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)  **Behavior**: - Success: Returns 200 OK with signed export (JSON or CSV) - Validation Error: Returns 400 Bad Request (invalid date range, etc.) - Unauthorized: Returns 401 if X-Auth-Request-User header missing - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)  **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)  **Export Formats**: - JSON: Complete event data with hash chain verification - CSV: Flattened tabular format for spreadsheet analysis  **Hash Chain Verification**: - Each export includes hash chain integrity status - Tampered events flagged with `hash_chain_valid: false` - Chain verification performed at export time  **Digital Signature**: - Export signed with service x509 certificate - Signature included in `export_metadata.signature` field - Detached signature available via `include_detached_signature=true`  **Pagination**: - Use `offset` and `limit` for large result sets - Maximum limit: 10,000 events per export - Signature covers ALL pages (use same query for verification)  **Metrics Emitted**: - `datastorage_export_successes_total{format=\"json|csv\"}` - `datastorage_export_failures_total{reason=\"unauthorized|validation|...\"}` 

        :param start_time: Start of time range (ISO 8601)
        :type start_time: datetime
        :param end_time: End of time range (ISO 8601)
        :type end_time: datetime
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param event_category: Filter by event category
        :type event_category: str
        :param format: Export format (json or csv)
        :type format: str
        :param include_detached_signature: Include detached signature file in response
        :type include_detached_signature: bool
        :param offset: Pagination offset
        :type offset: int
        :param limit: Maximum records per export
        :type limit: int
        :param redact_pii: Enable PII (Personally Identifiable Information) redaction in audit export.  **SOC2 Privacy Compliance**: Redacts sensitive data to comply with data minimization principles.  **Redaction Rules**: - Emails: user@domain.com → u***@d***.com - IP Addresses: 192.168.1.1 → 192.***.*.*** - Phone Numbers: +1-555-1234 → +1-***-****  **Fields Redacted**: - event_data.user_email - event_data.source_ip - event_data.phone_number - exported_by (if email)  **Use Cases**: - Sharing exports with external auditors - Compliance reports for legal teams - Anonymized analysis and research  Note: Redaction occurs AFTER hash chain verification to maintain integrity. 
        :type redact_pii: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_audit_events_serialize(
            start_time=start_time,
            end_time=end_time,
            correlation_id=correlation_id,
            event_category=event_category,
            format=format,
            include_detached_signature=include_detached_signature,
            offset=offset,
            limit=limit,
            redact_pii=redact_pii,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditExportResponse",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '413': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_audit_events_serialize(
        self,
        start_time,
        end_time,
        correlation_id,
        event_category,
        format,
        include_detached_signature,
        offset,
        limit,
        redact_pii,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_time is not None:
            if isinstance(start_time, datetime):
                _query_params.append(
                    (
                        'start_time',
                        start_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('start_time', start_time))
            
        if end_time is not None:
            if isinstance(end_time, datetime):
                _query_params.append(
                    (
                        'end_time',
                        end_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('end_time', end_time))
            
        if correlation_id is not None:
            
            _query_params.append(('correlation_id', correlation_id))
            
        if event_category is not None:
            
            _query_params.append(('event_category', event_category))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        if include_detached_signature is not None:
            
            _query_params.append(('include_detached_signature', include_detached_signature))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if redact_pii is not None:
            
            _query_params.append(('redact_pii', redact_pii))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/problem+json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/audit/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_legal_holds(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListLegalHolds200Response:
        """List all active legal holds

        Returns a list of all active legal holds across all audit events.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with array of active legal holds - No holds: Returns empty array  **Authorization**: No authentication required (read-only operation)  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"list\"}` 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_legal_holds_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_legal_holds_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListLegalHolds200Response]:
        """List all active legal holds

        Returns a list of all active legal holds across all audit events.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with array of active legal holds - No holds: Returns empty array  **Authorization**: No authentication required (read-only operation)  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"list\"}` 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_legal_holds_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_legal_holds_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all active legal holds

        Returns a list of all active legal holds across all audit events.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with array of active legal holds - No holds: Returns empty array  **Authorization**: No authentication required (read-only operation)  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"list\"}` 

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_legal_holds_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_legal_holds_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/audit/legal-hold',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def place_legal_hold(
        self,
        place_legal_hold_request: PlaceLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListLegalHolds200ResponseHoldsInner:
        """Place legal hold on audit events

        Places a legal hold on all audit events for a given correlation_id. Events with legal hold cannot be deleted (enforced by database trigger).  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)  **Behavior**: - Success: Returns 200 OK with legal hold metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if correlation_id doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who placed the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"place\"}` - `datastorage_legal_hold_failures_total{reason=\"missing_correlation_id|unauthorized|...\"}` 

        :param place_legal_hold_request: (required)
        :type place_legal_hold_request: PlaceLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_legal_hold_serialize(
            place_legal_hold_request=place_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200ResponseHoldsInner",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def place_legal_hold_with_http_info(
        self,
        place_legal_hold_request: PlaceLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListLegalHolds200ResponseHoldsInner]:
        """Place legal hold on audit events

        Places a legal hold on all audit events for a given correlation_id. Events with legal hold cannot be deleted (enforced by database trigger).  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)  **Behavior**: - Success: Returns 200 OK with legal hold metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if correlation_id doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who placed the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"place\"}` - `datastorage_legal_hold_failures_total{reason=\"missing_correlation_id|unauthorized|...\"}` 

        :param place_legal_hold_request: (required)
        :type place_legal_hold_request: PlaceLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_legal_hold_serialize(
            place_legal_hold_request=place_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200ResponseHoldsInner",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def place_legal_hold_without_preload_content(
        self,
        place_legal_hold_request: PlaceLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Place legal hold on audit events

        Places a legal hold on all audit events for a given correlation_id. Events with legal hold cannot be deleted (enforced by database trigger).  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)  **Behavior**: - Success: Returns 200 OK with legal hold metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if correlation_id doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who placed the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"place\"}` - `datastorage_legal_hold_failures_total{reason=\"missing_correlation_id|unauthorized|...\"}` 

        :param place_legal_hold_request: (required)
        :type place_legal_hold_request: PlaceLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._place_legal_hold_serialize(
            place_legal_hold_request=place_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListLegalHolds200ResponseHoldsInner",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _place_legal_hold_serialize(
        self,
        place_legal_hold_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if place_legal_hold_request is not None:
            _body_params = place_legal_hold_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/problem+json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/audit/legal-hold',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def query_audit_events(
        self,
        event_type: Annotated[Optional[StrictStr], Field(description="Filter by event type (ADR-034)")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category (ADR-034)")] = None,
        event_outcome: Annotated[Optional[StrictStr], Field(description="Filter by event outcome (ADR-034)")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Filter by severity level")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        since: Annotated[Optional[StrictStr], Field(description="Start time (relative like \"24h\" or absolute RFC3339)")] = None,
        until: Annotated[Optional[StrictStr], Field(description="End time (absolute RFC3339)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Page size (1-1000, default 50)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page offset (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditEventsQueryResponse:
        """Query audit events

        Query audit events with filters and pagination

        :param event_type: Filter by event type (ADR-034)
        :type event_type: str
        :param event_category: Filter by event category (ADR-034)
        :type event_category: str
        :param event_outcome: Filter by event outcome (ADR-034)
        :type event_outcome: str
        :param severity: Filter by severity level
        :type severity: str
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param since: Start time (relative like \"24h\" or absolute RFC3339)
        :type since: str
        :param until: End time (absolute RFC3339)
        :type until: str
        :param limit: Page size (1-1000, default 50)
        :type limit: int
        :param offset: Page offset (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_audit_events_serialize(
            event_type=event_type,
            event_category=event_category,
            event_outcome=event_outcome,
            severity=severity,
            correlation_id=correlation_id,
            since=since,
            until=until,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditEventsQueryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def query_audit_events_with_http_info(
        self,
        event_type: Annotated[Optional[StrictStr], Field(description="Filter by event type (ADR-034)")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category (ADR-034)")] = None,
        event_outcome: Annotated[Optional[StrictStr], Field(description="Filter by event outcome (ADR-034)")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Filter by severity level")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        since: Annotated[Optional[StrictStr], Field(description="Start time (relative like \"24h\" or absolute RFC3339)")] = None,
        until: Annotated[Optional[StrictStr], Field(description="End time (absolute RFC3339)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Page size (1-1000, default 50)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page offset (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditEventsQueryResponse]:
        """Query audit events

        Query audit events with filters and pagination

        :param event_type: Filter by event type (ADR-034)
        :type event_type: str
        :param event_category: Filter by event category (ADR-034)
        :type event_category: str
        :param event_outcome: Filter by event outcome (ADR-034)
        :type event_outcome: str
        :param severity: Filter by severity level
        :type severity: str
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param since: Start time (relative like \"24h\" or absolute RFC3339)
        :type since: str
        :param until: End time (absolute RFC3339)
        :type until: str
        :param limit: Page size (1-1000, default 50)
        :type limit: int
        :param offset: Page offset (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_audit_events_serialize(
            event_type=event_type,
            event_category=event_category,
            event_outcome=event_outcome,
            severity=severity,
            correlation_id=correlation_id,
            since=since,
            until=until,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditEventsQueryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def query_audit_events_without_preload_content(
        self,
        event_type: Annotated[Optional[StrictStr], Field(description="Filter by event type (ADR-034)")] = None,
        event_category: Annotated[Optional[StrictStr], Field(description="Filter by event category (ADR-034)")] = None,
        event_outcome: Annotated[Optional[StrictStr], Field(description="Filter by event outcome (ADR-034)")] = None,
        severity: Annotated[Optional[StrictStr], Field(description="Filter by severity level")] = None,
        correlation_id: Annotated[Optional[StrictStr], Field(description="Filter by correlation ID")] = None,
        since: Annotated[Optional[StrictStr], Field(description="Start time (relative like \"24h\" or absolute RFC3339)")] = None,
        until: Annotated[Optional[StrictStr], Field(description="End time (absolute RFC3339)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]], Field(description="Page size (1-1000, default 50)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Page offset (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query audit events

        Query audit events with filters and pagination

        :param event_type: Filter by event type (ADR-034)
        :type event_type: str
        :param event_category: Filter by event category (ADR-034)
        :type event_category: str
        :param event_outcome: Filter by event outcome (ADR-034)
        :type event_outcome: str
        :param severity: Filter by severity level
        :type severity: str
        :param correlation_id: Filter by correlation ID
        :type correlation_id: str
        :param since: Start time (relative like \"24h\" or absolute RFC3339)
        :type since: str
        :param until: End time (absolute RFC3339)
        :type until: str
        :param limit: Page size (1-1000, default 50)
        :type limit: int
        :param offset: Page offset (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._query_audit_events_serialize(
            event_type=event_type,
            event_category=event_category,
            event_outcome=event_outcome,
            severity=severity,
            correlation_id=correlation_id,
            since=since,
            until=until,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditEventsQueryResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _query_audit_events_serialize(
        self,
        event_type,
        event_category,
        event_outcome,
        severity,
        correlation_id,
        since,
        until,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if event_type is not None:
            
            _query_params.append(('event_type', event_type))
            
        if event_category is not None:
            
            _query_params.append(('event_category', event_category))
            
        if event_outcome is not None:
            
            _query_params.append(('event_outcome', event_outcome))
            
        if severity is not None:
            
            _query_params.append(('severity', severity))
            
        if correlation_id is not None:
            
            _query_params.append(('correlation_id', correlation_id))
            
        if since is not None:
            
            _query_params.append(('since', since))
            
        if until is not None:
            
            _query_params.append(('until', until))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/audit/events',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def release_legal_hold(
        self,
        correlation_id: Annotated[StrictStr, Field(description="Correlation ID of events to release legal hold from")],
        release_legal_hold_request: ReleaseLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReleaseLegalHold200Response:
        """Release legal hold on audit events

        Releases a legal hold on all audit events for a given correlation_id. Events can be deleted after legal hold is released.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with release metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if legal hold doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who released the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"release\"}` - `datastorage_legal_hold_failures_total{reason=\"unauthorized|not_found|...\"}` 

        :param correlation_id: Correlation ID of events to release legal hold from (required)
        :type correlation_id: str
        :param release_legal_hold_request: (required)
        :type release_legal_hold_request: ReleaseLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._release_legal_hold_serialize(
            correlation_id=correlation_id,
            release_legal_hold_request=release_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReleaseLegalHold200Response",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def release_legal_hold_with_http_info(
        self,
        correlation_id: Annotated[StrictStr, Field(description="Correlation ID of events to release legal hold from")],
        release_legal_hold_request: ReleaseLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReleaseLegalHold200Response]:
        """Release legal hold on audit events

        Releases a legal hold on all audit events for a given correlation_id. Events can be deleted after legal hold is released.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with release metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if legal hold doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who released the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"release\"}` - `datastorage_legal_hold_failures_total{reason=\"unauthorized|not_found|...\"}` 

        :param correlation_id: Correlation ID of events to release legal hold from (required)
        :type correlation_id: str
        :param release_legal_hold_request: (required)
        :type release_legal_hold_request: ReleaseLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._release_legal_hold_serialize(
            correlation_id=correlation_id,
            release_legal_hold_request=release_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReleaseLegalHold200Response",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def release_legal_hold_without_preload_content(
        self,
        correlation_id: Annotated[StrictStr, Field(description="Correlation ID of events to release legal hold from")],
        release_legal_hold_request: ReleaseLegalHoldRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Release legal hold on audit events

        Releases a legal hold on all audit events for a given correlation_id. Events can be deleted after legal hold is released.  **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention) **SOC2 Gap**: Gap #8 (Legal Hold enforcement)  **Behavior**: - Success: Returns 200 OK with release metadata - Validation Error: Returns 400 Bad Request (RFC 7807) - Not Found: Returns 404 Not Found if legal hold doesn't exist - Unauthorized: Returns 401 if X-User-ID header missing  **Authorization**: Requires X-User-ID header to track who released the hold  **Metrics Emitted**: - `datastorage_legal_hold_successes_total{operation=\"release\"}` - `datastorage_legal_hold_failures_total{reason=\"unauthorized|not_found|...\"}` 

        :param correlation_id: Correlation ID of events to release legal hold from (required)
        :type correlation_id: str
        :param release_legal_hold_request: (required)
        :type release_legal_hold_request: ReleaseLegalHoldRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._release_legal_hold_serialize(
            correlation_id=correlation_id,
            release_legal_hold_request=release_legal_hold_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReleaseLegalHold200Response",
            '400': "RFC7807Problem",
            '401': "RFC7807Problem",
            '404': "RFC7807Problem",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _release_legal_hold_serialize(
        self,
        correlation_id,
        release_legal_hold_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if correlation_id is not None:
            _path_params['correlation_id'] = correlation_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if release_legal_hold_request is not None:
            _body_params = release_legal_hold_request


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json', 
                'application/problem+json'
            ]
        )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v1/audit/legal-hold/{correlation_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


