package storage

import (
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/jordigilh/kubernaut/pkg/storage/vector"
	. "github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to storage_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Vector Types Unit Tests", func() {
	Context("ActionPattern Type", func() {
		var pattern *vector.ActionPattern

		BeforeEach(func() {
			pattern = CreateTestActionPattern("test-pattern-types")
		})

		It("should have all required fields populated", func() {
			Expect(pattern.ID).To(Equal("test-pattern-types"))
			Expect(pattern.ActionType).To(Equal("scale_deployment"))
			Expect(pattern.AlertName).To(Equal("HighMemoryUsage"))
			Expect(pattern.AlertSeverity).To(Equal("critical"))
			Expect(pattern.Namespace).To(Equal("production"))
			Expect(pattern.ResourceType).To(Equal("deployment"))
			Expect(pattern.ResourceName).To(Equal("web-server"))
		})

		It("should have valid action parameters", func() {
			Expect(pattern.ActionParameters).ToNot(BeNil(), "Action parameters should not be nil")
			Expect(pattern.ActionParameters).To(HaveKey("replicas"))
			Expect(pattern.ActionParameters["replicas"]).To(Equal(3))
		})

		It("should have context labels", func() {
			Expect(pattern.ContextLabels).ToNot(BeNil(), "Context labels should not be nil")
			Expect(pattern.ContextLabels).To(HaveKey("app"))
			Expect(pattern.ContextLabels).To(HaveKey("version"))
			Expect(pattern.ContextLabels["app"]).To(Equal("test"))
		})

		It("should have pre and post conditions", func() {
			Expect(pattern.PreConditions).ToNot(BeNil(), "Pre conditions should not be nil")
			Expect(pattern.PostConditions).ToNot(BeNil(), "Post conditions should not be nil")
			Expect(pattern.PreConditions).To(HaveKey("current_replicas"))
			Expect(pattern.PostConditions).To(HaveKey("target_replicas"))
		})

		It("should have effectiveness data", func() {
			Expect(pattern.EffectivenessData).ToNot(BeNil(), "Effectiveness data should not be nil")
			Expect(pattern.EffectivenessData.Score).To(Equal(0.85))
			Expect(pattern.EffectivenessData.SuccessCount).To(Equal(8))
			Expect(pattern.EffectivenessData.FailureCount).To(Equal(2))
		})

		It("should have valid embedding", func() {
			Expect(pattern.Embedding).ToNot(BeNil(), "Embedding should not be nil")
			Expect(len(pattern.Embedding)).To(BeNumerically(">", 0), "Embedding should have elements")
			Expect(pattern.Embedding).To(Equal([]float64{0.1, 0.2, 0.3, 0.4, 0.5}))
		})

		It("should have timestamps", func() {
			Expect(pattern.CreatedAt).ToNot(BeZero(), "Created timestamp should be set")
			Expect(pattern.UpdatedAt).ToNot(BeZero(), "Updated timestamp should be set")
		})

		It("should have metadata", func() {
			Expect(pattern.Metadata).ToNot(BeNil(), "Metadata should not be nil")
			// Expect(pattern.Metadata).To(HaveKey("created_by")) // Not included in mock
			Expect(pattern.Metadata).To(HaveKey("source"))
		})
	})

	Context("EffectivenessData Type", func() {
		var effectiveness *vector.EffectivenessData

		BeforeEach(func() {
			effectiveness = &vector.EffectivenessData{
				Score:                0.75,
				SuccessCount:         8,
				FailureCount:         2,
				AverageExecutionTime: 45 * time.Second,
				SideEffectsCount:     1,
				RecurrenceRate:       0.2,
				CostImpact: &vector.CostImpact{
					ResourceCostDelta:   -50.0,
					OperationalCost:     10.0,
					SavingsPotential:    100.0,
					CostEfficiencyRatio: 2.5,
				},
				ContextualFactors: map[string]float64{
					"cpu_pressure":    0.7,
					"memory_pressure": 0.8,
					"network_load":    0.3,
				},
				LastAssessed: time.Now().Add(-2 * time.Hour),
			}
		})

		It("should have valid score metrics", func() {
			Expect(effectiveness.Score).To(BeNumerically(">=", 0.0))
			Expect(effectiveness.Score).To(BeNumerically("<=", 1.0))
			Expect(effectiveness.SuccessCount).To(BeNumerically(">=", 0))
			Expect(effectiveness.FailureCount).To(BeNumerically(">=", 0))
		})

		It("should have valid timing metrics", func() {
			Expect(effectiveness.AverageExecutionTime).To(BeNumerically(">", 0))
			Expect(effectiveness.LastAssessed).ToNot(BeZero())
		})

		It("should have cost impact data", func() {
			Expect(effectiveness.CostImpact).ToNot(BeNil())
			Expect(effectiveness.CostImpact.CostEfficiencyRatio).To(BeNumerically(">", 0))
		})

		It("should have contextual factors", func() {
			Expect(effectiveness.ContextualFactors).ToNot(BeNil())
			Expect(effectiveness.ContextualFactors).To(HaveKey("cpu_pressure"))
			Expect(effectiveness.ContextualFactors["cpu_pressure"]).To(BeNumerically(">=", 0))
		})

		It("should validate recurrence rate bounds", func() {
			Expect(effectiveness.RecurrenceRate).To(BeNumerically(">=", 0.0))
			Expect(effectiveness.RecurrenceRate).To(BeNumerically("<=", 1.0))
		})
	})

	Context("CostImpact Type", func() {
		var costImpact *vector.CostImpact

		BeforeEach(func() {
			costImpact = &vector.CostImpact{
				ResourceCostDelta:   -25.0, // Negative = savings
				OperationalCost:     5.0,   // Cost to execute action
				SavingsPotential:    50.0,  // Potential savings
				CostEfficiencyRatio: 10.0,  // Savings per dollar spent
			}
		})

		It("should have meaningful cost deltas", func() {
			Expect(costImpact.ResourceCostDelta).ToNot(Equal(0.0), "Cost delta should be meaningful")
			Expect(costImpact.OperationalCost).To(BeNumerically(">=", 0), "Operational cost should be non-negative")
		})

		It("should have positive savings potential", func() {
			Expect(costImpact.SavingsPotential).To(BeNumerically(">=", 0), "Savings potential should be non-negative")
		})

		It("should have valid efficiency ratio", func() {
			Expect(costImpact.CostEfficiencyRatio).ToNot(Equal(0.0), "Efficiency ratio should be meaningful")
		})
	})

	Context("SimilarPattern Type", func() {
		var similarPattern *vector.SimilarPattern

		BeforeEach(func() {
			pattern := CreateTestActionPattern("similar-test")
			similarPattern = &vector.SimilarPattern{
				Pattern:    pattern,
				Similarity: 0.85,
				Rank:       1,
			}
		})

		It("should have valid pattern reference", func() {
			Expect(similarPattern.Pattern).ToNot(BeNil(), "Pattern should not be nil")
			Expect(similarPattern.Pattern.ID).To(Equal("similar-test"))
		})

		It("should have valid similarity score", func() {
			Expect(similarPattern.Similarity).To(BeNumerically(">=", 0.0), "Similarity should be non-negative")
			Expect(similarPattern.Similarity).To(BeNumerically("<=", 1.0), "Similarity should be <= 1.0")
		})

		It("should have valid rank", func() {
			Expect(similarPattern.Rank).To(BeNumerically(">", 0), "Rank should be positive")
		})
	})

	Context("PatternAnalytics Type", func() {
		var analytics *vector.PatternAnalytics

		BeforeEach(func() {
			analytics = &vector.PatternAnalytics{
				TotalPatterns: 15,
				PatternsByActionType: map[string]int{
					"scale":   5,
					"restart": 4,
					"cleanup": 6,
				},
				PatternsBySeverity: map[string]int{
					"critical": 8,
					"warning":  7,
				},
				AverageEffectiveness: 0.78,
				TopPerformingPatterns: []*vector.ActionPattern{
					CreateTestActionPattern("top-1"),
					CreateTestActionPattern("top-2"),
				},
				RecentPatterns: []*vector.ActionPattern{
					CreateTestActionPattern("recent-1"),
					CreateTestActionPattern("recent-2"),
				},
				EffectivenessDistribution: map[string]int{
					"excellent": 3,
					"very_good": 5,
					"good":      4,
					"fair":      2,
					"poor":      1,
				},
				GeneratedAt: time.Now(),
			}
		})

		It("should have valid total pattern count", func() {
			Expect(analytics.TotalPatterns).To(BeNumerically(">=", 0), "Total patterns should be non-negative")
		})

		It("should have action type breakdown", func() {
			Expect(analytics.PatternsByActionType).ToNot(BeNil(), "Action type breakdown should not be nil")

			total := 0
			for _, count := range analytics.PatternsByActionType {
				Expect(count).To(BeNumerically(">", 0), "Action type counts should be positive")
				total += count
			}
			Expect(total).To(Equal(analytics.TotalPatterns), "Action type totals should match total patterns")
		})

		It("should have severity breakdown", func() {
			Expect(analytics.PatternsBySeverity).ToNot(BeNil(), "Severity breakdown should not be nil")

			for _, count := range analytics.PatternsBySeverity {
				Expect(count).To(BeNumerically(">", 0), "Severity counts should be positive")
			}
		})

		It("should have valid effectiveness metrics", func() {
			Expect(analytics.AverageEffectiveness).To(BeNumerically(">=", 0.0))
			Expect(analytics.AverageEffectiveness).To(BeNumerically("<=", 1.0))
		})

		It("should have top performing patterns", func() {
			Expect(analytics.TopPerformingPatterns).ToNot(BeNil(), "Top performers should not be nil")
			Expect(len(analytics.TopPerformingPatterns)).To(BeNumerically(">", 0), "Should have top performers")
		})

		It("should have recent patterns", func() {
			Expect(analytics.RecentPatterns).ToNot(BeNil(), "Recent patterns should not be nil")
			Expect(len(analytics.RecentPatterns)).To(BeNumerically(">", 0), "Should have recent patterns")
		})

		It("should have effectiveness distribution", func() {
			Expect(analytics.EffectivenessDistribution).ToNot(BeNil(), "Distribution should not be nil")

			expectedBuckets := []string{"excellent", "very_good", "good", "fair", "poor", "very_poor"}
			for bucket, count := range analytics.EffectivenessDistribution {
				Expect(bucket).To(BeElementOf(expectedBuckets), "Should use standard effectiveness buckets")
				Expect(count).To(BeNumerically(">=", 0), "Distribution counts should be non-negative")
			}
		})

		It("should have generation timestamp", func() {
			Expect(analytics.GeneratedAt).ToNot(BeZero(), "Generation timestamp should be set")
			Expect(analytics.GeneratedAt).To(BeTemporally("<=", time.Now()), "Generation time should not be in future")
		})
	})

	Context("VectorSearchQuery Type", func() {
		var query *vector.VectorSearchQuery

		BeforeEach(func() {
			query = &vector.VectorSearchQuery{
				QueryText:     "memory alert production",
				QueryVector:   []float64{0.1, 0.2, 0.3},
				ActionTypes:   []string{"scale", "restart"},
				Severities:    []string{"critical", "warning"},
				Namespaces:    []string{"production", "staging"},
				ResourceTypes: []string{"deployment", "pod"},
				DateRange: &vector.DateRange{
					From: time.Now().Add(-24 * time.Hour),
					To:   time.Now(),
				},
				Metadata: map[string]interface{}{
					"source": "pattern_detection",
				},
				Limit:               10,
				SimilarityThreshold: 0.7,
				IncludeMetadata:     true,
			}
		})

		It("should support text-based queries", func() {
			Expect(query.QueryText).ToNot(BeEmpty(), "Query text should be provided")
		})

		It("should support vector-based queries", func() {
			Expect(query.QueryVector).ToNot(BeEmpty(), "Query vector should be provided")
			Expect(len(query.QueryVector)).To(BeNumerically(">", 0), "Query vector should have dimensions")
		})

		It("should support filtering by action types", func() {
			Expect(query.ActionTypes).ToNot(BeEmpty(), "Action type filters should be provided")
			Expect(query.ActionTypes).To(ContainElement("scale"))
			Expect(query.ActionTypes).To(ContainElement("restart"))
		})

		It("should support filtering by severities", func() {
			Expect(query.Severities).ToNot(BeEmpty(), "Severity filters should be provided")
			Expect(query.Severities).To(ContainElement("critical"))
			Expect(query.Severities).To(ContainElement("warning"))
		})

		It("should support filtering by namespaces", func() {
			Expect(query.Namespaces).ToNot(BeEmpty(), "Namespace filters should be provided")
			Expect(query.Namespaces).To(ContainElement("production"))
		})

		It("should support date range filtering", func() {
			Expect(query.DateRange).ToNot(BeNil(), "Date range should be provided")
			Expect(query.DateRange.From).To(BeTemporally("<", query.DateRange.To), "From should be before To")
		})

		It("should have valid search parameters", func() {
			Expect(query.Limit).To(BeNumerically(">", 0), "Limit should be positive")
			Expect(query.SimilarityThreshold).To(BeNumerically(">=", 0.0), "Threshold should be non-negative")
			Expect(query.SimilarityThreshold).To(BeNumerically("<=", 1.0), "Threshold should be <= 1.0")
		})

		It("should support metadata filtering", func() {
			Expect(query.Metadata).ToNot(BeNil(), "Metadata filters should be provided")
			Expect(query.Metadata).To(HaveKey("source"))
		})

		It("should support metadata inclusion flag", func() {
			Expect(query.IncludeMetadata).To(BeTrue(), "Metadata inclusion should be configurable")
		})
	})

	Context("DateRange Type", func() {
		var dateRange *vector.DateRange

		BeforeEach(func() {
			dateRange = &vector.DateRange{
				From: time.Now().Add(-7 * 24 * time.Hour), // 7 days ago
				To:   time.Now(),
			}
		})

		It("should have valid time range", func() {
			Expect(dateRange.From).ToNot(BeZero(), "From date should be set")
			Expect(dateRange.To).ToNot(BeZero(), "To date should be set")
			Expect(dateRange.From).To(BeTemporally("<", dateRange.To), "From should be before To")
		})

		It("should support same-day ranges", func() {
			sameDayRange := &vector.DateRange{
				From: time.Now().Truncate(24 * time.Hour),
				To:   time.Now().Truncate(24 * time.Hour).Add(24 * time.Hour),
			}

			Expect(sameDayRange.From).To(BeTemporally("<=", sameDayRange.To), "Same day range should be valid")
		})
	})

	Context("Cache Types", func() {
		Context("CacheStats Type", func() {
			var stats *vector.CacheStats

			BeforeEach(func() {
				stats = &vector.CacheStats{
					Hits:      150,
					Misses:    50,
					TotalKeys: 100,
					CacheType: "memory",
				}
				stats.CalculateHitRate()
			})

			It("should calculate hit rate correctly", func() {
				expectedHitRate := 150.0 / 200.0 // 0.75
				Expect(stats.HitRate).To(BeNumerically("~", expectedHitRate, 0.01))
			})

			It("should have valid statistics", func() {
				Expect(stats.Hits).To(BeNumerically(">=", 0), "Hits should be non-negative")
				Expect(stats.Misses).To(BeNumerically(">=", 0), "Misses should be non-negative")
				Expect(stats.TotalKeys).To(BeNumerically(">=", 0), "Total keys should be non-negative")
				Expect(stats.CacheType).ToNot(BeEmpty(), "Cache type should be specified")
			})

			It("should handle zero operations gracefully", func() {
				zeroStats := &vector.CacheStats{
					Hits:   0,
					Misses: 0,
				}
				zeroStats.CalculateHitRate()

				Expect(zeroStats.HitRate).To(Equal(0.0), "Hit rate should be 0 for no operations")
			})

			It("should handle perfect hit rate", func() {
				perfectStats := &vector.CacheStats{
					Hits:   100,
					Misses: 0,
				}
				perfectStats.CalculateHitRate()

				Expect(perfectStats.HitRate).To(Equal(1.0), "Hit rate should be 1.0 for all hits")
			})
		})

		Context("Cache Key Generation", func() {
			It("should generate consistent cache keys", func() {
				prefix := "test"
				input := "sample input"

				key1 := vector.CacheKey(prefix, input)
				key2 := vector.CacheKey(prefix, input)

				Expect(key1).To(Equal(key2), "Should generate consistent cache keys")
				Expect(key1).To(ContainSubstring(prefix), "Should include prefix")
				Expect(key1).To(ContainSubstring(input), "Should include input")
			})

			It("should generate different keys for different inputs", func() {
				prefix := "test"
				input1 := "first input"
				input2 := "second input"

				key1 := vector.CacheKey(prefix, input1)
				key2 := vector.CacheKey(prefix, input2)

				Expect(key1).ToNot(Equal(key2), "Should generate different keys for different inputs")
			})

			It("should handle empty inputs", func() {
				key1 := vector.CacheKey("prefix", "")
				key2 := vector.CacheKey("", "input")

				Expect(key1).ToNot(BeEmpty(), "Should handle empty input")
				Expect(key2).ToNot(BeEmpty(), "Should handle empty prefix")
			})
		})
	})

	Context("VectorData Type", func() {
		var vectorData *vector.VectorData

		BeforeEach(func() {
			vectorData = &vector.VectorData{
				ID:        "vector-data-test",
				Text:      "sample text for embedding",
				Embedding: []float64{0.1, 0.2, 0.3, 0.4},
				Metadata: map[string]interface{}{
					"source":    "unit_test",
					"timestamp": time.Now().Unix(),
				},
				Source:    "test_suite",
				Timestamp: time.Now(),
			}
		})

		It("should have required identification", func() {
			Expect(vectorData.ID).ToNot(BeEmpty(), "ID should not be empty")
		})

		It("should support text content", func() {
			Expect(vectorData.Text).ToNot(BeEmpty(), "Text should be provided")
		})

		It("should have valid embedding", func() {
			Expect(vectorData.Embedding).ToNot(BeEmpty(), "Embedding should be provided")
			Expect(len(vectorData.Embedding)).To(BeNumerically(">", 0), "Embedding should have dimensions")
		})

		It("should support metadata", func() {
			Expect(vectorData.Metadata).ToNot(BeNil(), "Metadata should be provided")
			Expect(vectorData.Metadata).To(HaveKey("source"))
		})

		It("should have timestamp", func() {
			Expect(vectorData.Timestamp).ToNot(BeZero(), "Timestamp should be set")
		})
	})
})
