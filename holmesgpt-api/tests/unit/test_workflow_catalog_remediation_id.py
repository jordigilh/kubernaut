"""
Unit tests for remediation_id propagation in workflow catalog tool

Business Requirement: BR-AUDIT-001, BR-INTEGRATION-003
Design Decision: DD-WORKFLOW-002 v2.4, DD-WORKFLOW-014 v2.0
Authority: REMEDIATION-ID-PROPAGATION-IMPLEMENTATION_PLAN_V1.4.md Day 1 AM

TDD Phase: RED (failing tests)

⚠️ CRITICAL: DD-WORKFLOW-014 v2.0 Architecture Change
- Audit generation moved from HolmesGPT API to Data Storage Service
- HolmesGPT API passes remediation_id in JSON request body
- Data Storage Service generates audit events with full workflow context

⚠️ CRITICAL: remediation_id Usage Constraint
- Field is MANDATORY but for CORRELATION/AUDIT ONLY
- Do NOT use for RCA analysis or workflow matching
- Pass in JSON body to Data Storage for audit correlation
"""

import pytest
from unittest.mock import Mock, patch


class TestWorkflowCatalogRemediationId:
    """
    Unit tests for remediation_id propagation in SearchWorkflowCatalogTool

    Business Requirement: BR-AUDIT-001 - Unified audit trail
    Design Decision: DD-WORKFLOW-002 v2.2 - remediation_id propagation
    Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

    Test Strategy (DD-WORKFLOW-014 v2.0):
    - Test tool accepts remediation_id in constructor
    - Test remediation_id is passed in JSON request body to Data Storage
    - Test NO audit event is generated by HolmesGPT API (Data Storage does it)
    """

    @pytest.fixture
    def mock_data_storage_response(self):
        """Mock Data Storage API response"""
        return {
            "workflows": [
                {
                    "workflow": {
                        "workflow_id": "oom-remediation-v1",
                        "version": "1.0.0",
                        "name": "OOM Remediation",
                        "description": "OOMKilled critical: Remediate memory issues",
                        "labels": {
                            "signal-type": "OOMKilled",
                            "severity": "critical"
                        }
                    },
                    "final_score": 0.92,
                    "base_similarity": 0.85,
                    "label_boost": 0.10,
                    "label_penalty": 0.03
                }
            ],
            "total_results": 1
        }

    def test_tool_accepts_remediation_id_in_constructor(self):
        """
        Test that SearchWorkflowCatalogTool accepts remediation_id in constructor

        Business Requirement: BR-AUDIT-001 - Unified audit trail
        Design Decision: DD-WORKFLOW-002 v2.2 - remediation_id propagation

        TDD Phase: RED (this test should FAIL initially)
        Expected: Tool initializes successfully with remediation_id
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool with remediation_id
        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        # ASSERT: remediation_id should be stored
        assert hasattr(tool, '_remediation_id'), \
            "Tool should have _remediation_id attribute"
        assert tool._remediation_id == remediation_id, \
            f"Expected remediation_id '{remediation_id}', got '{tool._remediation_id}'"

    def test_remediation_id_passed_in_json_body(
        self, mock_data_storage_response
    ):
        """
        Test that remediation_id is passed in JSON request body to Data Storage

        Business Requirement: BR-AUDIT-001 - Unified audit trail
        Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

        ⚠️ CRITICAL: remediation_id MUST be in JSON body (not HTTP header)
        - Consistent with existing request/response patterns
        - Follows RESTful conventions for request data
        - Enables standard JSON validation on server side

        TDD Phase: RED (this test should FAIL until implementation is complete)
        Expected: Request body includes remediation_id field
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Request body should include remediation_id
            assert mock_post.call_count == 1, \
                "DD-WORKFLOW-014 v2.0: Should only call search API (no audit call)"

            search_call = mock_post.call_args
            request_body = search_call[1]["json"]

            assert "remediation_id" in request_body, \
                "DD-WORKFLOW-014 v2.0: Request body must include remediation_id"
            assert request_body["remediation_id"] == remediation_id, \
                f"Expected remediation_id '{remediation_id}', got '{request_body.get('remediation_id')}'"

    def test_remediation_id_not_in_http_header(
        self, mock_data_storage_response
    ):
        """
        Test that remediation_id is NOT passed in HTTP header

        Design Decision: DD-WORKFLOW-014 v2.0 - JSON body approach

        ⚠️ CRITICAL: remediation_id should be in JSON body, NOT HTTP header
        - Consistent with existing API patterns
        - Easier server-side validation
        - Standard RESTful conventions

        TDD Phase: RED
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: remediation_id should NOT be in HTTP headers
            search_call = mock_post.call_args
            headers = search_call[1].get("headers", {})

            assert "X-Remediation-ID" not in headers, \
                "DD-WORKFLOW-014 v2.0: remediation_id should be in body, NOT header"
            assert "Remediation-ID" not in headers, \
                "DD-WORKFLOW-014 v2.0: remediation_id should be in body, NOT header"

    def test_no_audit_event_generated_by_holmesgpt_api(
        self, mock_data_storage_response
    ):
        """
        Test that HolmesGPT API does NOT generate audit events

        Business Requirement: BR-AUDIT-005 - Workflow selection audit trail
        Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

        ⚠️ CRITICAL: Per DD-WORKFLOW-014 v2.0, audit generation moved to Data Storage
        - HolmesGPT API only passes remediation_id in JSON body
        - Data Storage Service generates audit with full workflow context

        TDD Phase: RED (this test should FAIL until implementation is complete)
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id="req-2025-11-27-abc123"
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Only ONE HTTP call (search), NO audit call
            assert mock_post.call_count == 1, \
                f"DD-WORKFLOW-014 v2.0: Should only call search API, got {mock_post.call_count} calls"

            # Verify it was the search call, not audit
            search_call = mock_post.call_args
            url = search_call[0][0]
            assert "/workflows/search" in url, \
                f"DD-WORKFLOW-014 v2.0: Only call should be search, got {url}"
            assert "/audit" not in url, \
                f"DD-WORKFLOW-014 v2.0: Should NOT call audit API, got {url}"

    def test_tool_works_without_remediation_id_for_backwards_compatibility(
        self, mock_data_storage_response
    ):
        """
        Test that tool works without remediation_id (backwards compatibility)

        Note: While remediation_id is mandatory per DD-WORKFLOW-002 v2.2,
        the tool itself should handle the case where it's not provided
        to avoid breaking existing code during migration.

        TDD Phase: RED (this test should FAIL initially)
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool WITHOUT remediation_id
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080"
            # Note: No remediation_id provided
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search (should not crash)
            result = tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Search should succeed
            assert result is not None, "Search should succeed without remediation_id"

            # ASSERT: Request body should have empty or missing remediation_id
            search_call = mock_post.call_args
            request_body = search_call[1]["json"]
            remediation_id_value = request_body.get("remediation_id", "")
            assert remediation_id_value == "" or "remediation_id" not in request_body, \
                "Without remediation_id, field should be empty or absent"

    def test_empty_remediation_id_handled_gracefully(
        self, mock_data_storage_response
    ):
        """
        Test that empty remediation_id is handled gracefully

        Design Decision: DD-WORKFLOW-014 v2.0

        TDD Phase: RED
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool with empty remediation_id
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=""  # Empty string
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search (should not crash)
            result = tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Search should succeed
            assert result is not None, "Search should succeed with empty remediation_id"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
