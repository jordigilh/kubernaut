"""
Unit tests for remediation_id propagation in workflow catalog tool

Business Requirement: BR-AUDIT-001, BR-INTEGRATION-003
Design Decision: DD-WORKFLOW-002 v2.4, DD-WORKFLOW-014 v2.0
Authority: REMEDIATION-ID-PROPAGATION-IMPLEMENTATION_PLAN_V1.4.md Day 1 AM

TDD Phase: RED (failing tests)

⚠️ CRITICAL: DD-WORKFLOW-014 v2.0 Architecture Change
- Audit generation moved from HolmesGPT API to Data Storage Service
- HolmesGPT API passes remediation_id in JSON request body
- Data Storage Service generates audit events with full workflow context

⚠️ CRITICAL: remediation_id Usage Constraint
- Field is MANDATORY but for CORRELATION/AUDIT ONLY
- Do NOT use for RCA analysis or workflow matching
- Pass in JSON body to Data Storage for audit correlation
"""

import pytest
from unittest.mock import Mock, patch


class TestWorkflowCatalogRemediationId:
    """
    Unit tests for remediation_id propagation in SearchWorkflowCatalogTool

    Business Requirement: BR-AUDIT-001 - Unified audit trail
    Design Decision: DD-WORKFLOW-002 v2.2 - remediation_id propagation
    Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

    Test Strategy (DD-WORKFLOW-014 v2.0):
    - Test tool accepts remediation_id in constructor
    - Test remediation_id is passed in JSON request body to Data Storage
    - Test NO audit event is generated by HolmesGPT API (Data Storage does it)
    """

    @pytest.fixture
    def mock_data_storage_response(self):
        """Mock Data Storage API response"""
        return {
            "workflows": [
                {
                    "workflow": {
                        "workflow_id": "oom-remediation-v1",
                        "version": "1.0.0",
                        "name": "OOM Remediation",
                        "description": "OOMKilled critical: Remediate memory issues",
                        "labels": {
                            "signal-type": "OOMKilled",
                            "severity": "critical"
                        }
                    },
                    "final_score": 0.92,
                    "base_similarity": 0.85,
                    "label_boost": 0.10,
                    "label_penalty": 0.03
                }
            ],
            "total_results": 1
        }

    def test_tool_accepts_remediation_id_in_constructor(self):
        """
        Test that SearchWorkflowCatalogTool accepts remediation_id in constructor

        Business Requirement: BR-AUDIT-001 - Unified audit trail
        Design Decision: DD-WORKFLOW-002 v2.2 - remediation_id propagation

        TDD Phase: RED (this test should FAIL initially)
        Expected: Tool initializes successfully with remediation_id
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool with remediation_id
        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        # ASSERT: remediation_id should be stored
        assert hasattr(tool, '_remediation_id'), \
            "Tool should have _remediation_id attribute"
        assert tool._remediation_id == remediation_id, \
            f"Expected remediation_id '{remediation_id}', got '{tool._remediation_id}'"

    def test_remediation_id_passed_in_json_body(
        self, mock_data_storage_response
    ):
        """
        Test that remediation_id is passed in JSON request body to Data Storage

        Business Requirement: BR-AUDIT-001 - Unified audit trail
        Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

        ⚠️ CRITICAL: remediation_id MUST be in JSON body (not HTTP header)
        - Consistent with existing request/response patterns
        - Follows RESTful conventions for request data
        - Enables standard JSON validation on server side

        TDD Phase: RED (this test should FAIL until implementation is complete)
        Expected: Request body includes remediation_id field
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        with patch('datastorage.api.workflow_catalog_api_api.WorkflowCatalogAPIApi.search_workflows') as mock_search:
            # Mock OpenAPI response
            from datastorage.models.workflow_search_response import WorkflowSearchResponse
            from datastorage.models.workflow_search_result import WorkflowSearchResult
            from uuid import UUID

            mock_workflow = WorkflowSearchResult(
                workflow_id=str(UUID("1c7fcb0c-d22b-4e7c-b994-749dd1a591bd")),
                title="OOM Remediation",
                description="OOMKilled critical: Remediate memory issues",
                signal_type="OOMKilled",
                confidence=0.92,
                final_score=0.92,
                rank=1
            )
            mock_response = WorkflowSearchResponse(workflows=[mock_workflow], total_results=1)
            mock_search.return_value = mock_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Request body should include remediation_id
            assert mock_search.call_count == 1, \
                "DD-WORKFLOW-014 v2.0: Should only call search API (no audit call)"

            # OpenAPI client is called with keyword argument
            request_obj = mock_search.call_args.kwargs.get('workflow_search_request')

            assert request_obj is not None, \
                "DD-WORKFLOW-014 v2.0: Request object must be passed"
            assert hasattr(request_obj, 'remediation_id'), \
                "DD-WORKFLOW-014 v2.0: Request must include remediation_id"
            assert request_obj.remediation_id == remediation_id, \
                f"Expected remediation_id '{remediation_id}', got '{request_obj.remediation_id}'"

    def test_remediation_id_not_in_http_header(
        self, mock_data_storage_response
    ):
        """
        Test that remediation_id is in request body (via OpenAPI client)

        Design Decision: DD-WORKFLOW-014 v2.0 - JSON body approach

        ⚠️ CRITICAL: remediation_id should be in request object, NOT HTTP header
        - OpenAPI client handles HTTP details
        - remediation_id is part of WorkflowSearchRequest model

        TDD Phase: GREEN (using OpenAPI client)
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        remediation_id = "req-2025-11-27-abc123"
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=remediation_id
        )

        with patch('datastorage.api.workflow_catalog_api_api.WorkflowCatalogAPIApi.search_workflows') as mock_search:
            # Mock OpenAPI response
            from datastorage.models.workflow_search_response import WorkflowSearchResponse
            from datastorage.models.workflow_search_result import WorkflowSearchResult
            from uuid import UUID

            mock_workflow = WorkflowSearchResult(
                workflow_id=str(UUID("1c7fcb0c-d22b-4e7c-b994-749dd1a591bd")),
                title="OOM Remediation",
                description="OOMKilled critical: Remediate memory issues",
                signal_type="OOMKilled",
                confidence=0.92,
                final_score=0.92,
                rank=1
            )
            mock_response = WorkflowSearchResponse(workflows=[mock_workflow], total_results=1)
            mock_search.return_value = mock_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: remediation_id is in request object (OpenAPI client handles HTTP)
            request_obj = mock_search.call_args.kwargs.get('workflow_search_request')
            assert request_obj is not None
            assert hasattr(request_obj, 'remediation_id'), \
                "DD-WORKFLOW-014 v2.0: remediation_id must be in request object"
            assert request_obj.remediation_id == remediation_id

    def test_no_audit_event_generated_by_holmesgpt_api(
        self, mock_data_storage_response
    ):
        """
        Test that HolmesGPT API does NOT generate audit events

        Business Requirement: BR-AUDIT-005 - Workflow selection audit trail
        Design Decision: DD-WORKFLOW-014 v2.0 - Data Storage generates audit

        ⚠️ CRITICAL: Per DD-WORKFLOW-014 v2.0, audit generation moved to Data Storage
        - HolmesGPT API only passes remediation_id in JSON body
        - Data Storage Service generates audit with full workflow context

        TDD Phase: RED (this test should FAIL until implementation is complete)
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id="req-2025-11-27-abc123"
        )

        with patch('datastorage.api.workflow_catalog_api_api.WorkflowCatalogAPIApi.search_workflows') as mock_search:
            # Mock OpenAPI response
            from datastorage.models.workflow_search_response import WorkflowSearchResponse
            from datastorage.models.workflow_search_result import WorkflowSearchResult
            from uuid import UUID

            mock_workflow = WorkflowSearchResult(
                workflow_id=str(UUID("1c7fcb0c-d22b-4e7c-b994-749dd1a591bd")),
                title="OOM Remediation",
                description="OOMKilled critical: Remediate memory issues",
                signal_type="OOMKilled",
                confidence=0.92,
                final_score=0.92,
                rank=1
            )
            mock_response = WorkflowSearchResponse(workflows=[mock_workflow], total_results=1)
            mock_search.return_value = mock_response

            # ACT: Execute search
            tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Only ONE API call (search), NO audit call
            # With OpenAPI client, we verify only search_workflows is called (no separate audit call)
            assert mock_search.call_count == 1, \
                f"DD-WORKFLOW-014 v2.0: Should only call search API, got {mock_search.call_count} calls"

    def test_tool_works_without_remediation_id_for_backwards_compatibility(
        self, mock_data_storage_response
    ):
        """
        Test that tool works without remediation_id (backwards compatibility)

        Note: While remediation_id is mandatory per DD-WORKFLOW-002 v2.2,
        the tool itself should handle the case where it's not provided
        to avoid breaking existing code during migration.

        TDD Phase: RED (this test should FAIL initially)
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool WITHOUT remediation_id
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080"
            # Note: No remediation_id provided
        )

        with patch('datastorage.api.workflow_catalog_api_api.WorkflowCatalogAPIApi.search_workflows') as mock_search:
            # Mock OpenAPI response
            from datastorage.models.workflow_search_response import WorkflowSearchResponse
            from datastorage.models.workflow_search_result import WorkflowSearchResult
            from uuid import UUID

            mock_workflow = WorkflowSearchResult(
                workflow_id=str(UUID("1c7fcb0c-d22b-4e7c-b994-749dd1a591bd")),
                title="OOM Remediation",
                description="OOMKilled critical: Remediate memory issues",
                signal_type="OOMKilled",
                confidence=0.92,
                final_score=0.92,
                rank=1
            )
            mock_response = WorkflowSearchResponse(workflows=[mock_workflow], total_results=1)
            mock_search.return_value = mock_response

            # ACT: Execute search (should not crash)
            result = tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Search should succeed
            assert result is not None, "Search should succeed without remediation_id"

            # ASSERT: Request should have empty or missing remediation_id
            request_obj = mock_search.call_args.kwargs.get('workflow_search_request')
            if request_obj:
                remediation_id_value = getattr(request_obj, 'remediation_id', None)
                assert remediation_id_value is None or remediation_id_value == "", \
                    "Without remediation_id, field should be empty or absent"

    def test_empty_remediation_id_handled_gracefully(
        self, mock_data_storage_response
    ):
        """
        Test that empty remediation_id is handled gracefully

        Design Decision: DD-WORKFLOW-014 v2.0

        TDD Phase: RED
        """
        from src.toolsets.workflow_catalog import SearchWorkflowCatalogTool

        # ACT: Create tool with empty remediation_id
        tool = SearchWorkflowCatalogTool(
            data_storage_url="http://localhost:8080",
            remediation_id=""  # Empty string
        )

        with patch('requests.post') as mock_post:
            # Mock search response
            mock_search_response = Mock()
            mock_search_response.json.return_value = mock_data_storage_response
            mock_search_response.elapsed.total_seconds.return_value = 0.05
            mock_search_response.raise_for_status = Mock()

            mock_post.return_value = mock_search_response

            # ACT: Execute search (should not crash)
            result = tool._invoke(params={
                "query": "OOMKilled critical",
                "filters": {},
                "top_k": 3
            })

            # ASSERT: Search should succeed
            assert result is not None, "Search should succeed with empty remediation_id"


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
