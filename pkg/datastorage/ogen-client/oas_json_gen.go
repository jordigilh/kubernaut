// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AIAgentResponsePayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAgentResponsePayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_id")
		e.Str(s.EventID)
	}
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("response_data")
		s.ResponseData.Encode(e)
	}
}

var jsonFieldsNameOfAIAgentResponsePayload = [4]string{
	0: "event_type",
	1: "event_id",
	2: "incident_id",
	3: "response_data",
}

// Decode decodes AIAgentResponsePayload from json.
func (s *AIAgentResponsePayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAgentResponsePayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "incident_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "response_data":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ResponseData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response_data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAgentResponsePayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAgentResponsePayload) {
					name = jsonFieldsNameOfAIAgentResponsePayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAgentResponsePayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAgentResponsePayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AIAgentResponsePayloadEventType as json.
func (s AIAgentResponsePayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AIAgentResponsePayloadEventType from json.
func (s *AIAgentResponsePayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAgentResponsePayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AIAgentResponsePayloadEventType(v) {
	case AIAgentResponsePayloadEventTypeAiagentResponseComplete:
		*s = AIAgentResponsePayloadEventTypeAiagentResponseComplete
	default:
		*s = AIAgentResponsePayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AIAgentResponsePayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAgentResponsePayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisAIAgentCallPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisAIAgentCallPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("endpoint")
		e.Str(s.Endpoint)
	}
	{
		e.FieldStart("http_status_code")
		e.Int32(s.HTTPStatusCode)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
}

var jsonFieldsNameOfAIAnalysisAIAgentCallPayload = [3]string{
	0: "endpoint",
	1: "http_status_code",
	2: "duration_ms",
}

// Decode decodes AIAnalysisAIAgentCallPayload from json.
func (s *AIAnalysisAIAgentCallPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisAIAgentCallPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "endpoint":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Endpoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoint\"")
			}
		case "http_status_code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.HTTPStatusCode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"http_status_code\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisAIAgentCallPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisAIAgentCallPayload) {
					name = jsonFieldsNameOfAIAnalysisAIAgentCallPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisAIAgentCallPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisAIAgentCallPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisApprovalDecisionPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisApprovalDecisionPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("approval_required")
		e.Bool(s.ApprovalRequired)
	}
	{
		e.FieldStart("approval_reason")
		e.Str(s.ApprovalReason)
	}
	{
		e.FieldStart("auto_approved")
		e.Bool(s.AutoApproved)
	}
	{
		e.FieldStart("decision")
		e.Str(s.Decision)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("environment")
		e.Str(s.Environment)
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
}

var jsonFieldsNameOfAIAnalysisApprovalDecisionPayload = [8]string{
	0: "approval_required",
	1: "approval_reason",
	2: "auto_approved",
	3: "decision",
	4: "reason",
	5: "environment",
	6: "confidence",
	7: "workflow_id",
}

// Decode decodes AIAnalysisApprovalDecisionPayload from json.
func (s *AIAnalysisApprovalDecisionPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisApprovalDecisionPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "approval_required":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.ApprovalRequired = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_required\"")
			}
		case "approval_reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ApprovalReason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_reason\"")
			}
		case "auto_approved":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.AutoApproved = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_approved\"")
			}
		case "decision":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Decision = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisApprovalDecisionPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisApprovalDecisionPayload) {
					name = jsonFieldsNameOfAIAnalysisApprovalDecisionPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisApprovalDecisionPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisApprovalDecisionPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("analysis_name")
		e.Str(s.AnalysisName)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		e.FieldStart("phase")
		s.Phase.Encode(e)
	}
	{
		e.FieldStart("approval_required")
		e.Bool(s.ApprovalRequired)
	}
	{
		if s.ApprovalReason.Set {
			e.FieldStart("approval_reason")
			s.ApprovalReason.Encode(e)
		}
	}
	{
		e.FieldStart("degraded_mode")
		e.Bool(s.DegradedMode)
	}
	{
		e.FieldStart("warnings_count")
		e.Int(s.WarningsCount)
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		if s.TargetInOwnerChain.Set {
			e.FieldStart("target_in_owner_chain")
			s.TargetInOwnerChain.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.SubReason.Set {
			e.FieldStart("sub_reason")
			s.SubReason.Encode(e)
		}
	}
	{
		if s.ProviderResponseSummary.Set {
			e.FieldStart("provider_response_summary")
			s.ProviderResponseSummary.Encode(e)
		}
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfAIAnalysisAuditPayload = [15]string{
	0:  "event_type",
	1:  "analysis_name",
	2:  "namespace",
	3:  "phase",
	4:  "approval_required",
	5:  "approval_reason",
	6:  "degraded_mode",
	7:  "warnings_count",
	8:  "confidence",
	9:  "workflow_id",
	10: "target_in_owner_chain",
	11: "reason",
	12: "sub_reason",
	13: "provider_response_summary",
	14: "error_details",
}

// Decode decodes AIAnalysisAuditPayload from json.
func (s *AIAnalysisAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisAuditPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "analysis_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AnalysisName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "phase":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "approval_required":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.ApprovalRequired = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_required\"")
			}
		case "approval_reason":
			if err := func() error {
				s.ApprovalReason.Reset()
				if err := s.ApprovalReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_reason\"")
			}
		case "degraded_mode":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.DegradedMode = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"degraded_mode\"")
			}
		case "warnings_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.WarningsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings_count\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "target_in_owner_chain":
			if err := func() error {
				s.TargetInOwnerChain.Reset()
				if err := s.TargetInOwnerChain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_in_owner_chain\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "sub_reason":
			if err := func() error {
				s.SubReason.Reset()
				if err := s.SubReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_reason\"")
			}
		case "provider_response_summary":
			if err := func() error {
				s.ProviderResponseSummary.Reset()
				if err := s.ProviderResponseSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_response_summary\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11011111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisAuditPayload) {
					name = jsonFieldsNameOfAIAnalysisAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AIAnalysisAuditPayloadEventType as json.
func (s AIAnalysisAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AIAnalysisAuditPayloadEventType from json.
func (s *AIAnalysisAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AIAnalysisAuditPayloadEventType(v) {
	case AIAnalysisAuditPayloadEventTypeAianalysisAnalysisCompleted:
		*s = AIAnalysisAuditPayloadEventTypeAianalysisAnalysisCompleted
	case AIAnalysisAuditPayloadEventTypeAianalysisAnalysisFailed:
		*s = AIAnalysisAuditPayloadEventTypeAianalysisAnalysisFailed
	default:
		*s = AIAnalysisAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AIAnalysisAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AIAnalysisAuditPayloadPhase as json.
func (s AIAnalysisAuditPayloadPhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AIAnalysisAuditPayloadPhase from json.
func (s *AIAnalysisAuditPayloadPhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisAuditPayloadPhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AIAnalysisAuditPayloadPhase(v) {
	case AIAnalysisAuditPayloadPhasePending:
		*s = AIAnalysisAuditPayloadPhasePending
	case AIAnalysisAuditPayloadPhaseAnalyzing:
		*s = AIAnalysisAuditPayloadPhaseAnalyzing
	case AIAnalysisAuditPayloadPhaseCompleted:
		*s = AIAnalysisAuditPayloadPhaseCompleted
	case AIAnalysisAuditPayloadPhaseFailed:
		*s = AIAnalysisAuditPayloadPhaseFailed
	default:
		*s = AIAnalysisAuditPayloadPhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AIAnalysisAuditPayloadPhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisAuditPayloadPhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisErrorPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisErrorPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phase")
		e.Str(s.Phase)
	}
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
}

var jsonFieldsNameOfAIAnalysisErrorPayload = [2]string{
	0: "phase",
	1: "error_message",
}

// Decode decodes AIAnalysisErrorPayload from json.
func (s *AIAnalysisErrorPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisErrorPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phase":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Phase = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "error_message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisErrorPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisErrorPayload) {
					name = jsonFieldsNameOfAIAnalysisErrorPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisErrorPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisErrorPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisPhaseTransitionPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisPhaseTransitionPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("old_phase")
		e.Str(s.OldPhase)
	}
	{
		e.FieldStart("new_phase")
		e.Str(s.NewPhase)
	}
}

var jsonFieldsNameOfAIAnalysisPhaseTransitionPayload = [2]string{
	0: "old_phase",
	1: "new_phase",
}

// Decode decodes AIAnalysisPhaseTransitionPayload from json.
func (s *AIAnalysisPhaseTransitionPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisPhaseTransitionPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "old_phase":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OldPhase = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_phase\"")
			}
		case "new_phase":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NewPhase = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_phase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisPhaseTransitionPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisPhaseTransitionPayload) {
					name = jsonFieldsNameOfAIAnalysisPhaseTransitionPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisPhaseTransitionPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisPhaseTransitionPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AIAnalysisRegoEvaluationPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AIAnalysisRegoEvaluationPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("outcome")
		e.Str(s.Outcome)
	}
	{
		e.FieldStart("degraded")
		e.Bool(s.Degraded)
	}
	{
		e.FieldStart("duration_ms")
		e.Int32(s.DurationMs)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfAIAnalysisRegoEvaluationPayload = [4]string{
	0: "outcome",
	1: "degraded",
	2: "duration_ms",
	3: "reason",
}

// Decode decodes AIAnalysisRegoEvaluationPayload from json.
func (s *AIAnalysisRegoEvaluationPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AIAnalysisRegoEvaluationPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "outcome":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Outcome = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outcome\"")
			}
		case "degraded":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Degraded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"degraded\"")
			}
		case "duration_ms":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DurationMs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AIAnalysisRegoEvaluationPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAIAnalysisRegoEvaluationPayload) {
					name = jsonFieldsNameOfAIAnalysisRegoEvaluationPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AIAnalysisRegoEvaluationPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AIAnalysisRegoEvaluationPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionTypeEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionTypeEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actionType")
		e.Str(s.ActionType)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("workflowCount")
		e.Int(s.WorkflowCount)
	}
}

var jsonFieldsNameOfActionTypeEntry = [3]string{
	0: "actionType",
	1: "description",
	2: "workflowCount",
}

// Decode decodes ActionTypeEntry from json.
func (s *ActionTypeEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionTypeEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ActionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionType\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "workflowCount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.WorkflowCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionTypeEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionTypeEntry) {
					name = jsonFieldsNameOfActionTypeEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionTypeEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionTypeEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionTypeListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionTypeListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actionTypes")
		e.ArrStart()
		for _, elem := range s.ActionTypes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfActionTypeListResponse = [2]string{
	0: "actionTypes",
	1: "pagination",
}

// Decode decodes ActionTypeListResponse from json.
func (s *ActionTypeListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionTypeListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionTypes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ActionTypes = make([]ActionTypeEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActionTypeEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActionTypes = append(s.ActionTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionTypes\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionTypeListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionTypeListResponse) {
					name = jsonFieldsNameOfActionTypeListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionTypeListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionTypeListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AsyncAcceptanceResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AsyncAcceptanceResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAsyncAcceptanceResponse = [2]string{
	0: "status",
	1: "message",
}

// Decode decodes AsyncAcceptanceResponse from json.
func (s *AsyncAcceptanceResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AsyncAcceptanceResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AsyncAcceptanceResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAsyncAcceptanceResponse) {
					name = jsonFieldsNameOfAsyncAcceptanceResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AsyncAcceptanceResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AsyncAcceptanceResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditEvent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditEvent) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("event_type")
		e.Str(s.EventType)
	}
	{
		e.FieldStart("event_timestamp")
		json.EncodeDateTime(e, s.EventTimestamp)
	}
	{
		e.FieldStart("event_category")
		s.EventCategory.Encode(e)
	}
	{
		e.FieldStart("event_action")
		e.Str(s.EventAction)
	}
	{
		e.FieldStart("event_outcome")
		s.EventOutcome.Encode(e)
	}
	{
		if s.ActorType.Set {
			e.FieldStart("actor_type")
			s.ActorType.Encode(e)
		}
	}
	{
		if s.ActorID.Set {
			e.FieldStart("actor_id")
			s.ActorID.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resource_type")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceID.Set {
			e.FieldStart("resource_id")
			s.ResourceID.Encode(e)
		}
	}
	{
		e.FieldStart("correlation_id")
		e.Str(s.CorrelationID)
	}
	{
		if s.ParentEventID.Set {
			e.FieldStart("parent_event_id")
			s.ParentEventID.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("cluster_name")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		e.FieldStart("event_data")
		s.EventData.Encode(e)
	}
	{
		if s.EventID.Set {
			e.FieldStart("event_id")
			s.EventID.Encode(e)
		}
	}
	{
		if s.EventDate.Set {
			e.FieldStart("event_date")
			s.EventDate.Encode(e, json.EncodeDate)
		}
	}
}

var jsonFieldsNameOfAuditEvent = [19]string{
	0:  "version",
	1:  "event_type",
	2:  "event_timestamp",
	3:  "event_category",
	4:  "event_action",
	5:  "event_outcome",
	6:  "actor_type",
	7:  "actor_id",
	8:  "resource_type",
	9:  "resource_id",
	10: "correlation_id",
	11: "parent_event_id",
	12: "namespace",
	13: "cluster_name",
	14: "severity",
	15: "duration_ms",
	16: "event_data",
	17: "event_id",
	18: "event_date",
}

// Decode decodes AuditEvent from json.
func (s *AuditEvent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEvent to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "event_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EventTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_timestamp\"")
			}
		case "event_category":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EventCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_category\"")
			}
		case "event_action":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.EventAction = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_action\"")
			}
		case "event_outcome":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.EventOutcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_outcome\"")
			}
		case "actor_type":
			if err := func() error {
				s.ActorType.Reset()
				if err := s.ActorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_type\"")
			}
		case "actor_id":
			if err := func() error {
				s.ActorID.Reset()
				if err := s.ActorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_id\"")
			}
		case "resource_type":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		case "resource_id":
			if err := func() error {
				s.ResourceID.Reset()
				if err := s.ResourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_id\"")
			}
		case "correlation_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CorrelationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "parent_event_id":
			if err := func() error {
				s.ParentEventID.Reset()
				if err := s.ParentEventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_event_id\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "cluster_name":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster_name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "event_data":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.EventData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_data\"")
			}
		case "event_id":
			if err := func() error {
				s.EventID.Reset()
				if err := s.EventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "event_date":
			if err := func() error {
				s.EventDate.Reset()
				if err := s.EventDate.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditEvent")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00111111,
		0b00000100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditEvent) {
					name = jsonFieldsNameOfAuditEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditEvent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEvent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventEventCategory as json.
func (s AuditEventEventCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuditEventEventCategory from json.
func (s *AuditEventEventCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventEventCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuditEventEventCategory(v) {
	case AuditEventEventCategoryGateway:
		*s = AuditEventEventCategoryGateway
	case AuditEventEventCategoryNotification:
		*s = AuditEventEventCategoryNotification
	case AuditEventEventCategoryAnalysis:
		*s = AuditEventEventCategoryAnalysis
	case AuditEventEventCategoryAiagent:
		*s = AuditEventEventCategoryAiagent
	case AuditEventEventCategorySignalprocessing:
		*s = AuditEventEventCategorySignalprocessing
	case AuditEventEventCategoryWorkflow:
		*s = AuditEventEventCategoryWorkflow
	case AuditEventEventCategoryWorkflowexecution:
		*s = AuditEventEventCategoryWorkflowexecution
	case AuditEventEventCategoryOrchestration:
		*s = AuditEventEventCategoryOrchestration
	case AuditEventEventCategoryWebhook:
		*s = AuditEventEventCategoryWebhook
	case AuditEventEventCategoryEffectiveness:
		*s = AuditEventEventCategoryEffectiveness
	default:
		*s = AuditEventEventCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventEventCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventEventCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventEventData as json.
func (s AuditEventEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s AuditEventEventData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AuditEventEventDataGatewayCrdCreatedAuditEventEventData, AuditEventEventDataGatewayCrdFailedAuditEventEventData, AuditEventEventDataGatewaySignalDeduplicatedAuditEventEventData, AuditEventEventDataGatewaySignalReceivedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataGatewayCrdCreatedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("gateway.crd.created")
		case AuditEventEventDataGatewayCrdFailedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("gateway.crd.failed")
		case AuditEventEventDataGatewaySignalDeduplicatedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("gateway.signal.deduplicated")
		case AuditEventEventDataGatewaySignalReceivedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("gateway.signal.received")
		}
		{
			s := s.GatewayAuditPayload
			{
				if s.OriginalPayload.Set {
					e.FieldStart("original_payload")
					s.OriginalPayload.Encode(e)
				}
			}
			{
				if s.SignalLabels.Set {
					e.FieldStart("signal_labels")
					s.SignalLabels.Encode(e)
				}
			}
			{
				if s.SignalAnnotations.Set {
					e.FieldStart("signal_annotations")
					s.SignalAnnotations.Encode(e)
				}
			}
			{
				e.FieldStart("signal_type")
				s.SignalType.Encode(e)
			}
			{
				e.FieldStart("alert_name")
				e.Str(s.AlertName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("fingerprint")
				e.Str(s.Fingerprint)
			}
			{
				if s.Severity.Set {
					e.FieldStart("severity")
					s.Severity.Encode(e)
				}
			}
			{
				if s.ResourceKind.Set {
					e.FieldStart("resource_kind")
					s.ResourceKind.Encode(e)
				}
			}
			{
				if s.ResourceName.Set {
					e.FieldStart("resource_name")
					s.ResourceName.Encode(e)
				}
			}
			{
				if s.RemediationRequest.Set {
					e.FieldStart("remediation_request")
					s.RemediationRequest.Encode(e)
				}
			}
			{
				if s.DeduplicationStatus.Set {
					e.FieldStart("deduplication_status")
					s.DeduplicationStatus.Encode(e)
				}
			}
			{
				if s.OccurrenceCount.Set {
					e.FieldStart("occurrence_count")
					s.OccurrenceCount.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
		}
	case AuditEventEventDataOrchestratorApprovalApprovedAuditEventEventData, AuditEventEventDataOrchestratorApprovalRejectedAuditEventEventData, AuditEventEventDataOrchestratorApprovalRequestedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleCompletedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleCreatedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleFailedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleStartedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleTransitionedAuditEventEventData, AuditEventEventDataOrchestratorRemediationManualReviewAuditEventEventData, AuditEventEventDataOrchestratorRoutingBlockedAuditEventEventData, AuditEventEventDataRemediationWorkflowCreatedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataOrchestratorApprovalApprovedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.approved")
		case AuditEventEventDataOrchestratorApprovalRejectedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.rejected")
		case AuditEventEventDataOrchestratorApprovalRequestedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.requested")
		case AuditEventEventDataOrchestratorLifecycleCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.completed")
		case AuditEventEventDataOrchestratorLifecycleCreatedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.created")
		case AuditEventEventDataOrchestratorLifecycleFailedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.failed")
		case AuditEventEventDataOrchestratorLifecycleStartedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.started")
		case AuditEventEventDataOrchestratorLifecycleTransitionedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.transitioned")
		case AuditEventEventDataOrchestratorRemediationManualReviewAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.remediation.manual_review")
		case AuditEventEventDataOrchestratorRoutingBlockedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.routing.blocked")
		case AuditEventEventDataRemediationWorkflowCreatedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("remediation.workflow_created")
		}
		{
			s := s.RemediationOrchestratorAuditPayload
			{
				e.FieldStart("rr_name")
				e.Str(s.RrName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				if s.Outcome.Set {
					e.FieldStart("outcome")
					s.Outcome.Encode(e)
				}
			}
			{
				if s.DurationMs.Set {
					e.FieldStart("duration_ms")
					s.DurationMs.Encode(e)
				}
			}
			{
				if s.FailurePhase.Set {
					e.FieldStart("failure_phase")
					s.FailurePhase.Encode(e)
				}
			}
			{
				if s.FailureReason.Set {
					e.FieldStart("failure_reason")
					s.FailureReason.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
			{
				if s.FromPhase.Set {
					e.FieldStart("from_phase")
					s.FromPhase.Encode(e)
				}
			}
			{
				if s.ToPhase.Set {
					e.FieldStart("to_phase")
					s.ToPhase.Encode(e)
				}
			}
			{
				if s.TransitionReason.Set {
					e.FieldStart("transition_reason")
					s.TransitionReason.Encode(e)
				}
			}
			{
				if s.RarName.Set {
					e.FieldStart("rar_name")
					s.RarName.Encode(e)
				}
			}
			{
				if s.RequiredBy.Set {
					e.FieldStart("required_by")
					s.RequiredBy.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.ConfidenceStr.Set {
					e.FieldStart("confidence_str")
					s.ConfidenceStr.Encode(e)
				}
			}
			{
				if s.Decision.Set {
					e.FieldStart("decision")
					s.Decision.Encode(e)
				}
			}
			{
				if s.ApprovedBy.Set {
					e.FieldStart("approved_by")
					s.ApprovedBy.Encode(e)
				}
			}
			{
				if s.RejectedBy.Set {
					e.FieldStart("rejected_by")
					s.RejectedBy.Encode(e)
				}
			}
			{
				if s.RejectionReason.Set {
					e.FieldStart("rejection_reason")
					s.RejectionReason.Encode(e)
				}
			}
			{
				if s.Message.Set {
					e.FieldStart("message")
					s.Message.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.SubReason.Set {
					e.FieldStart("sub_reason")
					s.SubReason.Encode(e)
				}
			}
			{
				if s.NotificationName.Set {
					e.FieldStart("notification_name")
					s.NotificationName.Encode(e)
				}
			}
			{
				if s.TimeoutConfig.Set {
					e.FieldStart("timeout_config")
					s.TimeoutConfig.Encode(e)
				}
			}
			{
				if s.PreRemediationSpecHash.Set {
					e.FieldStart("pre_remediation_spec_hash")
					s.PreRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.TargetResource.Set {
					e.FieldStart("target_resource")
					s.TargetResource.Encode(e)
				}
			}
			{
				if s.WorkflowVersion.Set {
					e.FieldStart("workflow_version")
					s.WorkflowVersion.Encode(e)
				}
			}
			{
				if s.WorkflowType.Set {
					e.FieldStart("workflow_type")
					s.WorkflowType.Encode(e)
				}
			}
		}
	case AuditEventEventDataSignalprocessingBusinessClassifiedAuditEventEventData, AuditEventEventDataSignalprocessingClassificationDecisionAuditEventEventData, AuditEventEventDataSignalprocessingEnrichmentCompletedAuditEventEventData, AuditEventEventDataSignalprocessingErrorOccurredAuditEventEventData, AuditEventEventDataSignalprocessingPhaseTransitionAuditEventEventData, AuditEventEventDataSignalprocessingSignalProcessedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataSignalprocessingBusinessClassifiedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.business.classified")
		case AuditEventEventDataSignalprocessingClassificationDecisionAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.classification.decision")
		case AuditEventEventDataSignalprocessingEnrichmentCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.enrichment.completed")
		case AuditEventEventDataSignalprocessingErrorOccurredAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.error.occurred")
		case AuditEventEventDataSignalprocessingPhaseTransitionAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.phase.transition")
		case AuditEventEventDataSignalprocessingSignalProcessedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.signal.processed")
		}
		{
			s := s.SignalProcessingAuditPayload
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("signal")
				e.Str(s.Signal)
			}
			{
				if s.Severity.Set {
					e.FieldStart("severity")
					s.Severity.Encode(e)
				}
			}
			{
				if s.ExternalSeverity.Set {
					e.FieldStart("external_severity")
					s.ExternalSeverity.Encode(e)
				}
			}
			{
				if s.NormalizedSeverity.Set {
					e.FieldStart("normalized_severity")
					s.NormalizedSeverity.Encode(e)
				}
			}
			{
				if s.DeterminationSource.Set {
					e.FieldStart("determination_source")
					s.DeterminationSource.Encode(e)
				}
			}
			{
				if s.PolicyHash.Set {
					e.FieldStart("policy_hash")
					s.PolicyHash.Encode(e)
				}
			}
			{
				if s.Environment.Set {
					e.FieldStart("environment")
					s.Environment.Encode(e)
				}
			}
			{
				if s.EnvironmentSource.Set {
					e.FieldStart("environment_source")
					s.EnvironmentSource.Encode(e)
				}
			}
			{
				if s.Priority.Set {
					e.FieldStart("priority")
					s.Priority.Encode(e)
				}
			}
			{
				if s.PrioritySource.Set {
					e.FieldStart("priority_source")
					s.PrioritySource.Encode(e)
				}
			}
			{
				if s.Criticality.Set {
					e.FieldStart("criticality")
					s.Criticality.Encode(e)
				}
			}
			{
				if s.SLARequirement.Set {
					e.FieldStart("sla_requirement")
					s.SLARequirement.Encode(e)
				}
			}
			{
				if s.HasOwnerChain.Set {
					e.FieldStart("has_owner_chain")
					s.HasOwnerChain.Encode(e)
				}
			}
			{
				if s.OwnerChainLength.Set {
					e.FieldStart("owner_chain_length")
					s.OwnerChainLength.Encode(e)
				}
			}
			{
				if s.DegradedMode.Set {
					e.FieldStart("degraded_mode")
					s.DegradedMode.Encode(e)
				}
			}
			{
				if s.HasPdb.Set {
					e.FieldStart("has_pdb")
					s.HasPdb.Encode(e)
				}
			}
			{
				if s.HasHpa.Set {
					e.FieldStart("has_hpa")
					s.HasHpa.Encode(e)
				}
			}
			{
				if s.DurationMs.Set {
					e.FieldStart("duration_ms")
					s.DurationMs.Encode(e)
				}
			}
			{
				if s.HasNamespace.Set {
					e.FieldStart("has_namespace")
					s.HasNamespace.Encode(e)
				}
			}
			{
				if s.HasPod.Set {
					e.FieldStart("has_pod")
					s.HasPod.Encode(e)
				}
			}
			{
				if s.HasDeployment.Set {
					e.FieldStart("has_deployment")
					s.HasDeployment.Encode(e)
				}
			}
			{
				if s.BusinessUnit.Set {
					e.FieldStart("business_unit")
					s.BusinessUnit.Encode(e)
				}
			}
			{
				if s.FromPhase.Set {
					e.FieldStart("from_phase")
					s.FromPhase.Encode(e)
				}
			}
			{
				if s.ToPhase.Set {
					e.FieldStart("to_phase")
					s.ToPhase.Encode(e)
				}
			}
			{
				if s.SignalMode.Set {
					e.FieldStart("signal_mode")
					s.SignalMode.Encode(e)
				}
			}
			{
				if s.OriginalSignalType.Set {
					e.FieldStart("original_signal_type")
					s.OriginalSignalType.Encode(e)
				}
			}
			{
				if s.Error.Set {
					e.FieldStart("error")
					s.Error.Encode(e)
				}
			}
		}
	case AuditEventEventDataAianalysisAnalysisCompletedAuditEventEventData, AuditEventEventDataAianalysisAnalysisFailedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataAianalysisAnalysisCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.analysis.completed")
		case AuditEventEventDataAianalysisAnalysisFailedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.analysis.failed")
		}
		{
			s := s.AIAnalysisAuditPayload
			{
				e.FieldStart("analysis_name")
				e.Str(s.AnalysisName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("approval_required")
				e.Bool(s.ApprovalRequired)
			}
			{
				if s.ApprovalReason.Set {
					e.FieldStart("approval_reason")
					s.ApprovalReason.Encode(e)
				}
			}
			{
				e.FieldStart("degraded_mode")
				e.Bool(s.DegradedMode)
			}
			{
				e.FieldStart("warnings_count")
				e.Int(s.WarningsCount)
			}
			{
				if s.Confidence.Set {
					e.FieldStart("confidence")
					s.Confidence.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.TargetInOwnerChain.Set {
					e.FieldStart("target_in_owner_chain")
					s.TargetInOwnerChain.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.SubReason.Set {
					e.FieldStart("sub_reason")
					s.SubReason.Encode(e)
				}
			}
			{
				if s.ProviderResponseSummary.Set {
					e.FieldStart("provider_response_summary")
					s.ProviderResponseSummary.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
		}
	case AuditEventEventDataWorkflowexecutionExecutionStartedAuditEventEventData, AuditEventEventDataWorkflowexecutionSelectionCompletedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowCompletedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowFailedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowStartedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataWorkflowexecutionExecutionStartedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.execution.started")
		case AuditEventEventDataWorkflowexecutionSelectionCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.selection.completed")
		case AuditEventEventDataWorkflowexecutionWorkflowCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.completed")
		case AuditEventEventDataWorkflowexecutionWorkflowFailedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.failed")
		case AuditEventEventDataWorkflowexecutionWorkflowStartedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.started")
		}
		{
			s := s.WorkflowExecutionAuditPayload
			{
				e.FieldStart("workflow_id")
				e.Str(s.WorkflowID)
			}
			{
				e.FieldStart("workflow_version")
				e.Str(s.WorkflowVersion)
			}
			{
				e.FieldStart("target_resource")
				e.Str(s.TargetResource)
			}
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("container_image")
				e.Str(s.ContainerImage)
			}
			{
				e.FieldStart("execution_name")
				e.Str(s.ExecutionName)
			}
			{
				if s.StartedAt.Set {
					e.FieldStart("started_at")
					s.StartedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.CompletedAt.Set {
					e.FieldStart("completed_at")
					s.CompletedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.FailureReason.Set {
					e.FieldStart("failure_reason")
					s.FailureReason.Encode(e)
				}
			}
			{
				if s.FailureMessage.Set {
					e.FieldStart("failure_message")
					s.FailureMessage.Encode(e)
				}
			}
			{
				if s.FailedTaskName.Set {
					e.FieldStart("failed_task_name")
					s.FailedTaskName.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
			{
				if s.PipelinerunName.Set {
					e.FieldStart("pipelinerun_name")
					s.PipelinerunName.Encode(e)
				}
			}
		}
	case AuditEventEventDataWebhookNotificationAcknowledgedAuditEventEventData, AuditEventEventDataWebhookNotificationCancelledAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataWebhookNotificationAcknowledgedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("webhook.notification.acknowledged")
		case AuditEventEventDataWebhookNotificationCancelledAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("webhook.notification.cancelled")
		}
		{
			s := s.NotificationAuditPayload
			{
				if s.NotificationID.Set {
					e.FieldStart("notification_id")
					s.NotificationID.Encode(e)
				}
			}
			{
				if s.NotificationName.Set {
					e.FieldStart("notification_name")
					s.NotificationName.Encode(e)
				}
			}
			{
				if s.Type.Set {
					e.FieldStart("type")
					s.Type.Encode(e)
				}
			}
			{
				if s.NotificationType.Set {
					e.FieldStart("notification_type")
					s.NotificationType.Encode(e)
				}
			}
			{
				if s.Priority.Set {
					e.FieldStart("priority")
					s.Priority.Encode(e)
				}
			}
			{
				if s.FinalStatus.Set {
					e.FieldStart("final_status")
					s.FinalStatus.Encode(e)
				}
			}
			{
				if s.Recipients != nil {
					e.FieldStart("recipients")
					e.ArrStart()
					for _, elem := range s.Recipients {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.CancelledBy.Set {
					e.FieldStart("cancelled_by")
					s.CancelledBy.Encode(e)
				}
			}
			{
				if s.UserUID.Set {
					e.FieldStart("user_uid")
					s.UserUID.Encode(e)
				}
			}
			{
				if s.UserGroups != nil {
					e.FieldStart("user_groups")
					e.ArrStart()
					for _, elem := range s.UserGroups {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Action.Set {
					e.FieldStart("action")
					s.Action.Encode(e)
				}
			}
		}
	case WorkflowExecutionWebhookAuditPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("workflowexecution.block.cleared")
		{
			s := s.WorkflowExecutionWebhookAuditPayload
			{
				e.FieldStart("workflow_name")
				e.Str(s.WorkflowName)
			}
			{
				e.FieldStart("clear_reason")
				e.Str(s.ClearReason)
			}
			{
				e.FieldStart("cleared_at")
				json.EncodeDateTime(e, s.ClearedAt)
			}
			{
				e.FieldStart("previous_state")
				s.PreviousState.Encode(e)
			}
			{
				e.FieldStart("new_state")
				s.NewState.Encode(e)
			}
		}
	case RemediationApprovalAuditPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("webhook.remediationapprovalrequest.decided")
		{
			s := s.RemediationApprovalAuditPayload
			{
				e.FieldStart("request_name")
				e.Str(s.RequestName)
			}
			{
				e.FieldStart("decision")
				s.Decision.Encode(e)
			}
			{
				e.FieldStart("decided_at")
				json.EncodeDateTime(e, s.DecidedAt)
			}
			{
				e.FieldStart("decision_message")
				e.Str(s.DecisionMessage)
			}
			{
				e.FieldStart("ai_analysis_ref")
				e.Str(s.AiAnalysisRef)
			}
		}
	case RemediationApprovalDecisionPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("RemediationApprovalDecisionPayload")
		{
			s := s.RemediationApprovalDecisionPayload
			{
				e.FieldStart("remediation_request_name")
				e.Str(s.RemediationRequestName)
			}
			{
				e.FieldStart("ai_analysis_name")
				e.Str(s.AiAnalysisName)
			}
			{
				e.FieldStart("decision")
				s.Decision.Encode(e)
			}
			{
				e.FieldStart("decided_by")
				e.Str(s.DecidedBy)
			}
			{
				if s.DecidedAt.Set {
					e.FieldStart("decided_at")
					s.DecidedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.DecisionMessage.Set {
					e.FieldStart("decision_message")
					s.DecisionMessage.Encode(e)
				}
			}
			{
				e.FieldStart("confidence")
				e.Float32(s.Confidence)
			}
			{
				e.FieldStart("workflow_id")
				e.Str(s.WorkflowID)
			}
			{
				if s.WorkflowVersion.Set {
					e.FieldStart("workflow_version")
					s.WorkflowVersion.Encode(e)
				}
			}
			{
				if s.TargetResource.Set {
					e.FieldStart("target_resource")
					s.TargetResource.Encode(e)
				}
			}
			{
				if s.TimeoutDeadline.Set {
					e.FieldStart("timeout_deadline")
					s.TimeoutDeadline.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.DecisionDurationSeconds.Set {
					e.FieldStart("decision_duration_seconds")
					s.DecisionDurationSeconds.Encode(e)
				}
			}
			{
				if s.ApprovalReason.Set {
					e.FieldStart("approval_reason")
					s.ApprovalReason.Encode(e)
				}
			}
			{
				if s.TimeoutReason.Set {
					e.FieldStart("timeout_reason")
					s.TimeoutReason.Encode(e)
				}
			}
			{
				if s.TimeoutDurationSeconds.Set {
					e.FieldStart("timeout_duration_seconds")
					s.TimeoutDurationSeconds.Encode(e)
				}
			}
		}
	case AuditEventEventDataWorkflowCatalogActionsListedAuditEventEventData, AuditEventEventDataWorkflowCatalogSelectionValidatedAuditEventEventData, AuditEventEventDataWorkflowCatalogWorkflowRetrievedAuditEventEventData, AuditEventEventDataWorkflowCatalogWorkflowsListedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataWorkflowCatalogActionsListedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.actions_listed")
		case AuditEventEventDataWorkflowCatalogSelectionValidatedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.selection_validated")
		case AuditEventEventDataWorkflowCatalogWorkflowRetrievedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.workflow_retrieved")
		case AuditEventEventDataWorkflowCatalogWorkflowsListedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.workflows_listed")
		}
		{
			s := s.WorkflowDiscoveryAuditPayload
			{
				e.FieldStart("query")
				s.Query.Encode(e)
			}
			{
				e.FieldStart("results")
				s.Results.Encode(e)
			}
			{
				e.FieldStart("search_metadata")
				s.SearchMetadata.Encode(e)
			}
		}
	case WorkflowCatalogCreatedPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("datastorage.workflow.created")
		{
			s := s.WorkflowCatalogCreatedPayload
			{
				e.FieldStart("workflow_id")
				json.EncodeUUID(e, s.WorkflowID)
			}
			{
				e.FieldStart("workflow_name")
				e.Str(s.WorkflowName)
			}
			{
				e.FieldStart("version")
				e.Str(s.Version)
			}
			{
				e.FieldStart("status")
				s.Status.Encode(e)
			}
			{
				e.FieldStart("is_latest_version")
				e.Bool(s.IsLatestVersion)
			}
			{
				e.FieldStart("execution_engine")
				e.Str(s.ExecutionEngine)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Labels.Set {
					e.FieldStart("labels")
					s.Labels.Encode(e)
				}
			}
		}
	case WorkflowCatalogUpdatedPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("datastorage.workflow.updated")
		{
			s := s.WorkflowCatalogUpdatedPayload
			{
				e.FieldStart("workflow_id")
				json.EncodeUUID(e, s.WorkflowID)
			}
			{
				e.FieldStart("updated_fields")
				s.UpdatedFields.Encode(e)
			}
		}
	case AIAnalysisPhaseTransitionPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.phase.transition")
		{
			s := s.AIAnalysisPhaseTransitionPayload
			{
				e.FieldStart("old_phase")
				e.Str(s.OldPhase)
			}
			{
				e.FieldStart("new_phase")
				e.Str(s.NewPhase)
			}
		}
	case AuditEventEventDataAianalysisAiagentCallAuditEventEventData, AuditEventEventDataAianalysisAiagentResultAuditEventEventData, AuditEventEventDataAianalysisAiagentSessionLostAuditEventEventData, AuditEventEventDataAianalysisAiagentSubmitAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataAianalysisAiagentCallAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.call")
		case AuditEventEventDataAianalysisAiagentResultAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.result")
		case AuditEventEventDataAianalysisAiagentSessionLostAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.session_lost")
		case AuditEventEventDataAianalysisAiagentSubmitAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.submit")
		}
		{
			s := s.AIAnalysisAIAgentCallPayload
			{
				e.FieldStart("endpoint")
				e.Str(s.Endpoint)
			}
			{
				e.FieldStart("http_status_code")
				e.Int32(s.HTTPStatusCode)
			}
			{
				e.FieldStart("duration_ms")
				e.Int32(s.DurationMs)
			}
		}
	case AIAnalysisApprovalDecisionPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.approval.decision")
		{
			s := s.AIAnalysisApprovalDecisionPayload
			{
				e.FieldStart("approval_required")
				e.Bool(s.ApprovalRequired)
			}
			{
				e.FieldStart("approval_reason")
				e.Str(s.ApprovalReason)
			}
			{
				e.FieldStart("auto_approved")
				e.Bool(s.AutoApproved)
			}
			{
				e.FieldStart("decision")
				e.Str(s.Decision)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
			{
				e.FieldStart("environment")
				e.Str(s.Environment)
			}
			{
				if s.Confidence.Set {
					e.FieldStart("confidence")
					s.Confidence.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
		}
	case AIAnalysisRegoEvaluationPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.rego.evaluation")
		{
			s := s.AIAnalysisRegoEvaluationPayload
			{
				e.FieldStart("outcome")
				e.Str(s.Outcome)
			}
			{
				e.FieldStart("degraded")
				e.Bool(s.Degraded)
			}
			{
				e.FieldStart("duration_ms")
				e.Int32(s.DurationMs)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
		}
	case AIAnalysisErrorPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.error.occurred")
		{
			s := s.AIAnalysisErrorPayload
			{
				e.FieldStart("phase")
				e.Str(s.Phase)
			}
			{
				e.FieldStart("error_message")
				e.Str(s.ErrorMessage)
			}
		}
	case NotificationMessageSentPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.sent")
		{
			s := s.NotificationMessageSentPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("channel")
				e.Str(s.Channel)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("body")
				e.Str(s.Body)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("type")
				e.Str(s.Type)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageFailedPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.failed")
		{
			s := s.NotificationMessageFailedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("channel")
				e.Str(s.Channel)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("body")
				e.Str(s.Body)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("error_type")
				e.Str(s.ErrorType)
			}
			{
				if s.Error.Set {
					e.FieldStart("error")
					s.Error.Encode(e)
				}
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageAcknowledgedPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.acknowledged")
		{
			s := s.NotificationMessageAcknowledgedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageEscalatedPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.escalated")
		{
			s := s.NotificationMessageEscalatedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case AIAgentResponsePayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.response.complete")
		{
			s := s.AIAgentResponsePayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("response_data")
				s.ResponseData.Encode(e)
			}
		}
	case LLMRequestPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.request")
		{
			s := s.LLMRequestPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("model")
				e.Str(s.Model)
			}
			{
				e.FieldStart("prompt_length")
				e.Int(s.PromptLength)
			}
			{
				e.FieldStart("prompt_preview")
				e.Str(s.PromptPreview)
			}
			{
				if s.MaxTokens.Set {
					e.FieldStart("max_tokens")
					s.MaxTokens.Encode(e)
				}
			}
			{
				if s.ToolsetsEnabled != nil {
					e.FieldStart("toolsets_enabled")
					e.ArrStart()
					for _, elem := range s.ToolsetsEnabled {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.McpServers != nil {
					e.FieldStart("mcp_servers")
					e.ArrStart()
					for _, elem := range s.McpServers {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case LLMResponsePayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.response")
		{
			s := s.LLMResponsePayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("has_analysis")
				e.Bool(s.HasAnalysis)
			}
			{
				e.FieldStart("analysis_length")
				e.Int(s.AnalysisLength)
			}
			{
				e.FieldStart("analysis_preview")
				e.Str(s.AnalysisPreview)
			}
			{
				if s.TokensUsed.Set {
					e.FieldStart("tokens_used")
					s.TokensUsed.Encode(e)
				}
			}
			{
				if s.ToolCallCount.Set {
					e.FieldStart("tool_call_count")
					s.ToolCallCount.Encode(e)
				}
			}
		}
	case LLMToolCallPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.tool_call")
		{
			s := s.LLMToolCallPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("tool_call_index")
				e.Int(s.ToolCallIndex)
			}
			{
				e.FieldStart("tool_name")
				e.Str(s.ToolName)
			}
			{
				if s.ToolArguments.Set {
					e.FieldStart("tool_arguments")
					s.ToolArguments.Encode(e)
				}
			}
			{
				if len(s.ToolResult) != 0 {
					e.FieldStart("tool_result")
					e.Raw(s.ToolResult)
				}
			}
			{
				if s.ToolResultPreview.Set {
					e.FieldStart("tool_result_preview")
					s.ToolResultPreview.Encode(e)
				}
			}
		}
	case WorkflowValidationPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.workflow.validation_attempt")
		{
			s := s.WorkflowValidationPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("attempt")
				e.Int(s.Attempt)
			}
			{
				e.FieldStart("max_attempts")
				e.Int(s.MaxAttempts)
			}
			{
				e.FieldStart("is_valid")
				e.Bool(s.IsValid)
			}
			{
				if s.Errors != nil {
					e.FieldStart("errors")
					e.ArrStart()
					for _, elem := range s.Errors {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ValidationErrors.Set {
					e.FieldStart("validation_errors")
					s.ValidationErrors.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.WorkflowName.Set {
					e.FieldStart("workflow_name")
					s.WorkflowName.Encode(e)
				}
			}
			{
				if s.HumanReviewReason.Set {
					e.FieldStart("human_review_reason")
					s.HumanReviewReason.Encode(e)
				}
			}
			{
				if s.IsFinalAttempt.Set {
					e.FieldStart("is_final_attempt")
					s.IsFinalAttempt.Encode(e)
				}
			}
		}
	case RemediationRequestWebhookAuditPayloadAuditEventEventData:
		e.FieldStart("event_type")
		e.Str("webhook.remediationrequest.timeout_modified")
		{
			s := s.RemediationRequestWebhookAuditPayload
			{
				e.FieldStart("rr_name")
				e.Str(s.RrName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("modified_by")
				e.Str(s.ModifiedBy)
			}
			{
				e.FieldStart("modified_at")
				json.EncodeDateTime(e, s.ModifiedAt)
			}
			{
				if s.OldTimeoutConfig.Set {
					e.FieldStart("old_timeout_config")
					s.OldTimeoutConfig.Encode(e)
				}
			}
			{
				if s.NewTimeoutConfig.Set {
					e.FieldStart("new_timeout_config")
					s.NewTimeoutConfig.Encode(e)
				}
			}
		}
	case AuditEventEventDataEffectivenessAlertAssessedAuditEventEventData, AuditEventEventDataEffectivenessAssessmentCompletedAuditEventEventData, AuditEventEventDataEffectivenessAssessmentScheduledAuditEventEventData, AuditEventEventDataEffectivenessHashComputedAuditEventEventData, AuditEventEventDataEffectivenessHealthAssessedAuditEventEventData, AuditEventEventDataEffectivenessMetricsAssessedAuditEventEventData:
		switch s.Type {
		case AuditEventEventDataEffectivenessAlertAssessedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.alert.assessed")
		case AuditEventEventDataEffectivenessAssessmentCompletedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.assessment.completed")
		case AuditEventEventDataEffectivenessAssessmentScheduledAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.assessment.scheduled")
		case AuditEventEventDataEffectivenessHashComputedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.hash.computed")
		case AuditEventEventDataEffectivenessHealthAssessedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.health.assessed")
		case AuditEventEventDataEffectivenessMetricsAssessedAuditEventEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.metrics.assessed")
		}
		{
			s := s.EffectivenessAssessmentAuditPayload
			{
				e.FieldStart("correlation_id")
				e.Str(s.CorrelationID)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				if s.EaName.Set {
					e.FieldStart("ea_name")
					s.EaName.Encode(e)
				}
			}
			{
				e.FieldStart("component")
				s.Component.Encode(e)
			}
			{
				if s.Assessed.Set {
					e.FieldStart("assessed")
					s.Assessed.Encode(e)
				}
			}
			{
				if s.Score.Set {
					e.FieldStart("score")
					s.Score.Encode(e)
				}
			}
			{
				if s.Details.Set {
					e.FieldStart("details")
					s.Details.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.AlertName.Set {
					e.FieldStart("alert_name")
					s.AlertName.Encode(e)
				}
			}
			{
				if s.ComponentsAssessed != nil {
					e.FieldStart("components_assessed")
					e.ArrStart()
					for _, elem := range s.ComponentsAssessed {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.CompletedAt.Set {
					e.FieldStart("completed_at")
					s.CompletedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.AssessmentDurationSeconds.Set {
					e.FieldStart("assessment_duration_seconds")
					s.AssessmentDurationSeconds.Encode(e)
				}
			}
			{
				if s.ValidityDeadline.Set {
					e.FieldStart("validity_deadline")
					s.ValidityDeadline.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.PrometheusCheckAfter.Set {
					e.FieldStart("prometheus_check_after")
					s.PrometheusCheckAfter.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.AlertmanagerCheckAfter.Set {
					e.FieldStart("alertmanager_check_after")
					s.AlertmanagerCheckAfter.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.ValidityWindow.Set {
					e.FieldStart("validity_window")
					s.ValidityWindow.Encode(e)
				}
			}
			{
				if s.StabilizationWindow.Set {
					e.FieldStart("stabilization_window")
					s.StabilizationWindow.Encode(e)
				}
			}
			{
				if s.PreRemediationSpecHash.Set {
					e.FieldStart("pre_remediation_spec_hash")
					s.PreRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.PostRemediationSpecHash.Set {
					e.FieldStart("post_remediation_spec_hash")
					s.PostRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.HashMatch.Set {
					e.FieldStart("hash_match")
					s.HashMatch.Encode(e)
				}
			}
			{
				if s.HealthChecks.Set {
					e.FieldStart("health_checks")
					s.HealthChecks.Encode(e)
				}
			}
			{
				if s.MetricDeltas.Set {
					e.FieldStart("metric_deltas")
					s.MetricDeltas.Encode(e)
				}
			}
			{
				if s.AlertResolution.Set {
					e.FieldStart("alert_resolution")
					s.AlertResolution.Encode(e)
				}
			}
		}
	}
}

// Decode decodes AuditEventEventData from json.
func (s *AuditEventEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventEventData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "event_type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "gateway.crd.created":
					s.Type = AuditEventEventDataGatewayCrdCreatedAuditEventEventData
					found = true
				case "gateway.crd.failed":
					s.Type = AuditEventEventDataGatewayCrdFailedAuditEventEventData
					found = true
				case "gateway.signal.deduplicated":
					s.Type = AuditEventEventDataGatewaySignalDeduplicatedAuditEventEventData
					found = true
				case "gateway.signal.received":
					s.Type = AuditEventEventDataGatewaySignalReceivedAuditEventEventData
					found = true
				case "orchestrator.approval.approved":
					s.Type = AuditEventEventDataOrchestratorApprovalApprovedAuditEventEventData
					found = true
				case "orchestrator.approval.rejected":
					s.Type = AuditEventEventDataOrchestratorApprovalRejectedAuditEventEventData
					found = true
				case "orchestrator.approval.requested":
					s.Type = AuditEventEventDataOrchestratorApprovalRequestedAuditEventEventData
					found = true
				case "orchestrator.lifecycle.completed":
					s.Type = AuditEventEventDataOrchestratorLifecycleCompletedAuditEventEventData
					found = true
				case "orchestrator.lifecycle.created":
					s.Type = AuditEventEventDataOrchestratorLifecycleCreatedAuditEventEventData
					found = true
				case "orchestrator.lifecycle.failed":
					s.Type = AuditEventEventDataOrchestratorLifecycleFailedAuditEventEventData
					found = true
				case "orchestrator.lifecycle.started":
					s.Type = AuditEventEventDataOrchestratorLifecycleStartedAuditEventEventData
					found = true
				case "orchestrator.lifecycle.transitioned":
					s.Type = AuditEventEventDataOrchestratorLifecycleTransitionedAuditEventEventData
					found = true
				case "orchestrator.remediation.manual_review":
					s.Type = AuditEventEventDataOrchestratorRemediationManualReviewAuditEventEventData
					found = true
				case "orchestrator.routing.blocked":
					s.Type = AuditEventEventDataOrchestratorRoutingBlockedAuditEventEventData
					found = true
				case "remediation.workflow_created":
					s.Type = AuditEventEventDataRemediationWorkflowCreatedAuditEventEventData
					found = true
				case "signalprocessing.business.classified":
					s.Type = AuditEventEventDataSignalprocessingBusinessClassifiedAuditEventEventData
					found = true
				case "signalprocessing.classification.decision":
					s.Type = AuditEventEventDataSignalprocessingClassificationDecisionAuditEventEventData
					found = true
				case "signalprocessing.enrichment.completed":
					s.Type = AuditEventEventDataSignalprocessingEnrichmentCompletedAuditEventEventData
					found = true
				case "signalprocessing.error.occurred":
					s.Type = AuditEventEventDataSignalprocessingErrorOccurredAuditEventEventData
					found = true
				case "signalprocessing.phase.transition":
					s.Type = AuditEventEventDataSignalprocessingPhaseTransitionAuditEventEventData
					found = true
				case "signalprocessing.signal.processed":
					s.Type = AuditEventEventDataSignalprocessingSignalProcessedAuditEventEventData
					found = true
				case "aianalysis.analysis.completed":
					s.Type = AuditEventEventDataAianalysisAnalysisCompletedAuditEventEventData
					found = true
				case "aianalysis.analysis.failed":
					s.Type = AuditEventEventDataAianalysisAnalysisFailedAuditEventEventData
					found = true
				case "workflowexecution.execution.started":
					s.Type = AuditEventEventDataWorkflowexecutionExecutionStartedAuditEventEventData
					found = true
				case "workflowexecution.selection.completed":
					s.Type = AuditEventEventDataWorkflowexecutionSelectionCompletedAuditEventEventData
					found = true
				case "workflowexecution.workflow.completed":
					s.Type = AuditEventEventDataWorkflowexecutionWorkflowCompletedAuditEventEventData
					found = true
				case "workflowexecution.workflow.failed":
					s.Type = AuditEventEventDataWorkflowexecutionWorkflowFailedAuditEventEventData
					found = true
				case "workflowexecution.workflow.started":
					s.Type = AuditEventEventDataWorkflowexecutionWorkflowStartedAuditEventEventData
					found = true
				case "webhook.notification.acknowledged":
					s.Type = AuditEventEventDataWebhookNotificationAcknowledgedAuditEventEventData
					found = true
				case "webhook.notification.cancelled":
					s.Type = AuditEventEventDataWebhookNotificationCancelledAuditEventEventData
					found = true
				case "workflowexecution.block.cleared":
					s.Type = WorkflowExecutionWebhookAuditPayloadAuditEventEventData
					found = true
				case "webhook.remediationapprovalrequest.decided":
					s.Type = RemediationApprovalAuditPayloadAuditEventEventData
					found = true
				case "RemediationApprovalDecisionPayload":
					s.Type = RemediationApprovalDecisionPayloadAuditEventEventData
					found = true
				case "workflow.catalog.actions_listed":
					s.Type = AuditEventEventDataWorkflowCatalogActionsListedAuditEventEventData
					found = true
				case "workflow.catalog.selection_validated":
					s.Type = AuditEventEventDataWorkflowCatalogSelectionValidatedAuditEventEventData
					found = true
				case "workflow.catalog.workflow_retrieved":
					s.Type = AuditEventEventDataWorkflowCatalogWorkflowRetrievedAuditEventEventData
					found = true
				case "workflow.catalog.workflows_listed":
					s.Type = AuditEventEventDataWorkflowCatalogWorkflowsListedAuditEventEventData
					found = true
				case "datastorage.workflow.created":
					s.Type = WorkflowCatalogCreatedPayloadAuditEventEventData
					found = true
				case "datastorage.workflow.updated":
					s.Type = WorkflowCatalogUpdatedPayloadAuditEventEventData
					found = true
				case "aianalysis.phase.transition":
					s.Type = AIAnalysisPhaseTransitionPayloadAuditEventEventData
					found = true
				case "aianalysis.aiagent.call":
					s.Type = AuditEventEventDataAianalysisAiagentCallAuditEventEventData
					found = true
				case "aianalysis.aiagent.result":
					s.Type = AuditEventEventDataAianalysisAiagentResultAuditEventEventData
					found = true
				case "aianalysis.aiagent.session_lost":
					s.Type = AuditEventEventDataAianalysisAiagentSessionLostAuditEventEventData
					found = true
				case "aianalysis.aiagent.submit":
					s.Type = AuditEventEventDataAianalysisAiagentSubmitAuditEventEventData
					found = true
				case "aianalysis.approval.decision":
					s.Type = AIAnalysisApprovalDecisionPayloadAuditEventEventData
					found = true
				case "aianalysis.rego.evaluation":
					s.Type = AIAnalysisRegoEvaluationPayloadAuditEventEventData
					found = true
				case "aianalysis.error.occurred":
					s.Type = AIAnalysisErrorPayloadAuditEventEventData
					found = true
				case "notification.message.sent":
					s.Type = NotificationMessageSentPayloadAuditEventEventData
					found = true
				case "notification.message.failed":
					s.Type = NotificationMessageFailedPayloadAuditEventEventData
					found = true
				case "notification.message.acknowledged":
					s.Type = NotificationMessageAcknowledgedPayloadAuditEventEventData
					found = true
				case "notification.message.escalated":
					s.Type = NotificationMessageEscalatedPayloadAuditEventEventData
					found = true
				case "aiagent.response.complete":
					s.Type = AIAgentResponsePayloadAuditEventEventData
					found = true
				case "aiagent.llm.request":
					s.Type = LLMRequestPayloadAuditEventEventData
					found = true
				case "aiagent.llm.response":
					s.Type = LLMResponsePayloadAuditEventEventData
					found = true
				case "aiagent.llm.tool_call":
					s.Type = LLMToolCallPayloadAuditEventEventData
					found = true
				case "aiagent.workflow.validation_attempt":
					s.Type = WorkflowValidationPayloadAuditEventEventData
					found = true
				case "webhook.remediationrequest.timeout_modified":
					s.Type = RemediationRequestWebhookAuditPayloadAuditEventEventData
					found = true
				case "effectiveness.alert.assessed":
					s.Type = AuditEventEventDataEffectivenessAlertAssessedAuditEventEventData
					found = true
				case "effectiveness.assessment.completed":
					s.Type = AuditEventEventDataEffectivenessAssessmentCompletedAuditEventEventData
					found = true
				case "effectiveness.assessment.scheduled":
					s.Type = AuditEventEventDataEffectivenessAssessmentScheduledAuditEventEventData
					found = true
				case "effectiveness.hash.computed":
					s.Type = AuditEventEventDataEffectivenessHashComputedAuditEventEventData
					found = true
				case "effectiveness.health.assessed":
					s.Type = AuditEventEventDataEffectivenessHealthAssessedAuditEventEventData
					found = true
				case "effectiveness.metrics.assessed":
					s.Type = AuditEventEventDataEffectivenessMetricsAssessedAuditEventEventData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AuditEventEventDataGatewayCrdCreatedAuditEventEventData, AuditEventEventDataGatewayCrdFailedAuditEventEventData, AuditEventEventDataGatewaySignalDeduplicatedAuditEventEventData, AuditEventEventDataGatewaySignalReceivedAuditEventEventData:
		if err := s.GatewayAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataOrchestratorApprovalApprovedAuditEventEventData, AuditEventEventDataOrchestratorApprovalRejectedAuditEventEventData, AuditEventEventDataOrchestratorApprovalRequestedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleCompletedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleCreatedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleFailedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleStartedAuditEventEventData, AuditEventEventDataOrchestratorLifecycleTransitionedAuditEventEventData, AuditEventEventDataOrchestratorRemediationManualReviewAuditEventEventData, AuditEventEventDataOrchestratorRoutingBlockedAuditEventEventData, AuditEventEventDataRemediationWorkflowCreatedAuditEventEventData:
		if err := s.RemediationOrchestratorAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataSignalprocessingBusinessClassifiedAuditEventEventData, AuditEventEventDataSignalprocessingClassificationDecisionAuditEventEventData, AuditEventEventDataSignalprocessingEnrichmentCompletedAuditEventEventData, AuditEventEventDataSignalprocessingErrorOccurredAuditEventEventData, AuditEventEventDataSignalprocessingPhaseTransitionAuditEventEventData, AuditEventEventDataSignalprocessingSignalProcessedAuditEventEventData:
		if err := s.SignalProcessingAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataAianalysisAnalysisCompletedAuditEventEventData, AuditEventEventDataAianalysisAnalysisFailedAuditEventEventData:
		if err := s.AIAnalysisAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataWorkflowexecutionExecutionStartedAuditEventEventData, AuditEventEventDataWorkflowexecutionSelectionCompletedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowCompletedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowFailedAuditEventEventData, AuditEventEventDataWorkflowexecutionWorkflowStartedAuditEventEventData:
		if err := s.WorkflowExecutionAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataWebhookNotificationAcknowledgedAuditEventEventData, AuditEventEventDataWebhookNotificationCancelledAuditEventEventData:
		if err := s.NotificationAuditPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowExecutionWebhookAuditPayloadAuditEventEventData:
		if err := s.WorkflowExecutionWebhookAuditPayload.Decode(d); err != nil {
			return err
		}
	case RemediationApprovalAuditPayloadAuditEventEventData:
		if err := s.RemediationApprovalAuditPayload.Decode(d); err != nil {
			return err
		}
	case RemediationApprovalDecisionPayloadAuditEventEventData:
		if err := s.RemediationApprovalDecisionPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataWorkflowCatalogActionsListedAuditEventEventData, AuditEventEventDataWorkflowCatalogSelectionValidatedAuditEventEventData, AuditEventEventDataWorkflowCatalogWorkflowRetrievedAuditEventEventData, AuditEventEventDataWorkflowCatalogWorkflowsListedAuditEventEventData:
		if err := s.WorkflowDiscoveryAuditPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowCatalogCreatedPayloadAuditEventEventData:
		if err := s.WorkflowCatalogCreatedPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowCatalogUpdatedPayloadAuditEventEventData:
		if err := s.WorkflowCatalogUpdatedPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisPhaseTransitionPayloadAuditEventEventData:
		if err := s.AIAnalysisPhaseTransitionPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataAianalysisAiagentCallAuditEventEventData, AuditEventEventDataAianalysisAiagentResultAuditEventEventData, AuditEventEventDataAianalysisAiagentSessionLostAuditEventEventData, AuditEventEventDataAianalysisAiagentSubmitAuditEventEventData:
		if err := s.AIAnalysisAIAgentCallPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisApprovalDecisionPayloadAuditEventEventData:
		if err := s.AIAnalysisApprovalDecisionPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisRegoEvaluationPayloadAuditEventEventData:
		if err := s.AIAnalysisRegoEvaluationPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisErrorPayloadAuditEventEventData:
		if err := s.AIAnalysisErrorPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageSentPayloadAuditEventEventData:
		if err := s.NotificationMessageSentPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageFailedPayloadAuditEventEventData:
		if err := s.NotificationMessageFailedPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageAcknowledgedPayloadAuditEventEventData:
		if err := s.NotificationMessageAcknowledgedPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageEscalatedPayloadAuditEventEventData:
		if err := s.NotificationMessageEscalatedPayload.Decode(d); err != nil {
			return err
		}
	case AIAgentResponsePayloadAuditEventEventData:
		if err := s.AIAgentResponsePayload.Decode(d); err != nil {
			return err
		}
	case LLMRequestPayloadAuditEventEventData:
		if err := s.LLMRequestPayload.Decode(d); err != nil {
			return err
		}
	case LLMResponsePayloadAuditEventEventData:
		if err := s.LLMResponsePayload.Decode(d); err != nil {
			return err
		}
	case LLMToolCallPayloadAuditEventEventData:
		if err := s.LLMToolCallPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowValidationPayloadAuditEventEventData:
		if err := s.WorkflowValidationPayload.Decode(d); err != nil {
			return err
		}
	case RemediationRequestWebhookAuditPayloadAuditEventEventData:
		if err := s.RemediationRequestWebhookAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventEventDataEffectivenessAlertAssessedAuditEventEventData, AuditEventEventDataEffectivenessAssessmentCompletedAuditEventEventData, AuditEventEventDataEffectivenessAssessmentScheduledAuditEventEventData, AuditEventEventDataEffectivenessHashComputedAuditEventEventData, AuditEventEventDataEffectivenessHealthAssessedAuditEventEventData, AuditEventEventDataEffectivenessMetricsAssessedAuditEventEventData:
		if err := s.EffectivenessAssessmentAuditPayload.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventEventOutcome as json.
func (s AuditEventEventOutcome) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuditEventEventOutcome from json.
func (s *AuditEventEventOutcome) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventEventOutcome to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuditEventEventOutcome(v) {
	case AuditEventEventOutcomeSuccess:
		*s = AuditEventEventOutcomeSuccess
	case AuditEventEventOutcomeFailure:
		*s = AuditEventEventOutcomeFailure
	case AuditEventEventOutcomePending:
		*s = AuditEventEventOutcomePending
	default:
		*s = AuditEventEventOutcome(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventEventOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventEventOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditEventRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditEventRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("event_type")
		e.Str(s.EventType)
	}
	{
		e.FieldStart("event_timestamp")
		json.EncodeDateTime(e, s.EventTimestamp)
	}
	{
		e.FieldStart("event_category")
		s.EventCategory.Encode(e)
	}
	{
		e.FieldStart("event_action")
		e.Str(s.EventAction)
	}
	{
		e.FieldStart("event_outcome")
		s.EventOutcome.Encode(e)
	}
	{
		if s.ActorType.Set {
			e.FieldStart("actor_type")
			s.ActorType.Encode(e)
		}
	}
	{
		if s.ActorID.Set {
			e.FieldStart("actor_id")
			s.ActorID.Encode(e)
		}
	}
	{
		if s.ResourceType.Set {
			e.FieldStart("resource_type")
			s.ResourceType.Encode(e)
		}
	}
	{
		if s.ResourceID.Set {
			e.FieldStart("resource_id")
			s.ResourceID.Encode(e)
		}
	}
	{
		e.FieldStart("correlation_id")
		e.Str(s.CorrelationID)
	}
	{
		if s.ParentEventID.Set {
			e.FieldStart("parent_event_id")
			s.ParentEventID.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("cluster_name")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		e.FieldStart("event_data")
		s.EventData.Encode(e)
	}
}

var jsonFieldsNameOfAuditEventRequest = [17]string{
	0:  "version",
	1:  "event_type",
	2:  "event_timestamp",
	3:  "event_category",
	4:  "event_action",
	5:  "event_outcome",
	6:  "actor_type",
	7:  "actor_id",
	8:  "resource_type",
	9:  "resource_id",
	10: "correlation_id",
	11: "parent_event_id",
	12: "namespace",
	13: "cluster_name",
	14: "severity",
	15: "duration_ms",
	16: "event_data",
}

// Decode decodes AuditEventRequest from json.
func (s *AuditEventRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventRequest to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "event_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EventTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_timestamp\"")
			}
		case "event_category":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EventCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_category\"")
			}
		case "event_action":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.EventAction = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_action\"")
			}
		case "event_outcome":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.EventOutcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_outcome\"")
			}
		case "actor_type":
			if err := func() error {
				s.ActorType.Reset()
				if err := s.ActorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_type\"")
			}
		case "actor_id":
			if err := func() error {
				s.ActorID.Reset()
				if err := s.ActorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actor_id\"")
			}
		case "resource_type":
			if err := func() error {
				s.ResourceType.Reset()
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		case "resource_id":
			if err := func() error {
				s.ResourceID.Reset()
				if err := s.ResourceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_id\"")
			}
		case "correlation_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CorrelationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "parent_event_id":
			if err := func() error {
				s.ParentEventID.Reset()
				if err := s.ParentEventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_event_id\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "cluster_name":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster_name\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "event_data":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.EventData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditEventRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00111111,
		0b00000100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditEventRequest) {
					name = jsonFieldsNameOfAuditEventRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditEventRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventRequestEventCategory as json.
func (s AuditEventRequestEventCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuditEventRequestEventCategory from json.
func (s *AuditEventRequestEventCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventRequestEventCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuditEventRequestEventCategory(v) {
	case AuditEventRequestEventCategoryGateway:
		*s = AuditEventRequestEventCategoryGateway
	case AuditEventRequestEventCategoryNotification:
		*s = AuditEventRequestEventCategoryNotification
	case AuditEventRequestEventCategoryAnalysis:
		*s = AuditEventRequestEventCategoryAnalysis
	case AuditEventRequestEventCategoryAiagent:
		*s = AuditEventRequestEventCategoryAiagent
	case AuditEventRequestEventCategorySignalprocessing:
		*s = AuditEventRequestEventCategorySignalprocessing
	case AuditEventRequestEventCategoryWorkflow:
		*s = AuditEventRequestEventCategoryWorkflow
	case AuditEventRequestEventCategoryWorkflowexecution:
		*s = AuditEventRequestEventCategoryWorkflowexecution
	case AuditEventRequestEventCategoryOrchestration:
		*s = AuditEventRequestEventCategoryOrchestration
	case AuditEventRequestEventCategoryWebhook:
		*s = AuditEventRequestEventCategoryWebhook
	case AuditEventRequestEventCategoryEffectiveness:
		*s = AuditEventRequestEventCategoryEffectiveness
	default:
		*s = AuditEventRequestEventCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventRequestEventCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventRequestEventCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventRequestEventData as json.
func (s AuditEventRequestEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s AuditEventRequestEventData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AuditEventRequestEventDataGatewayCrdCreatedAuditEventRequestEventData, AuditEventRequestEventDataGatewayCrdFailedAuditEventRequestEventData, AuditEventRequestEventDataGatewaySignalDeduplicatedAuditEventRequestEventData, AuditEventRequestEventDataGatewaySignalReceivedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataGatewayCrdCreatedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("gateway.crd.created")
		case AuditEventRequestEventDataGatewayCrdFailedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("gateway.crd.failed")
		case AuditEventRequestEventDataGatewaySignalDeduplicatedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("gateway.signal.deduplicated")
		case AuditEventRequestEventDataGatewaySignalReceivedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("gateway.signal.received")
		}
		{
			s := s.GatewayAuditPayload
			{
				if s.OriginalPayload.Set {
					e.FieldStart("original_payload")
					s.OriginalPayload.Encode(e)
				}
			}
			{
				if s.SignalLabels.Set {
					e.FieldStart("signal_labels")
					s.SignalLabels.Encode(e)
				}
			}
			{
				if s.SignalAnnotations.Set {
					e.FieldStart("signal_annotations")
					s.SignalAnnotations.Encode(e)
				}
			}
			{
				e.FieldStart("signal_type")
				s.SignalType.Encode(e)
			}
			{
				e.FieldStart("alert_name")
				e.Str(s.AlertName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("fingerprint")
				e.Str(s.Fingerprint)
			}
			{
				if s.Severity.Set {
					e.FieldStart("severity")
					s.Severity.Encode(e)
				}
			}
			{
				if s.ResourceKind.Set {
					e.FieldStart("resource_kind")
					s.ResourceKind.Encode(e)
				}
			}
			{
				if s.ResourceName.Set {
					e.FieldStart("resource_name")
					s.ResourceName.Encode(e)
				}
			}
			{
				if s.RemediationRequest.Set {
					e.FieldStart("remediation_request")
					s.RemediationRequest.Encode(e)
				}
			}
			{
				if s.DeduplicationStatus.Set {
					e.FieldStart("deduplication_status")
					s.DeduplicationStatus.Encode(e)
				}
			}
			{
				if s.OccurrenceCount.Set {
					e.FieldStart("occurrence_count")
					s.OccurrenceCount.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataOrchestratorApprovalApprovedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorApprovalRejectedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorApprovalRequestedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleCompletedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleCreatedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleFailedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleStartedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleTransitionedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorRemediationManualReviewAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorRoutingBlockedAuditEventRequestEventData, AuditEventRequestEventDataRemediationWorkflowCreatedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataOrchestratorApprovalApprovedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.approved")
		case AuditEventRequestEventDataOrchestratorApprovalRejectedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.rejected")
		case AuditEventRequestEventDataOrchestratorApprovalRequestedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.approval.requested")
		case AuditEventRequestEventDataOrchestratorLifecycleCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.completed")
		case AuditEventRequestEventDataOrchestratorLifecycleCreatedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.created")
		case AuditEventRequestEventDataOrchestratorLifecycleFailedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.failed")
		case AuditEventRequestEventDataOrchestratorLifecycleStartedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.started")
		case AuditEventRequestEventDataOrchestratorLifecycleTransitionedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.lifecycle.transitioned")
		case AuditEventRequestEventDataOrchestratorRemediationManualReviewAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.remediation.manual_review")
		case AuditEventRequestEventDataOrchestratorRoutingBlockedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("orchestrator.routing.blocked")
		case AuditEventRequestEventDataRemediationWorkflowCreatedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("remediation.workflow_created")
		}
		{
			s := s.RemediationOrchestratorAuditPayload
			{
				e.FieldStart("rr_name")
				e.Str(s.RrName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				if s.Outcome.Set {
					e.FieldStart("outcome")
					s.Outcome.Encode(e)
				}
			}
			{
				if s.DurationMs.Set {
					e.FieldStart("duration_ms")
					s.DurationMs.Encode(e)
				}
			}
			{
				if s.FailurePhase.Set {
					e.FieldStart("failure_phase")
					s.FailurePhase.Encode(e)
				}
			}
			{
				if s.FailureReason.Set {
					e.FieldStart("failure_reason")
					s.FailureReason.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
			{
				if s.FromPhase.Set {
					e.FieldStart("from_phase")
					s.FromPhase.Encode(e)
				}
			}
			{
				if s.ToPhase.Set {
					e.FieldStart("to_phase")
					s.ToPhase.Encode(e)
				}
			}
			{
				if s.TransitionReason.Set {
					e.FieldStart("transition_reason")
					s.TransitionReason.Encode(e)
				}
			}
			{
				if s.RarName.Set {
					e.FieldStart("rar_name")
					s.RarName.Encode(e)
				}
			}
			{
				if s.RequiredBy.Set {
					e.FieldStart("required_by")
					s.RequiredBy.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.ConfidenceStr.Set {
					e.FieldStart("confidence_str")
					s.ConfidenceStr.Encode(e)
				}
			}
			{
				if s.Decision.Set {
					e.FieldStart("decision")
					s.Decision.Encode(e)
				}
			}
			{
				if s.ApprovedBy.Set {
					e.FieldStart("approved_by")
					s.ApprovedBy.Encode(e)
				}
			}
			{
				if s.RejectedBy.Set {
					e.FieldStart("rejected_by")
					s.RejectedBy.Encode(e)
				}
			}
			{
				if s.RejectionReason.Set {
					e.FieldStart("rejection_reason")
					s.RejectionReason.Encode(e)
				}
			}
			{
				if s.Message.Set {
					e.FieldStart("message")
					s.Message.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.SubReason.Set {
					e.FieldStart("sub_reason")
					s.SubReason.Encode(e)
				}
			}
			{
				if s.NotificationName.Set {
					e.FieldStart("notification_name")
					s.NotificationName.Encode(e)
				}
			}
			{
				if s.TimeoutConfig.Set {
					e.FieldStart("timeout_config")
					s.TimeoutConfig.Encode(e)
				}
			}
			{
				if s.PreRemediationSpecHash.Set {
					e.FieldStart("pre_remediation_spec_hash")
					s.PreRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.TargetResource.Set {
					e.FieldStart("target_resource")
					s.TargetResource.Encode(e)
				}
			}
			{
				if s.WorkflowVersion.Set {
					e.FieldStart("workflow_version")
					s.WorkflowVersion.Encode(e)
				}
			}
			{
				if s.WorkflowType.Set {
					e.FieldStart("workflow_type")
					s.WorkflowType.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataSignalprocessingBusinessClassifiedAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingClassificationDecisionAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingEnrichmentCompletedAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingErrorOccurredAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingPhaseTransitionAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingSignalProcessedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataSignalprocessingBusinessClassifiedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.business.classified")
		case AuditEventRequestEventDataSignalprocessingClassificationDecisionAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.classification.decision")
		case AuditEventRequestEventDataSignalprocessingEnrichmentCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.enrichment.completed")
		case AuditEventRequestEventDataSignalprocessingErrorOccurredAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.error.occurred")
		case AuditEventRequestEventDataSignalprocessingPhaseTransitionAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.phase.transition")
		case AuditEventRequestEventDataSignalprocessingSignalProcessedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("signalprocessing.signal.processed")
		}
		{
			s := s.SignalProcessingAuditPayload
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("signal")
				e.Str(s.Signal)
			}
			{
				if s.Severity.Set {
					e.FieldStart("severity")
					s.Severity.Encode(e)
				}
			}
			{
				if s.ExternalSeverity.Set {
					e.FieldStart("external_severity")
					s.ExternalSeverity.Encode(e)
				}
			}
			{
				if s.NormalizedSeverity.Set {
					e.FieldStart("normalized_severity")
					s.NormalizedSeverity.Encode(e)
				}
			}
			{
				if s.DeterminationSource.Set {
					e.FieldStart("determination_source")
					s.DeterminationSource.Encode(e)
				}
			}
			{
				if s.PolicyHash.Set {
					e.FieldStart("policy_hash")
					s.PolicyHash.Encode(e)
				}
			}
			{
				if s.Environment.Set {
					e.FieldStart("environment")
					s.Environment.Encode(e)
				}
			}
			{
				if s.EnvironmentSource.Set {
					e.FieldStart("environment_source")
					s.EnvironmentSource.Encode(e)
				}
			}
			{
				if s.Priority.Set {
					e.FieldStart("priority")
					s.Priority.Encode(e)
				}
			}
			{
				if s.PrioritySource.Set {
					e.FieldStart("priority_source")
					s.PrioritySource.Encode(e)
				}
			}
			{
				if s.Criticality.Set {
					e.FieldStart("criticality")
					s.Criticality.Encode(e)
				}
			}
			{
				if s.SLARequirement.Set {
					e.FieldStart("sla_requirement")
					s.SLARequirement.Encode(e)
				}
			}
			{
				if s.HasOwnerChain.Set {
					e.FieldStart("has_owner_chain")
					s.HasOwnerChain.Encode(e)
				}
			}
			{
				if s.OwnerChainLength.Set {
					e.FieldStart("owner_chain_length")
					s.OwnerChainLength.Encode(e)
				}
			}
			{
				if s.DegradedMode.Set {
					e.FieldStart("degraded_mode")
					s.DegradedMode.Encode(e)
				}
			}
			{
				if s.HasPdb.Set {
					e.FieldStart("has_pdb")
					s.HasPdb.Encode(e)
				}
			}
			{
				if s.HasHpa.Set {
					e.FieldStart("has_hpa")
					s.HasHpa.Encode(e)
				}
			}
			{
				if s.DurationMs.Set {
					e.FieldStart("duration_ms")
					s.DurationMs.Encode(e)
				}
			}
			{
				if s.HasNamespace.Set {
					e.FieldStart("has_namespace")
					s.HasNamespace.Encode(e)
				}
			}
			{
				if s.HasPod.Set {
					e.FieldStart("has_pod")
					s.HasPod.Encode(e)
				}
			}
			{
				if s.HasDeployment.Set {
					e.FieldStart("has_deployment")
					s.HasDeployment.Encode(e)
				}
			}
			{
				if s.BusinessUnit.Set {
					e.FieldStart("business_unit")
					s.BusinessUnit.Encode(e)
				}
			}
			{
				if s.FromPhase.Set {
					e.FieldStart("from_phase")
					s.FromPhase.Encode(e)
				}
			}
			{
				if s.ToPhase.Set {
					e.FieldStart("to_phase")
					s.ToPhase.Encode(e)
				}
			}
			{
				if s.SignalMode.Set {
					e.FieldStart("signal_mode")
					s.SignalMode.Encode(e)
				}
			}
			{
				if s.OriginalSignalType.Set {
					e.FieldStart("original_signal_type")
					s.OriginalSignalType.Encode(e)
				}
			}
			{
				if s.Error.Set {
					e.FieldStart("error")
					s.Error.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataAianalysisAnalysisCompletedAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAnalysisFailedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataAianalysisAnalysisCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.analysis.completed")
		case AuditEventRequestEventDataAianalysisAnalysisFailedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.analysis.failed")
		}
		{
			s := s.AIAnalysisAuditPayload
			{
				e.FieldStart("analysis_name")
				e.Str(s.AnalysisName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("approval_required")
				e.Bool(s.ApprovalRequired)
			}
			{
				if s.ApprovalReason.Set {
					e.FieldStart("approval_reason")
					s.ApprovalReason.Encode(e)
				}
			}
			{
				e.FieldStart("degraded_mode")
				e.Bool(s.DegradedMode)
			}
			{
				e.FieldStart("warnings_count")
				e.Int(s.WarningsCount)
			}
			{
				if s.Confidence.Set {
					e.FieldStart("confidence")
					s.Confidence.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.TargetInOwnerChain.Set {
					e.FieldStart("target_in_owner_chain")
					s.TargetInOwnerChain.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.SubReason.Set {
					e.FieldStart("sub_reason")
					s.SubReason.Encode(e)
				}
			}
			{
				if s.ProviderResponseSummary.Set {
					e.FieldStart("provider_response_summary")
					s.ProviderResponseSummary.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataWorkflowexecutionExecutionStartedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionSelectionCompletedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowCompletedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowFailedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowStartedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataWorkflowexecutionExecutionStartedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.execution.started")
		case AuditEventRequestEventDataWorkflowexecutionSelectionCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.selection.completed")
		case AuditEventRequestEventDataWorkflowexecutionWorkflowCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.completed")
		case AuditEventRequestEventDataWorkflowexecutionWorkflowFailedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.failed")
		case AuditEventRequestEventDataWorkflowexecutionWorkflowStartedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflowexecution.workflow.started")
		}
		{
			s := s.WorkflowExecutionAuditPayload
			{
				e.FieldStart("workflow_id")
				e.Str(s.WorkflowID)
			}
			{
				e.FieldStart("workflow_version")
				e.Str(s.WorkflowVersion)
			}
			{
				e.FieldStart("target_resource")
				e.Str(s.TargetResource)
			}
			{
				e.FieldStart("phase")
				s.Phase.Encode(e)
			}
			{
				e.FieldStart("container_image")
				e.Str(s.ContainerImage)
			}
			{
				e.FieldStart("execution_name")
				e.Str(s.ExecutionName)
			}
			{
				if s.StartedAt.Set {
					e.FieldStart("started_at")
					s.StartedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.CompletedAt.Set {
					e.FieldStart("completed_at")
					s.CompletedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.Duration.Set {
					e.FieldStart("duration")
					s.Duration.Encode(e)
				}
			}
			{
				if s.FailureReason.Set {
					e.FieldStart("failure_reason")
					s.FailureReason.Encode(e)
				}
			}
			{
				if s.FailureMessage.Set {
					e.FieldStart("failure_message")
					s.FailureMessage.Encode(e)
				}
			}
			{
				if s.FailedTaskName.Set {
					e.FieldStart("failed_task_name")
					s.FailedTaskName.Encode(e)
				}
			}
			{
				if s.ErrorDetails.Set {
					e.FieldStart("error_details")
					s.ErrorDetails.Encode(e)
				}
			}
			{
				if s.PipelinerunName.Set {
					e.FieldStart("pipelinerun_name")
					s.PipelinerunName.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataWebhookNotificationAcknowledgedAuditEventRequestEventData, AuditEventRequestEventDataWebhookNotificationCancelledAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataWebhookNotificationAcknowledgedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("webhook.notification.acknowledged")
		case AuditEventRequestEventDataWebhookNotificationCancelledAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("webhook.notification.cancelled")
		}
		{
			s := s.NotificationAuditPayload
			{
				if s.NotificationID.Set {
					e.FieldStart("notification_id")
					s.NotificationID.Encode(e)
				}
			}
			{
				if s.NotificationName.Set {
					e.FieldStart("notification_name")
					s.NotificationName.Encode(e)
				}
			}
			{
				if s.Type.Set {
					e.FieldStart("type")
					s.Type.Encode(e)
				}
			}
			{
				if s.NotificationType.Set {
					e.FieldStart("notification_type")
					s.NotificationType.Encode(e)
				}
			}
			{
				if s.Priority.Set {
					e.FieldStart("priority")
					s.Priority.Encode(e)
				}
			}
			{
				if s.FinalStatus.Set {
					e.FieldStart("final_status")
					s.FinalStatus.Encode(e)
				}
			}
			{
				if s.Recipients != nil {
					e.FieldStart("recipients")
					e.ArrStart()
					for _, elem := range s.Recipients {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				if s.CancelledBy.Set {
					e.FieldStart("cancelled_by")
					s.CancelledBy.Encode(e)
				}
			}
			{
				if s.UserUID.Set {
					e.FieldStart("user_uid")
					s.UserUID.Encode(e)
				}
			}
			{
				if s.UserGroups != nil {
					e.FieldStart("user_groups")
					e.ArrStart()
					for _, elem := range s.UserGroups {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.Action.Set {
					e.FieldStart("action")
					s.Action.Encode(e)
				}
			}
		}
	case WorkflowExecutionWebhookAuditPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("workflowexecution.block.cleared")
		{
			s := s.WorkflowExecutionWebhookAuditPayload
			{
				e.FieldStart("workflow_name")
				e.Str(s.WorkflowName)
			}
			{
				e.FieldStart("clear_reason")
				e.Str(s.ClearReason)
			}
			{
				e.FieldStart("cleared_at")
				json.EncodeDateTime(e, s.ClearedAt)
			}
			{
				e.FieldStart("previous_state")
				s.PreviousState.Encode(e)
			}
			{
				e.FieldStart("new_state")
				s.NewState.Encode(e)
			}
		}
	case RemediationApprovalAuditPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("webhook.remediationapprovalrequest.decided")
		{
			s := s.RemediationApprovalAuditPayload
			{
				e.FieldStart("request_name")
				e.Str(s.RequestName)
			}
			{
				e.FieldStart("decision")
				s.Decision.Encode(e)
			}
			{
				e.FieldStart("decided_at")
				json.EncodeDateTime(e, s.DecidedAt)
			}
			{
				e.FieldStart("decision_message")
				e.Str(s.DecisionMessage)
			}
			{
				e.FieldStart("ai_analysis_ref")
				e.Str(s.AiAnalysisRef)
			}
		}
	case RemediationApprovalDecisionPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("RemediationApprovalDecisionPayload")
		{
			s := s.RemediationApprovalDecisionPayload
			{
				e.FieldStart("remediation_request_name")
				e.Str(s.RemediationRequestName)
			}
			{
				e.FieldStart("ai_analysis_name")
				e.Str(s.AiAnalysisName)
			}
			{
				e.FieldStart("decision")
				s.Decision.Encode(e)
			}
			{
				e.FieldStart("decided_by")
				e.Str(s.DecidedBy)
			}
			{
				if s.DecidedAt.Set {
					e.FieldStart("decided_at")
					s.DecidedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.DecisionMessage.Set {
					e.FieldStart("decision_message")
					s.DecisionMessage.Encode(e)
				}
			}
			{
				e.FieldStart("confidence")
				e.Float32(s.Confidence)
			}
			{
				e.FieldStart("workflow_id")
				e.Str(s.WorkflowID)
			}
			{
				if s.WorkflowVersion.Set {
					e.FieldStart("workflow_version")
					s.WorkflowVersion.Encode(e)
				}
			}
			{
				if s.TargetResource.Set {
					e.FieldStart("target_resource")
					s.TargetResource.Encode(e)
				}
			}
			{
				if s.TimeoutDeadline.Set {
					e.FieldStart("timeout_deadline")
					s.TimeoutDeadline.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.DecisionDurationSeconds.Set {
					e.FieldStart("decision_duration_seconds")
					s.DecisionDurationSeconds.Encode(e)
				}
			}
			{
				if s.ApprovalReason.Set {
					e.FieldStart("approval_reason")
					s.ApprovalReason.Encode(e)
				}
			}
			{
				if s.TimeoutReason.Set {
					e.FieldStart("timeout_reason")
					s.TimeoutReason.Encode(e)
				}
			}
			{
				if s.TimeoutDurationSeconds.Set {
					e.FieldStart("timeout_duration_seconds")
					s.TimeoutDurationSeconds.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataWorkflowCatalogActionsListedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogSelectionValidatedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogWorkflowRetrievedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogWorkflowsListedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataWorkflowCatalogActionsListedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.actions_listed")
		case AuditEventRequestEventDataWorkflowCatalogSelectionValidatedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.selection_validated")
		case AuditEventRequestEventDataWorkflowCatalogWorkflowRetrievedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.workflow_retrieved")
		case AuditEventRequestEventDataWorkflowCatalogWorkflowsListedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("workflow.catalog.workflows_listed")
		}
		{
			s := s.WorkflowDiscoveryAuditPayload
			{
				e.FieldStart("query")
				s.Query.Encode(e)
			}
			{
				e.FieldStart("results")
				s.Results.Encode(e)
			}
			{
				e.FieldStart("search_metadata")
				s.SearchMetadata.Encode(e)
			}
		}
	case WorkflowCatalogCreatedPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("datastorage.workflow.created")
		{
			s := s.WorkflowCatalogCreatedPayload
			{
				e.FieldStart("workflow_id")
				json.EncodeUUID(e, s.WorkflowID)
			}
			{
				e.FieldStart("workflow_name")
				e.Str(s.WorkflowName)
			}
			{
				e.FieldStart("version")
				e.Str(s.Version)
			}
			{
				e.FieldStart("status")
				s.Status.Encode(e)
			}
			{
				e.FieldStart("is_latest_version")
				e.Bool(s.IsLatestVersion)
			}
			{
				e.FieldStart("execution_engine")
				e.Str(s.ExecutionEngine)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.Description.Set {
					e.FieldStart("description")
					s.Description.Encode(e)
				}
			}
			{
				if s.Labels.Set {
					e.FieldStart("labels")
					s.Labels.Encode(e)
				}
			}
		}
	case WorkflowCatalogUpdatedPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("datastorage.workflow.updated")
		{
			s := s.WorkflowCatalogUpdatedPayload
			{
				e.FieldStart("workflow_id")
				json.EncodeUUID(e, s.WorkflowID)
			}
			{
				e.FieldStart("updated_fields")
				s.UpdatedFields.Encode(e)
			}
		}
	case AIAnalysisPhaseTransitionPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.phase.transition")
		{
			s := s.AIAnalysisPhaseTransitionPayload
			{
				e.FieldStart("old_phase")
				e.Str(s.OldPhase)
			}
			{
				e.FieldStart("new_phase")
				e.Str(s.NewPhase)
			}
		}
	case AuditEventRequestEventDataAianalysisAiagentCallAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentResultAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentSessionLostAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentSubmitAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataAianalysisAiagentCallAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.call")
		case AuditEventRequestEventDataAianalysisAiagentResultAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.result")
		case AuditEventRequestEventDataAianalysisAiagentSessionLostAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.session_lost")
		case AuditEventRequestEventDataAianalysisAiagentSubmitAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("aianalysis.aiagent.submit")
		}
		{
			s := s.AIAnalysisAIAgentCallPayload
			{
				e.FieldStart("endpoint")
				e.Str(s.Endpoint)
			}
			{
				e.FieldStart("http_status_code")
				e.Int32(s.HTTPStatusCode)
			}
			{
				e.FieldStart("duration_ms")
				e.Int32(s.DurationMs)
			}
		}
	case AIAnalysisApprovalDecisionPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.approval.decision")
		{
			s := s.AIAnalysisApprovalDecisionPayload
			{
				e.FieldStart("approval_required")
				e.Bool(s.ApprovalRequired)
			}
			{
				e.FieldStart("approval_reason")
				e.Str(s.ApprovalReason)
			}
			{
				e.FieldStart("auto_approved")
				e.Bool(s.AutoApproved)
			}
			{
				e.FieldStart("decision")
				e.Str(s.Decision)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
			{
				e.FieldStart("environment")
				e.Str(s.Environment)
			}
			{
				if s.Confidence.Set {
					e.FieldStart("confidence")
					s.Confidence.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
		}
	case AIAnalysisRegoEvaluationPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.rego.evaluation")
		{
			s := s.AIAnalysisRegoEvaluationPayload
			{
				e.FieldStart("outcome")
				e.Str(s.Outcome)
			}
			{
				e.FieldStart("degraded")
				e.Bool(s.Degraded)
			}
			{
				e.FieldStart("duration_ms")
				e.Int32(s.DurationMs)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
		}
	case AIAnalysisErrorPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aianalysis.error.occurred")
		{
			s := s.AIAnalysisErrorPayload
			{
				e.FieldStart("phase")
				e.Str(s.Phase)
			}
			{
				e.FieldStart("error_message")
				e.Str(s.ErrorMessage)
			}
		}
	case NotificationMessageSentPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.sent")
		{
			s := s.NotificationMessageSentPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("channel")
				e.Str(s.Channel)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("body")
				e.Str(s.Body)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("type")
				e.Str(s.Type)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageFailedPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.failed")
		{
			s := s.NotificationMessageFailedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("channel")
				e.Str(s.Channel)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("body")
				e.Str(s.Body)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("error_type")
				e.Str(s.ErrorType)
			}
			{
				if s.Error.Set {
					e.FieldStart("error")
					s.Error.Encode(e)
				}
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageAcknowledgedPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.acknowledged")
		{
			s := s.NotificationMessageAcknowledgedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case NotificationMessageEscalatedPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("notification.message.escalated")
		{
			s := s.NotificationMessageEscalatedPayload
			{
				e.FieldStart("notification_id")
				e.Str(s.NotificationID)
			}
			{
				e.FieldStart("subject")
				e.Str(s.Subject)
			}
			{
				e.FieldStart("priority")
				e.Str(s.Priority)
			}
			{
				e.FieldStart("reason")
				e.Str(s.Reason)
			}
			{
				if s.Metadata.Set {
					e.FieldStart("metadata")
					s.Metadata.Encode(e)
				}
			}
		}
	case AIAgentResponsePayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.response.complete")
		{
			s := s.AIAgentResponsePayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("response_data")
				s.ResponseData.Encode(e)
			}
		}
	case LLMRequestPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.request")
		{
			s := s.LLMRequestPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("model")
				e.Str(s.Model)
			}
			{
				e.FieldStart("prompt_length")
				e.Int(s.PromptLength)
			}
			{
				e.FieldStart("prompt_preview")
				e.Str(s.PromptPreview)
			}
			{
				if s.MaxTokens.Set {
					e.FieldStart("max_tokens")
					s.MaxTokens.Encode(e)
				}
			}
			{
				if s.ToolsetsEnabled != nil {
					e.FieldStart("toolsets_enabled")
					e.ArrStart()
					for _, elem := range s.ToolsetsEnabled {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.McpServers != nil {
					e.FieldStart("mcp_servers")
					e.ArrStart()
					for _, elem := range s.McpServers {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case LLMResponsePayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.response")
		{
			s := s.LLMResponsePayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("has_analysis")
				e.Bool(s.HasAnalysis)
			}
			{
				e.FieldStart("analysis_length")
				e.Int(s.AnalysisLength)
			}
			{
				e.FieldStart("analysis_preview")
				e.Str(s.AnalysisPreview)
			}
			{
				if s.TokensUsed.Set {
					e.FieldStart("tokens_used")
					s.TokensUsed.Encode(e)
				}
			}
			{
				if s.ToolCallCount.Set {
					e.FieldStart("tool_call_count")
					s.ToolCallCount.Encode(e)
				}
			}
		}
	case LLMToolCallPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.llm.tool_call")
		{
			s := s.LLMToolCallPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("tool_call_index")
				e.Int(s.ToolCallIndex)
			}
			{
				e.FieldStart("tool_name")
				e.Str(s.ToolName)
			}
			{
				if s.ToolArguments.Set {
					e.FieldStart("tool_arguments")
					s.ToolArguments.Encode(e)
				}
			}
			{
				if len(s.ToolResult) != 0 {
					e.FieldStart("tool_result")
					e.Raw(s.ToolResult)
				}
			}
			{
				if s.ToolResultPreview.Set {
					e.FieldStart("tool_result_preview")
					s.ToolResultPreview.Encode(e)
				}
			}
		}
	case WorkflowValidationPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("aiagent.workflow.validation_attempt")
		{
			s := s.WorkflowValidationPayload
			{
				e.FieldStart("event_id")
				e.Str(s.EventID)
			}
			{
				e.FieldStart("incident_id")
				e.Str(s.IncidentID)
			}
			{
				e.FieldStart("attempt")
				e.Int(s.Attempt)
			}
			{
				e.FieldStart("max_attempts")
				e.Int(s.MaxAttempts)
			}
			{
				e.FieldStart("is_valid")
				e.Bool(s.IsValid)
			}
			{
				if s.Errors != nil {
					e.FieldStart("errors")
					e.ArrStart()
					for _, elem := range s.Errors {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.ValidationErrors.Set {
					e.FieldStart("validation_errors")
					s.ValidationErrors.Encode(e)
				}
			}
			{
				if s.WorkflowID.Set {
					e.FieldStart("workflow_id")
					s.WorkflowID.Encode(e)
				}
			}
			{
				if s.WorkflowName.Set {
					e.FieldStart("workflow_name")
					s.WorkflowName.Encode(e)
				}
			}
			{
				if s.HumanReviewReason.Set {
					e.FieldStart("human_review_reason")
					s.HumanReviewReason.Encode(e)
				}
			}
			{
				if s.IsFinalAttempt.Set {
					e.FieldStart("is_final_attempt")
					s.IsFinalAttempt.Encode(e)
				}
			}
		}
	case RemediationRequestWebhookAuditPayloadAuditEventRequestEventData:
		e.FieldStart("event_type")
		e.Str("webhook.remediationrequest.timeout_modified")
		{
			s := s.RemediationRequestWebhookAuditPayload
			{
				e.FieldStart("rr_name")
				e.Str(s.RrName)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				e.FieldStart("modified_by")
				e.Str(s.ModifiedBy)
			}
			{
				e.FieldStart("modified_at")
				json.EncodeDateTime(e, s.ModifiedAt)
			}
			{
				if s.OldTimeoutConfig.Set {
					e.FieldStart("old_timeout_config")
					s.OldTimeoutConfig.Encode(e)
				}
			}
			{
				if s.NewTimeoutConfig.Set {
					e.FieldStart("new_timeout_config")
					s.NewTimeoutConfig.Encode(e)
				}
			}
		}
	case AuditEventRequestEventDataEffectivenessAlertAssessedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessAssessmentCompletedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessAssessmentScheduledAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessHashComputedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessHealthAssessedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessMetricsAssessedAuditEventRequestEventData:
		switch s.Type {
		case AuditEventRequestEventDataEffectivenessAlertAssessedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.alert.assessed")
		case AuditEventRequestEventDataEffectivenessAssessmentCompletedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.assessment.completed")
		case AuditEventRequestEventDataEffectivenessAssessmentScheduledAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.assessment.scheduled")
		case AuditEventRequestEventDataEffectivenessHashComputedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.hash.computed")
		case AuditEventRequestEventDataEffectivenessHealthAssessedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.health.assessed")
		case AuditEventRequestEventDataEffectivenessMetricsAssessedAuditEventRequestEventData:
			e.FieldStart("event_type")
			e.Str("effectiveness.metrics.assessed")
		}
		{
			s := s.EffectivenessAssessmentAuditPayload
			{
				e.FieldStart("correlation_id")
				e.Str(s.CorrelationID)
			}
			{
				e.FieldStart("namespace")
				e.Str(s.Namespace)
			}
			{
				if s.EaName.Set {
					e.FieldStart("ea_name")
					s.EaName.Encode(e)
				}
			}
			{
				e.FieldStart("component")
				s.Component.Encode(e)
			}
			{
				if s.Assessed.Set {
					e.FieldStart("assessed")
					s.Assessed.Encode(e)
				}
			}
			{
				if s.Score.Set {
					e.FieldStart("score")
					s.Score.Encode(e)
				}
			}
			{
				if s.Details.Set {
					e.FieldStart("details")
					s.Details.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.AlertName.Set {
					e.FieldStart("alert_name")
					s.AlertName.Encode(e)
				}
			}
			{
				if s.ComponentsAssessed != nil {
					e.FieldStart("components_assessed")
					e.ArrStart()
					for _, elem := range s.ComponentsAssessed {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
			{
				if s.CompletedAt.Set {
					e.FieldStart("completed_at")
					s.CompletedAt.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.AssessmentDurationSeconds.Set {
					e.FieldStart("assessment_duration_seconds")
					s.AssessmentDurationSeconds.Encode(e)
				}
			}
			{
				if s.ValidityDeadline.Set {
					e.FieldStart("validity_deadline")
					s.ValidityDeadline.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.PrometheusCheckAfter.Set {
					e.FieldStart("prometheus_check_after")
					s.PrometheusCheckAfter.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.AlertmanagerCheckAfter.Set {
					e.FieldStart("alertmanager_check_after")
					s.AlertmanagerCheckAfter.Encode(e, json.EncodeDateTime)
				}
			}
			{
				if s.ValidityWindow.Set {
					e.FieldStart("validity_window")
					s.ValidityWindow.Encode(e)
				}
			}
			{
				if s.StabilizationWindow.Set {
					e.FieldStart("stabilization_window")
					s.StabilizationWindow.Encode(e)
				}
			}
			{
				if s.PreRemediationSpecHash.Set {
					e.FieldStart("pre_remediation_spec_hash")
					s.PreRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.PostRemediationSpecHash.Set {
					e.FieldStart("post_remediation_spec_hash")
					s.PostRemediationSpecHash.Encode(e)
				}
			}
			{
				if s.HashMatch.Set {
					e.FieldStart("hash_match")
					s.HashMatch.Encode(e)
				}
			}
			{
				if s.HealthChecks.Set {
					e.FieldStart("health_checks")
					s.HealthChecks.Encode(e)
				}
			}
			{
				if s.MetricDeltas.Set {
					e.FieldStart("metric_deltas")
					s.MetricDeltas.Encode(e)
				}
			}
			{
				if s.AlertResolution.Set {
					e.FieldStart("alert_resolution")
					s.AlertResolution.Encode(e)
				}
			}
		}
	}
}

// Decode decodes AuditEventRequestEventData from json.
func (s *AuditEventRequestEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventRequestEventData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "event_type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "gateway.crd.created":
					s.Type = AuditEventRequestEventDataGatewayCrdCreatedAuditEventRequestEventData
					found = true
				case "gateway.crd.failed":
					s.Type = AuditEventRequestEventDataGatewayCrdFailedAuditEventRequestEventData
					found = true
				case "gateway.signal.deduplicated":
					s.Type = AuditEventRequestEventDataGatewaySignalDeduplicatedAuditEventRequestEventData
					found = true
				case "gateway.signal.received":
					s.Type = AuditEventRequestEventDataGatewaySignalReceivedAuditEventRequestEventData
					found = true
				case "orchestrator.approval.approved":
					s.Type = AuditEventRequestEventDataOrchestratorApprovalApprovedAuditEventRequestEventData
					found = true
				case "orchestrator.approval.rejected":
					s.Type = AuditEventRequestEventDataOrchestratorApprovalRejectedAuditEventRequestEventData
					found = true
				case "orchestrator.approval.requested":
					s.Type = AuditEventRequestEventDataOrchestratorApprovalRequestedAuditEventRequestEventData
					found = true
				case "orchestrator.lifecycle.completed":
					s.Type = AuditEventRequestEventDataOrchestratorLifecycleCompletedAuditEventRequestEventData
					found = true
				case "orchestrator.lifecycle.created":
					s.Type = AuditEventRequestEventDataOrchestratorLifecycleCreatedAuditEventRequestEventData
					found = true
				case "orchestrator.lifecycle.failed":
					s.Type = AuditEventRequestEventDataOrchestratorLifecycleFailedAuditEventRequestEventData
					found = true
				case "orchestrator.lifecycle.started":
					s.Type = AuditEventRequestEventDataOrchestratorLifecycleStartedAuditEventRequestEventData
					found = true
				case "orchestrator.lifecycle.transitioned":
					s.Type = AuditEventRequestEventDataOrchestratorLifecycleTransitionedAuditEventRequestEventData
					found = true
				case "orchestrator.remediation.manual_review":
					s.Type = AuditEventRequestEventDataOrchestratorRemediationManualReviewAuditEventRequestEventData
					found = true
				case "orchestrator.routing.blocked":
					s.Type = AuditEventRequestEventDataOrchestratorRoutingBlockedAuditEventRequestEventData
					found = true
				case "remediation.workflow_created":
					s.Type = AuditEventRequestEventDataRemediationWorkflowCreatedAuditEventRequestEventData
					found = true
				case "signalprocessing.business.classified":
					s.Type = AuditEventRequestEventDataSignalprocessingBusinessClassifiedAuditEventRequestEventData
					found = true
				case "signalprocessing.classification.decision":
					s.Type = AuditEventRequestEventDataSignalprocessingClassificationDecisionAuditEventRequestEventData
					found = true
				case "signalprocessing.enrichment.completed":
					s.Type = AuditEventRequestEventDataSignalprocessingEnrichmentCompletedAuditEventRequestEventData
					found = true
				case "signalprocessing.error.occurred":
					s.Type = AuditEventRequestEventDataSignalprocessingErrorOccurredAuditEventRequestEventData
					found = true
				case "signalprocessing.phase.transition":
					s.Type = AuditEventRequestEventDataSignalprocessingPhaseTransitionAuditEventRequestEventData
					found = true
				case "signalprocessing.signal.processed":
					s.Type = AuditEventRequestEventDataSignalprocessingSignalProcessedAuditEventRequestEventData
					found = true
				case "aianalysis.analysis.completed":
					s.Type = AuditEventRequestEventDataAianalysisAnalysisCompletedAuditEventRequestEventData
					found = true
				case "aianalysis.analysis.failed":
					s.Type = AuditEventRequestEventDataAianalysisAnalysisFailedAuditEventRequestEventData
					found = true
				case "workflowexecution.execution.started":
					s.Type = AuditEventRequestEventDataWorkflowexecutionExecutionStartedAuditEventRequestEventData
					found = true
				case "workflowexecution.selection.completed":
					s.Type = AuditEventRequestEventDataWorkflowexecutionSelectionCompletedAuditEventRequestEventData
					found = true
				case "workflowexecution.workflow.completed":
					s.Type = AuditEventRequestEventDataWorkflowexecutionWorkflowCompletedAuditEventRequestEventData
					found = true
				case "workflowexecution.workflow.failed":
					s.Type = AuditEventRequestEventDataWorkflowexecutionWorkflowFailedAuditEventRequestEventData
					found = true
				case "workflowexecution.workflow.started":
					s.Type = AuditEventRequestEventDataWorkflowexecutionWorkflowStartedAuditEventRequestEventData
					found = true
				case "webhook.notification.acknowledged":
					s.Type = AuditEventRequestEventDataWebhookNotificationAcknowledgedAuditEventRequestEventData
					found = true
				case "webhook.notification.cancelled":
					s.Type = AuditEventRequestEventDataWebhookNotificationCancelledAuditEventRequestEventData
					found = true
				case "workflowexecution.block.cleared":
					s.Type = WorkflowExecutionWebhookAuditPayloadAuditEventRequestEventData
					found = true
				case "webhook.remediationapprovalrequest.decided":
					s.Type = RemediationApprovalAuditPayloadAuditEventRequestEventData
					found = true
				case "RemediationApprovalDecisionPayload":
					s.Type = RemediationApprovalDecisionPayloadAuditEventRequestEventData
					found = true
				case "workflow.catalog.actions_listed":
					s.Type = AuditEventRequestEventDataWorkflowCatalogActionsListedAuditEventRequestEventData
					found = true
				case "workflow.catalog.selection_validated":
					s.Type = AuditEventRequestEventDataWorkflowCatalogSelectionValidatedAuditEventRequestEventData
					found = true
				case "workflow.catalog.workflow_retrieved":
					s.Type = AuditEventRequestEventDataWorkflowCatalogWorkflowRetrievedAuditEventRequestEventData
					found = true
				case "workflow.catalog.workflows_listed":
					s.Type = AuditEventRequestEventDataWorkflowCatalogWorkflowsListedAuditEventRequestEventData
					found = true
				case "datastorage.workflow.created":
					s.Type = WorkflowCatalogCreatedPayloadAuditEventRequestEventData
					found = true
				case "datastorage.workflow.updated":
					s.Type = WorkflowCatalogUpdatedPayloadAuditEventRequestEventData
					found = true
				case "aianalysis.phase.transition":
					s.Type = AIAnalysisPhaseTransitionPayloadAuditEventRequestEventData
					found = true
				case "aianalysis.aiagent.call":
					s.Type = AuditEventRequestEventDataAianalysisAiagentCallAuditEventRequestEventData
					found = true
				case "aianalysis.aiagent.result":
					s.Type = AuditEventRequestEventDataAianalysisAiagentResultAuditEventRequestEventData
					found = true
				case "aianalysis.aiagent.session_lost":
					s.Type = AuditEventRequestEventDataAianalysisAiagentSessionLostAuditEventRequestEventData
					found = true
				case "aianalysis.aiagent.submit":
					s.Type = AuditEventRequestEventDataAianalysisAiagentSubmitAuditEventRequestEventData
					found = true
				case "aianalysis.approval.decision":
					s.Type = AIAnalysisApprovalDecisionPayloadAuditEventRequestEventData
					found = true
				case "aianalysis.rego.evaluation":
					s.Type = AIAnalysisRegoEvaluationPayloadAuditEventRequestEventData
					found = true
				case "aianalysis.error.occurred":
					s.Type = AIAnalysisErrorPayloadAuditEventRequestEventData
					found = true
				case "notification.message.sent":
					s.Type = NotificationMessageSentPayloadAuditEventRequestEventData
					found = true
				case "notification.message.failed":
					s.Type = NotificationMessageFailedPayloadAuditEventRequestEventData
					found = true
				case "notification.message.acknowledged":
					s.Type = NotificationMessageAcknowledgedPayloadAuditEventRequestEventData
					found = true
				case "notification.message.escalated":
					s.Type = NotificationMessageEscalatedPayloadAuditEventRequestEventData
					found = true
				case "aiagent.response.complete":
					s.Type = AIAgentResponsePayloadAuditEventRequestEventData
					found = true
				case "aiagent.llm.request":
					s.Type = LLMRequestPayloadAuditEventRequestEventData
					found = true
				case "aiagent.llm.response":
					s.Type = LLMResponsePayloadAuditEventRequestEventData
					found = true
				case "aiagent.llm.tool_call":
					s.Type = LLMToolCallPayloadAuditEventRequestEventData
					found = true
				case "aiagent.workflow.validation_attempt":
					s.Type = WorkflowValidationPayloadAuditEventRequestEventData
					found = true
				case "webhook.remediationrequest.timeout_modified":
					s.Type = RemediationRequestWebhookAuditPayloadAuditEventRequestEventData
					found = true
				case "effectiveness.alert.assessed":
					s.Type = AuditEventRequestEventDataEffectivenessAlertAssessedAuditEventRequestEventData
					found = true
				case "effectiveness.assessment.completed":
					s.Type = AuditEventRequestEventDataEffectivenessAssessmentCompletedAuditEventRequestEventData
					found = true
				case "effectiveness.assessment.scheduled":
					s.Type = AuditEventRequestEventDataEffectivenessAssessmentScheduledAuditEventRequestEventData
					found = true
				case "effectiveness.hash.computed":
					s.Type = AuditEventRequestEventDataEffectivenessHashComputedAuditEventRequestEventData
					found = true
				case "effectiveness.health.assessed":
					s.Type = AuditEventRequestEventDataEffectivenessHealthAssessedAuditEventRequestEventData
					found = true
				case "effectiveness.metrics.assessed":
					s.Type = AuditEventRequestEventDataEffectivenessMetricsAssessedAuditEventRequestEventData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AuditEventRequestEventDataGatewayCrdCreatedAuditEventRequestEventData, AuditEventRequestEventDataGatewayCrdFailedAuditEventRequestEventData, AuditEventRequestEventDataGatewaySignalDeduplicatedAuditEventRequestEventData, AuditEventRequestEventDataGatewaySignalReceivedAuditEventRequestEventData:
		if err := s.GatewayAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataOrchestratorApprovalApprovedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorApprovalRejectedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorApprovalRequestedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleCompletedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleCreatedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleFailedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleStartedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorLifecycleTransitionedAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorRemediationManualReviewAuditEventRequestEventData, AuditEventRequestEventDataOrchestratorRoutingBlockedAuditEventRequestEventData, AuditEventRequestEventDataRemediationWorkflowCreatedAuditEventRequestEventData:
		if err := s.RemediationOrchestratorAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataSignalprocessingBusinessClassifiedAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingClassificationDecisionAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingEnrichmentCompletedAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingErrorOccurredAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingPhaseTransitionAuditEventRequestEventData, AuditEventRequestEventDataSignalprocessingSignalProcessedAuditEventRequestEventData:
		if err := s.SignalProcessingAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataAianalysisAnalysisCompletedAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAnalysisFailedAuditEventRequestEventData:
		if err := s.AIAnalysisAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataWorkflowexecutionExecutionStartedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionSelectionCompletedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowCompletedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowFailedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowexecutionWorkflowStartedAuditEventRequestEventData:
		if err := s.WorkflowExecutionAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataWebhookNotificationAcknowledgedAuditEventRequestEventData, AuditEventRequestEventDataWebhookNotificationCancelledAuditEventRequestEventData:
		if err := s.NotificationAuditPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowExecutionWebhookAuditPayloadAuditEventRequestEventData:
		if err := s.WorkflowExecutionWebhookAuditPayload.Decode(d); err != nil {
			return err
		}
	case RemediationApprovalAuditPayloadAuditEventRequestEventData:
		if err := s.RemediationApprovalAuditPayload.Decode(d); err != nil {
			return err
		}
	case RemediationApprovalDecisionPayloadAuditEventRequestEventData:
		if err := s.RemediationApprovalDecisionPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataWorkflowCatalogActionsListedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogSelectionValidatedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogWorkflowRetrievedAuditEventRequestEventData, AuditEventRequestEventDataWorkflowCatalogWorkflowsListedAuditEventRequestEventData:
		if err := s.WorkflowDiscoveryAuditPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowCatalogCreatedPayloadAuditEventRequestEventData:
		if err := s.WorkflowCatalogCreatedPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowCatalogUpdatedPayloadAuditEventRequestEventData:
		if err := s.WorkflowCatalogUpdatedPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisPhaseTransitionPayloadAuditEventRequestEventData:
		if err := s.AIAnalysisPhaseTransitionPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataAianalysisAiagentCallAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentResultAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentSessionLostAuditEventRequestEventData, AuditEventRequestEventDataAianalysisAiagentSubmitAuditEventRequestEventData:
		if err := s.AIAnalysisAIAgentCallPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisApprovalDecisionPayloadAuditEventRequestEventData:
		if err := s.AIAnalysisApprovalDecisionPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisRegoEvaluationPayloadAuditEventRequestEventData:
		if err := s.AIAnalysisRegoEvaluationPayload.Decode(d); err != nil {
			return err
		}
	case AIAnalysisErrorPayloadAuditEventRequestEventData:
		if err := s.AIAnalysisErrorPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageSentPayloadAuditEventRequestEventData:
		if err := s.NotificationMessageSentPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageFailedPayloadAuditEventRequestEventData:
		if err := s.NotificationMessageFailedPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageAcknowledgedPayloadAuditEventRequestEventData:
		if err := s.NotificationMessageAcknowledgedPayload.Decode(d); err != nil {
			return err
		}
	case NotificationMessageEscalatedPayloadAuditEventRequestEventData:
		if err := s.NotificationMessageEscalatedPayload.Decode(d); err != nil {
			return err
		}
	case AIAgentResponsePayloadAuditEventRequestEventData:
		if err := s.AIAgentResponsePayload.Decode(d); err != nil {
			return err
		}
	case LLMRequestPayloadAuditEventRequestEventData:
		if err := s.LLMRequestPayload.Decode(d); err != nil {
			return err
		}
	case LLMResponsePayloadAuditEventRequestEventData:
		if err := s.LLMResponsePayload.Decode(d); err != nil {
			return err
		}
	case LLMToolCallPayloadAuditEventRequestEventData:
		if err := s.LLMToolCallPayload.Decode(d); err != nil {
			return err
		}
	case WorkflowValidationPayloadAuditEventRequestEventData:
		if err := s.WorkflowValidationPayload.Decode(d); err != nil {
			return err
		}
	case RemediationRequestWebhookAuditPayloadAuditEventRequestEventData:
		if err := s.RemediationRequestWebhookAuditPayload.Decode(d); err != nil {
			return err
		}
	case AuditEventRequestEventDataEffectivenessAlertAssessedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessAssessmentCompletedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessAssessmentScheduledAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessHashComputedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessHealthAssessedAuditEventRequestEventData, AuditEventRequestEventDataEffectivenessMetricsAssessedAuditEventRequestEventData:
		if err := s.EffectivenessAssessmentAuditPayload.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventRequestEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventRequestEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventRequestEventOutcome as json.
func (s AuditEventRequestEventOutcome) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuditEventRequestEventOutcome from json.
func (s *AuditEventRequestEventOutcome) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventRequestEventOutcome to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuditEventRequestEventOutcome(v) {
	case AuditEventRequestEventOutcomeSuccess:
		*s = AuditEventRequestEventOutcomeSuccess
	case AuditEventRequestEventOutcomeFailure:
		*s = AuditEventRequestEventOutcomeFailure
	case AuditEventRequestEventOutcomePending:
		*s = AuditEventRequestEventOutcomePending
	default:
		*s = AuditEventRequestEventOutcome(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditEventRequestEventOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventRequestEventOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditEventResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_id")
		json.EncodeUUID(e, s.EventID)
	}
	{
		e.FieldStart("event_timestamp")
		json.EncodeDateTime(e, s.EventTimestamp)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAuditEventResponse = [3]string{
	0: "event_id",
	1: "event_timestamp",
	2: "message",
}

// Decode decodes AuditEventResponse from json.
func (s *AuditEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.EventID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "event_timestamp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.EventTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_timestamp\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditEventResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditEventResponse) {
					name = jsonFieldsNameOfAuditEventResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditEventsQueryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditEventsQueryResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pagination.Set {
			e.FieldStart("pagination")
			s.Pagination.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditEventsQueryResponse = [2]string{
	0: "data",
	1: "pagination",
}

// Decode decodes AuditEventsQueryResponse from json.
func (s *AuditEventsQueryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventsQueryResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			if err := func() error {
				s.Data = make([]AuditEvent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuditEvent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "pagination":
			if err := func() error {
				s.Pagination.Reset()
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditEventsQueryResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditEventsQueryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventsQueryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditEventsQueryResponsePagination) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditEventsQueryResponsePagination) encodeFields(e *jx.Encoder) {
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.HasMore.Set {
			e.FieldStart("has_more")
			s.HasMore.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditEventsQueryResponsePagination = [4]string{
	0: "limit",
	1: "offset",
	2: "total",
	3: "has_more",
}

// Decode decodes AuditEventsQueryResponsePagination from json.
func (s *AuditEventsQueryResponsePagination) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditEventsQueryResponsePagination to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "has_more":
			if err := func() error {
				s.HasMore.Reset()
				if err := s.HasMore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditEventsQueryResponsePagination")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditEventsQueryResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditEventsQueryResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditExportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditExportResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("export_metadata")
		s.ExportMetadata.Encode(e)
	}
	{
		e.FieldStart("events")
		e.ArrStart()
		for _, elem := range s.Events {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hash_chain_verification")
		s.HashChainVerification.Encode(e)
	}
	{
		if s.DetachedSignature.Set {
			e.FieldStart("detached_signature")
			s.DetachedSignature.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditExportResponse = [4]string{
	0: "export_metadata",
	1: "events",
	2: "hash_chain_verification",
	3: "detached_signature",
}

// Decode decodes AuditExportResponse from json.
func (s *AuditExportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "export_metadata":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ExportMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"export_metadata\"")
			}
		case "events":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Events = make([]AuditExportResponseEventsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuditExportResponseEventsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "hash_chain_verification":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.HashChainVerification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash_chain_verification\"")
			}
		case "detached_signature":
			if err := func() error {
				s.DetachedSignature.Reset()
				if err := s.DetachedSignature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detached_signature\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditExportResponse) {
					name = jsonFieldsNameOfAuditExportResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditExportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditExportResponseEventsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditExportResponseEventsItem) encodeFields(e *jx.Encoder) {
	{
		if s.EventID.Set {
			e.FieldStart("event_id")
			s.EventID.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.EventType.Set {
			e.FieldStart("event_type")
			s.EventType.Encode(e)
		}
	}
	{
		if s.EventTimestamp.Set {
			e.FieldStart("event_timestamp")
			s.EventTimestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EventCategory.Set {
			e.FieldStart("event_category")
			s.EventCategory.Encode(e)
		}
	}
	{
		if s.EventAction.Set {
			e.FieldStart("event_action")
			s.EventAction.Encode(e)
		}
	}
	{
		if s.EventOutcome.Set {
			e.FieldStart("event_outcome")
			s.EventOutcome.Encode(e)
		}
	}
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
	{
		if s.EventData.Set {
			e.FieldStart("event_data")
			s.EventData.Encode(e)
		}
	}
	{
		if s.EventHash.Set {
			e.FieldStart("event_hash")
			s.EventHash.Encode(e)
		}
	}
	{
		if s.PreviousEventHash.Set {
			e.FieldStart("previous_event_hash")
			s.PreviousEventHash.Encode(e)
		}
	}
	{
		if s.HashChainValid.Set {
			e.FieldStart("hash_chain_valid")
			s.HashChainValid.Encode(e)
		}
	}
	{
		if s.LegalHold.Set {
			e.FieldStart("legal_hold")
			s.LegalHold.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditExportResponseEventsItem = [13]string{
	0:  "event_id",
	1:  "version",
	2:  "event_type",
	3:  "event_timestamp",
	4:  "event_category",
	5:  "event_action",
	6:  "event_outcome",
	7:  "correlation_id",
	8:  "event_data",
	9:  "event_hash",
	10: "previous_event_hash",
	11: "hash_chain_valid",
	12: "legal_hold",
}

// Decode decodes AuditExportResponseEventsItem from json.
func (s *AuditExportResponseEventsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseEventsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_id":
			if err := func() error {
				s.EventID.Reset()
				if err := s.EventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "event_type":
			if err := func() error {
				s.EventType.Reset()
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_timestamp":
			if err := func() error {
				s.EventTimestamp.Reset()
				if err := s.EventTimestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_timestamp\"")
			}
		case "event_category":
			if err := func() error {
				s.EventCategory.Reset()
				if err := s.EventCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_category\"")
			}
		case "event_action":
			if err := func() error {
				s.EventAction.Reset()
				if err := s.EventAction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_action\"")
			}
		case "event_outcome":
			if err := func() error {
				s.EventOutcome.Reset()
				if err := s.EventOutcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_outcome\"")
			}
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "event_data":
			if err := func() error {
				s.EventData.Reset()
				if err := s.EventData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_data\"")
			}
		case "event_hash":
			if err := func() error {
				s.EventHash.Reset()
				if err := s.EventHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_hash\"")
			}
		case "previous_event_hash":
			if err := func() error {
				s.PreviousEventHash.Reset()
				if err := s.PreviousEventHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_event_hash\"")
			}
		case "hash_chain_valid":
			if err := func() error {
				s.HashChainValid.Reset()
				if err := s.HashChainValid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash_chain_valid\"")
			}
		case "legal_hold":
			if err := func() error {
				s.LegalHold.Reset()
				if err := s.LegalHold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"legal_hold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponseEventsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditExportResponseEventsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseEventsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AuditExportResponseEventsItemEventData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AuditExportResponseEventsItemEventData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AuditExportResponseEventsItemEventData from json.
func (s *AuditExportResponseEventsItemEventData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseEventsItemEventData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponseEventsItemEventData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditExportResponseEventsItemEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseEventsItemEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditExportResponseExportMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditExportResponseExportMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("export_timestamp")
		json.EncodeDateTime(e, s.ExportTimestamp)
	}
	{
		e.FieldStart("export_format")
		s.ExportFormat.Encode(e)
	}
	{
		if s.QueryFilters.Set {
			e.FieldStart("query_filters")
			s.QueryFilters.Encode(e)
		}
	}
	{
		e.FieldStart("total_events")
		e.Int(s.TotalEvents)
	}
	{
		e.FieldStart("signature")
		e.Str(s.Signature)
	}
	{
		if s.SignatureAlgorithm.Set {
			e.FieldStart("signature_algorithm")
			s.SignatureAlgorithm.Encode(e)
		}
	}
	{
		if s.CertificateFingerprint.Set {
			e.FieldStart("certificate_fingerprint")
			s.CertificateFingerprint.Encode(e)
		}
	}
	{
		if s.ExportedBy.Set {
			e.FieldStart("exported_by")
			s.ExportedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditExportResponseExportMetadata = [8]string{
	0: "export_timestamp",
	1: "export_format",
	2: "query_filters",
	3: "total_events",
	4: "signature",
	5: "signature_algorithm",
	6: "certificate_fingerprint",
	7: "exported_by",
}

// Decode decodes AuditExportResponseExportMetadata from json.
func (s *AuditExportResponseExportMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseExportMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "export_timestamp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExportTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"export_timestamp\"")
			}
		case "export_format":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ExportFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"export_format\"")
			}
		case "query_filters":
			if err := func() error {
				s.QueryFilters.Reset()
				if err := s.QueryFilters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_filters\"")
			}
		case "total_events":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalEvents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_events\"")
			}
		case "signature":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Signature = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature\"")
			}
		case "signature_algorithm":
			if err := func() error {
				s.SignatureAlgorithm.Reset()
				if err := s.SignatureAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signature_algorithm\"")
			}
		case "certificate_fingerprint":
			if err := func() error {
				s.CertificateFingerprint.Reset()
				if err := s.CertificateFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate_fingerprint\"")
			}
		case "exported_by":
			if err := func() error {
				s.ExportedBy.Reset()
				if err := s.ExportedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exported_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponseExportMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditExportResponseExportMetadata) {
					name = jsonFieldsNameOfAuditExportResponseExportMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditExportResponseExportMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseExportMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditExportResponseExportMetadataExportFormat as json.
func (s AuditExportResponseExportMetadataExportFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuditExportResponseExportMetadataExportFormat from json.
func (s *AuditExportResponseExportMetadataExportFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseExportMetadataExportFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuditExportResponseExportMetadataExportFormat(v) {
	case AuditExportResponseExportMetadataExportFormatJSON:
		*s = AuditExportResponseExportMetadataExportFormatJSON
	case AuditExportResponseExportMetadataExportFormatCsv:
		*s = AuditExportResponseExportMetadataExportFormatCsv
	default:
		*s = AuditExportResponseExportMetadataExportFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuditExportResponseExportMetadataExportFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseExportMetadataExportFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditExportResponseExportMetadataQueryFilters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditExportResponseExportMetadataQueryFilters) encodeFields(e *jx.Encoder) {
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
	{
		if s.EventCategory.Set {
			e.FieldStart("event_category")
			s.EventCategory.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuditExportResponseExportMetadataQueryFilters = [6]string{
	0: "start_time",
	1: "end_time",
	2: "correlation_id",
	3: "event_category",
	4: "offset",
	5: "limit",
}

// Decode decodes AuditExportResponseExportMetadataQueryFilters from json.
func (s *AuditExportResponseExportMetadataQueryFilters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseExportMetadataQueryFilters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "event_category":
			if err := func() error {
				s.EventCategory.Reset()
				if err := s.EventCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_category\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponseExportMetadataQueryFilters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditExportResponseExportMetadataQueryFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseExportMetadataQueryFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuditExportResponseHashChainVerification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuditExportResponseHashChainVerification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_events_verified")
		e.Int(s.TotalEventsVerified)
	}
	{
		e.FieldStart("valid_chain_events")
		e.Int(s.ValidChainEvents)
	}
	{
		e.FieldStart("broken_chain_events")
		e.Int(s.BrokenChainEvents)
	}
	{
		if s.ChainIntegrityPercentage.Set {
			e.FieldStart("chain_integrity_percentage")
			s.ChainIntegrityPercentage.Encode(e)
		}
	}
	{
		e.FieldStart("verification_timestamp")
		json.EncodeDateTime(e, s.VerificationTimestamp)
	}
	{
		if s.TamperedEventIds != nil {
			e.FieldStart("tampered_event_ids")
			e.ArrStart()
			for _, elem := range s.TamperedEventIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuditExportResponseHashChainVerification = [6]string{
	0: "total_events_verified",
	1: "valid_chain_events",
	2: "broken_chain_events",
	3: "chain_integrity_percentage",
	4: "verification_timestamp",
	5: "tampered_event_ids",
}

// Decode decodes AuditExportResponseHashChainVerification from json.
func (s *AuditExportResponseHashChainVerification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuditExportResponseHashChainVerification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_events_verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalEventsVerified = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_events_verified\"")
			}
		case "valid_chain_events":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ValidChainEvents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid_chain_events\"")
			}
		case "broken_chain_events":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.BrokenChainEvents = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"broken_chain_events\"")
			}
		case "chain_integrity_percentage":
			if err := func() error {
				s.ChainIntegrityPercentage.Reset()
				if err := s.ChainIntegrityPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain_integrity_percentage\"")
			}
		case "verification_timestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.VerificationTimestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_timestamp\"")
			}
		case "tampered_event_ids":
			if err := func() error {
				s.TamperedEventIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TamperedEventIds = append(s.TamperedEventIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tampered_event_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuditExportResponseHashChainVerification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuditExportResponseHashChainVerification) {
					name = jsonFieldsNameOfAuditExportResponseHashChainVerification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuditExportResponseHashChainVerification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuditExportResponseHashChainVerification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchAuditEventResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchAuditEventResponse) encodeFields(e *jx.Encoder) {
	{
		if s.EventIds != nil {
			e.FieldStart("event_ids")
			e.ArrStart()
			for _, elem := range s.EventIds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchAuditEventResponse = [2]string{
	0: "event_ids",
	1: "message",
}

// Decode decodes BatchAuditEventResponse from json.
func (s *BatchAuditEventResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchAuditEventResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_ids":
			if err := func() error {
				s.EventIds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.EventIds = append(s.EventIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_ids\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchAuditEventResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchAuditEventResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchAuditEventResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAuditEventBadRequest as json.
func (s *CreateAuditEventBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAuditEventBadRequest from json.
func (s *CreateAuditEventBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAuditEventBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAuditEventBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAuditEventBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAuditEventBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAuditEventForbidden as json.
func (s *CreateAuditEventForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAuditEventForbidden from json.
func (s *CreateAuditEventForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAuditEventForbidden to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAuditEventForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAuditEventForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAuditEventForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAuditEventInternalServerError as json.
func (s *CreateAuditEventInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAuditEventInternalServerError from json.
func (s *CreateAuditEventInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAuditEventInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAuditEventInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAuditEventInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAuditEventInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAuditEventUnauthorized as json.
func (s *CreateAuditEventUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateAuditEventUnauthorized from json.
func (s *CreateAuditEventUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAuditEventUnauthorized to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateAuditEventUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAuditEventUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAuditEventUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNotificationAuditAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNotificationAuditAccepted) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfCreateNotificationAuditAccepted = [2]string{
	0: "status",
	1: "message",
}

// Decode decodes CreateNotificationAuditAccepted from json.
func (s *CreateNotificationAuditAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNotificationAuditAccepted to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNotificationAuditAccepted")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNotificationAuditAccepted) {
					name = jsonFieldsNameOfCreateNotificationAuditAccepted[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNotificationAuditAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNotificationAuditAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNotificationAuditAcceptedStatus as json.
func (s CreateNotificationAuditAcceptedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateNotificationAuditAcceptedStatus from json.
func (s *CreateNotificationAuditAcceptedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNotificationAuditAcceptedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateNotificationAuditAcceptedStatus(v) {
	case CreateNotificationAuditAcceptedStatusAccepted:
		*s = CreateNotificationAuditAcceptedStatusAccepted
	default:
		*s = CreateNotificationAuditAcceptedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateNotificationAuditAcceptedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNotificationAuditAcceptedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNotificationAuditBadRequest as json.
func (s *CreateNotificationAuditBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateNotificationAuditBadRequest from json.
func (s *CreateNotificationAuditBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNotificationAuditBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateNotificationAuditBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNotificationAuditBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNotificationAuditBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNotificationAuditConflict as json.
func (s *CreateNotificationAuditConflict) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateNotificationAuditConflict from json.
func (s *CreateNotificationAuditConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNotificationAuditConflict to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateNotificationAuditConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNotificationAuditConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNotificationAuditConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNotificationAuditInternalServerError as json.
func (s *CreateNotificationAuditInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateNotificationAuditInternalServerError from json.
func (s *CreateNotificationAuditInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNotificationAuditInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateNotificationAuditInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNotificationAuditInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNotificationAuditInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowBadGateway as json.
func (s *CreateWorkflowBadGateway) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowBadGateway from json.
func (s *CreateWorkflowBadGateway) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowBadGateway to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowBadGateway(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowBadGateway) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowBadGateway) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowBadRequest as json.
func (s *CreateWorkflowBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowBadRequest from json.
func (s *CreateWorkflowBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowConflict as json.
func (s *CreateWorkflowConflict) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowConflict from json.
func (s *CreateWorkflowConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowConflict to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowForbidden as json.
func (s *CreateWorkflowForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowForbidden from json.
func (s *CreateWorkflowForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowForbidden to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateWorkflowFromOCIRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateWorkflowFromOCIRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("container_image")
		e.Str(s.ContainerImage)
	}
}

var jsonFieldsNameOfCreateWorkflowFromOCIRequest = [1]string{
	0: "container_image",
}

// Decode decodes CreateWorkflowFromOCIRequest from json.
func (s *CreateWorkflowFromOCIRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowFromOCIRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container_image":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContainerImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateWorkflowFromOCIRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateWorkflowFromOCIRequest) {
					name = jsonFieldsNameOfCreateWorkflowFromOCIRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowFromOCIRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowFromOCIRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowInternalServerError as json.
func (s *CreateWorkflowInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowInternalServerError from json.
func (s *CreateWorkflowInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowUnauthorized as json.
func (s *CreateWorkflowUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowUnauthorized from json.
func (s *CreateWorkflowUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowUnauthorized to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateWorkflowUnprocessableEntity as json.
func (s *CreateWorkflowUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes CreateWorkflowUnprocessableEntity from json.
func (s *CreateWorkflowUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateWorkflowUnprocessableEntity to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = CreateWorkflowUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateWorkflowUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateWorkflowUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CustomLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CustomLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes CustomLabels from json.
func (s *CustomLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CustomLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CustomLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CustomLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CustomLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeprecateWorkflowBadRequest as json.
func (s *DeprecateWorkflowBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeprecateWorkflowBadRequest from json.
func (s *DeprecateWorkflowBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeprecateWorkflowBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeprecateWorkflowBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeprecateWorkflowBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeprecateWorkflowBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeprecateWorkflowNotFound as json.
func (s *DeprecateWorkflowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeprecateWorkflowNotFound from json.
func (s *DeprecateWorkflowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeprecateWorkflowNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeprecateWorkflowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeprecateWorkflowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeprecateWorkflowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DetectedLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DetectedLabels) encodeFields(e *jx.Encoder) {
	{
		if s.FailedDetections != nil {
			e.FieldStart("failed_detections")
			e.ArrStart()
			for _, elem := range s.FailedDetections {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GitOpsManaged.Set {
			e.FieldStart("gitOpsManaged")
			s.GitOpsManaged.Encode(e)
		}
	}
	{
		if s.GitOpsTool.Set {
			e.FieldStart("gitOpsTool")
			s.GitOpsTool.Encode(e)
		}
	}
	{
		if s.PdbProtected.Set {
			e.FieldStart("pdbProtected")
			s.PdbProtected.Encode(e)
		}
	}
	{
		if s.HpaEnabled.Set {
			e.FieldStart("hpaEnabled")
			s.HpaEnabled.Encode(e)
		}
	}
	{
		if s.Stateful.Set {
			e.FieldStart("stateful")
			s.Stateful.Encode(e)
		}
	}
	{
		if s.HelmManaged.Set {
			e.FieldStart("helmManaged")
			s.HelmManaged.Encode(e)
		}
	}
	{
		if s.NetworkIsolated.Set {
			e.FieldStart("networkIsolated")
			s.NetworkIsolated.Encode(e)
		}
	}
	{
		if s.ServiceMesh.Set {
			e.FieldStart("serviceMesh")
			s.ServiceMesh.Encode(e)
		}
	}
}

var jsonFieldsNameOfDetectedLabels = [9]string{
	0: "failed_detections",
	1: "gitOpsManaged",
	2: "gitOpsTool",
	3: "pdbProtected",
	4: "hpaEnabled",
	5: "stateful",
	6: "helmManaged",
	7: "networkIsolated",
	8: "serviceMesh",
}

// Decode decodes DetectedLabels from json.
func (s *DetectedLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DetectedLabels to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failed_detections":
			if err := func() error {
				s.FailedDetections = make([]DetectedLabelsFailedDetectionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DetectedLabelsFailedDetectionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailedDetections = append(s.FailedDetections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_detections\"")
			}
		case "gitOpsManaged":
			if err := func() error {
				s.GitOpsManaged.Reset()
				if err := s.GitOpsManaged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitOpsManaged\"")
			}
		case "gitOpsTool":
			if err := func() error {
				s.GitOpsTool.Reset()
				if err := s.GitOpsTool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gitOpsTool\"")
			}
		case "pdbProtected":
			if err := func() error {
				s.PdbProtected.Reset()
				if err := s.PdbProtected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdbProtected\"")
			}
		case "hpaEnabled":
			if err := func() error {
				s.HpaEnabled.Reset()
				if err := s.HpaEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hpaEnabled\"")
			}
		case "stateful":
			if err := func() error {
				s.Stateful.Reset()
				if err := s.Stateful.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stateful\"")
			}
		case "helmManaged":
			if err := func() error {
				s.HelmManaged.Reset()
				if err := s.HelmManaged.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"helmManaged\"")
			}
		case "networkIsolated":
			if err := func() error {
				s.NetworkIsolated.Reset()
				if err := s.NetworkIsolated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"networkIsolated\"")
			}
		case "serviceMesh":
			if err := func() error {
				s.ServiceMesh.Reset()
				if err := s.ServiceMesh.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceMesh\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DetectedLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DetectedLabelsFailedDetectionsItem as json.
func (s DetectedLabelsFailedDetectionsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DetectedLabelsFailedDetectionsItem from json.
func (s *DetectedLabelsFailedDetectionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DetectedLabelsFailedDetectionsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DetectedLabelsFailedDetectionsItem(v) {
	case DetectedLabelsFailedDetectionsItemGitOpsManaged:
		*s = DetectedLabelsFailedDetectionsItemGitOpsManaged
	case DetectedLabelsFailedDetectionsItemPdbProtected:
		*s = DetectedLabelsFailedDetectionsItemPdbProtected
	case DetectedLabelsFailedDetectionsItemHpaEnabled:
		*s = DetectedLabelsFailedDetectionsItemHpaEnabled
	case DetectedLabelsFailedDetectionsItemStateful:
		*s = DetectedLabelsFailedDetectionsItemStateful
	case DetectedLabelsFailedDetectionsItemHelmManaged:
		*s = DetectedLabelsFailedDetectionsItemHelmManaged
	case DetectedLabelsFailedDetectionsItemNetworkIsolated:
		*s = DetectedLabelsFailedDetectionsItemNetworkIsolated
	case DetectedLabelsFailedDetectionsItemServiceMesh:
		*s = DetectedLabelsFailedDetectionsItemServiceMesh
	default:
		*s = DetectedLabelsFailedDetectionsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DetectedLabelsFailedDetectionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DetectedLabelsFailedDetectionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DetectedLabelsGitOpsTool as json.
func (s DetectedLabelsGitOpsTool) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DetectedLabelsGitOpsTool from json.
func (s *DetectedLabelsGitOpsTool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DetectedLabelsGitOpsTool to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DetectedLabelsGitOpsTool(v) {
	case DetectedLabelsGitOpsTool_argocd:
		*s = DetectedLabelsGitOpsTool_argocd
	case DetectedLabelsGitOpsTool_flux:
		*s = DetectedLabelsGitOpsTool_flux
	case DetectedLabelsGitOpsTool_:
		*s = DetectedLabelsGitOpsTool_
	default:
		*s = DetectedLabelsGitOpsTool(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DetectedLabelsGitOpsTool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DetectedLabelsGitOpsTool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DetectedLabelsServiceMesh as json.
func (s DetectedLabelsServiceMesh) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DetectedLabelsServiceMesh from json.
func (s *DetectedLabelsServiceMesh) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DetectedLabelsServiceMesh to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DetectedLabelsServiceMesh(v) {
	case DetectedLabelsServiceMesh_istio:
		*s = DetectedLabelsServiceMesh_istio
	case DetectedLabelsServiceMesh_linkerd:
		*s = DetectedLabelsServiceMesh_linkerd
	case DetectedLabelsServiceMesh_:
		*s = DetectedLabelsServiceMesh_
	default:
		*s = DetectedLabelsServiceMesh(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DetectedLabelsServiceMesh) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DetectedLabelsServiceMesh) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableWorkflowBadRequest as json.
func (s *DisableWorkflowBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes DisableWorkflowBadRequest from json.
func (s *DisableWorkflowBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableWorkflowBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisableWorkflowBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableWorkflowBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableWorkflowBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableWorkflowNotFound as json.
func (s *DisableWorkflowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes DisableWorkflowNotFound from json.
func (s *DisableWorkflowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableWorkflowNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DisableWorkflowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableWorkflowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableWorkflowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessAssessmentAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessAssessmentAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("correlation_id")
		e.Str(s.CorrelationID)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		if s.EaName.Set {
			e.FieldStart("ea_name")
			s.EaName.Encode(e)
		}
	}
	{
		e.FieldStart("component")
		s.Component.Encode(e)
	}
	{
		if s.Assessed.Set {
			e.FieldStart("assessed")
			s.Assessed.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.AlertName.Set {
			e.FieldStart("alert_name")
			s.AlertName.Encode(e)
		}
	}
	{
		if s.ComponentsAssessed != nil {
			e.FieldStart("components_assessed")
			e.ArrStart()
			for _, elem := range s.ComponentsAssessed {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AssessmentDurationSeconds.Set {
			e.FieldStart("assessment_duration_seconds")
			s.AssessmentDurationSeconds.Encode(e)
		}
	}
	{
		if s.ValidityDeadline.Set {
			e.FieldStart("validity_deadline")
			s.ValidityDeadline.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PrometheusCheckAfter.Set {
			e.FieldStart("prometheus_check_after")
			s.PrometheusCheckAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AlertmanagerCheckAfter.Set {
			e.FieldStart("alertmanager_check_after")
			s.AlertmanagerCheckAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ValidityWindow.Set {
			e.FieldStart("validity_window")
			s.ValidityWindow.Encode(e)
		}
	}
	{
		if s.StabilizationWindow.Set {
			e.FieldStart("stabilization_window")
			s.StabilizationWindow.Encode(e)
		}
	}
	{
		if s.PreRemediationSpecHash.Set {
			e.FieldStart("pre_remediation_spec_hash")
			s.PreRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.PostRemediationSpecHash.Set {
			e.FieldStart("post_remediation_spec_hash")
			s.PostRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.HashMatch.Set {
			e.FieldStart("hash_match")
			s.HashMatch.Encode(e)
		}
	}
	{
		if s.HealthChecks.Set {
			e.FieldStart("health_checks")
			s.HealthChecks.Encode(e)
		}
	}
	{
		if s.MetricDeltas.Set {
			e.FieldStart("metric_deltas")
			s.MetricDeltas.Encode(e)
		}
	}
	{
		if s.AlertResolution.Set {
			e.FieldStart("alert_resolution")
			s.AlertResolution.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectivenessAssessmentAuditPayload = [24]string{
	0:  "event_type",
	1:  "correlation_id",
	2:  "namespace",
	3:  "ea_name",
	4:  "component",
	5:  "assessed",
	6:  "score",
	7:  "details",
	8:  "reason",
	9:  "alert_name",
	10: "components_assessed",
	11: "completed_at",
	12: "assessment_duration_seconds",
	13: "validity_deadline",
	14: "prometheus_check_after",
	15: "alertmanager_check_after",
	16: "validity_window",
	17: "stabilization_window",
	18: "pre_remediation_spec_hash",
	19: "post_remediation_spec_hash",
	20: "hash_match",
	21: "health_checks",
	22: "metric_deltas",
	23: "alert_resolution",
}

// Decode decodes EffectivenessAssessmentAuditPayload from json.
func (s *EffectivenessAssessmentAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayload to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "correlation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CorrelationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "ea_name":
			if err := func() error {
				s.EaName.Reset()
				if err := s.EaName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ea_name\"")
			}
		case "component":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Component.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "assessed":
			if err := func() error {
				s.Assessed.Reset()
				if err := s.Assessed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessed\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "alert_name":
			if err := func() error {
				s.AlertName.Reset()
				if err := s.AlertName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_name\"")
			}
		case "components_assessed":
			if err := func() error {
				s.ComponentsAssessed = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ComponentsAssessed = append(s.ComponentsAssessed, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components_assessed\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "assessment_duration_seconds":
			if err := func() error {
				s.AssessmentDurationSeconds.Reset()
				if err := s.AssessmentDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessment_duration_seconds\"")
			}
		case "validity_deadline":
			if err := func() error {
				s.ValidityDeadline.Reset()
				if err := s.ValidityDeadline.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validity_deadline\"")
			}
		case "prometheus_check_after":
			if err := func() error {
				s.PrometheusCheckAfter.Reset()
				if err := s.PrometheusCheckAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prometheus_check_after\"")
			}
		case "alertmanager_check_after":
			if err := func() error {
				s.AlertmanagerCheckAfter.Reset()
				if err := s.AlertmanagerCheckAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alertmanager_check_after\"")
			}
		case "validity_window":
			if err := func() error {
				s.ValidityWindow.Reset()
				if err := s.ValidityWindow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validity_window\"")
			}
		case "stabilization_window":
			if err := func() error {
				s.StabilizationWindow.Reset()
				if err := s.StabilizationWindow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stabilization_window\"")
			}
		case "pre_remediation_spec_hash":
			if err := func() error {
				s.PreRemediationSpecHash.Reset()
				if err := s.PreRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_remediation_spec_hash\"")
			}
		case "post_remediation_spec_hash":
			if err := func() error {
				s.PostRemediationSpecHash.Reset()
				if err := s.PostRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_remediation_spec_hash\"")
			}
		case "hash_match":
			if err := func() error {
				s.HashMatch.Reset()
				if err := s.HashMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash_match\"")
			}
		case "health_checks":
			if err := func() error {
				s.HealthChecks.Reset()
				if err := s.HealthChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_checks\"")
			}
		case "metric_deltas":
			if err := func() error {
				s.MetricDeltas.Reset()
				if err := s.MetricDeltas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metric_deltas\"")
			}
		case "alert_resolution":
			if err := func() error {
				s.AlertResolution.Reset()
				if err := s.AlertResolution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_resolution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessAssessmentAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00010111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectivenessAssessmentAuditPayload) {
					name = jsonFieldsNameOfEffectivenessAssessmentAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessAssessmentAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadAlertResolution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessAssessmentAuditPayloadAlertResolution) encodeFields(e *jx.Encoder) {
	{
		if s.AlertResolved.Set {
			e.FieldStart("alert_resolved")
			s.AlertResolved.Encode(e)
		}
	}
	{
		if s.ActiveCount.Set {
			e.FieldStart("active_count")
			s.ActiveCount.Encode(e)
		}
	}
	{
		if s.ResolutionTimeSeconds.Set {
			e.FieldStart("resolution_time_seconds")
			s.ResolutionTimeSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectivenessAssessmentAuditPayloadAlertResolution = [3]string{
	0: "alert_resolved",
	1: "active_count",
	2: "resolution_time_seconds",
}

// Decode decodes EffectivenessAssessmentAuditPayloadAlertResolution from json.
func (s *EffectivenessAssessmentAuditPayloadAlertResolution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayloadAlertResolution to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alert_resolved":
			if err := func() error {
				s.AlertResolved.Reset()
				if err := s.AlertResolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_resolved\"")
			}
		case "active_count":
			if err := func() error {
				s.ActiveCount.Reset()
				if err := s.ActiveCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active_count\"")
			}
		case "resolution_time_seconds":
			if err := func() error {
				s.ResolutionTimeSeconds.Reset()
				if err := s.ResolutionTimeSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolution_time_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessAssessmentAuditPayloadAlertResolution")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadAlertResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayloadAlertResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessAssessmentAuditPayloadComponent as json.
func (s EffectivenessAssessmentAuditPayloadComponent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectivenessAssessmentAuditPayloadComponent from json.
func (s *EffectivenessAssessmentAuditPayloadComponent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayloadComponent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectivenessAssessmentAuditPayloadComponent(v) {
	case EffectivenessAssessmentAuditPayloadComponentHealth:
		*s = EffectivenessAssessmentAuditPayloadComponentHealth
	case EffectivenessAssessmentAuditPayloadComponentAlert:
		*s = EffectivenessAssessmentAuditPayloadComponentAlert
	case EffectivenessAssessmentAuditPayloadComponentMetrics:
		*s = EffectivenessAssessmentAuditPayloadComponentMetrics
	case EffectivenessAssessmentAuditPayloadComponentHash:
		*s = EffectivenessAssessmentAuditPayloadComponentHash
	case EffectivenessAssessmentAuditPayloadComponentScheduled:
		*s = EffectivenessAssessmentAuditPayloadComponentScheduled
	case EffectivenessAssessmentAuditPayloadComponentCompleted:
		*s = EffectivenessAssessmentAuditPayloadComponentCompleted
	default:
		*s = EffectivenessAssessmentAuditPayloadComponent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectivenessAssessmentAuditPayloadComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayloadComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessAssessmentAuditPayloadEventType as json.
func (s EffectivenessAssessmentAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectivenessAssessmentAuditPayloadEventType from json.
func (s *EffectivenessAssessmentAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectivenessAssessmentAuditPayloadEventType(v) {
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessHealthAssessed:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessHealthAssessed
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessHashComputed:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessHashComputed
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAlertAssessed:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAlertAssessed
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessMetricsAssessed:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessMetricsAssessed
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAssessmentScheduled:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAssessmentScheduled
	case EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAssessmentCompleted:
		*s = EffectivenessAssessmentAuditPayloadEventTypeEffectivenessAssessmentCompleted
	default:
		*s = EffectivenessAssessmentAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectivenessAssessmentAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadHealthChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessAssessmentAuditPayloadHealthChecks) encodeFields(e *jx.Encoder) {
	{
		if s.PodRunning.Set {
			e.FieldStart("pod_running")
			s.PodRunning.Encode(e)
		}
	}
	{
		if s.ReadinessPass.Set {
			e.FieldStart("readiness_pass")
			s.ReadinessPass.Encode(e)
		}
	}
	{
		if s.TotalReplicas.Set {
			e.FieldStart("total_replicas")
			s.TotalReplicas.Encode(e)
		}
	}
	{
		if s.ReadyReplicas.Set {
			e.FieldStart("ready_replicas")
			s.ReadyReplicas.Encode(e)
		}
	}
	{
		if s.RestartDelta.Set {
			e.FieldStart("restart_delta")
			s.RestartDelta.Encode(e)
		}
	}
	{
		if s.CrashLoops.Set {
			e.FieldStart("crash_loops")
			s.CrashLoops.Encode(e)
		}
	}
	{
		if s.OomKilled.Set {
			e.FieldStart("oom_killed")
			s.OomKilled.Encode(e)
		}
	}
	{
		if s.PendingCount.Set {
			e.FieldStart("pending_count")
			s.PendingCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectivenessAssessmentAuditPayloadHealthChecks = [8]string{
	0: "pod_running",
	1: "readiness_pass",
	2: "total_replicas",
	3: "ready_replicas",
	4: "restart_delta",
	5: "crash_loops",
	6: "oom_killed",
	7: "pending_count",
}

// Decode decodes EffectivenessAssessmentAuditPayloadHealthChecks from json.
func (s *EffectivenessAssessmentAuditPayloadHealthChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayloadHealthChecks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pod_running":
			if err := func() error {
				s.PodRunning.Reset()
				if err := s.PodRunning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pod_running\"")
			}
		case "readiness_pass":
			if err := func() error {
				s.ReadinessPass.Reset()
				if err := s.ReadinessPass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readiness_pass\"")
			}
		case "total_replicas":
			if err := func() error {
				s.TotalReplicas.Reset()
				if err := s.TotalReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_replicas\"")
			}
		case "ready_replicas":
			if err := func() error {
				s.ReadyReplicas.Reset()
				if err := s.ReadyReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready_replicas\"")
			}
		case "restart_delta":
			if err := func() error {
				s.RestartDelta.Reset()
				if err := s.RestartDelta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restart_delta\"")
			}
		case "crash_loops":
			if err := func() error {
				s.CrashLoops.Reset()
				if err := s.CrashLoops.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crash_loops\"")
			}
		case "oom_killed":
			if err := func() error {
				s.OomKilled.Reset()
				if err := s.OomKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oom_killed\"")
			}
		case "pending_count":
			if err := func() error {
				s.PendingCount.Reset()
				if err := s.PendingCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessAssessmentAuditPayloadHealthChecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadHealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayloadHealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadMetricDeltas) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessAssessmentAuditPayloadMetricDeltas) encodeFields(e *jx.Encoder) {
	{
		if s.CPUBefore.Set {
			e.FieldStart("cpu_before")
			s.CPUBefore.Encode(e)
		}
	}
	{
		if s.CPUAfter.Set {
			e.FieldStart("cpu_after")
			s.CPUAfter.Encode(e)
		}
	}
	{
		if s.MemoryBefore.Set {
			e.FieldStart("memory_before")
			s.MemoryBefore.Encode(e)
		}
	}
	{
		if s.MemoryAfter.Set {
			e.FieldStart("memory_after")
			s.MemoryAfter.Encode(e)
		}
	}
	{
		if s.LatencyP95BeforeMs.Set {
			e.FieldStart("latency_p95_before_ms")
			s.LatencyP95BeforeMs.Encode(e)
		}
	}
	{
		if s.LatencyP95AfterMs.Set {
			e.FieldStart("latency_p95_after_ms")
			s.LatencyP95AfterMs.Encode(e)
		}
	}
	{
		if s.ErrorRateBefore.Set {
			e.FieldStart("error_rate_before")
			s.ErrorRateBefore.Encode(e)
		}
	}
	{
		if s.ErrorRateAfter.Set {
			e.FieldStart("error_rate_after")
			s.ErrorRateAfter.Encode(e)
		}
	}
	{
		if s.ThroughputBeforeRps.Set {
			e.FieldStart("throughput_before_rps")
			s.ThroughputBeforeRps.Encode(e)
		}
	}
	{
		if s.ThroughputAfterRps.Set {
			e.FieldStart("throughput_after_rps")
			s.ThroughputAfterRps.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectivenessAssessmentAuditPayloadMetricDeltas = [10]string{
	0: "cpu_before",
	1: "cpu_after",
	2: "memory_before",
	3: "memory_after",
	4: "latency_p95_before_ms",
	5: "latency_p95_after_ms",
	6: "error_rate_before",
	7: "error_rate_after",
	8: "throughput_before_rps",
	9: "throughput_after_rps",
}

// Decode decodes EffectivenessAssessmentAuditPayloadMetricDeltas from json.
func (s *EffectivenessAssessmentAuditPayloadMetricDeltas) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessAssessmentAuditPayloadMetricDeltas to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu_before":
			if err := func() error {
				s.CPUBefore.Reset()
				if err := s.CPUBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_before\"")
			}
		case "cpu_after":
			if err := func() error {
				s.CPUAfter.Reset()
				if err := s.CPUAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_after\"")
			}
		case "memory_before":
			if err := func() error {
				s.MemoryBefore.Reset()
				if err := s.MemoryBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_before\"")
			}
		case "memory_after":
			if err := func() error {
				s.MemoryAfter.Reset()
				if err := s.MemoryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_after\"")
			}
		case "latency_p95_before_ms":
			if err := func() error {
				s.LatencyP95BeforeMs.Reset()
				if err := s.LatencyP95BeforeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_p95_before_ms\"")
			}
		case "latency_p95_after_ms":
			if err := func() error {
				s.LatencyP95AfterMs.Reset()
				if err := s.LatencyP95AfterMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latency_p95_after_ms\"")
			}
		case "error_rate_before":
			if err := func() error {
				s.ErrorRateBefore.Reset()
				if err := s.ErrorRateBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_rate_before\"")
			}
		case "error_rate_after":
			if err := func() error {
				s.ErrorRateAfter.Reset()
				if err := s.ErrorRateAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_rate_after\"")
			}
		case "throughput_before_rps":
			if err := func() error {
				s.ThroughputBeforeRps.Reset()
				if err := s.ThroughputBeforeRps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"throughput_before_rps\"")
			}
		case "throughput_after_rps":
			if err := func() error {
				s.ThroughputAfterRps.Reset()
				if err := s.ThroughputAfterRps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"throughput_after_rps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessAssessmentAuditPayloadMetricDeltas")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessAssessmentAuditPayloadMetricDeltas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessAssessmentAuditPayloadMetricDeltas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessComponents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessComponents) encodeFields(e *jx.Encoder) {
	{
		if s.HealthAssessed.Set {
			e.FieldStart("health_assessed")
			s.HealthAssessed.Encode(e)
		}
	}
	{
		if s.HealthScore.Set {
			e.FieldStart("health_score")
			s.HealthScore.Encode(e)
		}
	}
	{
		if s.HealthDetails.Set {
			e.FieldStart("health_details")
			s.HealthDetails.Encode(e)
		}
	}
	{
		if s.AlertAssessed.Set {
			e.FieldStart("alert_assessed")
			s.AlertAssessed.Encode(e)
		}
	}
	{
		if s.AlertScore.Set {
			e.FieldStart("alert_score")
			s.AlertScore.Encode(e)
		}
	}
	{
		if s.AlertDetails.Set {
			e.FieldStart("alert_details")
			s.AlertDetails.Encode(e)
		}
	}
	{
		if s.MetricsAssessed.Set {
			e.FieldStart("metrics_assessed")
			s.MetricsAssessed.Encode(e)
		}
	}
	{
		if s.MetricsScore.Set {
			e.FieldStart("metrics_score")
			s.MetricsScore.Encode(e)
		}
	}
	{
		if s.MetricsDetails.Set {
			e.FieldStart("metrics_details")
			s.MetricsDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfEffectivenessComponents = [9]string{
	0: "health_assessed",
	1: "health_score",
	2: "health_details",
	3: "alert_assessed",
	4: "alert_score",
	5: "alert_details",
	6: "metrics_assessed",
	7: "metrics_score",
	8: "metrics_details",
}

// Decode decodes EffectivenessComponents from json.
func (s *EffectivenessComponents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessComponents to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "health_assessed":
			if err := func() error {
				s.HealthAssessed.Reset()
				if err := s.HealthAssessed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_assessed\"")
			}
		case "health_score":
			if err := func() error {
				s.HealthScore.Reset()
				if err := s.HealthScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_score\"")
			}
		case "health_details":
			if err := func() error {
				s.HealthDetails.Reset()
				if err := s.HealthDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"health_details\"")
			}
		case "alert_assessed":
			if err := func() error {
				s.AlertAssessed.Reset()
				if err := s.AlertAssessed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_assessed\"")
			}
		case "alert_score":
			if err := func() error {
				s.AlertScore.Reset()
				if err := s.AlertScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_score\"")
			}
		case "alert_details":
			if err := func() error {
				s.AlertDetails.Reset()
				if err := s.AlertDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_details\"")
			}
		case "metrics_assessed":
			if err := func() error {
				s.MetricsAssessed.Reset()
				if err := s.MetricsAssessed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics_assessed\"")
			}
		case "metrics_score":
			if err := func() error {
				s.MetricsScore.Reset()
				if err := s.MetricsScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics_score\"")
			}
		case "metrics_details":
			if err := func() error {
				s.MetricsDetails.Reset()
				if err := s.MetricsDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessComponents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EffectivenessScoreResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EffectivenessScoreResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("correlation_id")
		e.Str(s.CorrelationID)
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		e.FieldStart("components")
		s.Components.Encode(e)
	}
	{
		if s.HashComparison.Set {
			e.FieldStart("hash_comparison")
			s.HashComparison.Encode(e)
		}
	}
	{
		e.FieldStart("assessment_status")
		s.AssessmentStatus.Encode(e)
	}
	{
		e.FieldStart("computed_at")
		json.EncodeDateTime(e, s.ComputedAt)
	}
}

var jsonFieldsNameOfEffectivenessScoreResponse = [6]string{
	0: "correlation_id",
	1: "score",
	2: "components",
	3: "hash_comparison",
	4: "assessment_status",
	5: "computed_at",
}

// Decode decodes EffectivenessScoreResponse from json.
func (s *EffectivenessScoreResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessScoreResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "correlation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CorrelationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "components":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Components.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "hash_comparison":
			if err := func() error {
				s.HashComparison.Reset()
				if err := s.HashComparison.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash_comparison\"")
			}
		case "assessment_status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AssessmentStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessment_status\"")
			}
		case "computed_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ComputedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computed_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EffectivenessScoreResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEffectivenessScoreResponse) {
					name = jsonFieldsNameOfEffectivenessScoreResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EffectivenessScoreResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessScoreResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessScoreResponseAssessmentStatus as json.
func (s EffectivenessScoreResponseAssessmentStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EffectivenessScoreResponseAssessmentStatus from json.
func (s *EffectivenessScoreResponseAssessmentStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EffectivenessScoreResponseAssessmentStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EffectivenessScoreResponseAssessmentStatus(v) {
	case EffectivenessScoreResponseAssessmentStatusNoData:
		*s = EffectivenessScoreResponseAssessmentStatusNoData
	case EffectivenessScoreResponseAssessmentStatusInProgress:
		*s = EffectivenessScoreResponseAssessmentStatusInProgress
	case EffectivenessScoreResponseAssessmentStatusFull:
		*s = EffectivenessScoreResponseAssessmentStatusFull
	case EffectivenessScoreResponseAssessmentStatusPartial:
		*s = EffectivenessScoreResponseAssessmentStatusPartial
	case EffectivenessScoreResponseAssessmentStatusSpecDrift:
		*s = EffectivenessScoreResponseAssessmentStatusSpecDrift
	case EffectivenessScoreResponseAssessmentStatusExpired:
		*s = EffectivenessScoreResponseAssessmentStatusExpired
	case EffectivenessScoreResponseAssessmentStatusNoExecution:
		*s = EffectivenessScoreResponseAssessmentStatusNoExecution
	case EffectivenessScoreResponseAssessmentStatusMetricsTimedOut:
		*s = EffectivenessScoreResponseAssessmentStatusMetricsTimedOut
	case EffectivenessScoreResponseAssessmentStatusEffectivenessAssessed:
		*s = EffectivenessScoreResponseAssessmentStatusEffectivenessAssessed
	default:
		*s = EffectivenessScoreResponseAssessmentStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EffectivenessScoreResponseAssessmentStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EffectivenessScoreResponseAssessmentStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableWorkflowBadRequest as json.
func (s *EnableWorkflowBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes EnableWorkflowBadRequest from json.
func (s *EnableWorkflowBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableWorkflowBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EnableWorkflowBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableWorkflowBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableWorkflowBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableWorkflowNotFound as json.
func (s *EnableWorkflowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes EnableWorkflowNotFound from json.
func (s *EnableWorkflowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableWorkflowNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EnableWorkflowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableWorkflowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableWorkflowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("component")
		s.Component.Encode(e)
	}
	{
		e.FieldStart("retry_possible")
		e.Bool(s.RetryPossible)
	}
	{
		if s.StackTrace != nil {
			e.FieldStart("stack_trace")
			e.ArrStart()
			for _, elem := range s.StackTrace {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfErrorDetails = [5]string{
	0: "message",
	1: "code",
	2: "component",
	3: "retry_possible",
	4: "stack_trace",
}

// Decode decodes ErrorDetails from json.
func (s *ErrorDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetails to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "component":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Component.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "retry_possible":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.RetryPossible = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_possible\"")
			}
		case "stack_trace":
			if err := func() error {
				s.StackTrace = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.StackTrace = append(s.StackTrace, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack_trace\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorDetails) {
					name = jsonFieldsNameOfErrorDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorDetailsComponent as json.
func (s ErrorDetailsComponent) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ErrorDetailsComponent from json.
func (s *ErrorDetailsComponent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorDetailsComponent to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ErrorDetailsComponent(v) {
	case ErrorDetailsComponentGateway:
		*s = ErrorDetailsComponentGateway
	case ErrorDetailsComponentAianalysis:
		*s = ErrorDetailsComponentAianalysis
	case ErrorDetailsComponentWorkflowexecution:
		*s = ErrorDetailsComponentWorkflowexecution
	case ErrorDetailsComponentRemediationorchestrator:
		*s = ErrorDetailsComponentRemediationorchestrator
	case ErrorDetailsComponentSignalprocessing:
		*s = ErrorDetailsComponentSignalprocessing
	case ErrorDetailsComponentAuthwebhook:
		*s = ErrorDetailsComponentAuthwebhook
	default:
		*s = ErrorDetailsComponent(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorDetailsComponent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorDetailsComponent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportAuditEventsBadRequest as json.
func (s *ExportAuditEventsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExportAuditEventsBadRequest from json.
func (s *ExportAuditEventsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportAuditEventsBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportAuditEventsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportAuditEventsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportAuditEventsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportAuditEventsRequestEntityTooLarge as json.
func (s *ExportAuditEventsRequestEntityTooLarge) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExportAuditEventsRequestEntityTooLarge from json.
func (s *ExportAuditEventsRequestEntityTooLarge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportAuditEventsRequestEntityTooLarge to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportAuditEventsRequestEntityTooLarge(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportAuditEventsRequestEntityTooLarge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportAuditEventsRequestEntityTooLarge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportAuditEventsUnauthorized as json.
func (s *ExportAuditEventsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ExportAuditEventsUnauthorized from json.
func (s *ExportAuditEventsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportAuditEventsUnauthorized to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ExportAuditEventsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExportAuditEventsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportAuditEventsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GatewayAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GatewayAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		if s.OriginalPayload.Set {
			e.FieldStart("original_payload")
			s.OriginalPayload.Encode(e)
		}
	}
	{
		if s.SignalLabels.Set {
			e.FieldStart("signal_labels")
			s.SignalLabels.Encode(e)
		}
	}
	{
		if s.SignalAnnotations.Set {
			e.FieldStart("signal_annotations")
			s.SignalAnnotations.Encode(e)
		}
	}
	{
		e.FieldStart("signal_type")
		s.SignalType.Encode(e)
	}
	{
		e.FieldStart("alert_name")
		e.Str(s.AlertName)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		e.FieldStart("fingerprint")
		e.Str(s.Fingerprint)
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.ResourceKind.Set {
			e.FieldStart("resource_kind")
			s.ResourceKind.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resource_name")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.RemediationRequest.Set {
			e.FieldStart("remediation_request")
			s.RemediationRequest.Encode(e)
		}
	}
	{
		if s.DeduplicationStatus.Set {
			e.FieldStart("deduplication_status")
			s.DeduplicationStatus.Encode(e)
		}
	}
	{
		if s.OccurrenceCount.Set {
			e.FieldStart("occurrence_count")
			s.OccurrenceCount.Encode(e)
		}
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
}

var jsonFieldsNameOfGatewayAuditPayload = [15]string{
	0:  "event_type",
	1:  "original_payload",
	2:  "signal_labels",
	3:  "signal_annotations",
	4:  "signal_type",
	5:  "alert_name",
	6:  "namespace",
	7:  "fingerprint",
	8:  "severity",
	9:  "resource_kind",
	10: "resource_name",
	11: "remediation_request",
	12: "deduplication_status",
	13: "occurrence_count",
	14: "error_details",
}

// Decode decodes GatewayAuditPayload from json.
func (s *GatewayAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "original_payload":
			if err := func() error {
				s.OriginalPayload.Reset()
				if err := s.OriginalPayload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_payload\"")
			}
		case "signal_labels":
			if err := func() error {
				s.SignalLabels.Reset()
				if err := s.SignalLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_labels\"")
			}
		case "signal_annotations":
			if err := func() error {
				s.SignalAnnotations.Reset()
				if err := s.SignalAnnotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_annotations\"")
			}
		case "signal_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "alert_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AlertName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alert_name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "fingerprint":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Fingerprint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "resource_kind":
			if err := func() error {
				s.ResourceKind.Reset()
				if err := s.ResourceKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_kind\"")
			}
		case "resource_name":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_name\"")
			}
		case "remediation_request":
			if err := func() error {
				s.RemediationRequest.Reset()
				if err := s.RemediationRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_request\"")
			}
		case "deduplication_status":
			if err := func() error {
				s.DeduplicationStatus.Reset()
				if err := s.DeduplicationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deduplication_status\"")
			}
		case "occurrence_count":
			if err := func() error {
				s.OccurrenceCount.Reset()
				if err := s.OccurrenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurrence_count\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatewayAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGatewayAuditPayload) {
					name = jsonFieldsNameOfGatewayAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GatewayAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadDeduplicationStatus as json.
func (s GatewayAuditPayloadDeduplicationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatewayAuditPayloadDeduplicationStatus from json.
func (s *GatewayAuditPayloadDeduplicationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadDeduplicationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatewayAuditPayloadDeduplicationStatus(v) {
	case GatewayAuditPayloadDeduplicationStatusNew:
		*s = GatewayAuditPayloadDeduplicationStatusNew
	case GatewayAuditPayloadDeduplicationStatusDuplicate:
		*s = GatewayAuditPayloadDeduplicationStatusDuplicate
	default:
		*s = GatewayAuditPayloadDeduplicationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadDeduplicationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadDeduplicationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadEventType as json.
func (s GatewayAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatewayAuditPayloadEventType from json.
func (s *GatewayAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatewayAuditPayloadEventType(v) {
	case GatewayAuditPayloadEventTypeGatewaySignalReceived:
		*s = GatewayAuditPayloadEventTypeGatewaySignalReceived
	case GatewayAuditPayloadEventTypeGatewaySignalDeduplicated:
		*s = GatewayAuditPayloadEventTypeGatewaySignalDeduplicated
	case GatewayAuditPayloadEventTypeGatewayCrdCreated:
		*s = GatewayAuditPayloadEventTypeGatewayCrdCreated
	case GatewayAuditPayloadEventTypeGatewayCrdFailed:
		*s = GatewayAuditPayloadEventTypeGatewayCrdFailed
	default:
		*s = GatewayAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GatewayAuditPayloadOriginalPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GatewayAuditPayloadOriginalPayload) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes GatewayAuditPayloadOriginalPayload from json.
func (s *GatewayAuditPayloadOriginalPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadOriginalPayload to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatewayAuditPayloadOriginalPayload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadOriginalPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadOriginalPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GatewayAuditPayloadSignalAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GatewayAuditPayloadSignalAnnotations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GatewayAuditPayloadSignalAnnotations from json.
func (s *GatewayAuditPayloadSignalAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadSignalAnnotations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatewayAuditPayloadSignalAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadSignalAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadSignalAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GatewayAuditPayloadSignalLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GatewayAuditPayloadSignalLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GatewayAuditPayloadSignalLabels from json.
func (s *GatewayAuditPayloadSignalLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadSignalLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatewayAuditPayloadSignalLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadSignalLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadSignalLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadSignalType as json.
func (s GatewayAuditPayloadSignalType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GatewayAuditPayloadSignalType from json.
func (s *GatewayAuditPayloadSignalType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayAuditPayloadSignalType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GatewayAuditPayloadSignalType(v) {
	case GatewayAuditPayloadSignalTypePrometheusAlert:
		*s = GatewayAuditPayloadSignalTypePrometheusAlert
	case GatewayAuditPayloadSignalTypeKubernetesEvent:
		*s = GatewayAuditPayloadSignalTypeKubernetesEvent
	default:
		*s = GatewayAuditPayloadSignalType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayAuditPayloadSignalType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayAuditPayloadSignalType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEffectivenessScoreInternalServerError as json.
func (s *GetEffectivenessScoreInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEffectivenessScoreInternalServerError from json.
func (s *GetEffectivenessScoreInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEffectivenessScoreInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEffectivenessScoreInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEffectivenessScoreInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEffectivenessScoreInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetEffectivenessScoreNotFound as json.
func (s *GetEffectivenessScoreNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetEffectivenessScoreNotFound from json.
func (s *GetEffectivenessScoreNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetEffectivenessScoreNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetEffectivenessScoreNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetEffectivenessScoreNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetEffectivenessScoreNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemediationHistoryContextBadRequest as json.
func (s *GetRemediationHistoryContextBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRemediationHistoryContextBadRequest from json.
func (s *GetRemediationHistoryContextBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemediationHistoryContextBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRemediationHistoryContextBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemediationHistoryContextBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemediationHistoryContextBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemediationHistoryContextInternalServerError as json.
func (s *GetRemediationHistoryContextInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRemediationHistoryContextInternalServerError from json.
func (s *GetRemediationHistoryContextInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemediationHistoryContextInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRemediationHistoryContextInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemediationHistoryContextInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemediationHistoryContextInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWorkflowByIDInternalServerError as json.
func (s *GetWorkflowByIDInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWorkflowByIDInternalServerError from json.
func (s *GetWorkflowByIDInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWorkflowByIDInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWorkflowByIDInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWorkflowByIDInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWorkflowByIDInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetWorkflowByIDNotFound as json.
func (s *GetWorkflowByIDNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetWorkflowByIDNotFound from json.
func (s *GetWorkflowByIDNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWorkflowByIDNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetWorkflowByIDNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWorkflowByIDNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWorkflowByIDNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HashComparisonData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HashComparisonData) encodeFields(e *jx.Encoder) {
	{
		if s.PreRemediationSpecHash.Set {
			e.FieldStart("pre_remediation_spec_hash")
			s.PreRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.PostRemediationSpecHash.Set {
			e.FieldStart("post_remediation_spec_hash")
			s.PostRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.HashMatch.Set {
			e.FieldStart("hash_match")
			s.HashMatch.Encode(e)
		}
	}
}

var jsonFieldsNameOfHashComparisonData = [3]string{
	0: "pre_remediation_spec_hash",
	1: "post_remediation_spec_hash",
	2: "hash_match",
}

// Decode decodes HashComparisonData from json.
func (s *HashComparisonData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HashComparisonData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pre_remediation_spec_hash":
			if err := func() error {
				s.PreRemediationSpecHash.Reset()
				if err := s.PreRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_remediation_spec_hash\"")
			}
		case "post_remediation_spec_hash":
			if err := func() error {
				s.PostRemediationSpecHash.Reset()
				if err := s.PostRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_remediation_spec_hash\"")
			}
		case "hash_match":
			if err := func() error {
				s.HashMatch.Reset()
				if err := s.HashMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash_match\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HashComparisonData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HashComparisonData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HashComparisonData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckOK) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthCheckOK = [1]string{
	0: "status",
}

// Decode decodes HealthCheckOK from json.
func (s *HealthCheckOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckOKStatus as json.
func (s HealthCheckOKStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthCheckOKStatus from json.
func (s *HealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckOKStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthCheckOKStatus(v) {
	case HealthCheckOKStatusHealthy:
		*s = HealthCheckOKStatusHealthy
	default:
		*s = HealthCheckOKStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthCheckServiceUnavailable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthCheckServiceUnavailable) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthCheckServiceUnavailable = [2]string{
	0: "status",
	1: "error",
}

// Decode decodes HealthCheckServiceUnavailable from json.
func (s *HealthCheckServiceUnavailable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckServiceUnavailable to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthCheckServiceUnavailable")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthCheckServiceUnavailable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckServiceUnavailable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckServiceUnavailableStatus as json.
func (s HealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthCheckServiceUnavailableStatus from json.
func (s *HealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthCheckServiceUnavailableStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthCheckServiceUnavailableStatus(v) {
	case HealthCheckServiceUnavailableStatusUnhealthy:
		*s = HealthCheckServiceUnavailableStatusUnhealthy
	default:
		*s = HealthCheckServiceUnavailableStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentResponseData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("analysis")
		e.Str(s.Analysis)
	}
	{
		e.FieldStart("root_cause_analysis")
		s.RootCauseAnalysis.Encode(e)
	}
	{
		if s.SelectedWorkflow.Set {
			e.FieldStart("selected_workflow")
			s.SelectedWorkflow.Encode(e)
		}
	}
	{
		e.FieldStart("confidence")
		e.Float32(s.Confidence)
	}
	{
		e.FieldStart("timestamp")
		json.EncodeDateTime(e, s.Timestamp)
	}
	{
		if s.NeedsHumanReview.Set {
			e.FieldStart("needs_human_review")
			s.NeedsHumanReview.Encode(e)
		}
	}
	{
		if s.HumanReviewReason.Set {
			e.FieldStart("human_review_reason")
			s.HumanReviewReason.Encode(e)
		}
	}
	{
		if s.TargetInOwnerChain.Set {
			e.FieldStart("target_in_owner_chain")
			s.TargetInOwnerChain.Encode(e)
		}
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlternativeWorkflows != nil {
			e.FieldStart("alternative_workflows")
			e.ArrStart()
			for _, elem := range s.AlternativeWorkflows {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIncidentResponseData = [11]string{
	0:  "incident_id",
	1:  "analysis",
	2:  "root_cause_analysis",
	3:  "selected_workflow",
	4:  "confidence",
	5:  "timestamp",
	6:  "needs_human_review",
	7:  "human_review_reason",
	8:  "target_in_owner_chain",
	9:  "warnings",
	10: "alternative_workflows",
}

// Decode decodes IncidentResponseData from json.
func (s *IncidentResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseData to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "analysis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Analysis = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis\"")
			}
		case "root_cause_analysis":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RootCauseAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_cause_analysis\"")
			}
		case "selected_workflow":
			if err := func() error {
				s.SelectedWorkflow.Reset()
				if err := s.SelectedWorkflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_workflow\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float32()
				s.Confidence = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Timestamp = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "needs_human_review":
			if err := func() error {
				s.NeedsHumanReview.Reset()
				if err := s.NeedsHumanReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_human_review\"")
			}
		case "human_review_reason":
			if err := func() error {
				s.HumanReviewReason.Reset()
				if err := s.HumanReviewReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_review_reason\"")
			}
		case "target_in_owner_chain":
			if err := func() error {
				s.TargetInOwnerChain.Reset()
				if err := s.TargetInOwnerChain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_in_owner_chain\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		case "alternative_workflows":
			if err := func() error {
				s.AlternativeWorkflows = make([]IncidentResponseDataAlternativeWorkflowsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IncidentResponseDataAlternativeWorkflowsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlternativeWorkflows = append(s.AlternativeWorkflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alternative_workflows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentResponseData) {
					name = jsonFieldsNameOfIncidentResponseData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentResponseDataAlternativeWorkflowsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentResponseDataAlternativeWorkflowsItem) encodeFields(e *jx.Encoder) {
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		if s.Rationale.Set {
			e.FieldStart("rationale")
			s.Rationale.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentResponseDataAlternativeWorkflowsItem = [2]string{
	0: "workflow_id",
	1: "rationale",
}

// Decode decodes IncidentResponseDataAlternativeWorkflowsItem from json.
func (s *IncidentResponseDataAlternativeWorkflowsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataAlternativeWorkflowsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "rationale":
			if err := func() error {
				s.Rationale.Reset()
				if err := s.Rationale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseDataAlternativeWorkflowsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentResponseDataAlternativeWorkflowsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataAlternativeWorkflowsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDataHumanReviewReason as json.
func (s IncidentResponseDataHumanReviewReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IncidentResponseDataHumanReviewReason from json.
func (s *IncidentResponseDataHumanReviewReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataHumanReviewReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IncidentResponseDataHumanReviewReason(v) {
	case IncidentResponseDataHumanReviewReasonWorkflowNotFound:
		*s = IncidentResponseDataHumanReviewReasonWorkflowNotFound
	case IncidentResponseDataHumanReviewReasonImageMismatch:
		*s = IncidentResponseDataHumanReviewReasonImageMismatch
	case IncidentResponseDataHumanReviewReasonParameterValidationFailed:
		*s = IncidentResponseDataHumanReviewReasonParameterValidationFailed
	case IncidentResponseDataHumanReviewReasonNoMatchingWorkflows:
		*s = IncidentResponseDataHumanReviewReasonNoMatchingWorkflows
	case IncidentResponseDataHumanReviewReasonLowConfidence:
		*s = IncidentResponseDataHumanReviewReasonLowConfidence
	case IncidentResponseDataHumanReviewReasonLlmParsingError:
		*s = IncidentResponseDataHumanReviewReasonLlmParsingError
	case IncidentResponseDataHumanReviewReasonInvestigationInconclusive:
		*s = IncidentResponseDataHumanReviewReasonInvestigationInconclusive
	case IncidentResponseDataHumanReviewReasonRcaIncomplete:
		*s = IncidentResponseDataHumanReviewReasonRcaIncomplete
	default:
		*s = IncidentResponseDataHumanReviewReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseDataHumanReviewReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataHumanReviewReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentResponseDataRootCauseAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentResponseDataRootCauseAnalysis) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("contributing_factors")
		e.ArrStart()
		for _, elem := range s.ContributingFactors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIncidentResponseDataRootCauseAnalysis = [3]string{
	0: "summary",
	1: "severity",
	2: "contributing_factors",
}

// Decode decodes IncidentResponseDataRootCauseAnalysis from json.
func (s *IncidentResponseDataRootCauseAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataRootCauseAnalysis to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "contributing_factors":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.ContributingFactors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ContributingFactors = append(s.ContributingFactors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributing_factors\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseDataRootCauseAnalysis")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentResponseDataRootCauseAnalysis) {
					name = jsonFieldsNameOfIncidentResponseDataRootCauseAnalysis[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentResponseDataRootCauseAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataRootCauseAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDataRootCauseAnalysisSeverity as json.
func (s IncidentResponseDataRootCauseAnalysisSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IncidentResponseDataRootCauseAnalysisSeverity from json.
func (s *IncidentResponseDataRootCauseAnalysisSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataRootCauseAnalysisSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IncidentResponseDataRootCauseAnalysisSeverity(v) {
	case IncidentResponseDataRootCauseAnalysisSeverityCritical:
		*s = IncidentResponseDataRootCauseAnalysisSeverityCritical
	case IncidentResponseDataRootCauseAnalysisSeverityHigh:
		*s = IncidentResponseDataRootCauseAnalysisSeverityHigh
	case IncidentResponseDataRootCauseAnalysisSeverityMedium:
		*s = IncidentResponseDataRootCauseAnalysisSeverityMedium
	case IncidentResponseDataRootCauseAnalysisSeverityLow:
		*s = IncidentResponseDataRootCauseAnalysisSeverityLow
	case IncidentResponseDataRootCauseAnalysisSeverityUnknown:
		*s = IncidentResponseDataRootCauseAnalysisSeverityUnknown
	default:
		*s = IncidentResponseDataRootCauseAnalysisSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseDataRootCauseAnalysisSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataRootCauseAnalysisSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentResponseDataSelectedWorkflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentResponseDataSelectedWorkflow) encodeFields(e *jx.Encoder) {
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		if s.ActionType.Set {
			e.FieldStart("action_type")
			s.ActionType.Encode(e)
		}
	}
	{
		if s.ContainerImage.Set {
			e.FieldStart("container_image")
			s.ContainerImage.Encode(e)
		}
	}
	{
		if s.Confidence.Set {
			e.FieldStart("confidence")
			s.Confidence.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentResponseDataSelectedWorkflow = [5]string{
	0: "workflow_id",
	1: "action_type",
	2: "container_image",
	3: "confidence",
	4: "parameters",
}

// Decode decodes IncidentResponseDataSelectedWorkflow from json.
func (s *IncidentResponseDataSelectedWorkflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataSelectedWorkflow to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "action_type":
			if err := func() error {
				s.ActionType.Reset()
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "container_image":
			if err := func() error {
				s.ContainerImage.Reset()
				if err := s.ContainerImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_image\"")
			}
		case "confidence":
			if err := func() error {
				s.Confidence.Reset()
				if err := s.Confidence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseDataSelectedWorkflow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentResponseDataSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IncidentResponseDataSelectedWorkflowParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IncidentResponseDataSelectedWorkflowParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes IncidentResponseDataSelectedWorkflowParameters from json.
func (s *IncidentResponseDataSelectedWorkflowParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDataSelectedWorkflowParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseDataSelectedWorkflowParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseDataSelectedWorkflowParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDataSelectedWorkflowParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMRequestPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMRequestPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_id")
		e.Str(s.EventID)
	}
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("model")
		e.Str(s.Model)
	}
	{
		e.FieldStart("prompt_length")
		e.Int(s.PromptLength)
	}
	{
		e.FieldStart("prompt_preview")
		e.Str(s.PromptPreview)
	}
	{
		if s.MaxTokens.Set {
			e.FieldStart("max_tokens")
			s.MaxTokens.Encode(e)
		}
	}
	{
		if s.ToolsetsEnabled != nil {
			e.FieldStart("toolsets_enabled")
			e.ArrStart()
			for _, elem := range s.ToolsetsEnabled {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.McpServers != nil {
			e.FieldStart("mcp_servers")
			e.ArrStart()
			for _, elem := range s.McpServers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLLMRequestPayload = [9]string{
	0: "event_type",
	1: "event_id",
	2: "incident_id",
	3: "model",
	4: "prompt_length",
	5: "prompt_preview",
	6: "max_tokens",
	7: "toolsets_enabled",
	8: "mcp_servers",
}

// Decode decodes LLMRequestPayload from json.
func (s *LLMRequestPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMRequestPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "incident_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Model = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "prompt_length":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.PromptLength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_length\"")
			}
		case "prompt_preview":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PromptPreview = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_preview\"")
			}
		case "max_tokens":
			if err := func() error {
				s.MaxTokens.Reset()
				if err := s.MaxTokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_tokens\"")
			}
		case "toolsets_enabled":
			if err := func() error {
				s.ToolsetsEnabled = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ToolsetsEnabled = append(s.ToolsetsEnabled, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toolsets_enabled\"")
			}
		case "mcp_servers":
			if err := func() error {
				s.McpServers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.McpServers = append(s.McpServers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcp_servers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMRequestPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMRequestPayload) {
					name = jsonFieldsNameOfLLMRequestPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMRequestPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMRequestPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMRequestPayloadEventType as json.
func (s LLMRequestPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LLMRequestPayloadEventType from json.
func (s *LLMRequestPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMRequestPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LLMRequestPayloadEventType(v) {
	case LLMRequestPayloadEventTypeAiagentLlmRequest:
		*s = LLMRequestPayloadEventTypeAiagentLlmRequest
	default:
		*s = LLMRequestPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMRequestPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMRequestPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMResponsePayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMResponsePayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_id")
		e.Str(s.EventID)
	}
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("has_analysis")
		e.Bool(s.HasAnalysis)
	}
	{
		e.FieldStart("analysis_length")
		e.Int(s.AnalysisLength)
	}
	{
		e.FieldStart("analysis_preview")
		e.Str(s.AnalysisPreview)
	}
	{
		if s.TokensUsed.Set {
			e.FieldStart("tokens_used")
			s.TokensUsed.Encode(e)
		}
	}
	{
		if s.ToolCallCount.Set {
			e.FieldStart("tool_call_count")
			s.ToolCallCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMResponsePayload = [8]string{
	0: "event_type",
	1: "event_id",
	2: "incident_id",
	3: "has_analysis",
	4: "analysis_length",
	5: "analysis_preview",
	6: "tokens_used",
	7: "tool_call_count",
}

// Decode decodes LLMResponsePayload from json.
func (s *LLMResponsePayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMResponsePayload to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "incident_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "has_analysis":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasAnalysis = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_analysis\"")
			}
		case "analysis_length":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.AnalysisLength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_length\"")
			}
		case "analysis_preview":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AnalysisPreview = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_preview\"")
			}
		case "tokens_used":
			if err := func() error {
				s.TokensUsed.Reset()
				if err := s.TokensUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokens_used\"")
			}
		case "tool_call_count":
			if err := func() error {
				s.ToolCallCount.Reset()
				if err := s.ToolCallCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMResponsePayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMResponsePayload) {
					name = jsonFieldsNameOfLLMResponsePayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMResponsePayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMResponsePayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMResponsePayloadEventType as json.
func (s LLMResponsePayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LLMResponsePayloadEventType from json.
func (s *LLMResponsePayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMResponsePayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LLMResponsePayloadEventType(v) {
	case LLMResponsePayloadEventTypeAiagentLlmResponse:
		*s = LLMResponsePayloadEventTypeAiagentLlmResponse
	default:
		*s = LLMResponsePayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMResponsePayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMResponsePayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMToolCallPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMToolCallPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_id")
		e.Str(s.EventID)
	}
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("tool_call_index")
		e.Int(s.ToolCallIndex)
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		if s.ToolArguments.Set {
			e.FieldStart("tool_arguments")
			s.ToolArguments.Encode(e)
		}
	}
	{
		if len(s.ToolResult) != 0 {
			e.FieldStart("tool_result")
			e.Raw(s.ToolResult)
		}
	}
	{
		if s.ToolResultPreview.Set {
			e.FieldStart("tool_result_preview")
			s.ToolResultPreview.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMToolCallPayload = [8]string{
	0: "event_type",
	1: "event_id",
	2: "incident_id",
	3: "tool_call_index",
	4: "tool_name",
	5: "tool_arguments",
	6: "tool_result",
	7: "tool_result_preview",
}

// Decode decodes LLMToolCallPayload from json.
func (s *LLMToolCallPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMToolCallPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "incident_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "tool_call_index":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ToolCallIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_index\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "tool_arguments":
			if err := func() error {
				s.ToolArguments.Reset()
				if err := s.ToolArguments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_arguments\"")
			}
		case "tool_result":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.ToolResult = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_result\"")
			}
		case "tool_result_preview":
			if err := func() error {
				s.ToolResultPreview.Reset()
				if err := s.ToolResultPreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_result_preview\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMToolCallPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMToolCallPayload) {
					name = jsonFieldsNameOfLLMToolCallPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMToolCallPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMToolCallPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMToolCallPayloadEventType as json.
func (s LLMToolCallPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LLMToolCallPayloadEventType from json.
func (s *LLMToolCallPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMToolCallPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LLMToolCallPayloadEventType(v) {
	case LLMToolCallPayloadEventTypeAiagentLlmToolCall:
		*s = LLMToolCallPayloadEventTypeAiagentLlmToolCall
	default:
		*s = LLMToolCallPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMToolCallPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMToolCallPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LLMToolCallPayloadToolArguments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LLMToolCallPayloadToolArguments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes LLMToolCallPayloadToolArguments from json.
func (s *LLMToolCallPayloadToolArguments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMToolCallPayloadToolArguments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMToolCallPayloadToolArguments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMToolCallPayloadToolArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMToolCallPayloadToolArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAvailableActionsBadRequest as json.
func (s *ListAvailableActionsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListAvailableActionsBadRequest from json.
func (s *ListAvailableActionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAvailableActionsBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListAvailableActionsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAvailableActionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAvailableActionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListAvailableActionsInternalServerError as json.
func (s *ListAvailableActionsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListAvailableActionsInternalServerError from json.
func (s *ListAvailableActionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAvailableActionsInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListAvailableActionsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAvailableActionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAvailableActionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListLegalHoldsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListLegalHoldsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Holds != nil {
			e.FieldStart("holds")
			e.ArrStart()
			for _, elem := range s.Holds {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfListLegalHoldsOK = [2]string{
	0: "holds",
	1: "total",
}

// Decode decodes ListLegalHoldsOK from json.
func (s *ListLegalHoldsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListLegalHoldsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "holds":
			if err := func() error {
				s.Holds = make([]ListLegalHoldsOKHoldsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ListLegalHoldsOKHoldsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Holds = append(s.Holds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"holds\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListLegalHoldsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListLegalHoldsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListLegalHoldsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListLegalHoldsOKHoldsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListLegalHoldsOKHoldsItem) encodeFields(e *jx.Encoder) {
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
	{
		if s.EventsAffected.Set {
			e.FieldStart("events_affected")
			s.EventsAffected.Encode(e)
		}
	}
	{
		if s.PlacedBy.Set {
			e.FieldStart("placed_by")
			s.PlacedBy.Encode(e)
		}
	}
	{
		if s.PlacedAt.Set {
			e.FieldStart("placed_at")
			s.PlacedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfListLegalHoldsOKHoldsItem = [5]string{
	0: "correlation_id",
	1: "events_affected",
	2: "placed_by",
	3: "placed_at",
	4: "reason",
}

// Decode decodes ListLegalHoldsOKHoldsItem from json.
func (s *ListLegalHoldsOKHoldsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListLegalHoldsOKHoldsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "events_affected":
			if err := func() error {
				s.EventsAffected.Reset()
				if err := s.EventsAffected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_affected\"")
			}
		case "placed_by":
			if err := func() error {
				s.PlacedBy.Reset()
				if err := s.PlacedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placed_by\"")
			}
		case "placed_at":
			if err := func() error {
				s.PlacedAt.Reset()
				if err := s.PlacedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placed_at\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListLegalHoldsOKHoldsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListLegalHoldsOKHoldsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListLegalHoldsOKHoldsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListWorkflowsByActionTypeBadRequest as json.
func (s *ListWorkflowsByActionTypeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListWorkflowsByActionTypeBadRequest from json.
func (s *ListWorkflowsByActionTypeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListWorkflowsByActionTypeBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListWorkflowsByActionTypeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListWorkflowsByActionTypeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListWorkflowsByActionTypeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListWorkflowsByActionTypeInternalServerError as json.
func (s *ListWorkflowsByActionTypeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ListWorkflowsByActionTypeInternalServerError from json.
func (s *ListWorkflowsByActionTypeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListWorkflowsByActionTypeInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListWorkflowsByActionTypeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListWorkflowsByActionTypeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListWorkflowsByActionTypeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MandatoryLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MandatoryLabels) encodeFields(e *jx.Encoder) {
	{
		if s.SignalType.Set {
			e.FieldStart("signal_type")
			s.SignalType.Encode(e)
		}
	}
	{
		e.FieldStart("severity")
		e.ArrStart()
		for _, elem := range s.Severity {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("environment")
		e.ArrStart()
		for _, elem := range s.Environment {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("priority")
		s.Priority.Encode(e)
	}
}

var jsonFieldsNameOfMandatoryLabels = [5]string{
	0: "signal_type",
	1: "severity",
	2: "component",
	3: "environment",
	4: "priority",
}

// Decode decodes MandatoryLabels from json.
func (s *MandatoryLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MandatoryLabels to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signal_type":
			if err := func() error {
				s.SignalType.Reset()
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Severity = make([]MandatoryLabelsSeverityItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MandatoryLabelsSeverityItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Severity = append(s.Severity, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "component":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Environment = make([]MandatoryLabelsEnvironmentItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MandatoryLabelsEnvironmentItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Environment = append(s.Environment, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MandatoryLabels")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMandatoryLabels) {
					name = jsonFieldsNameOfMandatoryLabels[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MandatoryLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MandatoryLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MandatoryLabelsEnvironmentItem as json.
func (s MandatoryLabelsEnvironmentItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MandatoryLabelsEnvironmentItem from json.
func (s *MandatoryLabelsEnvironmentItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MandatoryLabelsEnvironmentItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MandatoryLabelsEnvironmentItem(v) {
	case MandatoryLabelsEnvironmentItem_production:
		*s = MandatoryLabelsEnvironmentItem_production
	case MandatoryLabelsEnvironmentItem_staging:
		*s = MandatoryLabelsEnvironmentItem_staging
	case MandatoryLabelsEnvironmentItem_development:
		*s = MandatoryLabelsEnvironmentItem_development
	case MandatoryLabelsEnvironmentItem_test:
		*s = MandatoryLabelsEnvironmentItem_test
	case MandatoryLabelsEnvironmentItem_:
		*s = MandatoryLabelsEnvironmentItem_
	default:
		*s = MandatoryLabelsEnvironmentItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MandatoryLabelsEnvironmentItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MandatoryLabelsEnvironmentItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MandatoryLabelsPriority as json.
func (s MandatoryLabelsPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MandatoryLabelsPriority from json.
func (s *MandatoryLabelsPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MandatoryLabelsPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MandatoryLabelsPriority(v) {
	case MandatoryLabelsPriority_P0:
		*s = MandatoryLabelsPriority_P0
	case MandatoryLabelsPriority_P1:
		*s = MandatoryLabelsPriority_P1
	case MandatoryLabelsPriority_P2:
		*s = MandatoryLabelsPriority_P2
	case MandatoryLabelsPriority_P3:
		*s = MandatoryLabelsPriority_P3
	case MandatoryLabelsPriority_:
		*s = MandatoryLabelsPriority_
	default:
		*s = MandatoryLabelsPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MandatoryLabelsPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MandatoryLabelsPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MandatoryLabelsSeverityItem as json.
func (s MandatoryLabelsSeverityItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MandatoryLabelsSeverityItem from json.
func (s *MandatoryLabelsSeverityItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MandatoryLabelsSeverityItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MandatoryLabelsSeverityItem(v) {
	case MandatoryLabelsSeverityItemCritical:
		*s = MandatoryLabelsSeverityItemCritical
	case MandatoryLabelsSeverityItemHigh:
		*s = MandatoryLabelsSeverityItemHigh
	case MandatoryLabelsSeverityItemMedium:
		*s = MandatoryLabelsSeverityItemMedium
	case MandatoryLabelsSeverityItemLow:
		*s = MandatoryLabelsSeverityItemLow
	default:
		*s = MandatoryLabelsSeverityItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MandatoryLabelsSeverityItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MandatoryLabelsSeverityItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationAudit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationAudit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remediation_id")
		e.Str(s.RemediationID)
	}
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("recipient")
		e.Str(s.Recipient)
	}
	{
		e.FieldStart("channel")
		s.Channel.Encode(e)
	}
	{
		e.FieldStart("message_summary")
		e.Str(s.MessageSummary)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("sent_at")
		json.EncodeDateTime(e, s.SentAt)
	}
	{
		if s.DeliveryStatus.Set {
			e.FieldStart("delivery_status")
			s.DeliveryStatus.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.EscalationLevel.Set {
			e.FieldStart("escalation_level")
			s.EscalationLevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationAudit = [10]string{
	0: "remediation_id",
	1: "notification_id",
	2: "recipient",
	3: "channel",
	4: "message_summary",
	5: "status",
	6: "sent_at",
	7: "delivery_status",
	8: "error_message",
	9: "escalation_level",
}

// Decode decodes NotificationAudit from json.
func (s *NotificationAudit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAudit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remediation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RemediationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_id\"")
			}
		case "notification_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "recipient":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Recipient = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipient\"")
			}
		case "channel":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Channel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel\"")
			}
		case "message_summary":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.MessageSummary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_summary\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "sent_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.SentAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sent_at\"")
			}
		case "delivery_status":
			if err := func() error {
				s.DeliveryStatus.Reset()
				if err := s.DeliveryStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery_status\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "escalation_level":
			if err := func() error {
				s.EscalationLevel.Reset()
				if err := s.EscalationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"escalation_level\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationAudit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationAudit) {
					name = jsonFieldsNameOfNotificationAudit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationAudit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAudit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditChannel as json.
func (s NotificationAuditChannel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditChannel from json.
func (s *NotificationAuditChannel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditChannel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditChannel(v) {
	case NotificationAuditChannelEmail:
		*s = NotificationAuditChannelEmail
	case NotificationAuditChannelSlack:
		*s = NotificationAuditChannelSlack
	case NotificationAuditChannelPagerduty:
		*s = NotificationAuditChannelPagerduty
	case NotificationAuditChannelWebhook:
		*s = NotificationAuditChannelWebhook
	default:
		*s = NotificationAuditChannel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditChannel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditChannel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		if s.NotificationID.Set {
			e.FieldStart("notification_id")
			s.NotificationID.Encode(e)
		}
	}
	{
		if s.NotificationName.Set {
			e.FieldStart("notification_name")
			s.NotificationName.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.NotificationType.Set {
			e.FieldStart("notification_type")
			s.NotificationType.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.FinalStatus.Set {
			e.FieldStart("final_status")
			s.FinalStatus.Encode(e)
		}
	}
	{
		if s.Recipients != nil {
			e.FieldStart("recipients")
			e.ArrStart()
			for _, elem := range s.Recipients {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CancelledBy.Set {
			e.FieldStart("cancelled_by")
			s.CancelledBy.Encode(e)
		}
	}
	{
		if s.UserUID.Set {
			e.FieldStart("user_uid")
			s.UserUID.Encode(e)
		}
	}
	{
		if s.UserGroups != nil {
			e.FieldStart("user_groups")
			e.ArrStart()
			for _, elem := range s.UserGroups {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationAuditPayload = [12]string{
	0:  "event_type",
	1:  "notification_id",
	2:  "notification_name",
	3:  "type",
	4:  "notification_type",
	5:  "priority",
	6:  "final_status",
	7:  "recipients",
	8:  "cancelled_by",
	9:  "user_uid",
	10: "user_groups",
	11: "action",
}

// Decode decodes NotificationAuditPayload from json.
func (s *NotificationAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "notification_id":
			if err := func() error {
				s.NotificationID.Reset()
				if err := s.NotificationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "notification_name":
			if err := func() error {
				s.NotificationName.Reset()
				if err := s.NotificationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "notification_type":
			if err := func() error {
				s.NotificationType.Reset()
				if err := s.NotificationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_type\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "final_status":
			if err := func() error {
				s.FinalStatus.Reset()
				if err := s.FinalStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final_status\"")
			}
		case "recipients":
			if err := func() error {
				s.Recipients = make([]NotificationAuditPayloadRecipientsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NotificationAuditPayloadRecipientsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recipients = append(s.Recipients, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipients\"")
			}
		case "cancelled_by":
			if err := func() error {
				s.CancelledBy.Reset()
				if err := s.CancelledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelled_by\"")
			}
		case "user_uid":
			if err := func() error {
				s.UserUID.Reset()
				if err := s.UserUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_uid\"")
			}
		case "user_groups":
			if err := func() error {
				s.UserGroups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.UserGroups = append(s.UserGroups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_groups\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationAuditPayload) {
					name = jsonFieldsNameOfNotificationAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadAction as json.
func (s NotificationAuditPayloadAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadAction from json.
func (s *NotificationAuditPayloadAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadAction(v) {
	case NotificationAuditPayloadActionNotificationCancelled:
		*s = NotificationAuditPayloadActionNotificationCancelled
	case NotificationAuditPayloadActionNotificationAcknowledged:
		*s = NotificationAuditPayloadActionNotificationAcknowledged
	default:
		*s = NotificationAuditPayloadAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadEventType as json.
func (s NotificationAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadEventType from json.
func (s *NotificationAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadEventType(v) {
	case NotificationAuditPayloadEventTypeWebhookNotificationCancelled:
		*s = NotificationAuditPayloadEventTypeWebhookNotificationCancelled
	case NotificationAuditPayloadEventTypeWebhookNotificationAcknowledged:
		*s = NotificationAuditPayloadEventTypeWebhookNotificationAcknowledged
	default:
		*s = NotificationAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadFinalStatus as json.
func (s NotificationAuditPayloadFinalStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadFinalStatus from json.
func (s *NotificationAuditPayloadFinalStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadFinalStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadFinalStatus(v) {
	case NotificationAuditPayloadFinalStatusPending:
		*s = NotificationAuditPayloadFinalStatusPending
	case NotificationAuditPayloadFinalStatusSending:
		*s = NotificationAuditPayloadFinalStatusSending
	case NotificationAuditPayloadFinalStatusSent:
		*s = NotificationAuditPayloadFinalStatusSent
	case NotificationAuditPayloadFinalStatusFailed:
		*s = NotificationAuditPayloadFinalStatusFailed
	case NotificationAuditPayloadFinalStatusCancelled:
		*s = NotificationAuditPayloadFinalStatusCancelled
	default:
		*s = NotificationAuditPayloadFinalStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadFinalStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadFinalStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadNotificationType as json.
func (s NotificationAuditPayloadNotificationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadNotificationType from json.
func (s *NotificationAuditPayloadNotificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadNotificationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadNotificationType(v) {
	case NotificationAuditPayloadNotificationTypeEscalation:
		*s = NotificationAuditPayloadNotificationTypeEscalation
	case NotificationAuditPayloadNotificationTypeSimple:
		*s = NotificationAuditPayloadNotificationTypeSimple
	case NotificationAuditPayloadNotificationTypeStatusUpdate:
		*s = NotificationAuditPayloadNotificationTypeStatusUpdate
	case NotificationAuditPayloadNotificationTypeApproval:
		*s = NotificationAuditPayloadNotificationTypeApproval
	case NotificationAuditPayloadNotificationTypeManualReview:
		*s = NotificationAuditPayloadNotificationTypeManualReview
	default:
		*s = NotificationAuditPayloadNotificationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadNotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadNotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadPriority as json.
func (s NotificationAuditPayloadPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadPriority from json.
func (s *NotificationAuditPayloadPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadPriority(v) {
	case NotificationAuditPayloadPriorityCritical:
		*s = NotificationAuditPayloadPriorityCritical
	case NotificationAuditPayloadPriorityHigh:
		*s = NotificationAuditPayloadPriorityHigh
	case NotificationAuditPayloadPriorityMedium:
		*s = NotificationAuditPayloadPriorityMedium
	case NotificationAuditPayloadPriorityLow:
		*s = NotificationAuditPayloadPriorityLow
	default:
		*s = NotificationAuditPayloadPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationAuditPayloadRecipientsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationAuditPayloadRecipientsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Slack.Set {
			e.FieldStart("slack")
			s.Slack.Encode(e)
		}
	}
	{
		if s.Teams.Set {
			e.FieldStart("teams")
			s.Teams.Encode(e)
		}
	}
	{
		if s.Phone.Set {
			e.FieldStart("phone")
			s.Phone.Encode(e)
		}
	}
	{
		if s.WebhookURL.Set {
			e.FieldStart("webhookURL")
			s.WebhookURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationAuditPayloadRecipientsItem = [5]string{
	0: "email",
	1: "slack",
	2: "teams",
	3: "phone",
	4: "webhookURL",
}

// Decode decodes NotificationAuditPayloadRecipientsItem from json.
func (s *NotificationAuditPayloadRecipientsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadRecipientsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "slack":
			if err := func() error {
				s.Slack.Reset()
				if err := s.Slack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slack\"")
			}
		case "teams":
			if err := func() error {
				s.Teams.Reset()
				if err := s.Teams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		case "phone":
			if err := func() error {
				s.Phone.Reset()
				if err := s.Phone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone\"")
			}
		case "webhookURL":
			if err := func() error {
				s.WebhookURL.Reset()
				if err := s.WebhookURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhookURL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationAuditPayloadRecipientsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationAuditPayloadRecipientsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadRecipientsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadType as json.
func (s NotificationAuditPayloadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditPayloadType from json.
func (s *NotificationAuditPayloadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditPayloadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditPayloadType(v) {
	case NotificationAuditPayloadTypeEscalation:
		*s = NotificationAuditPayloadTypeEscalation
	case NotificationAuditPayloadTypeSimple:
		*s = NotificationAuditPayloadTypeSimple
	case NotificationAuditPayloadTypeStatusUpdate:
		*s = NotificationAuditPayloadTypeStatusUpdate
	case NotificationAuditPayloadTypeApproval:
		*s = NotificationAuditPayloadTypeApproval
	case NotificationAuditPayloadTypeManualReview:
		*s = NotificationAuditPayloadTypeManualReview
	default:
		*s = NotificationAuditPayloadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationAuditResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationAuditResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remediation_id")
		e.Str(s.RemediationID)
	}
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("recipient")
		e.Str(s.Recipient)
	}
	{
		e.FieldStart("channel")
		s.Channel.Encode(e)
	}
	{
		e.FieldStart("message_summary")
		e.Str(s.MessageSummary)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("sent_at")
		json.EncodeDateTime(e, s.SentAt)
	}
	{
		if s.DeliveryStatus.Set {
			e.FieldStart("delivery_status")
			s.DeliveryStatus.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.EscalationLevel.Set {
			e.FieldStart("escalation_level")
			s.EscalationLevel.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfNotificationAuditResponse = [13]string{
	0:  "remediation_id",
	1:  "notification_id",
	2:  "recipient",
	3:  "channel",
	4:  "message_summary",
	5:  "status",
	6:  "sent_at",
	7:  "delivery_status",
	8:  "error_message",
	9:  "escalation_level",
	10: "id",
	11: "created_at",
	12: "updated_at",
}

// Decode decodes NotificationAuditResponse from json.
func (s *NotificationAuditResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remediation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RemediationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_id\"")
			}
		case "notification_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "recipient":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Recipient = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipient\"")
			}
		case "channel":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Channel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel\"")
			}
		case "message_summary":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.MessageSummary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_summary\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "sent_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.SentAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sent_at\"")
			}
		case "delivery_status":
			if err := func() error {
				s.DeliveryStatus.Reset()
				if err := s.DeliveryStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery_status\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "escalation_level":
			if err := func() error {
				s.EscalationLevel.Reset()
				if err := s.EscalationLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"escalation_level\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationAuditResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationAuditResponse) {
					name = jsonFieldsNameOfNotificationAuditResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationAuditResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditResponseChannel as json.
func (s NotificationAuditResponseChannel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditResponseChannel from json.
func (s *NotificationAuditResponseChannel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditResponseChannel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditResponseChannel(v) {
	case NotificationAuditResponseChannelEmail:
		*s = NotificationAuditResponseChannelEmail
	case NotificationAuditResponseChannelSlack:
		*s = NotificationAuditResponseChannelSlack
	case NotificationAuditResponseChannelPagerduty:
		*s = NotificationAuditResponseChannelPagerduty
	case NotificationAuditResponseChannelWebhook:
		*s = NotificationAuditResponseChannelWebhook
	default:
		*s = NotificationAuditResponseChannel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditResponseChannel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditResponseChannel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditResponseStatus as json.
func (s NotificationAuditResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditResponseStatus from json.
func (s *NotificationAuditResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditResponseStatus(v) {
	case NotificationAuditResponseStatusSent:
		*s = NotificationAuditResponseStatusSent
	case NotificationAuditResponseStatusFailed:
		*s = NotificationAuditResponseStatusFailed
	case NotificationAuditResponseStatusPending:
		*s = NotificationAuditResponseStatusPending
	default:
		*s = NotificationAuditResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditStatus as json.
func (s NotificationAuditStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationAuditStatus from json.
func (s *NotificationAuditStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAuditStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationAuditStatus(v) {
	case NotificationAuditStatusSent:
		*s = NotificationAuditStatusSent
	case NotificationAuditStatusFailed:
		*s = NotificationAuditStatusFailed
	case NotificationAuditStatusPending:
		*s = NotificationAuditStatusPending
	default:
		*s = NotificationAuditStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationAuditStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAuditStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationMessageAcknowledgedPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationMessageAcknowledgedPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("subject")
		e.Str(s.Subject)
	}
	{
		e.FieldStart("priority")
		e.Str(s.Priority)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationMessageAcknowledgedPayload = [4]string{
	0: "notification_id",
	1: "subject",
	2: "priority",
	3: "metadata",
}

// Decode decodes NotificationMessageAcknowledgedPayload from json.
func (s *NotificationMessageAcknowledgedPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageAcknowledgedPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notification_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Subject = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Priority = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageAcknowledgedPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationMessageAcknowledgedPayload) {
					name = jsonFieldsNameOfNotificationMessageAcknowledgedPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationMessageAcknowledgedPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageAcknowledgedPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NotificationMessageAcknowledgedPayloadMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NotificationMessageAcknowledgedPayloadMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NotificationMessageAcknowledgedPayloadMetadata from json.
func (s *NotificationMessageAcknowledgedPayloadMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageAcknowledgedPayloadMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageAcknowledgedPayloadMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationMessageAcknowledgedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageAcknowledgedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationMessageEscalatedPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationMessageEscalatedPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("subject")
		e.Str(s.Subject)
	}
	{
		e.FieldStart("priority")
		e.Str(s.Priority)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationMessageEscalatedPayload = [5]string{
	0: "notification_id",
	1: "subject",
	2: "priority",
	3: "reason",
	4: "metadata",
}

// Decode decodes NotificationMessageEscalatedPayload from json.
func (s *NotificationMessageEscalatedPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageEscalatedPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notification_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Subject = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Priority = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageEscalatedPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationMessageEscalatedPayload) {
					name = jsonFieldsNameOfNotificationMessageEscalatedPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationMessageEscalatedPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageEscalatedPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NotificationMessageEscalatedPayloadMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NotificationMessageEscalatedPayloadMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NotificationMessageEscalatedPayloadMetadata from json.
func (s *NotificationMessageEscalatedPayloadMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageEscalatedPayloadMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageEscalatedPayloadMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationMessageEscalatedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageEscalatedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationMessageFailedPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationMessageFailedPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("channel")
		e.Str(s.Channel)
	}
	{
		e.FieldStart("subject")
		e.Str(s.Subject)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("priority")
		e.Str(s.Priority)
	}
	{
		e.FieldStart("error_type")
		e.Str(s.ErrorType)
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationMessageFailedPayload = [8]string{
	0: "notification_id",
	1: "channel",
	2: "subject",
	3: "body",
	4: "priority",
	5: "error_type",
	6: "error",
	7: "metadata",
}

// Decode decodes NotificationMessageFailedPayload from json.
func (s *NotificationMessageFailedPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageFailedPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notification_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "channel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Channel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Subject = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Priority = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "error_type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ErrorType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_type\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageFailedPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationMessageFailedPayload) {
					name = jsonFieldsNameOfNotificationMessageFailedPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationMessageFailedPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageFailedPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NotificationMessageFailedPayloadMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NotificationMessageFailedPayloadMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NotificationMessageFailedPayloadMetadata from json.
func (s *NotificationMessageFailedPayloadMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageFailedPayloadMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageFailedPayloadMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationMessageFailedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageFailedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationMessageSentPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationMessageSentPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("notification_id")
		e.Str(s.NotificationID)
	}
	{
		e.FieldStart("channel")
		e.Str(s.Channel)
	}
	{
		e.FieldStart("subject")
		e.Str(s.Subject)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("priority")
		e.Str(s.Priority)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotificationMessageSentPayload = [7]string{
	0: "notification_id",
	1: "channel",
	2: "subject",
	3: "body",
	4: "priority",
	5: "type",
	6: "metadata",
}

// Decode decodes NotificationMessageSentPayload from json.
func (s *NotificationMessageSentPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageSentPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "notification_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NotificationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_id\"")
			}
		case "channel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Channel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel\"")
			}
		case "subject":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Subject = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subject\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Priority = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageSentPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationMessageSentPayload) {
					name = jsonFieldsNameOfNotificationMessageSentPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationMessageSentPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageSentPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NotificationMessageSentPayloadMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NotificationMessageSentPayloadMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes NotificationMessageSentPayloadMetadata from json.
func (s *NotificationMessageSentPayloadMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessageSentPayloadMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessageSentPayloadMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationMessageSentPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessageSentPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditEventsQueryResponsePagination as json.
func (o OptAuditEventsQueryResponsePagination) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditEventsQueryResponsePagination from json.
func (o *OptAuditEventsQueryResponsePagination) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditEventsQueryResponsePagination to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuditEventsQueryResponsePagination) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuditEventsQueryResponsePagination) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditExportResponseEventsItemEventData as json.
func (o OptAuditExportResponseEventsItemEventData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditExportResponseEventsItemEventData from json.
func (o *OptAuditExportResponseEventsItemEventData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditExportResponseEventsItemEventData to nil")
	}
	o.Set = true
	o.Value = make(AuditExportResponseEventsItemEventData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuditExportResponseEventsItemEventData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuditExportResponseEventsItemEventData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuditExportResponseExportMetadataQueryFilters as json.
func (o OptAuditExportResponseExportMetadataQueryFilters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AuditExportResponseExportMetadataQueryFilters from json.
func (o *OptAuditExportResponseExportMetadataQueryFilters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuditExportResponseExportMetadataQueryFilters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuditExportResponseExportMetadataQueryFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuditExportResponseExportMetadataQueryFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CustomLabels as json.
func (o OptCustomLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CustomLabels from json.
func (o *OptCustomLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCustomLabels to nil")
	}
	o.Set = true
	o.Value = make(CustomLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCustomLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCustomLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DetectedLabels as json.
func (o OptDetectedLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DetectedLabels from json.
func (o *OptDetectedLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDetectedLabels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DetectedLabelsGitOpsTool as json.
func (o OptDetectedLabelsGitOpsTool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DetectedLabelsGitOpsTool from json.
func (o *OptDetectedLabelsGitOpsTool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDetectedLabelsGitOpsTool to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDetectedLabelsGitOpsTool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDetectedLabelsGitOpsTool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DetectedLabelsServiceMesh as json.
func (o OptDetectedLabelsServiceMesh) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DetectedLabelsServiceMesh from json.
func (o *OptDetectedLabelsServiceMesh) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDetectedLabelsServiceMesh to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDetectedLabelsServiceMesh) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDetectedLabelsServiceMesh) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessAssessmentAuditPayloadAlertResolution as json.
func (o OptEffectivenessAssessmentAuditPayloadAlertResolution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectivenessAssessmentAuditPayloadAlertResolution from json.
func (o *OptEffectivenessAssessmentAuditPayloadAlertResolution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectivenessAssessmentAuditPayloadAlertResolution to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectivenessAssessmentAuditPayloadAlertResolution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectivenessAssessmentAuditPayloadAlertResolution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessAssessmentAuditPayloadHealthChecks as json.
func (o OptEffectivenessAssessmentAuditPayloadHealthChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectivenessAssessmentAuditPayloadHealthChecks from json.
func (o *OptEffectivenessAssessmentAuditPayloadHealthChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectivenessAssessmentAuditPayloadHealthChecks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectivenessAssessmentAuditPayloadHealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectivenessAssessmentAuditPayloadHealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EffectivenessAssessmentAuditPayloadMetricDeltas as json.
func (o OptEffectivenessAssessmentAuditPayloadMetricDeltas) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EffectivenessAssessmentAuditPayloadMetricDeltas from json.
func (o *OptEffectivenessAssessmentAuditPayloadMetricDeltas) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEffectivenessAssessmentAuditPayloadMetricDeltas to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEffectivenessAssessmentAuditPayloadMetricDeltas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEffectivenessAssessmentAuditPayloadMetricDeltas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorDetails as json.
func (o OptErrorDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ErrorDetails from json.
func (o *OptErrorDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrorDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrorDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrorDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadDeduplicationStatus as json.
func (o OptGatewayAuditPayloadDeduplicationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GatewayAuditPayloadDeduplicationStatus from json.
func (o *OptGatewayAuditPayloadDeduplicationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatewayAuditPayloadDeduplicationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatewayAuditPayloadDeduplicationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatewayAuditPayloadDeduplicationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadOriginalPayload as json.
func (o OptGatewayAuditPayloadOriginalPayload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GatewayAuditPayloadOriginalPayload from json.
func (o *OptGatewayAuditPayloadOriginalPayload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatewayAuditPayloadOriginalPayload to nil")
	}
	o.Set = true
	o.Value = make(GatewayAuditPayloadOriginalPayload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatewayAuditPayloadOriginalPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatewayAuditPayloadOriginalPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadSignalAnnotations as json.
func (o OptGatewayAuditPayloadSignalAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GatewayAuditPayloadSignalAnnotations from json.
func (o *OptGatewayAuditPayloadSignalAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatewayAuditPayloadSignalAnnotations to nil")
	}
	o.Set = true
	o.Value = make(GatewayAuditPayloadSignalAnnotations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatewayAuditPayloadSignalAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatewayAuditPayloadSignalAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GatewayAuditPayloadSignalLabels as json.
func (o OptGatewayAuditPayloadSignalLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GatewayAuditPayloadSignalLabels from json.
func (o *OptGatewayAuditPayloadSignalLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGatewayAuditPayloadSignalLabels to nil")
	}
	o.Set = true
	o.Value = make(GatewayAuditPayloadSignalLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGatewayAuditPayloadSignalLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGatewayAuditPayloadSignalLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HashComparisonData as json.
func (o OptHashComparisonData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HashComparisonData from json.
func (o *OptHashComparisonData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHashComparisonData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHashComparisonData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHashComparisonData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckOKStatus as json.
func (o OptHealthCheckOKStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HealthCheckOKStatus from json.
func (o *OptHealthCheckOKStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthCheckOKStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthCheckOKStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthCheckOKStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthCheckServiceUnavailableStatus as json.
func (o OptHealthCheckServiceUnavailableStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HealthCheckServiceUnavailableStatus from json.
func (o *OptHealthCheckServiceUnavailableStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthCheckServiceUnavailableStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthCheckServiceUnavailableStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthCheckServiceUnavailableStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDataHumanReviewReason as json.
func (o OptIncidentResponseDataHumanReviewReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IncidentResponseDataHumanReviewReason from json.
func (o *OptIncidentResponseDataHumanReviewReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIncidentResponseDataHumanReviewReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIncidentResponseDataHumanReviewReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIncidentResponseDataHumanReviewReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDataSelectedWorkflow as json.
func (o OptIncidentResponseDataSelectedWorkflow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IncidentResponseDataSelectedWorkflow from json.
func (o *OptIncidentResponseDataSelectedWorkflow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIncidentResponseDataSelectedWorkflow to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIncidentResponseDataSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIncidentResponseDataSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDataSelectedWorkflowParameters as json.
func (o OptIncidentResponseDataSelectedWorkflowParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IncidentResponseDataSelectedWorkflowParameters from json.
func (o *OptIncidentResponseDataSelectedWorkflowParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIncidentResponseDataSelectedWorkflowParameters to nil")
	}
	o.Set = true
	o.Value = make(IncidentResponseDataSelectedWorkflowParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIncidentResponseDataSelectedWorkflowParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIncidentResponseDataSelectedWorkflowParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMToolCallPayloadToolArguments as json.
func (o OptLLMToolCallPayloadToolArguments) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMToolCallPayloadToolArguments from json.
func (o *OptLLMToolCallPayloadToolArguments) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMToolCallPayloadToolArguments to nil")
	}
	o.Set = true
	o.Value = make(LLMToolCallPayloadToolArguments)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMToolCallPayloadToolArguments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMToolCallPayloadToolArguments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDate to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistoryEntryAssessmentReason as json.
func (o OptNilRemediationHistoryEntryAssessmentReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationHistoryEntryAssessmentReason from json.
func (o *OptNilRemediationHistoryEntryAssessmentReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRemediationHistoryEntryAssessmentReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RemediationHistoryEntryAssessmentReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRemediationHistoryEntryAssessmentReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRemediationHistoryEntryAssessmentReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistorySummaryAssessmentReason as json.
func (o OptNilRemediationHistorySummaryAssessmentReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationHistorySummaryAssessmentReason from json.
func (o *OptNilRemediationHistorySummaryAssessmentReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRemediationHistorySummaryAssessmentReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RemediationHistorySummaryAssessmentReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRemediationHistorySummaryAssessmentReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRemediationHistorySummaryAssessmentReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadAction as json.
func (o OptNotificationAuditPayloadAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationAuditPayloadAction from json.
func (o *OptNotificationAuditPayloadAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationAuditPayloadAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationAuditPayloadAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationAuditPayloadAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadFinalStatus as json.
func (o OptNotificationAuditPayloadFinalStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationAuditPayloadFinalStatus from json.
func (o *OptNotificationAuditPayloadFinalStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationAuditPayloadFinalStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationAuditPayloadFinalStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationAuditPayloadFinalStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadNotificationType as json.
func (o OptNotificationAuditPayloadNotificationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationAuditPayloadNotificationType from json.
func (o *OptNotificationAuditPayloadNotificationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationAuditPayloadNotificationType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationAuditPayloadNotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationAuditPayloadNotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadPriority as json.
func (o OptNotificationAuditPayloadPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationAuditPayloadPriority from json.
func (o *OptNotificationAuditPayloadPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationAuditPayloadPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationAuditPayloadPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationAuditPayloadPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationAuditPayloadType as json.
func (o OptNotificationAuditPayloadType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationAuditPayloadType from json.
func (o *OptNotificationAuditPayloadType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationAuditPayloadType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationAuditPayloadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationAuditPayloadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationMessageAcknowledgedPayloadMetadata as json.
func (o OptNotificationMessageAcknowledgedPayloadMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NotificationMessageAcknowledgedPayloadMetadata from json.
func (o *OptNotificationMessageAcknowledgedPayloadMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationMessageAcknowledgedPayloadMetadata to nil")
	}
	o.Set = true
	o.Value = make(NotificationMessageAcknowledgedPayloadMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationMessageAcknowledgedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationMessageAcknowledgedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationMessageEscalatedPayloadMetadata as json.
func (o OptNotificationMessageEscalatedPayloadMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NotificationMessageEscalatedPayloadMetadata from json.
func (o *OptNotificationMessageEscalatedPayloadMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationMessageEscalatedPayloadMetadata to nil")
	}
	o.Set = true
	o.Value = make(NotificationMessageEscalatedPayloadMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationMessageEscalatedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationMessageEscalatedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationMessageFailedPayloadMetadata as json.
func (o OptNotificationMessageFailedPayloadMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NotificationMessageFailedPayloadMetadata from json.
func (o *OptNotificationMessageFailedPayloadMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationMessageFailedPayloadMetadata to nil")
	}
	o.Set = true
	o.Value = make(NotificationMessageFailedPayloadMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationMessageFailedPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationMessageFailedPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationMessageSentPayloadMetadata as json.
func (o OptNotificationMessageSentPayloadMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NotificationMessageSentPayloadMetadata from json.
func (o *OptNotificationMessageSentPayloadMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotificationMessageSentPayloadMetadata to nil")
	}
	o.Set = true
	o.Value = make(NotificationMessageSentPayloadMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotificationMessageSentPayloadMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotificationMessageSentPayloadMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProviderResponseSummary as json.
func (o OptProviderResponseSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProviderResponseSummary from json.
func (o *OptProviderResponseSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProviderResponseSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProviderResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProviderResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RFC7807ProblemFieldErrors as json.
func (o OptRFC7807ProblemFieldErrors) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RFC7807ProblemFieldErrors from json.
func (o *OptRFC7807ProblemFieldErrors) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRFC7807ProblemFieldErrors to nil")
	}
	o.Set = true
	o.Value = make(RFC7807ProblemFieldErrors)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRFC7807ProblemFieldErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRFC7807ProblemFieldErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHealthChecks as json.
func (o OptRemediationHealthChecks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RemediationHealthChecks from json.
func (o *OptRemediationHealthChecks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationHealthChecks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationHealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationHealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistoryEntryHashMatch as json.
func (o OptRemediationHistoryEntryHashMatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationHistoryEntryHashMatch from json.
func (o *OptRemediationHistoryEntryHashMatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationHistoryEntryHashMatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationHistoryEntryHashMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationHistoryEntryHashMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistorySummaryHashMatch as json.
func (o OptRemediationHistorySummaryHashMatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationHistorySummaryHashMatch from json.
func (o *OptRemediationHistorySummaryHashMatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationHistorySummaryHashMatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationHistorySummaryHashMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationHistorySummaryHashMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationMetricDeltas as json.
func (o OptRemediationMetricDeltas) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RemediationMetricDeltas from json.
func (o *OptRemediationMetricDeltas) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationMetricDeltas to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationMetricDeltas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationMetricDeltas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadDecision as json.
func (o OptRemediationOrchestratorAuditPayloadDecision) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationOrchestratorAuditPayloadDecision from json.
func (o *OptRemediationOrchestratorAuditPayloadDecision) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationOrchestratorAuditPayloadDecision to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationOrchestratorAuditPayloadDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationOrchestratorAuditPayloadDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadFailurePhase as json.
func (o OptRemediationOrchestratorAuditPayloadFailurePhase) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationOrchestratorAuditPayloadFailurePhase from json.
func (o *OptRemediationOrchestratorAuditPayloadFailurePhase) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationOrchestratorAuditPayloadFailurePhase to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationOrchestratorAuditPayloadFailurePhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationOrchestratorAuditPayloadFailurePhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadFailureReason as json.
func (o OptRemediationOrchestratorAuditPayloadFailureReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationOrchestratorAuditPayloadFailureReason from json.
func (o *OptRemediationOrchestratorAuditPayloadFailureReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationOrchestratorAuditPayloadFailureReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationOrchestratorAuditPayloadFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationOrchestratorAuditPayloadFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadOutcome as json.
func (o OptRemediationOrchestratorAuditPayloadOutcome) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RemediationOrchestratorAuditPayloadOutcome from json.
func (o *OptRemediationOrchestratorAuditPayloadOutcome) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationOrchestratorAuditPayloadOutcome to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationOrchestratorAuditPayloadOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationOrchestratorAuditPayloadOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationWorkflowParameters as json.
func (o OptRemediationWorkflowParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RemediationWorkflowParameters from json.
func (o *OptRemediationWorkflowParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRemediationWorkflowParameters to nil")
	}
	o.Set = true
	o.Value = make(RemediationWorkflowParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRemediationWorkflowParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRemediationWorkflowParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadCriticality as json.
func (o OptSignalProcessingAuditPayloadCriticality) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadCriticality from json.
func (o *OptSignalProcessingAuditPayloadCriticality) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadCriticality to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadCriticality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadCriticality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadDeterminationSource as json.
func (o OptSignalProcessingAuditPayloadDeterminationSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadDeterminationSource from json.
func (o *OptSignalProcessingAuditPayloadDeterminationSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadDeterminationSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadDeterminationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadDeterminationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadEnvironment as json.
func (o OptSignalProcessingAuditPayloadEnvironment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadEnvironment from json.
func (o *OptSignalProcessingAuditPayloadEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadEnvironment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadEnvironmentSource as json.
func (o OptSignalProcessingAuditPayloadEnvironmentSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadEnvironmentSource from json.
func (o *OptSignalProcessingAuditPayloadEnvironmentSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadEnvironmentSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadEnvironmentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadEnvironmentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadNormalizedSeverity as json.
func (o OptSignalProcessingAuditPayloadNormalizedSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadNormalizedSeverity from json.
func (o *OptSignalProcessingAuditPayloadNormalizedSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadNormalizedSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadNormalizedSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadNormalizedSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadPriority as json.
func (o OptSignalProcessingAuditPayloadPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadPriority from json.
func (o *OptSignalProcessingAuditPayloadPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadPrioritySource as json.
func (o OptSignalProcessingAuditPayloadPrioritySource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadPrioritySource from json.
func (o *OptSignalProcessingAuditPayloadPrioritySource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadPrioritySource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadPrioritySource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadPrioritySource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadSeverity as json.
func (o OptSignalProcessingAuditPayloadSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadSeverity from json.
func (o *OptSignalProcessingAuditPayloadSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadSeverity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadSignalMode as json.
func (o OptSignalProcessingAuditPayloadSignalMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalProcessingAuditPayloadSignalMode from json.
func (o *OptSignalProcessingAuditPayloadSignalMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignalProcessingAuditPayloadSignalMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignalProcessingAuditPayloadSignalMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignalProcessingAuditPayloadSignalMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TimeoutConfig as json.
func (o OptTimeoutConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TimeoutConfig from json.
func (o *OptTimeoutConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTimeoutConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTimeoutConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTimeoutConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowCatalogCreatedPayloadLabels as json.
func (o OptWorkflowCatalogCreatedPayloadLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowCatalogCreatedPayloadLabels from json.
func (o *OptWorkflowCatalogCreatedPayloadLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowCatalogCreatedPayloadLabels to nil")
	}
	o.Set = true
	o.Value = make(WorkflowCatalogCreatedPayloadLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowCatalogCreatedPayloadLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowCatalogCreatedPayloadLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowDiscoveryEntryExecutionEngine as json.
func (o OptWorkflowDiscoveryEntryExecutionEngine) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowDiscoveryEntryExecutionEngine from json.
func (o *OptWorkflowDiscoveryEntryExecutionEngine) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowDiscoveryEntryExecutionEngine to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowDiscoveryEntryExecutionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowDiscoveryEntryExecutionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionAuditPayloadFailureReason as json.
func (o OptWorkflowExecutionAuditPayloadFailureReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowExecutionAuditPayloadFailureReason from json.
func (o *OptWorkflowExecutionAuditPayloadFailureReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowExecutionAuditPayloadFailureReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowExecutionAuditPayloadFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowExecutionAuditPayloadFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowResultAuditLabels as json.
func (o OptWorkflowResultAuditLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowResultAuditLabels from json.
func (o *OptWorkflowResultAuditLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowResultAuditLabels to nil")
	}
	o.Set = true
	o.Value = make(WorkflowResultAuditLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowResultAuditLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowResultAuditLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowSearchFilters as json.
func (o OptWorkflowSearchFilters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowSearchFilters from json.
func (o *OptWorkflowSearchFilters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowSearchFilters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowSearchFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowSearchFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowUpdateRequestStatus as json.
func (o OptWorkflowUpdateRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowUpdateRequestStatus from json.
func (o *OptWorkflowUpdateRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowUpdateRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowUpdateRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowUpdateRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PaginationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PaginationMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalCount")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("hasMore")
		e.Bool(s.HasMore)
	}
}

var jsonFieldsNameOfPaginationMetadata = [4]string{
	0: "totalCount",
	1: "offset",
	2: "limit",
	3: "hasMore",
}

// Decode decodes PaginationMetadata from json.
func (s *PaginationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PaginationMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCount\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "hasMore":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasMore\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PaginationMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPaginationMetadata) {
					name = jsonFieldsNameOfPaginationMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PaginationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PaginationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlaceLegalHoldBadRequest as json.
func (s *PlaceLegalHoldBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes PlaceLegalHoldBadRequest from json.
func (s *PlaceLegalHoldBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaceLegalHoldBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PlaceLegalHoldBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaceLegalHoldBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaceLegalHoldBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlaceLegalHoldNotFound as json.
func (s *PlaceLegalHoldNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes PlaceLegalHoldNotFound from json.
func (s *PlaceLegalHoldNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaceLegalHoldNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PlaceLegalHoldNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaceLegalHoldNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaceLegalHoldNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlaceLegalHoldOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlaceLegalHoldOK) encodeFields(e *jx.Encoder) {
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
	{
		if s.EventsAffected.Set {
			e.FieldStart("events_affected")
			s.EventsAffected.Encode(e)
		}
	}
	{
		if s.PlacedBy.Set {
			e.FieldStart("placed_by")
			s.PlacedBy.Encode(e)
		}
	}
	{
		if s.PlacedAt.Set {
			e.FieldStart("placed_at")
			s.PlacedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlaceLegalHoldOK = [5]string{
	0: "correlation_id",
	1: "events_affected",
	2: "placed_by",
	3: "placed_at",
	4: "reason",
}

// Decode decodes PlaceLegalHoldOK from json.
func (s *PlaceLegalHoldOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaceLegalHoldOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "events_affected":
			if err := func() error {
				s.EventsAffected.Reset()
				if err := s.EventsAffected.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_affected\"")
			}
		case "placed_by":
			if err := func() error {
				s.PlacedBy.Reset()
				if err := s.PlacedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placed_by\"")
			}
		case "placed_at":
			if err := func() error {
				s.PlacedAt.Reset()
				if err := s.PlacedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"placed_at\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlaceLegalHoldOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaceLegalHoldOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaceLegalHoldOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlaceLegalHoldReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlaceLegalHoldReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("correlation_id")
		e.Str(s.CorrelationID)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
}

var jsonFieldsNameOfPlaceLegalHoldReq = [2]string{
	0: "correlation_id",
	1: "reason",
}

// Decode decodes PlaceLegalHoldReq from json.
func (s *PlaceLegalHoldReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaceLegalHoldReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "correlation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CorrelationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlaceLegalHoldReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlaceLegalHoldReq) {
					name = jsonFieldsNameOfPlaceLegalHoldReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaceLegalHoldReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaceLegalHoldReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlaceLegalHoldUnauthorized as json.
func (s *PlaceLegalHoldUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes PlaceLegalHoldUnauthorized from json.
func (s *PlaceLegalHoldUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlaceLegalHoldUnauthorized to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PlaceLegalHoldUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlaceLegalHoldUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlaceLegalHoldUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProviderResponseSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProviderResponseSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("analysis_preview")
		e.Str(s.AnalysisPreview)
	}
	{
		if s.SelectedWorkflowID.Set {
			e.FieldStart("selected_workflow_id")
			s.SelectedWorkflowID.Encode(e)
		}
	}
	{
		e.FieldStart("needs_human_review")
		e.Bool(s.NeedsHumanReview)
	}
	{
		e.FieldStart("warnings_count")
		e.Int(s.WarningsCount)
	}
}

var jsonFieldsNameOfProviderResponseSummary = [5]string{
	0: "incident_id",
	1: "analysis_preview",
	2: "selected_workflow_id",
	3: "needs_human_review",
	4: "warnings_count",
}

// Decode decodes ProviderResponseSummary from json.
func (s *ProviderResponseSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProviderResponseSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "analysis_preview":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AnalysisPreview = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_preview\"")
			}
		case "selected_workflow_id":
			if err := func() error {
				s.SelectedWorkflowID.Reset()
				if err := s.SelectedWorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_workflow_id\"")
			}
		case "needs_human_review":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.NeedsHumanReview = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_human_review\"")
			}
		case "warnings_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.WarningsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProviderResponseSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProviderResponseSummary) {
					name = jsonFieldsNameOfProviderResponseSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProviderResponseSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProviderResponseSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *QueryMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *QueryMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("top_k")
		e.Int32(s.TopK)
	}
	{
		if s.MinScore.Set {
			e.FieldStart("min_score")
			s.MinScore.Encode(e)
		}
	}
	{
		if s.Filters.Set {
			e.FieldStart("filters")
			s.Filters.Encode(e)
		}
	}
}

var jsonFieldsNameOfQueryMetadata = [3]string{
	0: "top_k",
	1: "min_score",
	2: "filters",
}

// Decode decodes QueryMetadata from json.
func (s *QueryMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "top_k":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TopK = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_k\"")
			}
		case "min_score":
			if err := func() error {
				s.MinScore.Reset()
				if err := s.MinScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min_score\"")
			}
		case "filters":
			if err := func() error {
				s.Filters.Reset()
				if err := s.Filters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode QueryMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfQueryMetadata) {
					name = jsonFieldsNameOfQueryMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *QueryMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RFC7807Problem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RFC7807Problem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		json.EncodeURI(e, s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("status")
		e.Int32(s.Status)
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
	{
		if s.FieldErrors.Set {
			e.FieldStart("field_errors")
			s.FieldErrors.Encode(e)
		}
	}
}

var jsonFieldsNameOfRFC7807Problem = [6]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
	5: "field_errors",
}

// Decode decodes RFC7807Problem from json.
func (s *RFC7807Problem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RFC7807Problem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.Type = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Status = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "field_errors":
			if err := func() error {
				s.FieldErrors.Reset()
				if err := s.FieldErrors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"field_errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RFC7807Problem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRFC7807Problem) {
					name = jsonFieldsNameOfRFC7807Problem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RFC7807Problem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RFC7807Problem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RFC7807ProblemFieldErrors) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RFC7807ProblemFieldErrors) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes RFC7807ProblemFieldErrors from json.
func (s *RFC7807ProblemFieldErrors) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RFC7807ProblemFieldErrors to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RFC7807ProblemFieldErrors")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RFC7807ProblemFieldErrors) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RFC7807ProblemFieldErrors) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconstructRemediationRequestBadRequest as json.
func (s *ReconstructRemediationRequestBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReconstructRemediationRequestBadRequest from json.
func (s *ReconstructRemediationRequestBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconstructRemediationRequestBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconstructRemediationRequestBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconstructRemediationRequestBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconstructRemediationRequestBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconstructRemediationRequestInternalServerError as json.
func (s *ReconstructRemediationRequestInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReconstructRemediationRequestInternalServerError from json.
func (s *ReconstructRemediationRequestInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconstructRemediationRequestInternalServerError to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconstructRemediationRequestInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconstructRemediationRequestInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconstructRemediationRequestInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReconstructRemediationRequestNotFound as json.
func (s *ReconstructRemediationRequestNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReconstructRemediationRequestNotFound from json.
func (s *ReconstructRemediationRequestNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconstructRemediationRequestNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReconstructRemediationRequestNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconstructRemediationRequestNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconstructRemediationRequestNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReconstructionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReconstructionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remediation_request_yaml")
		e.Str(s.RemediationRequestYaml)
	}
	{
		e.FieldStart("validation")
		s.Validation.Encode(e)
	}
	{
		if s.ReconstructedAt.Set {
			e.FieldStart("reconstructed_at")
			s.ReconstructedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
}

var jsonFieldsNameOfReconstructionResponse = [4]string{
	0: "remediation_request_yaml",
	1: "validation",
	2: "reconstructed_at",
	3: "correlation_id",
}

// Decode decodes ReconstructionResponse from json.
func (s *ReconstructionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReconstructionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remediation_request_yaml":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RemediationRequestYaml = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_request_yaml\"")
			}
		case "validation":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Validation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation\"")
			}
		case "reconstructed_at":
			if err := func() error {
				s.ReconstructedAt.Reset()
				if err := s.ReconstructedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reconstructed_at\"")
			}
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReconstructionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReconstructionResponse) {
					name = jsonFieldsNameOfReconstructionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReconstructionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReconstructionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReleaseLegalHoldBadRequest as json.
func (s *ReleaseLegalHoldBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReleaseLegalHoldBadRequest from json.
func (s *ReleaseLegalHoldBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseLegalHoldBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReleaseLegalHoldBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseLegalHoldBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseLegalHoldBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReleaseLegalHoldNotFound as json.
func (s *ReleaseLegalHoldNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReleaseLegalHoldNotFound from json.
func (s *ReleaseLegalHoldNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseLegalHoldNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReleaseLegalHoldNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseLegalHoldNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseLegalHoldNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReleaseLegalHoldOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReleaseLegalHoldOK) encodeFields(e *jx.Encoder) {
	{
		if s.CorrelationID.Set {
			e.FieldStart("correlation_id")
			s.CorrelationID.Encode(e)
		}
	}
	{
		if s.EventsReleased.Set {
			e.FieldStart("events_released")
			s.EventsReleased.Encode(e)
		}
	}
	{
		if s.ReleasedBy.Set {
			e.FieldStart("released_by")
			s.ReleasedBy.Encode(e)
		}
	}
	{
		if s.ReleasedAt.Set {
			e.FieldStart("released_at")
			s.ReleasedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfReleaseLegalHoldOK = [4]string{
	0: "correlation_id",
	1: "events_released",
	2: "released_by",
	3: "released_at",
}

// Decode decodes ReleaseLegalHoldOK from json.
func (s *ReleaseLegalHoldOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseLegalHoldOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "correlation_id":
			if err := func() error {
				s.CorrelationID.Reset()
				if err := s.CorrelationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"correlation_id\"")
			}
		case "events_released":
			if err := func() error {
				s.EventsReleased.Reset()
				if err := s.EventsReleased.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events_released\"")
			}
		case "released_by":
			if err := func() error {
				s.ReleasedBy.Reset()
				if err := s.ReleasedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"released_by\"")
			}
		case "released_at":
			if err := func() error {
				s.ReleasedAt.Reset()
				if err := s.ReleasedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"released_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReleaseLegalHoldOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseLegalHoldOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseLegalHoldOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReleaseLegalHoldReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReleaseLegalHoldReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("release_reason")
		e.Str(s.ReleaseReason)
	}
}

var jsonFieldsNameOfReleaseLegalHoldReq = [1]string{
	0: "release_reason",
}

// Decode decodes ReleaseLegalHoldReq from json.
func (s *ReleaseLegalHoldReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseLegalHoldReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "release_reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ReleaseReason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"release_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReleaseLegalHoldReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReleaseLegalHoldReq) {
					name = jsonFieldsNameOfReleaseLegalHoldReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseLegalHoldReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseLegalHoldReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReleaseLegalHoldUnauthorized as json.
func (s *ReleaseLegalHoldUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes ReleaseLegalHoldUnauthorized from json.
func (s *ReleaseLegalHoldUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReleaseLegalHoldUnauthorized to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ReleaseLegalHoldUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReleaseLegalHoldUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReleaseLegalHoldUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationApprovalAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationApprovalAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("request_name")
		e.Str(s.RequestName)
	}
	{
		e.FieldStart("decision")
		s.Decision.Encode(e)
	}
	{
		e.FieldStart("decided_at")
		json.EncodeDateTime(e, s.DecidedAt)
	}
	{
		e.FieldStart("decision_message")
		e.Str(s.DecisionMessage)
	}
	{
		e.FieldStart("ai_analysis_ref")
		e.Str(s.AiAnalysisRef)
	}
}

var jsonFieldsNameOfRemediationApprovalAuditPayload = [6]string{
	0: "event_type",
	1: "request_name",
	2: "decision",
	3: "decided_at",
	4: "decision_message",
	5: "ai_analysis_ref",
}

// Decode decodes RemediationApprovalAuditPayload from json.
func (s *RemediationApprovalAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalAuditPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "request_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RequestName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_name\"")
			}
		case "decision":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Decision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision\"")
			}
		case "decided_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DecidedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decided_at\"")
			}
		case "decision_message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DecisionMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision_message\"")
			}
		case "ai_analysis_ref":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.AiAnalysisRef = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai_analysis_ref\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationApprovalAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationApprovalAuditPayload) {
					name = jsonFieldsNameOfRemediationApprovalAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationApprovalAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationApprovalAuditPayloadDecision as json.
func (s RemediationApprovalAuditPayloadDecision) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationApprovalAuditPayloadDecision from json.
func (s *RemediationApprovalAuditPayloadDecision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalAuditPayloadDecision to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationApprovalAuditPayloadDecision(v) {
	case RemediationApprovalAuditPayloadDecisionApproved:
		*s = RemediationApprovalAuditPayloadDecisionApproved
	case RemediationApprovalAuditPayloadDecisionRejected:
		*s = RemediationApprovalAuditPayloadDecisionRejected
	default:
		*s = RemediationApprovalAuditPayloadDecision(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationApprovalAuditPayloadDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalAuditPayloadDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationApprovalAuditPayloadEventType as json.
func (s RemediationApprovalAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationApprovalAuditPayloadEventType from json.
func (s *RemediationApprovalAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationApprovalAuditPayloadEventType(v) {
	case RemediationApprovalAuditPayloadEventTypeWebhookRemediationapprovalrequestDecided:
		*s = RemediationApprovalAuditPayloadEventTypeWebhookRemediationapprovalrequestDecided
	default:
		*s = RemediationApprovalAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationApprovalAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationApprovalDecisionPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationApprovalDecisionPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("remediation_request_name")
		e.Str(s.RemediationRequestName)
	}
	{
		e.FieldStart("ai_analysis_name")
		e.Str(s.AiAnalysisName)
	}
	{
		e.FieldStart("decision")
		s.Decision.Encode(e)
	}
	{
		e.FieldStart("decided_by")
		e.Str(s.DecidedBy)
	}
	{
		if s.DecidedAt.Set {
			e.FieldStart("decided_at")
			s.DecidedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DecisionMessage.Set {
			e.FieldStart("decision_message")
			s.DecisionMessage.Encode(e)
		}
	}
	{
		e.FieldStart("confidence")
		e.Float32(s.Confidence)
	}
	{
		e.FieldStart("workflow_id")
		e.Str(s.WorkflowID)
	}
	{
		if s.WorkflowVersion.Set {
			e.FieldStart("workflow_version")
			s.WorkflowVersion.Encode(e)
		}
	}
	{
		if s.TargetResource.Set {
			e.FieldStart("target_resource")
			s.TargetResource.Encode(e)
		}
	}
	{
		if s.TimeoutDeadline.Set {
			e.FieldStart("timeout_deadline")
			s.TimeoutDeadline.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DecisionDurationSeconds.Set {
			e.FieldStart("decision_duration_seconds")
			s.DecisionDurationSeconds.Encode(e)
		}
	}
	{
		if s.ApprovalReason.Set {
			e.FieldStart("approval_reason")
			s.ApprovalReason.Encode(e)
		}
	}
	{
		if s.TimeoutReason.Set {
			e.FieldStart("timeout_reason")
			s.TimeoutReason.Encode(e)
		}
	}
	{
		if s.TimeoutDurationSeconds.Set {
			e.FieldStart("timeout_duration_seconds")
			s.TimeoutDurationSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationApprovalDecisionPayload = [16]string{
	0:  "event_type",
	1:  "remediation_request_name",
	2:  "ai_analysis_name",
	3:  "decision",
	4:  "decided_by",
	5:  "decided_at",
	6:  "decision_message",
	7:  "confidence",
	8:  "workflow_id",
	9:  "workflow_version",
	10: "target_resource",
	11: "timeout_deadline",
	12: "decision_duration_seconds",
	13: "approval_reason",
	14: "timeout_reason",
	15: "timeout_duration_seconds",
}

// Decode decodes RemediationApprovalDecisionPayload from json.
func (s *RemediationApprovalDecisionPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalDecisionPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "remediation_request_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RemediationRequestName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_request_name\"")
			}
		case "ai_analysis_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AiAnalysisName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ai_analysis_name\"")
			}
		case "decision":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Decision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision\"")
			}
		case "decided_by":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DecidedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decided_by\"")
			}
		case "decided_at":
			if err := func() error {
				s.DecidedAt.Reset()
				if err := s.DecidedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decided_at\"")
			}
		case "decision_message":
			if err := func() error {
				s.DecisionMessage.Reset()
				if err := s.DecisionMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision_message\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float32()
				s.Confidence = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "workflow_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WorkflowID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "workflow_version":
			if err := func() error {
				s.WorkflowVersion.Reset()
				if err := s.WorkflowVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_version\"")
			}
		case "target_resource":
			if err := func() error {
				s.TargetResource.Reset()
				if err := s.TargetResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_resource\"")
			}
		case "timeout_deadline":
			if err := func() error {
				s.TimeoutDeadline.Reset()
				if err := s.TimeoutDeadline.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_deadline\"")
			}
		case "decision_duration_seconds":
			if err := func() error {
				s.DecisionDurationSeconds.Reset()
				if err := s.DecisionDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision_duration_seconds\"")
			}
		case "approval_reason":
			if err := func() error {
				s.ApprovalReason.Reset()
				if err := s.ApprovalReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_reason\"")
			}
		case "timeout_reason":
			if err := func() error {
				s.TimeoutReason.Reset()
				if err := s.TimeoutReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_reason\"")
			}
		case "timeout_duration_seconds":
			if err := func() error {
				s.TimeoutDurationSeconds.Reset()
				if err := s.TimeoutDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_duration_seconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationApprovalDecisionPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10011111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationApprovalDecisionPayload) {
					name = jsonFieldsNameOfRemediationApprovalDecisionPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationApprovalDecisionPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalDecisionPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationApprovalDecisionPayloadDecision as json.
func (s RemediationApprovalDecisionPayloadDecision) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationApprovalDecisionPayloadDecision from json.
func (s *RemediationApprovalDecisionPayloadDecision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalDecisionPayloadDecision to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationApprovalDecisionPayloadDecision(v) {
	case RemediationApprovalDecisionPayloadDecisionApproved:
		*s = RemediationApprovalDecisionPayloadDecisionApproved
	case RemediationApprovalDecisionPayloadDecisionRejected:
		*s = RemediationApprovalDecisionPayloadDecisionRejected
	case RemediationApprovalDecisionPayloadDecisionExpired:
		*s = RemediationApprovalDecisionPayloadDecisionExpired
	default:
		*s = RemediationApprovalDecisionPayloadDecision(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationApprovalDecisionPayloadDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalDecisionPayloadDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationApprovalDecisionPayloadEventType as json.
func (s RemediationApprovalDecisionPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationApprovalDecisionPayloadEventType from json.
func (s *RemediationApprovalDecisionPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationApprovalDecisionPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationApprovalDecisionPayloadEventType(v) {
	case RemediationApprovalDecisionPayloadEventTypeApprovalDecision:
		*s = RemediationApprovalDecisionPayloadEventTypeApprovalDecision
	case RemediationApprovalDecisionPayloadEventTypeApprovalRequestCreated:
		*s = RemediationApprovalDecisionPayloadEventTypeApprovalRequestCreated
	case RemediationApprovalDecisionPayloadEventTypeApprovalTimeout:
		*s = RemediationApprovalDecisionPayloadEventTypeApprovalTimeout
	default:
		*s = RemediationApprovalDecisionPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationApprovalDecisionPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationApprovalDecisionPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHealthChecks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHealthChecks) encodeFields(e *jx.Encoder) {
	{
		if s.PodRunning.Set {
			e.FieldStart("podRunning")
			s.PodRunning.Encode(e)
		}
	}
	{
		if s.ReadinessPass.Set {
			e.FieldStart("readinessPass")
			s.ReadinessPass.Encode(e)
		}
	}
	{
		if s.RestartDelta.Set {
			e.FieldStart("restartDelta")
			s.RestartDelta.Encode(e)
		}
	}
	{
		if s.CrashLoops.Set {
			e.FieldStart("crashLoops")
			s.CrashLoops.Encode(e)
		}
	}
	{
		if s.OomKilled.Set {
			e.FieldStart("oomKilled")
			s.OomKilled.Encode(e)
		}
	}
	{
		if s.PendingCount.Set {
			e.FieldStart("pendingCount")
			s.PendingCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationHealthChecks = [6]string{
	0: "podRunning",
	1: "readinessPass",
	2: "restartDelta",
	3: "crashLoops",
	4: "oomKilled",
	5: "pendingCount",
}

// Decode decodes RemediationHealthChecks from json.
func (s *RemediationHealthChecks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHealthChecks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "podRunning":
			if err := func() error {
				s.PodRunning.Reset()
				if err := s.PodRunning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podRunning\"")
			}
		case "readinessPass":
			if err := func() error {
				s.ReadinessPass.Reset()
				if err := s.ReadinessPass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readinessPass\"")
			}
		case "restartDelta":
			if err := func() error {
				s.RestartDelta.Reset()
				if err := s.RestartDelta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restartDelta\"")
			}
		case "crashLoops":
			if err := func() error {
				s.CrashLoops.Reset()
				if err := s.CrashLoops.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crashLoops\"")
			}
		case "oomKilled":
			if err := func() error {
				s.OomKilled.Reset()
				if err := s.OomKilled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oomKilled\"")
			}
		case "pendingCount":
			if err := func() error {
				s.PendingCount.Reset()
				if err := s.PendingCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pendingCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHealthChecks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHealthChecks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHealthChecks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHistoryContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHistoryContext) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("targetResource")
		e.Str(s.TargetResource)
	}
	{
		e.FieldStart("currentSpecHash")
		e.Str(s.CurrentSpecHash)
	}
	{
		e.FieldStart("regressionDetected")
		e.Bool(s.RegressionDetected)
	}
	{
		e.FieldStart("tier1")
		s.Tier1.Encode(e)
	}
	{
		e.FieldStart("tier2")
		s.Tier2.Encode(e)
	}
}

var jsonFieldsNameOfRemediationHistoryContext = [5]string{
	0: "targetResource",
	1: "currentSpecHash",
	2: "regressionDetected",
	3: "tier1",
	4: "tier2",
}

// Decode decodes RemediationHistoryContext from json.
func (s *RemediationHistoryContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryContext to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "targetResource":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TargetResource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"targetResource\"")
			}
		case "currentSpecHash":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CurrentSpecHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentSpecHash\"")
			}
		case "regressionDetected":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.RegressionDetected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regressionDetected\"")
			}
		case "tier1":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Tier1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier1\"")
			}
		case "tier2":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Tier2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier2\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHistoryContext")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationHistoryContext) {
					name = jsonFieldsNameOfRemediationHistoryContext[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHistoryContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHistoryEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHistoryEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remediationUID")
		e.Str(s.RemediationUID)
	}
	{
		if s.SignalFingerprint.Set {
			e.FieldStart("signalFingerprint")
			s.SignalFingerprint.Encode(e)
		}
	}
	{
		if s.SignalType.Set {
			e.FieldStart("signalType")
			s.SignalType.Encode(e)
		}
	}
	{
		if s.WorkflowType.Set {
			e.FieldStart("workflowType")
			s.WorkflowType.Encode(e)
		}
	}
	{
		if s.Outcome.Set {
			e.FieldStart("outcome")
			s.Outcome.Encode(e)
		}
	}
	{
		if s.EffectivenessScore.Set {
			e.FieldStart("effectivenessScore")
			s.EffectivenessScore.Encode(e)
		}
	}
	{
		if s.SignalResolved.Set {
			e.FieldStart("signalResolved")
			s.SignalResolved.Encode(e)
		}
	}
	{
		if s.HashMatch.Set {
			e.FieldStart("hashMatch")
			s.HashMatch.Encode(e)
		}
	}
	{
		if s.PreRemediationSpecHash.Set {
			e.FieldStart("preRemediationSpecHash")
			s.PreRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.PostRemediationSpecHash.Set {
			e.FieldStart("postRemediationSpecHash")
			s.PostRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.HealthChecks.Set {
			e.FieldStart("healthChecks")
			s.HealthChecks.Encode(e)
		}
	}
	{
		if s.MetricDeltas.Set {
			e.FieldStart("metricDeltas")
			s.MetricDeltas.Encode(e)
		}
	}
	{
		if s.SideEffects != nil {
			e.FieldStart("sideEffects")
			e.ArrStart()
			for _, elem := range s.SideEffects {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("completedAt")
		json.EncodeDateTime(e, s.CompletedAt)
	}
	{
		if s.AssessmentReason.Set {
			e.FieldStart("assessmentReason")
			s.AssessmentReason.Encode(e)
		}
	}
	{
		if s.AssessedAt.Set {
			e.FieldStart("assessedAt")
			s.AssessedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRemediationHistoryEntry = [16]string{
	0:  "remediationUID",
	1:  "signalFingerprint",
	2:  "signalType",
	3:  "workflowType",
	4:  "outcome",
	5:  "effectivenessScore",
	6:  "signalResolved",
	7:  "hashMatch",
	8:  "preRemediationSpecHash",
	9:  "postRemediationSpecHash",
	10: "healthChecks",
	11: "metricDeltas",
	12: "sideEffects",
	13: "completedAt",
	14: "assessmentReason",
	15: "assessedAt",
}

// Decode decodes RemediationHistoryEntry from json.
func (s *RemediationHistoryEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryEntry to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remediationUID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RemediationUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationUID\"")
			}
		case "signalFingerprint":
			if err := func() error {
				s.SignalFingerprint.Reset()
				if err := s.SignalFingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signalFingerprint\"")
			}
		case "signalType":
			if err := func() error {
				s.SignalType.Reset()
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signalType\"")
			}
		case "workflowType":
			if err := func() error {
				s.WorkflowType.Reset()
				if err := s.WorkflowType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowType\"")
			}
		case "outcome":
			if err := func() error {
				s.Outcome.Reset()
				if err := s.Outcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outcome\"")
			}
		case "effectivenessScore":
			if err := func() error {
				s.EffectivenessScore.Reset()
				if err := s.EffectivenessScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effectivenessScore\"")
			}
		case "signalResolved":
			if err := func() error {
				s.SignalResolved.Reset()
				if err := s.SignalResolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signalResolved\"")
			}
		case "hashMatch":
			if err := func() error {
				s.HashMatch.Reset()
				if err := s.HashMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashMatch\"")
			}
		case "preRemediationSpecHash":
			if err := func() error {
				s.PreRemediationSpecHash.Reset()
				if err := s.PreRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preRemediationSpecHash\"")
			}
		case "postRemediationSpecHash":
			if err := func() error {
				s.PostRemediationSpecHash.Reset()
				if err := s.PostRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"postRemediationSpecHash\"")
			}
		case "healthChecks":
			if err := func() error {
				s.HealthChecks.Reset()
				if err := s.HealthChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthChecks\"")
			}
		case "metricDeltas":
			if err := func() error {
				s.MetricDeltas.Reset()
				if err := s.MetricDeltas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metricDeltas\"")
			}
		case "sideEffects":
			if err := func() error {
				s.SideEffects = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SideEffects = append(s.SideEffects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sideEffects\"")
			}
		case "completedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CompletedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "assessmentReason":
			if err := func() error {
				s.AssessmentReason.Reset()
				if err := s.AssessmentReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessmentReason\"")
			}
		case "assessedAt":
			if err := func() error {
				s.AssessedAt.Reset()
				if err := s.AssessedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHistoryEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationHistoryEntry) {
					name = jsonFieldsNameOfRemediationHistoryEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHistoryEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistoryEntryAssessmentReason as json.
func (s RemediationHistoryEntryAssessmentReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationHistoryEntryAssessmentReason from json.
func (s *RemediationHistoryEntryAssessmentReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryEntryAssessmentReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationHistoryEntryAssessmentReason(v) {
	case RemediationHistoryEntryAssessmentReasonFull:
		*s = RemediationHistoryEntryAssessmentReasonFull
	case RemediationHistoryEntryAssessmentReasonPartial:
		*s = RemediationHistoryEntryAssessmentReasonPartial
	case RemediationHistoryEntryAssessmentReasonSpecDrift:
		*s = RemediationHistoryEntryAssessmentReasonSpecDrift
	case RemediationHistoryEntryAssessmentReasonExpired:
		*s = RemediationHistoryEntryAssessmentReasonExpired
	case RemediationHistoryEntryAssessmentReasonNoExecution:
		*s = RemediationHistoryEntryAssessmentReasonNoExecution
	case RemediationHistoryEntryAssessmentReasonMetricsTimedOut:
		*s = RemediationHistoryEntryAssessmentReasonMetricsTimedOut
	default:
		*s = RemediationHistoryEntryAssessmentReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationHistoryEntryAssessmentReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryEntryAssessmentReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistoryEntryHashMatch as json.
func (s RemediationHistoryEntryHashMatch) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationHistoryEntryHashMatch from json.
func (s *RemediationHistoryEntryHashMatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryEntryHashMatch to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationHistoryEntryHashMatch(v) {
	case RemediationHistoryEntryHashMatchPreRemediation:
		*s = RemediationHistoryEntryHashMatchPreRemediation
	case RemediationHistoryEntryHashMatchPostRemediation:
		*s = RemediationHistoryEntryHashMatchPostRemediation
	case RemediationHistoryEntryHashMatchNone:
		*s = RemediationHistoryEntryHashMatchNone
	default:
		*s = RemediationHistoryEntryHashMatch(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationHistoryEntryHashMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryEntryHashMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHistorySummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHistorySummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("remediationUID")
		e.Str(s.RemediationUID)
	}
	{
		if s.SignalType.Set {
			e.FieldStart("signalType")
			s.SignalType.Encode(e)
		}
	}
	{
		if s.WorkflowType.Set {
			e.FieldStart("workflowType")
			s.WorkflowType.Encode(e)
		}
	}
	{
		if s.Outcome.Set {
			e.FieldStart("outcome")
			s.Outcome.Encode(e)
		}
	}
	{
		if s.EffectivenessScore.Set {
			e.FieldStart("effectivenessScore")
			s.EffectivenessScore.Encode(e)
		}
	}
	{
		if s.SignalResolved.Set {
			e.FieldStart("signalResolved")
			s.SignalResolved.Encode(e)
		}
	}
	{
		if s.HashMatch.Set {
			e.FieldStart("hashMatch")
			s.HashMatch.Encode(e)
		}
	}
	{
		if s.AssessmentReason.Set {
			e.FieldStart("assessmentReason")
			s.AssessmentReason.Encode(e)
		}
	}
	{
		e.FieldStart("completedAt")
		json.EncodeDateTime(e, s.CompletedAt)
	}
}

var jsonFieldsNameOfRemediationHistorySummary = [9]string{
	0: "remediationUID",
	1: "signalType",
	2: "workflowType",
	3: "outcome",
	4: "effectivenessScore",
	5: "signalResolved",
	6: "hashMatch",
	7: "assessmentReason",
	8: "completedAt",
}

// Decode decodes RemediationHistorySummary from json.
func (s *RemediationHistorySummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistorySummary to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "remediationUID":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RemediationUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediationUID\"")
			}
		case "signalType":
			if err := func() error {
				s.SignalType.Reset()
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signalType\"")
			}
		case "workflowType":
			if err := func() error {
				s.WorkflowType.Reset()
				if err := s.WorkflowType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowType\"")
			}
		case "outcome":
			if err := func() error {
				s.Outcome.Reset()
				if err := s.Outcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outcome\"")
			}
		case "effectivenessScore":
			if err := func() error {
				s.EffectivenessScore.Reset()
				if err := s.EffectivenessScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effectivenessScore\"")
			}
		case "signalResolved":
			if err := func() error {
				s.SignalResolved.Reset()
				if err := s.SignalResolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signalResolved\"")
			}
		case "hashMatch":
			if err := func() error {
				s.HashMatch.Reset()
				if err := s.HashMatch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashMatch\"")
			}
		case "assessmentReason":
			if err := func() error {
				s.AssessmentReason.Reset()
				if err := s.AssessmentReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assessmentReason\"")
			}
		case "completedAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CompletedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHistorySummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationHistorySummary) {
					name = jsonFieldsNameOfRemediationHistorySummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHistorySummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistorySummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistorySummaryAssessmentReason as json.
func (s RemediationHistorySummaryAssessmentReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationHistorySummaryAssessmentReason from json.
func (s *RemediationHistorySummaryAssessmentReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistorySummaryAssessmentReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationHistorySummaryAssessmentReason(v) {
	case RemediationHistorySummaryAssessmentReasonFull:
		*s = RemediationHistorySummaryAssessmentReasonFull
	case RemediationHistorySummaryAssessmentReasonPartial:
		*s = RemediationHistorySummaryAssessmentReasonPartial
	case RemediationHistorySummaryAssessmentReasonSpecDrift:
		*s = RemediationHistorySummaryAssessmentReasonSpecDrift
	case RemediationHistorySummaryAssessmentReasonExpired:
		*s = RemediationHistorySummaryAssessmentReasonExpired
	case RemediationHistorySummaryAssessmentReasonNoExecution:
		*s = RemediationHistorySummaryAssessmentReasonNoExecution
	case RemediationHistorySummaryAssessmentReasonMetricsTimedOut:
		*s = RemediationHistorySummaryAssessmentReasonMetricsTimedOut
	default:
		*s = RemediationHistorySummaryAssessmentReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationHistorySummaryAssessmentReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistorySummaryAssessmentReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationHistorySummaryHashMatch as json.
func (s RemediationHistorySummaryHashMatch) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationHistorySummaryHashMatch from json.
func (s *RemediationHistorySummaryHashMatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistorySummaryHashMatch to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationHistorySummaryHashMatch(v) {
	case RemediationHistorySummaryHashMatchPreRemediation:
		*s = RemediationHistorySummaryHashMatchPreRemediation
	case RemediationHistorySummaryHashMatchPostRemediation:
		*s = RemediationHistorySummaryHashMatchPostRemediation
	case RemediationHistorySummaryHashMatchNone:
		*s = RemediationHistorySummaryHashMatchNone
	default:
		*s = RemediationHistorySummaryHashMatch(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationHistorySummaryHashMatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistorySummaryHashMatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHistoryTier1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHistoryTier1) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("window")
		e.Str(s.Window)
	}
	{
		e.FieldStart("chain")
		e.ArrStart()
		for _, elem := range s.Chain {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRemediationHistoryTier1 = [2]string{
	0: "window",
	1: "chain",
}

// Decode decodes RemediationHistoryTier1 from json.
func (s *RemediationHistoryTier1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryTier1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "window":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Window = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"window\"")
			}
		case "chain":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Chain = make([]RemediationHistoryEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemediationHistoryEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chain = append(s.Chain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHistoryTier1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationHistoryTier1) {
					name = jsonFieldsNameOfRemediationHistoryTier1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHistoryTier1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryTier1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationHistoryTier2) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationHistoryTier2) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("window")
		e.Str(s.Window)
	}
	{
		e.FieldStart("chain")
		e.ArrStart()
		for _, elem := range s.Chain {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRemediationHistoryTier2 = [2]string{
	0: "window",
	1: "chain",
}

// Decode decodes RemediationHistoryTier2 from json.
func (s *RemediationHistoryTier2) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationHistoryTier2 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "window":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Window = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"window\"")
			}
		case "chain":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Chain = make([]RemediationHistorySummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemediationHistorySummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chain = append(s.Chain, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationHistoryTier2")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationHistoryTier2) {
					name = jsonFieldsNameOfRemediationHistoryTier2[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationHistoryTier2) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationHistoryTier2) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationMetricDeltas) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationMetricDeltas) encodeFields(e *jx.Encoder) {
	{
		if s.CpuBefore.Set {
			e.FieldStart("cpuBefore")
			s.CpuBefore.Encode(e)
		}
	}
	{
		if s.CpuAfter.Set {
			e.FieldStart("cpuAfter")
			s.CpuAfter.Encode(e)
		}
	}
	{
		if s.MemoryBefore.Set {
			e.FieldStart("memoryBefore")
			s.MemoryBefore.Encode(e)
		}
	}
	{
		if s.MemoryAfter.Set {
			e.FieldStart("memoryAfter")
			s.MemoryAfter.Encode(e)
		}
	}
	{
		if s.LatencyP95BeforeMs.Set {
			e.FieldStart("latencyP95BeforeMs")
			s.LatencyP95BeforeMs.Encode(e)
		}
	}
	{
		if s.LatencyP95AfterMs.Set {
			e.FieldStart("latencyP95AfterMs")
			s.LatencyP95AfterMs.Encode(e)
		}
	}
	{
		if s.ErrorRateBefore.Set {
			e.FieldStart("errorRateBefore")
			s.ErrorRateBefore.Encode(e)
		}
	}
	{
		if s.ErrorRateAfter.Set {
			e.FieldStart("errorRateAfter")
			s.ErrorRateAfter.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationMetricDeltas = [8]string{
	0: "cpuBefore",
	1: "cpuAfter",
	2: "memoryBefore",
	3: "memoryAfter",
	4: "latencyP95BeforeMs",
	5: "latencyP95AfterMs",
	6: "errorRateBefore",
	7: "errorRateAfter",
}

// Decode decodes RemediationMetricDeltas from json.
func (s *RemediationMetricDeltas) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationMetricDeltas to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpuBefore":
			if err := func() error {
				s.CpuBefore.Reset()
				if err := s.CpuBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuBefore\"")
			}
		case "cpuAfter":
			if err := func() error {
				s.CpuAfter.Reset()
				if err := s.CpuAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuAfter\"")
			}
		case "memoryBefore":
			if err := func() error {
				s.MemoryBefore.Reset()
				if err := s.MemoryBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryBefore\"")
			}
		case "memoryAfter":
			if err := func() error {
				s.MemoryAfter.Reset()
				if err := s.MemoryAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryAfter\"")
			}
		case "latencyP95BeforeMs":
			if err := func() error {
				s.LatencyP95BeforeMs.Reset()
				if err := s.LatencyP95BeforeMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latencyP95BeforeMs\"")
			}
		case "latencyP95AfterMs":
			if err := func() error {
				s.LatencyP95AfterMs.Reset()
				if err := s.LatencyP95AfterMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latencyP95AfterMs\"")
			}
		case "errorRateBefore":
			if err := func() error {
				s.ErrorRateBefore.Reset()
				if err := s.ErrorRateBefore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorRateBefore\"")
			}
		case "errorRateAfter":
			if err := func() error {
				s.ErrorRateAfter.Reset()
				if err := s.ErrorRateAfter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorRateAfter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationMetricDeltas")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationMetricDeltas) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationMetricDeltas) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationOrchestratorAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationOrchestratorAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("rr_name")
		e.Str(s.RrName)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		if s.Outcome.Set {
			e.FieldStart("outcome")
			s.Outcome.Encode(e)
		}
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		if s.FailurePhase.Set {
			e.FieldStart("failure_phase")
			s.FailurePhase.Encode(e)
		}
	}
	{
		if s.FailureReason.Set {
			e.FieldStart("failure_reason")
			s.FailureReason.Encode(e)
		}
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
	{
		if s.FromPhase.Set {
			e.FieldStart("from_phase")
			s.FromPhase.Encode(e)
		}
	}
	{
		if s.ToPhase.Set {
			e.FieldStart("to_phase")
			s.ToPhase.Encode(e)
		}
	}
	{
		if s.TransitionReason.Set {
			e.FieldStart("transition_reason")
			s.TransitionReason.Encode(e)
		}
	}
	{
		if s.RarName.Set {
			e.FieldStart("rar_name")
			s.RarName.Encode(e)
		}
	}
	{
		if s.RequiredBy.Set {
			e.FieldStart("required_by")
			s.RequiredBy.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		if s.ConfidenceStr.Set {
			e.FieldStart("confidence_str")
			s.ConfidenceStr.Encode(e)
		}
	}
	{
		if s.Decision.Set {
			e.FieldStart("decision")
			s.Decision.Encode(e)
		}
	}
	{
		if s.ApprovedBy.Set {
			e.FieldStart("approved_by")
			s.ApprovedBy.Encode(e)
		}
	}
	{
		if s.RejectedBy.Set {
			e.FieldStart("rejected_by")
			s.RejectedBy.Encode(e)
		}
	}
	{
		if s.RejectionReason.Set {
			e.FieldStart("rejection_reason")
			s.RejectionReason.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.SubReason.Set {
			e.FieldStart("sub_reason")
			s.SubReason.Encode(e)
		}
	}
	{
		if s.NotificationName.Set {
			e.FieldStart("notification_name")
			s.NotificationName.Encode(e)
		}
	}
	{
		if s.TimeoutConfig.Set {
			e.FieldStart("timeout_config")
			s.TimeoutConfig.Encode(e)
		}
	}
	{
		if s.PreRemediationSpecHash.Set {
			e.FieldStart("pre_remediation_spec_hash")
			s.PreRemediationSpecHash.Encode(e)
		}
	}
	{
		if s.TargetResource.Set {
			e.FieldStart("target_resource")
			s.TargetResource.Encode(e)
		}
	}
	{
		if s.WorkflowVersion.Set {
			e.FieldStart("workflow_version")
			s.WorkflowVersion.Encode(e)
		}
	}
	{
		if s.WorkflowType.Set {
			e.FieldStart("workflow_type")
			s.WorkflowType.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationOrchestratorAuditPayload = [28]string{
	0:  "event_type",
	1:  "rr_name",
	2:  "namespace",
	3:  "outcome",
	4:  "duration_ms",
	5:  "failure_phase",
	6:  "failure_reason",
	7:  "error_details",
	8:  "from_phase",
	9:  "to_phase",
	10: "transition_reason",
	11: "rar_name",
	12: "required_by",
	13: "workflow_id",
	14: "confidence_str",
	15: "decision",
	16: "approved_by",
	17: "rejected_by",
	18: "rejection_reason",
	19: "message",
	20: "reason",
	21: "sub_reason",
	22: "notification_name",
	23: "timeout_config",
	24: "pre_remediation_spec_hash",
	25: "target_resource",
	26: "workflow_version",
	27: "workflow_type",
}

// Decode decodes RemediationOrchestratorAuditPayload from json.
func (s *RemediationOrchestratorAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayload to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "rr_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RrName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rr_name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "outcome":
			if err := func() error {
				s.Outcome.Reset()
				if err := s.Outcome.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outcome\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "failure_phase":
			if err := func() error {
				s.FailurePhase.Reset()
				if err := s.FailurePhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_phase\"")
			}
		case "failure_reason":
			if err := func() error {
				s.FailureReason.Reset()
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_reason\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		case "from_phase":
			if err := func() error {
				s.FromPhase.Reset()
				if err := s.FromPhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_phase\"")
			}
		case "to_phase":
			if err := func() error {
				s.ToPhase.Reset()
				if err := s.ToPhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_phase\"")
			}
		case "transition_reason":
			if err := func() error {
				s.TransitionReason.Reset()
				if err := s.TransitionReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transition_reason\"")
			}
		case "rar_name":
			if err := func() error {
				s.RarName.Reset()
				if err := s.RarName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rar_name\"")
			}
		case "required_by":
			if err := func() error {
				s.RequiredBy.Reset()
				if err := s.RequiredBy.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required_by\"")
			}
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "confidence_str":
			if err := func() error {
				s.ConfidenceStr.Reset()
				if err := s.ConfidenceStr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence_str\"")
			}
		case "decision":
			if err := func() error {
				s.Decision.Reset()
				if err := s.Decision.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"decision\"")
			}
		case "approved_by":
			if err := func() error {
				s.ApprovedBy.Reset()
				if err := s.ApprovedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approved_by\"")
			}
		case "rejected_by":
			if err := func() error {
				s.RejectedBy.Reset()
				if err := s.RejectedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejected_by\"")
			}
		case "rejection_reason":
			if err := func() error {
				s.RejectionReason.Reset()
				if err := s.RejectionReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rejection_reason\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "sub_reason":
			if err := func() error {
				s.SubReason.Reset()
				if err := s.SubReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sub_reason\"")
			}
		case "notification_name":
			if err := func() error {
				s.NotificationName.Reset()
				if err := s.NotificationName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_name\"")
			}
		case "timeout_config":
			if err := func() error {
				s.TimeoutConfig.Reset()
				if err := s.TimeoutConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout_config\"")
			}
		case "pre_remediation_spec_hash":
			if err := func() error {
				s.PreRemediationSpecHash.Reset()
				if err := s.PreRemediationSpecHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_remediation_spec_hash\"")
			}
		case "target_resource":
			if err := func() error {
				s.TargetResource.Reset()
				if err := s.TargetResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_resource\"")
			}
		case "workflow_version":
			if err := func() error {
				s.WorkflowVersion.Reset()
				if err := s.WorkflowVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_version\"")
			}
		case "workflow_type":
			if err := func() error {
				s.WorkflowType.Reset()
				if err := s.WorkflowType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationOrchestratorAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationOrchestratorAuditPayload) {
					name = jsonFieldsNameOfRemediationOrchestratorAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationOrchestratorAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadDecision as json.
func (s RemediationOrchestratorAuditPayloadDecision) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationOrchestratorAuditPayloadDecision from json.
func (s *RemediationOrchestratorAuditPayloadDecision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayloadDecision to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationOrchestratorAuditPayloadDecision(v) {
	case RemediationOrchestratorAuditPayloadDecisionApproved:
		*s = RemediationOrchestratorAuditPayloadDecisionApproved
	case RemediationOrchestratorAuditPayloadDecisionRejected:
		*s = RemediationOrchestratorAuditPayloadDecisionRejected
	case RemediationOrchestratorAuditPayloadDecisionPending:
		*s = RemediationOrchestratorAuditPayloadDecisionPending
	default:
		*s = RemediationOrchestratorAuditPayloadDecision(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationOrchestratorAuditPayloadDecision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayloadDecision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadEventType as json.
func (s RemediationOrchestratorAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationOrchestratorAuditPayloadEventType from json.
func (s *RemediationOrchestratorAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationOrchestratorAuditPayloadEventType(v) {
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleStarted:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleStarted
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleCreated:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleCreated
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleCompleted:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleCompleted
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleFailed:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleFailed
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleTransitioned:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorLifecycleTransitioned
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalRequested:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalRequested
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalApproved:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalApproved
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalRejected:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorApprovalRejected
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorRemediationManualReview:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorRemediationManualReview
	case RemediationOrchestratorAuditPayloadEventTypeOrchestratorRoutingBlocked:
		*s = RemediationOrchestratorAuditPayloadEventTypeOrchestratorRoutingBlocked
	case RemediationOrchestratorAuditPayloadEventTypeRemediationWorkflowCreated:
		*s = RemediationOrchestratorAuditPayloadEventTypeRemediationWorkflowCreated
	default:
		*s = RemediationOrchestratorAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationOrchestratorAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadFailurePhase as json.
func (s RemediationOrchestratorAuditPayloadFailurePhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationOrchestratorAuditPayloadFailurePhase from json.
func (s *RemediationOrchestratorAuditPayloadFailurePhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayloadFailurePhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationOrchestratorAuditPayloadFailurePhase(v) {
	case RemediationOrchestratorAuditPayloadFailurePhaseSignalProcessing:
		*s = RemediationOrchestratorAuditPayloadFailurePhaseSignalProcessing
	case RemediationOrchestratorAuditPayloadFailurePhaseAIAnalysis:
		*s = RemediationOrchestratorAuditPayloadFailurePhaseAIAnalysis
	case RemediationOrchestratorAuditPayloadFailurePhaseWorkflowExecution:
		*s = RemediationOrchestratorAuditPayloadFailurePhaseWorkflowExecution
	case RemediationOrchestratorAuditPayloadFailurePhaseApproval:
		*s = RemediationOrchestratorAuditPayloadFailurePhaseApproval
	default:
		*s = RemediationOrchestratorAuditPayloadFailurePhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationOrchestratorAuditPayloadFailurePhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayloadFailurePhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadFailureReason as json.
func (s RemediationOrchestratorAuditPayloadFailureReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationOrchestratorAuditPayloadFailureReason from json.
func (s *RemediationOrchestratorAuditPayloadFailureReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayloadFailureReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationOrchestratorAuditPayloadFailureReason(v) {
	case RemediationOrchestratorAuditPayloadFailureReasonTimeout:
		*s = RemediationOrchestratorAuditPayloadFailureReasonTimeout
	case RemediationOrchestratorAuditPayloadFailureReasonValidationError:
		*s = RemediationOrchestratorAuditPayloadFailureReasonValidationError
	case RemediationOrchestratorAuditPayloadFailureReasonInfrastructureError:
		*s = RemediationOrchestratorAuditPayloadFailureReasonInfrastructureError
	case RemediationOrchestratorAuditPayloadFailureReasonApprovalRejected:
		*s = RemediationOrchestratorAuditPayloadFailureReasonApprovalRejected
	case RemediationOrchestratorAuditPayloadFailureReasonUnknown:
		*s = RemediationOrchestratorAuditPayloadFailureReasonUnknown
	default:
		*s = RemediationOrchestratorAuditPayloadFailureReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationOrchestratorAuditPayloadFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayloadFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationOrchestratorAuditPayloadOutcome as json.
func (s RemediationOrchestratorAuditPayloadOutcome) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationOrchestratorAuditPayloadOutcome from json.
func (s *RemediationOrchestratorAuditPayloadOutcome) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationOrchestratorAuditPayloadOutcome to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationOrchestratorAuditPayloadOutcome(v) {
	case RemediationOrchestratorAuditPayloadOutcomeSuccess:
		*s = RemediationOrchestratorAuditPayloadOutcomeSuccess
	case RemediationOrchestratorAuditPayloadOutcomeFailed:
		*s = RemediationOrchestratorAuditPayloadOutcomeFailed
	case RemediationOrchestratorAuditPayloadOutcomePending:
		*s = RemediationOrchestratorAuditPayloadOutcomePending
	default:
		*s = RemediationOrchestratorAuditPayloadOutcome(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationOrchestratorAuditPayloadOutcome) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationOrchestratorAuditPayloadOutcome) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationRequestWebhookAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationRequestWebhookAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("rr_name")
		e.Str(s.RrName)
	}
	{
		e.FieldStart("namespace")
		e.Str(s.Namespace)
	}
	{
		e.FieldStart("modified_by")
		e.Str(s.ModifiedBy)
	}
	{
		e.FieldStart("modified_at")
		json.EncodeDateTime(e, s.ModifiedAt)
	}
	{
		if s.OldTimeoutConfig.Set {
			e.FieldStart("old_timeout_config")
			s.OldTimeoutConfig.Encode(e)
		}
	}
	{
		if s.NewTimeoutConfig.Set {
			e.FieldStart("new_timeout_config")
			s.NewTimeoutConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationRequestWebhookAuditPayload = [7]string{
	0: "event_type",
	1: "rr_name",
	2: "namespace",
	3: "modified_by",
	4: "modified_at",
	5: "old_timeout_config",
	6: "new_timeout_config",
}

// Decode decodes RemediationRequestWebhookAuditPayload from json.
func (s *RemediationRequestWebhookAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationRequestWebhookAuditPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "rr_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RrName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rr_name\"")
			}
		case "namespace":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Namespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "modified_by":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ModifiedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modified_by\"")
			}
		case "modified_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ModifiedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modified_at\"")
			}
		case "old_timeout_config":
			if err := func() error {
				s.OldTimeoutConfig.Reset()
				if err := s.OldTimeoutConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_timeout_config\"")
			}
		case "new_timeout_config":
			if err := func() error {
				s.NewTimeoutConfig.Reset()
				if err := s.NewTimeoutConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_timeout_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationRequestWebhookAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationRequestWebhookAuditPayload) {
					name = jsonFieldsNameOfRemediationRequestWebhookAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationRequestWebhookAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationRequestWebhookAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationRequestWebhookAuditPayloadEventType as json.
func (s RemediationRequestWebhookAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationRequestWebhookAuditPayloadEventType from json.
func (s *RemediationRequestWebhookAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationRequestWebhookAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationRequestWebhookAuditPayloadEventType(v) {
	case RemediationRequestWebhookAuditPayloadEventTypeWebhookRemediationrequestTimeoutModified:
		*s = RemediationRequestWebhookAuditPayloadEventTypeWebhookRemediationrequestTimeoutModified
	default:
		*s = RemediationRequestWebhookAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationRequestWebhookAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationRequestWebhookAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemediationWorkflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemediationWorkflow) encodeFields(e *jx.Encoder) {
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		e.FieldStart("workflow_name")
		e.Str(s.WorkflowName)
	}
	{
		e.FieldStart("action_type")
		e.Str(s.ActionType)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Maintainer.Set {
			e.FieldStart("maintainer")
			s.Maintainer.Encode(e)
		}
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("content_hash")
		e.Str(s.ContentHash)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		e.FieldStart("execution_engine")
		e.Str(s.ExecutionEngine)
	}
	{
		if s.ContainerImage.Set {
			e.FieldStart("container_image")
			s.ContainerImage.Encode(e)
		}
	}
	{
		if s.ContainerDigest.Set {
			e.FieldStart("container_digest")
			s.ContainerDigest.Encode(e)
		}
	}
	{
		e.FieldStart("labels")
		s.Labels.Encode(e)
	}
	{
		if s.CustomLabels.Set {
			e.FieldStart("custom_labels")
			s.CustomLabels.Encode(e)
		}
	}
	{
		if s.DetectedLabels.Set {
			e.FieldStart("detected_labels")
			s.DetectedLabels.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.DisabledAt.Set {
			e.FieldStart("disabled_at")
			s.DisabledAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.DisabledBy.Set {
			e.FieldStart("disabled_by")
			s.DisabledBy.Encode(e)
		}
	}
	{
		if s.DisabledReason.Set {
			e.FieldStart("disabled_reason")
			s.DisabledReason.Encode(e)
		}
	}
	{
		if s.IsLatestVersion.Set {
			e.FieldStart("is_latest_version")
			s.IsLatestVersion.Encode(e)
		}
	}
	{
		if s.PreviousVersion.Set {
			e.FieldStart("previous_version")
			s.PreviousVersion.Encode(e)
		}
	}
	{
		if s.DeprecationNotice.Set {
			e.FieldStart("deprecation_notice")
			s.DeprecationNotice.Encode(e)
		}
	}
	{
		if s.VersionNotes.Set {
			e.FieldStart("version_notes")
			s.VersionNotes.Encode(e)
		}
	}
	{
		if s.ChangeSummary.Set {
			e.FieldStart("change_summary")
			s.ChangeSummary.Encode(e)
		}
	}
	{
		if s.ApprovedBy.Set {
			e.FieldStart("approved_by")
			s.ApprovedBy.Encode(e)
		}
	}
	{
		if s.ApprovedAt.Set {
			e.FieldStart("approved_at")
			s.ApprovedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExpectedSuccessRate.Set {
			e.FieldStart("expected_success_rate")
			s.ExpectedSuccessRate.Encode(e)
		}
	}
	{
		if s.ExpectedDurationSeconds.Set {
			e.FieldStart("expected_duration_seconds")
			s.ExpectedDurationSeconds.Encode(e)
		}
	}
	{
		if s.ActualSuccessRate.Set {
			e.FieldStart("actual_success_rate")
			s.ActualSuccessRate.Encode(e)
		}
	}
	{
		if s.TotalExecutions.Set {
			e.FieldStart("total_executions")
			s.TotalExecutions.Encode(e)
		}
	}
	{
		if s.SuccessfulExecutions.Set {
			e.FieldStart("successful_executions")
			s.SuccessfulExecutions.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updated_at")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("created_by")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemediationWorkflow = [37]string{
	0:  "workflow_id",
	1:  "workflow_name",
	2:  "action_type",
	3:  "version",
	4:  "name",
	5:  "description",
	6:  "owner",
	7:  "maintainer",
	8:  "content",
	9:  "content_hash",
	10: "parameters",
	11: "execution_engine",
	12: "container_image",
	13: "container_digest",
	14: "labels",
	15: "custom_labels",
	16: "detected_labels",
	17: "status",
	18: "disabled_at",
	19: "disabled_by",
	20: "disabled_reason",
	21: "is_latest_version",
	22: "previous_version",
	23: "deprecation_notice",
	24: "version_notes",
	25: "change_summary",
	26: "approved_by",
	27: "approved_at",
	28: "expected_success_rate",
	29: "expected_duration_seconds",
	30: "actual_success_rate",
	31: "total_executions",
	32: "successful_executions",
	33: "created_at",
	34: "updated_at",
	35: "created_by",
	36: "updated_by",
}

// Decode decodes RemediationWorkflow from json.
func (s *RemediationWorkflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationWorkflow to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "workflow_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_name\"")
			}
		case "action_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ActionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "maintainer":
			if err := func() error {
				s.Maintainer.Reset()
				if err := s.Maintainer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer\"")
			}
		case "content":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "content_hash":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ContentHash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_hash\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "execution_engine":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExecutionEngine = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_engine\"")
			}
		case "container_image":
			if err := func() error {
				s.ContainerImage.Reset()
				if err := s.ContainerImage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_image\"")
			}
		case "container_digest":
			if err := func() error {
				s.ContainerDigest.Reset()
				if err := s.ContainerDigest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_digest\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "custom_labels":
			if err := func() error {
				s.CustomLabels.Reset()
				if err := s.CustomLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_labels\"")
			}
		case "detected_labels":
			if err := func() error {
				s.DetectedLabels.Reset()
				if err := s.DetectedLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detected_labels\"")
			}
		case "status":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "disabled_at":
			if err := func() error {
				s.DisabledAt.Reset()
				if err := s.DisabledAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_at\"")
			}
		case "disabled_by":
			if err := func() error {
				s.DisabledBy.Reset()
				if err := s.DisabledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_by\"")
			}
		case "disabled_reason":
			if err := func() error {
				s.DisabledReason.Reset()
				if err := s.DisabledReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_reason\"")
			}
		case "is_latest_version":
			if err := func() error {
				s.IsLatestVersion.Reset()
				if err := s.IsLatestVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_latest_version\"")
			}
		case "previous_version":
			if err := func() error {
				s.PreviousVersion.Reset()
				if err := s.PreviousVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_version\"")
			}
		case "deprecation_notice":
			if err := func() error {
				s.DeprecationNotice.Reset()
				if err := s.DeprecationNotice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecation_notice\"")
			}
		case "version_notes":
			if err := func() error {
				s.VersionNotes.Reset()
				if err := s.VersionNotes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_notes\"")
			}
		case "change_summary":
			if err := func() error {
				s.ChangeSummary.Reset()
				if err := s.ChangeSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"change_summary\"")
			}
		case "approved_by":
			if err := func() error {
				s.ApprovedBy.Reset()
				if err := s.ApprovedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approved_by\"")
			}
		case "approved_at":
			if err := func() error {
				s.ApprovedAt.Reset()
				if err := s.ApprovedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approved_at\"")
			}
		case "expected_success_rate":
			if err := func() error {
				s.ExpectedSuccessRate.Reset()
				if err := s.ExpectedSuccessRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_success_rate\"")
			}
		case "expected_duration_seconds":
			if err := func() error {
				s.ExpectedDurationSeconds.Reset()
				if err := s.ExpectedDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_duration_seconds\"")
			}
		case "actual_success_rate":
			if err := func() error {
				s.ActualSuccessRate.Reset()
				if err := s.ActualSuccessRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actual_success_rate\"")
			}
		case "total_executions":
			if err := func() error {
				s.TotalExecutions.Reset()
				if err := s.TotalExecutions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_executions\"")
			}
		case "successful_executions":
			if err := func() error {
				s.SuccessfulExecutions.Reset()
				if err := s.SuccessfulExecutions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successful_executions\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "created_by":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationWorkflow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00111110,
		0b01001011,
		0b00000010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemediationWorkflow) {
					name = jsonFieldsNameOfRemediationWorkflow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemediationWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RemediationWorkflowParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RemediationWorkflowParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RemediationWorkflowParameters from json.
func (s *RemediationWorkflowParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationWorkflowParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemediationWorkflowParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationWorkflowParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationWorkflowParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RemediationWorkflowStatus as json.
func (s RemediationWorkflowStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RemediationWorkflowStatus from json.
func (s *RemediationWorkflowStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemediationWorkflowStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RemediationWorkflowStatus(v) {
	case RemediationWorkflowStatusActive:
		*s = RemediationWorkflowStatusActive
	case RemediationWorkflowStatusDisabled:
		*s = RemediationWorkflowStatusDisabled
	case RemediationWorkflowStatusDeprecated:
		*s = RemediationWorkflowStatusDeprecated
	case RemediationWorkflowStatusArchived:
		*s = RemediationWorkflowStatusArchived
	default:
		*s = RemediationWorkflowStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RemediationWorkflowStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemediationWorkflowStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultsMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultsMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total_found")
		e.Int32(s.TotalFound)
	}
	{
		e.FieldStart("returned")
		e.Int32(s.Returned)
	}
	{
		e.FieldStart("workflows")
		e.ArrStart()
		for _, elem := range s.Workflows {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResultsMetadata = [3]string{
	0: "total_found",
	1: "returned",
	2: "workflows",
}

// Decode decodes ResultsMetadata from json.
func (s *ResultsMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultsMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_found":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.TotalFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_found\"")
			}
		case "returned":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Returned = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"returned\"")
			}
		case "workflows":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Workflows = make([]WorkflowResultAudit, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowResultAudit
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Workflows = append(s.Workflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultsMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResultsMetadata) {
					name = jsonFieldsNameOfResultsMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultsMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultsMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScoringV1Audit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScoringV1Audit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("confidence")
		e.Float64(s.Confidence)
	}
}

var jsonFieldsNameOfScoringV1Audit = [1]string{
	0: "confidence",
}

// Decode decodes ScoringV1Audit from json.
func (s *ScoringV1Audit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScoringV1Audit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "confidence":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Confidence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScoringV1Audit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScoringV1Audit) {
					name = jsonFieldsNameOfScoringV1Audit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScoringV1Audit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScoringV1Audit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchExecutionMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchExecutionMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("duration_ms")
		e.Int64(s.DurationMs)
	}
}

var jsonFieldsNameOfSearchExecutionMetadata = [1]string{
	0: "duration_ms",
}

// Decode decodes SearchExecutionMetadata from json.
func (s *SearchExecutionMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchExecutionMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.DurationMs = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchExecutionMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchExecutionMetadata) {
					name = jsonFieldsNameOfSearchExecutionMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchExecutionMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchExecutionMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SignalProcessingAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SignalProcessingAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("phase")
		s.Phase.Encode(e)
	}
	{
		e.FieldStart("signal")
		e.Str(s.Signal)
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.ExternalSeverity.Set {
			e.FieldStart("external_severity")
			s.ExternalSeverity.Encode(e)
		}
	}
	{
		if s.NormalizedSeverity.Set {
			e.FieldStart("normalized_severity")
			s.NormalizedSeverity.Encode(e)
		}
	}
	{
		if s.DeterminationSource.Set {
			e.FieldStart("determination_source")
			s.DeterminationSource.Encode(e)
		}
	}
	{
		if s.PolicyHash.Set {
			e.FieldStart("policy_hash")
			s.PolicyHash.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		if s.EnvironmentSource.Set {
			e.FieldStart("environment_source")
			s.EnvironmentSource.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.PrioritySource.Set {
			e.FieldStart("priority_source")
			s.PrioritySource.Encode(e)
		}
	}
	{
		if s.Criticality.Set {
			e.FieldStart("criticality")
			s.Criticality.Encode(e)
		}
	}
	{
		if s.SLARequirement.Set {
			e.FieldStart("sla_requirement")
			s.SLARequirement.Encode(e)
		}
	}
	{
		if s.HasOwnerChain.Set {
			e.FieldStart("has_owner_chain")
			s.HasOwnerChain.Encode(e)
		}
	}
	{
		if s.OwnerChainLength.Set {
			e.FieldStart("owner_chain_length")
			s.OwnerChainLength.Encode(e)
		}
	}
	{
		if s.DegradedMode.Set {
			e.FieldStart("degraded_mode")
			s.DegradedMode.Encode(e)
		}
	}
	{
		if s.HasPdb.Set {
			e.FieldStart("has_pdb")
			s.HasPdb.Encode(e)
		}
	}
	{
		if s.HasHpa.Set {
			e.FieldStart("has_hpa")
			s.HasHpa.Encode(e)
		}
	}
	{
		if s.DurationMs.Set {
			e.FieldStart("duration_ms")
			s.DurationMs.Encode(e)
		}
	}
	{
		if s.HasNamespace.Set {
			e.FieldStart("has_namespace")
			s.HasNamespace.Encode(e)
		}
	}
	{
		if s.HasPod.Set {
			e.FieldStart("has_pod")
			s.HasPod.Encode(e)
		}
	}
	{
		if s.HasDeployment.Set {
			e.FieldStart("has_deployment")
			s.HasDeployment.Encode(e)
		}
	}
	{
		if s.BusinessUnit.Set {
			e.FieldStart("business_unit")
			s.BusinessUnit.Encode(e)
		}
	}
	{
		if s.FromPhase.Set {
			e.FieldStart("from_phase")
			s.FromPhase.Encode(e)
		}
	}
	{
		if s.ToPhase.Set {
			e.FieldStart("to_phase")
			s.ToPhase.Encode(e)
		}
	}
	{
		if s.SignalMode.Set {
			e.FieldStart("signal_mode")
			s.SignalMode.Encode(e)
		}
	}
	{
		if s.OriginalSignalType.Set {
			e.FieldStart("original_signal_type")
			s.OriginalSignalType.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfSignalProcessingAuditPayload = [29]string{
	0:  "event_type",
	1:  "phase",
	2:  "signal",
	3:  "severity",
	4:  "external_severity",
	5:  "normalized_severity",
	6:  "determination_source",
	7:  "policy_hash",
	8:  "environment",
	9:  "environment_source",
	10: "priority",
	11: "priority_source",
	12: "criticality",
	13: "sla_requirement",
	14: "has_owner_chain",
	15: "owner_chain_length",
	16: "degraded_mode",
	17: "has_pdb",
	18: "has_hpa",
	19: "duration_ms",
	20: "has_namespace",
	21: "has_pod",
	22: "has_deployment",
	23: "business_unit",
	24: "from_phase",
	25: "to_phase",
	26: "signal_mode",
	27: "original_signal_type",
	28: "error",
}

// Decode decodes SignalProcessingAuditPayload from json.
func (s *SignalProcessingAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayload to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "phase":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "signal":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Signal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "external_severity":
			if err := func() error {
				s.ExternalSeverity.Reset()
				if err := s.ExternalSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_severity\"")
			}
		case "normalized_severity":
			if err := func() error {
				s.NormalizedSeverity.Reset()
				if err := s.NormalizedSeverity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_severity\"")
			}
		case "determination_source":
			if err := func() error {
				s.DeterminationSource.Reset()
				if err := s.DeterminationSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"determination_source\"")
			}
		case "policy_hash":
			if err := func() error {
				s.PolicyHash.Reset()
				if err := s.PolicyHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy_hash\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "environment_source":
			if err := func() error {
				s.EnvironmentSource.Reset()
				if err := s.EnvironmentSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment_source\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "priority_source":
			if err := func() error {
				s.PrioritySource.Reset()
				if err := s.PrioritySource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority_source\"")
			}
		case "criticality":
			if err := func() error {
				s.Criticality.Reset()
				if err := s.Criticality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criticality\"")
			}
		case "sla_requirement":
			if err := func() error {
				s.SLARequirement.Reset()
				if err := s.SLARequirement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sla_requirement\"")
			}
		case "has_owner_chain":
			if err := func() error {
				s.HasOwnerChain.Reset()
				if err := s.HasOwnerChain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_owner_chain\"")
			}
		case "owner_chain_length":
			if err := func() error {
				s.OwnerChainLength.Reset()
				if err := s.OwnerChainLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_chain_length\"")
			}
		case "degraded_mode":
			if err := func() error {
				s.DegradedMode.Reset()
				if err := s.DegradedMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"degraded_mode\"")
			}
		case "has_pdb":
			if err := func() error {
				s.HasPdb.Reset()
				if err := s.HasPdb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pdb\"")
			}
		case "has_hpa":
			if err := func() error {
				s.HasHpa.Reset()
				if err := s.HasHpa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_hpa\"")
			}
		case "duration_ms":
			if err := func() error {
				s.DurationMs.Reset()
				if err := s.DurationMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "has_namespace":
			if err := func() error {
				s.HasNamespace.Reset()
				if err := s.HasNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_namespace\"")
			}
		case "has_pod":
			if err := func() error {
				s.HasPod.Reset()
				if err := s.HasPod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_pod\"")
			}
		case "has_deployment":
			if err := func() error {
				s.HasDeployment.Reset()
				if err := s.HasDeployment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_deployment\"")
			}
		case "business_unit":
			if err := func() error {
				s.BusinessUnit.Reset()
				if err := s.BusinessUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_unit\"")
			}
		case "from_phase":
			if err := func() error {
				s.FromPhase.Reset()
				if err := s.FromPhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_phase\"")
			}
		case "to_phase":
			if err := func() error {
				s.ToPhase.Reset()
				if err := s.ToPhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_phase\"")
			}
		case "signal_mode":
			if err := func() error {
				s.SignalMode.Reset()
				if err := s.SignalMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_mode\"")
			}
		case "original_signal_type":
			if err := func() error {
				s.OriginalSignalType.Reset()
				if err := s.OriginalSignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_signal_type\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SignalProcessingAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000111,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSignalProcessingAuditPayload) {
					name = jsonFieldsNameOfSignalProcessingAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SignalProcessingAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadCriticality as json.
func (s SignalProcessingAuditPayloadCriticality) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadCriticality from json.
func (s *SignalProcessingAuditPayloadCriticality) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadCriticality to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadCriticality(v) {
	case SignalProcessingAuditPayloadCriticalityCritical:
		*s = SignalProcessingAuditPayloadCriticalityCritical
	case SignalProcessingAuditPayloadCriticalityHigh:
		*s = SignalProcessingAuditPayloadCriticalityHigh
	case SignalProcessingAuditPayloadCriticalityMedium:
		*s = SignalProcessingAuditPayloadCriticalityMedium
	case SignalProcessingAuditPayloadCriticalityLow:
		*s = SignalProcessingAuditPayloadCriticalityLow
	default:
		*s = SignalProcessingAuditPayloadCriticality(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadCriticality) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadCriticality) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadDeterminationSource as json.
func (s SignalProcessingAuditPayloadDeterminationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadDeterminationSource from json.
func (s *SignalProcessingAuditPayloadDeterminationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadDeterminationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadDeterminationSource(v) {
	case SignalProcessingAuditPayloadDeterminationSourceRegoPolicy:
		*s = SignalProcessingAuditPayloadDeterminationSourceRegoPolicy
	case SignalProcessingAuditPayloadDeterminationSourceFallback:
		*s = SignalProcessingAuditPayloadDeterminationSourceFallback
	case SignalProcessingAuditPayloadDeterminationSourceDefault:
		*s = SignalProcessingAuditPayloadDeterminationSourceDefault
	default:
		*s = SignalProcessingAuditPayloadDeterminationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadDeterminationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadDeterminationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadEnvironment as json.
func (s SignalProcessingAuditPayloadEnvironment) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadEnvironment from json.
func (s *SignalProcessingAuditPayloadEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadEnvironment to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadEnvironment(v) {
	case SignalProcessingAuditPayloadEnvironmentProduction:
		*s = SignalProcessingAuditPayloadEnvironmentProduction
	case SignalProcessingAuditPayloadEnvironmentStaging:
		*s = SignalProcessingAuditPayloadEnvironmentStaging
	case SignalProcessingAuditPayloadEnvironmentDevelopment:
		*s = SignalProcessingAuditPayloadEnvironmentDevelopment
	default:
		*s = SignalProcessingAuditPayloadEnvironment(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadEnvironmentSource as json.
func (s SignalProcessingAuditPayloadEnvironmentSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadEnvironmentSource from json.
func (s *SignalProcessingAuditPayloadEnvironmentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadEnvironmentSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadEnvironmentSource(v) {
	case SignalProcessingAuditPayloadEnvironmentSourceRego:
		*s = SignalProcessingAuditPayloadEnvironmentSourceRego
	case SignalProcessingAuditPayloadEnvironmentSourceLabels:
		*s = SignalProcessingAuditPayloadEnvironmentSourceLabels
	case SignalProcessingAuditPayloadEnvironmentSourceDefault:
		*s = SignalProcessingAuditPayloadEnvironmentSourceDefault
	default:
		*s = SignalProcessingAuditPayloadEnvironmentSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadEnvironmentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadEnvironmentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadEventType as json.
func (s SignalProcessingAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadEventType from json.
func (s *SignalProcessingAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadEventType(v) {
	case SignalProcessingAuditPayloadEventTypeSignalprocessingSignalProcessed:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingSignalProcessed
	case SignalProcessingAuditPayloadEventTypeSignalprocessingPhaseTransition:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingPhaseTransition
	case SignalProcessingAuditPayloadEventTypeSignalprocessingClassificationDecision:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingClassificationDecision
	case SignalProcessingAuditPayloadEventTypeSignalprocessingBusinessClassified:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingBusinessClassified
	case SignalProcessingAuditPayloadEventTypeSignalprocessingEnrichmentCompleted:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingEnrichmentCompleted
	case SignalProcessingAuditPayloadEventTypeSignalprocessingErrorOccurred:
		*s = SignalProcessingAuditPayloadEventTypeSignalprocessingErrorOccurred
	default:
		*s = SignalProcessingAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadNormalizedSeverity as json.
func (s SignalProcessingAuditPayloadNormalizedSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadNormalizedSeverity from json.
func (s *SignalProcessingAuditPayloadNormalizedSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadNormalizedSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadNormalizedSeverity(v) {
	case SignalProcessingAuditPayloadNormalizedSeverityCritical:
		*s = SignalProcessingAuditPayloadNormalizedSeverityCritical
	case SignalProcessingAuditPayloadNormalizedSeverityHigh:
		*s = SignalProcessingAuditPayloadNormalizedSeverityHigh
	case SignalProcessingAuditPayloadNormalizedSeverityMedium:
		*s = SignalProcessingAuditPayloadNormalizedSeverityMedium
	case SignalProcessingAuditPayloadNormalizedSeverityLow:
		*s = SignalProcessingAuditPayloadNormalizedSeverityLow
	case SignalProcessingAuditPayloadNormalizedSeverityUnknown:
		*s = SignalProcessingAuditPayloadNormalizedSeverityUnknown
	default:
		*s = SignalProcessingAuditPayloadNormalizedSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadNormalizedSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadNormalizedSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadPhase as json.
func (s SignalProcessingAuditPayloadPhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadPhase from json.
func (s *SignalProcessingAuditPayloadPhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadPhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadPhase(v) {
	case SignalProcessingAuditPayloadPhasePending:
		*s = SignalProcessingAuditPayloadPhasePending
	case SignalProcessingAuditPayloadPhaseEnriching:
		*s = SignalProcessingAuditPayloadPhaseEnriching
	case SignalProcessingAuditPayloadPhaseClassifying:
		*s = SignalProcessingAuditPayloadPhaseClassifying
	case SignalProcessingAuditPayloadPhaseCategorizing:
		*s = SignalProcessingAuditPayloadPhaseCategorizing
	case SignalProcessingAuditPayloadPhaseCompleted:
		*s = SignalProcessingAuditPayloadPhaseCompleted
	case SignalProcessingAuditPayloadPhaseFailed:
		*s = SignalProcessingAuditPayloadPhaseFailed
	default:
		*s = SignalProcessingAuditPayloadPhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadPhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadPhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadPriority as json.
func (s SignalProcessingAuditPayloadPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadPriority from json.
func (s *SignalProcessingAuditPayloadPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadPriority(v) {
	case SignalProcessingAuditPayloadPriorityP0:
		*s = SignalProcessingAuditPayloadPriorityP0
	case SignalProcessingAuditPayloadPriorityP1:
		*s = SignalProcessingAuditPayloadPriorityP1
	case SignalProcessingAuditPayloadPriorityP2:
		*s = SignalProcessingAuditPayloadPriorityP2
	case SignalProcessingAuditPayloadPriorityP3:
		*s = SignalProcessingAuditPayloadPriorityP3
	case SignalProcessingAuditPayloadPriorityP4:
		*s = SignalProcessingAuditPayloadPriorityP4
	default:
		*s = SignalProcessingAuditPayloadPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadPrioritySource as json.
func (s SignalProcessingAuditPayloadPrioritySource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadPrioritySource from json.
func (s *SignalProcessingAuditPayloadPrioritySource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadPrioritySource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadPrioritySource(v) {
	case SignalProcessingAuditPayloadPrioritySourceRego:
		*s = SignalProcessingAuditPayloadPrioritySourceRego
	case SignalProcessingAuditPayloadPrioritySourceSeverity:
		*s = SignalProcessingAuditPayloadPrioritySourceSeverity
	case SignalProcessingAuditPayloadPrioritySourceDefault:
		*s = SignalProcessingAuditPayloadPrioritySourceDefault
	default:
		*s = SignalProcessingAuditPayloadPrioritySource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadPrioritySource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadPrioritySource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadSeverity as json.
func (s SignalProcessingAuditPayloadSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadSeverity from json.
func (s *SignalProcessingAuditPayloadSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadSeverity(v) {
	case SignalProcessingAuditPayloadSeverityCritical:
		*s = SignalProcessingAuditPayloadSeverityCritical
	case SignalProcessingAuditPayloadSeverityHigh:
		*s = SignalProcessingAuditPayloadSeverityHigh
	case SignalProcessingAuditPayloadSeverityMedium:
		*s = SignalProcessingAuditPayloadSeverityMedium
	case SignalProcessingAuditPayloadSeverityLow:
		*s = SignalProcessingAuditPayloadSeverityLow
	case SignalProcessingAuditPayloadSeverityUnknown:
		*s = SignalProcessingAuditPayloadSeverityUnknown
	default:
		*s = SignalProcessingAuditPayloadSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalProcessingAuditPayloadSignalMode as json.
func (s SignalProcessingAuditPayloadSignalMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalProcessingAuditPayloadSignalMode from json.
func (s *SignalProcessingAuditPayloadSignalMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalProcessingAuditPayloadSignalMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalProcessingAuditPayloadSignalMode(v) {
	case SignalProcessingAuditPayloadSignalModeReactive:
		*s = SignalProcessingAuditPayloadSignalModeReactive
	case SignalProcessingAuditPayloadSignalModePredictive:
		*s = SignalProcessingAuditPayloadSignalModePredictive
	default:
		*s = SignalProcessingAuditPayloadSignalMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalProcessingAuditPayloadSignalMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalProcessingAuditPayloadSignalMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StructuredDescription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StructuredDescription) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("what")
		e.Str(s.What)
	}
	{
		e.FieldStart("whenToUse")
		e.Str(s.WhenToUse)
	}
	{
		if s.WhenNotToUse.Set {
			e.FieldStart("whenNotToUse")
			s.WhenNotToUse.Encode(e)
		}
	}
	{
		if s.Preconditions.Set {
			e.FieldStart("preconditions")
			s.Preconditions.Encode(e)
		}
	}
}

var jsonFieldsNameOfStructuredDescription = [4]string{
	0: "what",
	1: "whenToUse",
	2: "whenNotToUse",
	3: "preconditions",
}

// Decode decodes StructuredDescription from json.
func (s *StructuredDescription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StructuredDescription to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "what":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.What = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"what\"")
			}
		case "whenToUse":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WhenToUse = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whenToUse\"")
			}
		case "whenNotToUse":
			if err := func() error {
				s.WhenNotToUse.Reset()
				if err := s.WhenNotToUse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whenNotToUse\"")
			}
		case "preconditions":
			if err := func() error {
				s.Preconditions.Reset()
				if err := s.Preconditions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preconditions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StructuredDescription")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStructuredDescription) {
					name = jsonFieldsNameOfStructuredDescription[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StructuredDescription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StructuredDescription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeoutConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeoutConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Global.Set {
			e.FieldStart("global")
			s.Global.Encode(e)
		}
	}
	{
		if s.Processing.Set {
			e.FieldStart("processing")
			s.Processing.Encode(e)
		}
	}
	{
		if s.Analyzing.Set {
			e.FieldStart("analyzing")
			s.Analyzing.Encode(e)
		}
	}
	{
		if s.Executing.Set {
			e.FieldStart("executing")
			s.Executing.Encode(e)
		}
	}
}

var jsonFieldsNameOfTimeoutConfig = [4]string{
	0: "global",
	1: "processing",
	2: "analyzing",
	3: "executing",
}

// Decode decodes TimeoutConfig from json.
func (s *TimeoutConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeoutConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "global":
			if err := func() error {
				s.Global.Reset()
				if err := s.Global.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"global\"")
			}
		case "processing":
			if err := func() error {
				s.Processing.Reset()
				if err := s.Processing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processing\"")
			}
		case "analyzing":
			if err := func() error {
				s.Analyzing.Reset()
				if err := s.Analyzing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analyzing\"")
			}
		case "executing":
			if err := func() error {
				s.Executing.Reset()
				if err := s.Executing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeoutConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeoutConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeoutConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorkflowBadRequest as json.
func (s *UpdateWorkflowBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorkflowBadRequest from json.
func (s *UpdateWorkflowBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorkflowBadRequest to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorkflowBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorkflowBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorkflowBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWorkflowNotFound as json.
func (s *UpdateWorkflowNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*RFC7807Problem)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateWorkflowNotFound from json.
func (s *UpdateWorkflowNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorkflowNotFound to nil")
	}
	var unwrapped RFC7807Problem
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWorkflowNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorkflowNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorkflowNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
	{
		e.FieldStart("completeness")
		e.Int(s.Completeness)
	}
	{
		e.FieldStart("errors")
		e.ArrStart()
		for _, elem := range s.Errors {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("warnings")
		e.ArrStart()
		for _, elem := range s.Warnings {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfValidationResult = [4]string{
	0: "is_valid",
	1: "completeness",
	2: "errors",
	3: "warnings",
}

// Decode decodes ValidationResult from json.
func (s *ValidationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_valid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "completeness":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Completeness = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completeness\"")
			}
		case "errors":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "warnings":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationResult) {
					name = jsonFieldsNameOfValidationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowCatalogCreatedPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowCatalogCreatedPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_id")
		json.EncodeUUID(e, s.WorkflowID)
	}
	{
		e.FieldStart("workflow_name")
		e.Str(s.WorkflowName)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("is_latest_version")
		e.Bool(s.IsLatestVersion)
	}
	{
		e.FieldStart("execution_engine")
		e.Str(s.ExecutionEngine)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowCatalogCreatedPayload = [9]string{
	0: "workflow_id",
	1: "workflow_name",
	2: "version",
	3: "status",
	4: "is_latest_version",
	5: "execution_engine",
	6: "name",
	7: "description",
	8: "labels",
}

// Decode decodes WorkflowCatalogCreatedPayload from json.
func (s *WorkflowCatalogCreatedPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowCatalogCreatedPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WorkflowID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "workflow_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "is_latest_version":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsLatestVersion = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_latest_version\"")
			}
		case "execution_engine":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ExecutionEngine = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_engine\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowCatalogCreatedPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowCatalogCreatedPayload) {
					name = jsonFieldsNameOfWorkflowCatalogCreatedPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowCatalogCreatedPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowCatalogCreatedPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WorkflowCatalogCreatedPayloadLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WorkflowCatalogCreatedPayloadLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes WorkflowCatalogCreatedPayloadLabels from json.
func (s *WorkflowCatalogCreatedPayloadLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowCatalogCreatedPayloadLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowCatalogCreatedPayloadLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowCatalogCreatedPayloadLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowCatalogCreatedPayloadLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowCatalogCreatedPayloadStatus as json.
func (s WorkflowCatalogCreatedPayloadStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowCatalogCreatedPayloadStatus from json.
func (s *WorkflowCatalogCreatedPayloadStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowCatalogCreatedPayloadStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowCatalogCreatedPayloadStatus(v) {
	case WorkflowCatalogCreatedPayloadStatusActive:
		*s = WorkflowCatalogCreatedPayloadStatusActive
	case WorkflowCatalogCreatedPayloadStatusDisabled:
		*s = WorkflowCatalogCreatedPayloadStatusDisabled
	case WorkflowCatalogCreatedPayloadStatusArchived:
		*s = WorkflowCatalogCreatedPayloadStatusArchived
	default:
		*s = WorkflowCatalogCreatedPayloadStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowCatalogCreatedPayloadStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowCatalogCreatedPayloadStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowCatalogUpdatedFields) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowCatalogUpdatedFields) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.DisabledBy.Set {
			e.FieldStart("disabled_by")
			s.DisabledBy.Encode(e)
		}
	}
	{
		if s.DisabledReason.Set {
			e.FieldStart("disabled_reason")
			s.DisabledReason.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowCatalogUpdatedFields = [5]string{
	0: "status",
	1: "disabled_by",
	2: "disabled_reason",
	3: "version",
	4: "description",
}

// Decode decodes WorkflowCatalogUpdatedFields from json.
func (s *WorkflowCatalogUpdatedFields) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowCatalogUpdatedFields to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "disabled_by":
			if err := func() error {
				s.DisabledBy.Reset()
				if err := s.DisabledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_by\"")
			}
		case "disabled_reason":
			if err := func() error {
				s.DisabledReason.Reset()
				if err := s.DisabledReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_reason\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowCatalogUpdatedFields")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowCatalogUpdatedFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowCatalogUpdatedFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowCatalogUpdatedPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowCatalogUpdatedPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_id")
		json.EncodeUUID(e, s.WorkflowID)
	}
	{
		e.FieldStart("updated_fields")
		s.UpdatedFields.Encode(e)
	}
}

var jsonFieldsNameOfWorkflowCatalogUpdatedPayload = [2]string{
	0: "workflow_id",
	1: "updated_fields",
}

// Decode decodes WorkflowCatalogUpdatedPayload from json.
func (s *WorkflowCatalogUpdatedPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowCatalogUpdatedPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WorkflowID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "updated_fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.UpdatedFields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowCatalogUpdatedPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowCatalogUpdatedPayload) {
					name = jsonFieldsNameOfWorkflowCatalogUpdatedPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowCatalogUpdatedPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowCatalogUpdatedPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowDiscoveryAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowDiscoveryAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("query")
		s.Query.Encode(e)
	}
	{
		e.FieldStart("results")
		s.Results.Encode(e)
	}
	{
		e.FieldStart("search_metadata")
		s.SearchMetadata.Encode(e)
	}
}

var jsonFieldsNameOfWorkflowDiscoveryAuditPayload = [4]string{
	0: "event_type",
	1: "query",
	2: "results",
	3: "search_metadata",
}

// Decode decodes WorkflowDiscoveryAuditPayload from json.
func (s *WorkflowDiscoveryAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowDiscoveryAuditPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Results.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "search_metadata":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SearchMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search_metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowDiscoveryAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowDiscoveryAuditPayload) {
					name = jsonFieldsNameOfWorkflowDiscoveryAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowDiscoveryAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowDiscoveryAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowDiscoveryAuditPayloadEventType as json.
func (s WorkflowDiscoveryAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowDiscoveryAuditPayloadEventType from json.
func (s *WorkflowDiscoveryAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowDiscoveryAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowDiscoveryAuditPayloadEventType(v) {
	case WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogActionsListed:
		*s = WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogActionsListed
	case WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogWorkflowsListed:
		*s = WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogWorkflowsListed
	case WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogWorkflowRetrieved:
		*s = WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogWorkflowRetrieved
	case WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogSelectionValidated:
		*s = WorkflowDiscoveryAuditPayloadEventTypeWorkflowCatalogSelectionValidated
	default:
		*s = WorkflowDiscoveryAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowDiscoveryAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowDiscoveryAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowDiscoveryEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowDiscoveryEntry) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflowId")
		json.EncodeUUID(e, s.WorkflowId)
	}
	{
		e.FieldStart("workflowName")
		e.Str(s.WorkflowName)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("containerImage")
		e.Str(s.ContainerImage)
	}
	{
		if s.ExecutionEngine.Set {
			e.FieldStart("executionEngine")
			s.ExecutionEngine.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowDiscoveryEntry = [7]string{
	0: "workflowId",
	1: "workflowName",
	2: "name",
	3: "description",
	4: "version",
	5: "containerImage",
	6: "executionEngine",
}

// Decode decodes WorkflowDiscoveryEntry from json.
func (s *WorkflowDiscoveryEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowDiscoveryEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflowId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WorkflowId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowId\"")
			}
		case "workflowName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowName\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "containerImage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ContainerImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerImage\"")
			}
		case "executionEngine":
			if err := func() error {
				s.ExecutionEngine.Reset()
				if err := s.ExecutionEngine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionEngine\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowDiscoveryEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowDiscoveryEntry) {
					name = jsonFieldsNameOfWorkflowDiscoveryEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowDiscoveryEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowDiscoveryEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowDiscoveryEntryExecutionEngine as json.
func (s WorkflowDiscoveryEntryExecutionEngine) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowDiscoveryEntryExecutionEngine from json.
func (s *WorkflowDiscoveryEntryExecutionEngine) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowDiscoveryEntryExecutionEngine to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowDiscoveryEntryExecutionEngine(v) {
	case WorkflowDiscoveryEntryExecutionEngineTekton:
		*s = WorkflowDiscoveryEntryExecutionEngineTekton
	case WorkflowDiscoveryEntryExecutionEngineJob:
		*s = WorkflowDiscoveryEntryExecutionEngineJob
	default:
		*s = WorkflowDiscoveryEntryExecutionEngine(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowDiscoveryEntryExecutionEngine) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowDiscoveryEntryExecutionEngine) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowDiscoveryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowDiscoveryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actionType")
		e.Str(s.ActionType)
	}
	{
		e.FieldStart("workflows")
		e.ArrStart()
		for _, elem := range s.Workflows {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("pagination")
		s.Pagination.Encode(e)
	}
}

var jsonFieldsNameOfWorkflowDiscoveryResponse = [3]string{
	0: "actionType",
	1: "workflows",
	2: "pagination",
}

// Decode decodes WorkflowDiscoveryResponse from json.
func (s *WorkflowDiscoveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowDiscoveryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ActionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionType\"")
			}
		case "workflows":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Workflows = make([]WorkflowDiscoveryEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowDiscoveryEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Workflows = append(s.Workflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		case "pagination":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Pagination.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pagination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowDiscoveryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowDiscoveryResponse) {
					name = jsonFieldsNameOfWorkflowDiscoveryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowDiscoveryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowDiscoveryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowExecutionAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowExecutionAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("workflow_id")
		e.Str(s.WorkflowID)
	}
	{
		e.FieldStart("workflow_version")
		e.Str(s.WorkflowVersion)
	}
	{
		e.FieldStart("target_resource")
		e.Str(s.TargetResource)
	}
	{
		e.FieldStart("phase")
		s.Phase.Encode(e)
	}
	{
		e.FieldStart("container_image")
		e.Str(s.ContainerImage)
	}
	{
		e.FieldStart("execution_name")
		e.Str(s.ExecutionName)
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completed_at")
			s.CompletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.FailureReason.Set {
			e.FieldStart("failure_reason")
			s.FailureReason.Encode(e)
		}
	}
	{
		if s.FailureMessage.Set {
			e.FieldStart("failure_message")
			s.FailureMessage.Encode(e)
		}
	}
	{
		if s.FailedTaskName.Set {
			e.FieldStart("failed_task_name")
			s.FailedTaskName.Encode(e)
		}
	}
	{
		if s.ErrorDetails.Set {
			e.FieldStart("error_details")
			s.ErrorDetails.Encode(e)
		}
	}
	{
		if s.PipelinerunName.Set {
			e.FieldStart("pipelinerun_name")
			s.PipelinerunName.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowExecutionAuditPayload = [15]string{
	0:  "event_type",
	1:  "workflow_id",
	2:  "workflow_version",
	3:  "target_resource",
	4:  "phase",
	5:  "container_image",
	6:  "execution_name",
	7:  "started_at",
	8:  "completed_at",
	9:  "duration",
	10: "failure_reason",
	11: "failure_message",
	12: "failed_task_name",
	13: "error_details",
	14: "pipelinerun_name",
}

// Decode decodes WorkflowExecutionAuditPayload from json.
func (s *WorkflowExecutionAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionAuditPayload to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "workflow_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "workflow_version":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WorkflowVersion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_version\"")
			}
		case "target_resource":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TargetResource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_resource\"")
			}
		case "phase":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "container_image":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ContainerImage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_image\"")
			}
		case "execution_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ExecutionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_name\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "completed_at":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed_at\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "failure_reason":
			if err := func() error {
				s.FailureReason.Reset()
				if err := s.FailureReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_reason\"")
			}
		case "failure_message":
			if err := func() error {
				s.FailureMessage.Reset()
				if err := s.FailureMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_message\"")
			}
		case "failed_task_name":
			if err := func() error {
				s.FailedTaskName.Reset()
				if err := s.FailedTaskName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_task_name\"")
			}
		case "error_details":
			if err := func() error {
				s.ErrorDetails.Reset()
				if err := s.ErrorDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_details\"")
			}
		case "pipelinerun_name":
			if err := func() error {
				s.PipelinerunName.Reset()
				if err := s.PipelinerunName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pipelinerun_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowExecutionAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowExecutionAuditPayload) {
					name = jsonFieldsNameOfWorkflowExecutionAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowExecutionAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionAuditPayloadEventType as json.
func (s WorkflowExecutionAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionAuditPayloadEventType from json.
func (s *WorkflowExecutionAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionAuditPayloadEventType(v) {
	case WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowStarted:
		*s = WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowStarted
	case WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowCompleted:
		*s = WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowCompleted
	case WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowFailed:
		*s = WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionWorkflowFailed
	case WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionSelectionCompleted:
		*s = WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionSelectionCompleted
	case WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionExecutionStarted:
		*s = WorkflowExecutionAuditPayloadEventTypeWorkflowexecutionExecutionStarted
	default:
		*s = WorkflowExecutionAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionAuditPayloadFailureReason as json.
func (s WorkflowExecutionAuditPayloadFailureReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionAuditPayloadFailureReason from json.
func (s *WorkflowExecutionAuditPayloadFailureReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionAuditPayloadFailureReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionAuditPayloadFailureReason(v) {
	case WorkflowExecutionAuditPayloadFailureReasonOOMKilled:
		*s = WorkflowExecutionAuditPayloadFailureReasonOOMKilled
	case WorkflowExecutionAuditPayloadFailureReasonDeadlineExceeded:
		*s = WorkflowExecutionAuditPayloadFailureReasonDeadlineExceeded
	case WorkflowExecutionAuditPayloadFailureReasonForbidden:
		*s = WorkflowExecutionAuditPayloadFailureReasonForbidden
	case WorkflowExecutionAuditPayloadFailureReasonImagePullBackOff:
		*s = WorkflowExecutionAuditPayloadFailureReasonImagePullBackOff
	case WorkflowExecutionAuditPayloadFailureReasonConfigurationError:
		*s = WorkflowExecutionAuditPayloadFailureReasonConfigurationError
	case WorkflowExecutionAuditPayloadFailureReasonResourceExhausted:
		*s = WorkflowExecutionAuditPayloadFailureReasonResourceExhausted
	case WorkflowExecutionAuditPayloadFailureReasonTaskFailed:
		*s = WorkflowExecutionAuditPayloadFailureReasonTaskFailed
	case WorkflowExecutionAuditPayloadFailureReasonUnknown:
		*s = WorkflowExecutionAuditPayloadFailureReasonUnknown
	default:
		*s = WorkflowExecutionAuditPayloadFailureReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionAuditPayloadFailureReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionAuditPayloadFailureReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionAuditPayloadPhase as json.
func (s WorkflowExecutionAuditPayloadPhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionAuditPayloadPhase from json.
func (s *WorkflowExecutionAuditPayloadPhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionAuditPayloadPhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionAuditPayloadPhase(v) {
	case WorkflowExecutionAuditPayloadPhasePending:
		*s = WorkflowExecutionAuditPayloadPhasePending
	case WorkflowExecutionAuditPayloadPhaseRunning:
		*s = WorkflowExecutionAuditPayloadPhaseRunning
	case WorkflowExecutionAuditPayloadPhaseCompleted:
		*s = WorkflowExecutionAuditPayloadPhaseCompleted
	case WorkflowExecutionAuditPayloadPhaseFailed:
		*s = WorkflowExecutionAuditPayloadPhaseFailed
	default:
		*s = WorkflowExecutionAuditPayloadPhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionAuditPayloadPhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionAuditPayloadPhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowExecutionWebhookAuditPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowExecutionWebhookAuditPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("workflow_name")
		e.Str(s.WorkflowName)
	}
	{
		e.FieldStart("clear_reason")
		e.Str(s.ClearReason)
	}
	{
		e.FieldStart("cleared_at")
		json.EncodeDateTime(e, s.ClearedAt)
	}
	{
		e.FieldStart("previous_state")
		s.PreviousState.Encode(e)
	}
	{
		e.FieldStart("new_state")
		s.NewState.Encode(e)
	}
}

var jsonFieldsNameOfWorkflowExecutionWebhookAuditPayload = [6]string{
	0: "event_type",
	1: "workflow_name",
	2: "clear_reason",
	3: "cleared_at",
	4: "previous_state",
	5: "new_state",
}

// Decode decodes WorkflowExecutionWebhookAuditPayload from json.
func (s *WorkflowExecutionWebhookAuditPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionWebhookAuditPayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "workflow_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_name\"")
			}
		case "clear_reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ClearReason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clear_reason\"")
			}
		case "cleared_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ClearedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cleared_at\"")
			}
		case "previous_state":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.PreviousState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_state\"")
			}
		case "new_state":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.NewState.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowExecutionWebhookAuditPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowExecutionWebhookAuditPayload) {
					name = jsonFieldsNameOfWorkflowExecutionWebhookAuditPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowExecutionWebhookAuditPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionWebhookAuditPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionWebhookAuditPayloadEventType as json.
func (s WorkflowExecutionWebhookAuditPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionWebhookAuditPayloadEventType from json.
func (s *WorkflowExecutionWebhookAuditPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionWebhookAuditPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionWebhookAuditPayloadEventType(v) {
	case WorkflowExecutionWebhookAuditPayloadEventTypeWorkflowexecutionBlockCleared:
		*s = WorkflowExecutionWebhookAuditPayloadEventTypeWorkflowexecutionBlockCleared
	default:
		*s = WorkflowExecutionWebhookAuditPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionWebhookAuditPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionWebhookAuditPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionWebhookAuditPayloadNewState as json.
func (s WorkflowExecutionWebhookAuditPayloadNewState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionWebhookAuditPayloadNewState from json.
func (s *WorkflowExecutionWebhookAuditPayloadNewState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionWebhookAuditPayloadNewState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionWebhookAuditPayloadNewState(v) {
	case WorkflowExecutionWebhookAuditPayloadNewStateRunning:
		*s = WorkflowExecutionWebhookAuditPayloadNewStateRunning
	default:
		*s = WorkflowExecutionWebhookAuditPayloadNewState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionWebhookAuditPayloadNewState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionWebhookAuditPayloadNewState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowExecutionWebhookAuditPayloadPreviousState as json.
func (s WorkflowExecutionWebhookAuditPayloadPreviousState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowExecutionWebhookAuditPayloadPreviousState from json.
func (s *WorkflowExecutionWebhookAuditPayloadPreviousState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowExecutionWebhookAuditPayloadPreviousState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowExecutionWebhookAuditPayloadPreviousState(v) {
	case WorkflowExecutionWebhookAuditPayloadPreviousStateBlocked:
		*s = WorkflowExecutionWebhookAuditPayloadPreviousStateBlocked
	default:
		*s = WorkflowExecutionWebhookAuditPayloadPreviousState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowExecutionWebhookAuditPayloadPreviousState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowExecutionWebhookAuditPayloadPreviousState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowLifecycleRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowLifecycleRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updated_by")
			s.UpdatedBy.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowLifecycleRequest = [2]string{
	0: "reason",
	1: "updated_by",
}

// Decode decodes WorkflowLifecycleRequest from json.
func (s *WorkflowLifecycleRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowLifecycleRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "updated_by":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowLifecycleRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowLifecycleRequest) {
					name = jsonFieldsNameOfWorkflowLifecycleRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowLifecycleRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowLifecycleRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowListResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Workflows != nil {
			e.FieldStart("workflows")
			e.ArrStart()
			for _, elem := range s.Workflows {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowListResponse = [4]string{
	0: "workflows",
	1: "limit",
	2: "offset",
	3: "total",
}

// Decode decodes WorkflowListResponse from json.
func (s *WorkflowListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowListResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflows":
			if err := func() error {
				s.Workflows = make([]RemediationWorkflow, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemediationWorkflow
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Workflows = append(s.Workflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflows\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowListResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowResultAudit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowResultAudit) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_id")
		json.EncodeUUID(e, s.WorkflowID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("rank")
		e.Int32(s.Rank)
	}
	{
		e.FieldStart("scoring")
		s.Scoring.Encode(e)
	}
	{
		if s.Owner.Set {
			e.FieldStart("owner")
			s.Owner.Encode(e)
		}
	}
	{
		if s.Maintainer.Set {
			e.FieldStart("maintainer")
			s.Maintainer.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowResultAudit = [8]string{
	0: "workflow_id",
	1: "title",
	2: "rank",
	3: "scoring",
	4: "owner",
	5: "maintainer",
	6: "description",
	7: "labels",
}

// Decode decodes WorkflowResultAudit from json.
func (s *WorkflowResultAudit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowResultAudit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.WorkflowID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "rank":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Rank = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rank\"")
			}
		case "scoring":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Scoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scoring\"")
			}
		case "owner":
			if err := func() error {
				s.Owner.Reset()
				if err := s.Owner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner\"")
			}
		case "maintainer":
			if err := func() error {
				s.Maintainer.Reset()
				if err := s.Maintainer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowResultAudit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowResultAudit) {
					name = jsonFieldsNameOfWorkflowResultAudit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowResultAudit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowResultAudit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s WorkflowResultAuditLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s WorkflowResultAuditLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes WorkflowResultAuditLabels from json.
func (s *WorkflowResultAuditLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowResultAuditLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowResultAuditLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowResultAuditLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowResultAuditLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowSearchFilters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowSearchFilters) encodeFields(e *jx.Encoder) {
	{
		if s.SignalType.Set {
			e.FieldStart("signal_type")
			s.SignalType.Encode(e)
		}
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("environment")
		e.Str(s.Environment)
	}
	{
		e.FieldStart("priority")
		s.Priority.Encode(e)
	}
	{
		if s.CustomLabels.Set {
			e.FieldStart("custom_labels")
			s.CustomLabels.Encode(e)
		}
	}
	{
		if s.DetectedLabels.Set {
			e.FieldStart("detected_labels")
			s.DetectedLabels.Encode(e)
		}
	}
	{
		if s.Status != nil {
			e.FieldStart("status")
			e.ArrStart()
			for _, elem := range s.Status {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWorkflowSearchFilters = [8]string{
	0: "signal_type",
	1: "severity",
	2: "component",
	3: "environment",
	4: "priority",
	5: "custom_labels",
	6: "detected_labels",
	7: "status",
}

// Decode decodes WorkflowSearchFilters from json.
func (s *WorkflowSearchFilters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowSearchFilters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signal_type":
			if err := func() error {
				s.SignalType.Reset()
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "component":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "environment":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "custom_labels":
			if err := func() error {
				s.CustomLabels.Reset()
				if err := s.CustomLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_labels\"")
			}
		case "detected_labels":
			if err := func() error {
				s.DetectedLabels.Reset()
				if err := s.DetectedLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detected_labels\"")
			}
		case "status":
			if err := func() error {
				s.Status = make([]WorkflowSearchFiltersStatusItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowSearchFiltersStatusItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Status = append(s.Status, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowSearchFilters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowSearchFilters) {
					name = jsonFieldsNameOfWorkflowSearchFilters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowSearchFilters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowSearchFilters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowSearchFiltersPriority as json.
func (s WorkflowSearchFiltersPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowSearchFiltersPriority from json.
func (s *WorkflowSearchFiltersPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowSearchFiltersPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowSearchFiltersPriority(v) {
	case WorkflowSearchFiltersPriorityP0:
		*s = WorkflowSearchFiltersPriorityP0
	case WorkflowSearchFiltersPriorityP1:
		*s = WorkflowSearchFiltersPriorityP1
	case WorkflowSearchFiltersPriorityP2:
		*s = WorkflowSearchFiltersPriorityP2
	case WorkflowSearchFiltersPriorityP3:
		*s = WorkflowSearchFiltersPriorityP3
	default:
		*s = WorkflowSearchFiltersPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowSearchFiltersPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowSearchFiltersPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowSearchFiltersSeverity as json.
func (s WorkflowSearchFiltersSeverity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowSearchFiltersSeverity from json.
func (s *WorkflowSearchFiltersSeverity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowSearchFiltersSeverity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowSearchFiltersSeverity(v) {
	case WorkflowSearchFiltersSeverityCritical:
		*s = WorkflowSearchFiltersSeverityCritical
	case WorkflowSearchFiltersSeverityHigh:
		*s = WorkflowSearchFiltersSeverityHigh
	case WorkflowSearchFiltersSeverityMedium:
		*s = WorkflowSearchFiltersSeverityMedium
	case WorkflowSearchFiltersSeverityLow:
		*s = WorkflowSearchFiltersSeverityLow
	default:
		*s = WorkflowSearchFiltersSeverity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowSearchFiltersSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowSearchFiltersSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowSearchFiltersStatusItem as json.
func (s WorkflowSearchFiltersStatusItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowSearchFiltersStatusItem from json.
func (s *WorkflowSearchFiltersStatusItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowSearchFiltersStatusItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowSearchFiltersStatusItem(v) {
	case WorkflowSearchFiltersStatusItemActive:
		*s = WorkflowSearchFiltersStatusItemActive
	case WorkflowSearchFiltersStatusItemDisabled:
		*s = WorkflowSearchFiltersStatusItemDisabled
	case WorkflowSearchFiltersStatusItemDeprecated:
		*s = WorkflowSearchFiltersStatusItemDeprecated
	case WorkflowSearchFiltersStatusItemArchived:
		*s = WorkflowSearchFiltersStatusItemArchived
	default:
		*s = WorkflowSearchFiltersStatusItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowSearchFiltersStatusItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowSearchFiltersStatusItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.DisabledBy.Set {
			e.FieldStart("disabled_by")
			s.DisabledBy.Encode(e)
		}
	}
	{
		if s.DisabledReason.Set {
			e.FieldStart("disabled_reason")
			s.DisabledReason.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowUpdateRequest = [3]string{
	0: "status",
	1: "disabled_by",
	2: "disabled_reason",
}

// Decode decodes WorkflowUpdateRequest from json.
func (s *WorkflowUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowUpdateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "disabled_by":
			if err := func() error {
				s.DisabledBy.Reset()
				if err := s.DisabledBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_by\"")
			}
		case "disabled_reason":
			if err := func() error {
				s.DisabledReason.Reset()
				if err := s.DisabledReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabled_reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowUpdateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowUpdateRequestStatus as json.
func (s WorkflowUpdateRequestStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowUpdateRequestStatus from json.
func (s *WorkflowUpdateRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowUpdateRequestStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowUpdateRequestStatus(v) {
	case WorkflowUpdateRequestStatusActive:
		*s = WorkflowUpdateRequestStatusActive
	case WorkflowUpdateRequestStatusDisabled:
		*s = WorkflowUpdateRequestStatusDisabled
	case WorkflowUpdateRequestStatusDeprecated:
		*s = WorkflowUpdateRequestStatusDeprecated
	case WorkflowUpdateRequestStatusArchived:
		*s = WorkflowUpdateRequestStatusArchived
	default:
		*s = WorkflowUpdateRequestStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowUpdateRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowUpdateRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowValidationPayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowValidationPayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("event_type")
		s.EventType.Encode(e)
	}
	{
		e.FieldStart("event_id")
		e.Str(s.EventID)
	}
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("attempt")
		e.Int(s.Attempt)
	}
	{
		e.FieldStart("max_attempts")
		e.Int(s.MaxAttempts)
	}
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ValidationErrors.Set {
			e.FieldStart("validation_errors")
			s.ValidationErrors.Encode(e)
		}
	}
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		if s.WorkflowName.Set {
			e.FieldStart("workflow_name")
			s.WorkflowName.Encode(e)
		}
	}
	{
		if s.HumanReviewReason.Set {
			e.FieldStart("human_review_reason")
			s.HumanReviewReason.Encode(e)
		}
	}
	{
		if s.IsFinalAttempt.Set {
			e.FieldStart("is_final_attempt")
			s.IsFinalAttempt.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowValidationPayload = [12]string{
	0:  "event_type",
	1:  "event_id",
	2:  "incident_id",
	3:  "attempt",
	4:  "max_attempts",
	5:  "is_valid",
	6:  "errors",
	7:  "validation_errors",
	8:  "workflow_id",
	9:  "workflow_name",
	10: "human_review_reason",
	11: "is_final_attempt",
}

// Decode decodes WorkflowValidationPayload from json.
func (s *WorkflowValidationPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowValidationPayload to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "event_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EventType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_type\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.EventID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "incident_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "attempt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Attempt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attempt\"")
			}
		case "max_attempts":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaxAttempts = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_attempts\"")
			}
		case "is_valid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "validation_errors":
			if err := func() error {
				s.ValidationErrors.Reset()
				if err := s.ValidationErrors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_errors\"")
			}
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "workflow_name":
			if err := func() error {
				s.WorkflowName.Reset()
				if err := s.WorkflowName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_name\"")
			}
		case "human_review_reason":
			if err := func() error {
				s.HumanReviewReason.Reset()
				if err := s.HumanReviewReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_review_reason\"")
			}
		case "is_final_attempt":
			if err := func() error {
				s.IsFinalAttempt.Reset()
				if err := s.IsFinalAttempt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_final_attempt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowValidationPayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowValidationPayload) {
					name = jsonFieldsNameOfWorkflowValidationPayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowValidationPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowValidationPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowValidationPayloadEventType as json.
func (s WorkflowValidationPayloadEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowValidationPayloadEventType from json.
func (s *WorkflowValidationPayloadEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowValidationPayloadEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowValidationPayloadEventType(v) {
	case WorkflowValidationPayloadEventTypeAiagentWorkflowValidationAttempt:
		*s = WorkflowValidationPayloadEventTypeAiagentWorkflowValidationAttempt
	default:
		*s = WorkflowValidationPayloadEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowValidationPayloadEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowValidationPayloadEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
