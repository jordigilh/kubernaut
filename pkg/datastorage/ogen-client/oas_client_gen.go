// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateAuditEvent invokes createAuditEvent operation.
	//
	// Persists a unified audit event to the audit_events table (ADR-034).
	// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
	// **Behavior**:
	// - Success: Returns 201 Created with event_id
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
	//
	// POST /api/v1/audit/events
	CreateAuditEvent(ctx context.Context, request *AuditEventRequest) (CreateAuditEventRes, error)
	// CreateAuditEventsBatch invokes createAuditEventsBatch operation.
	//
	// Write multiple audit events in a single request.
	//
	// POST /api/v1/audit/events/batch
	CreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (*BatchAuditEventResponse, error)
	// CreateNotificationAudit invokes createNotificationAudit operation.
	//
	// Persists a notification delivery attempt audit record.
	// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
	// **Behavior**:
	// - Success: Returns 201 Created with created record
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Duplicate: Returns 409 Conflict (RFC 7807)
	// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
	// **Metrics Emitted** (GAP-10):
	// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
	// - `datastorage_audit_lag_seconds{service="notification"}`
	// - `datastorage_write_duration_seconds{table="notification_audit"}`
	// - `datastorage_validation_failures_total{field="...", reason="..."}`.
	//
	// POST /api/v1/audit/notifications
	CreateNotificationAudit(ctx context.Context, request *NotificationAudit) (CreateNotificationAuditRes, error)
	// CreateWorkflow invokes createWorkflow operation.
	//
	// Register a new workflow by providing an OCI image pullspec.
	// Data Storage pulls the image, extracts /workflow-schema.yaml (ADR-043),
	// validates the schema, and populates all catalog fields from it.
	// **Business Requirement**: BR-WORKFLOW-017-001 (OCI-based workflow registration)
	// **Design Decision**: DD-WORKFLOW-017 (Workflow Lifecycle Component Interactions).
	//
	// POST /api/v1/workflows
	CreateWorkflow(ctx context.Context, request *CreateWorkflowFromOCIRequest) (CreateWorkflowRes, error)
	// DisableWorkflow invokes disableWorkflow operation.
	//
	// Convenience endpoint to disable a workflow (soft delete).
	// Sets status to 'disabled' with timestamp and reason.
	// **Design Decision**: DD-WORKFLOW-012 (Convenience endpoint for soft-delete).
	//
	// PATCH /api/v1/workflows/{workflow_id}/disable
	DisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (DisableWorkflowRes, error)
	// ExportAuditEvents invokes exportAuditEvents operation.
	//
	// Exports audit events matching the specified filters with cryptographic signatures
	// for tamper detection and compliance verification.
	// **Business Requirement**: BR-AUDIT-007 (Audit Export)
	// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
	// **Behavior**:
	// - Success: Returns 200 OK with signed export (JSON or CSV)
	// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
	// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
	// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
	// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
	// **Export Formats**:
	// - JSON: Complete event data with hash chain verification
	// - CSV: Flattened tabular format for spreadsheet analysis
	// **Hash Chain Verification**:
	// - Each export includes hash chain integrity status
	// - Tampered events flagged with `hash_chain_valid: false`
	// - Chain verification performed at export time
	// **Digital Signature**:
	// - Export signed with service x509 certificate
	// - Signature included in `export_metadata.signature` field
	// - Detached signature available via `include_detached_signature=true`
	// **Pagination**:
	// - Use `offset` and `limit` for large result sets
	// - Maximum limit: 10,000 events per export
	// - Signature covers ALL pages (use same query for verification)
	// **Metrics Emitted**:
	// - `datastorage_export_successes_total{format="json|csv"}`
	// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
	//
	// GET /api/v1/audit/export
	ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (ExportAuditEventsRes, error)
	// GetEffectivenessScore invokes getEffectivenessScore operation.
	//
	// Computes the weighted effectiveness score for a given remediation lifecycle
	// from component audit events in the audit trail.
	// **Architecture**: Per ADR-EM-001 Principle 5, DataStorage computes the overall score.
	// The Effectiveness Monitor emits raw component assessment events; this endpoint
	// aggregates them and applies the DD-017 v2.1 scoring formula:
	// score = (health_score * 0.40 + alert_score * 0.35 + metrics_score * 0.25) / total_weight
	// **Business Requirements**: BR-EM-001 to BR-EM-004
	// **Response includes**:
	// - Weighted overall score (0.0 to 1.0)
	// - Individual component scores (health, alert, metrics)
	// - Hash comparison data (pre/post remediation spec hash per DD-EM-002)
	// - Assessment status (no_data, in_progress, EffectivenessAssessed)
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	//
	// GET /api/v1/effectiveness/{correlation_id}
	GetEffectivenessScore(ctx context.Context, params GetEffectivenessScoreParams) (GetEffectivenessScoreRes, error)
	// GetMetrics invokes getMetrics operation.
	//
	// Exposes Prometheus metrics in text format.
	// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
	// - `datastorage_audit_traces_total{service,status}` - Audit write operations
	// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
	// - `datastorage_write_duration_seconds{table}` - Database write latency
	// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
	//
	// GET /metrics
	GetMetrics(ctx context.Context) (GetMetricsOK, error)
	// GetRemediationHistoryContext invokes getRemediationHistoryContext operation.
	//
	// Returns structured remediation history context for LLM prompt enrichment.
	// **Business Requirements**: BR-HAPI-016 (Remediation history context)
	// **Design Document**: DD-HAPI-016
	// **Behavior**:
	// Aggregates `remediation.workflow_created` (RO) and `effectiveness.assessment.completed` (EM)
	// audit events into structured remediation chains for a target resource.
	// **Two-Tier Query Design**:
	// - **Tier 1** (default 24h): Detailed remediation chain with health checks, metric deltas,
	// and full effectiveness data for the target resource.
	// - **Tier 2** (default 90d): Summary chain activated when `currentSpecHash` matches a
	// historical `preRemediationSpecHash` beyond the Tier 1 window, indicating configuration
	// regression.
	// **Hash Comparison**: For each entry, performs three-way comparison of `currentSpecHash`
	// against `preRemediationSpecHash` and `postRemediationSpecHash`.
	// **Regression Detection**: Sets `regressionDetected: true` if any entry's
	// `preRemediationSpecHash` matches `currentSpecHash`.
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	// Integration tests use mock X-Auth-Request-User header.
	//
	// GET /api/v1/remediation-history/context
	GetRemediationHistoryContext(ctx context.Context, params GetRemediationHistoryContextParams) (GetRemediationHistoryContextRes, error)
	// GetWorkflowByID invokes getWorkflowByID operation.
	//
	// Retrieve a specific workflow by its UUID.
	// Step 3 of the three-step workflow discovery protocol when context filters are provided.
	// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key)
	// **Security Gate**: DD-WORKFLOW-016, DD-HAPI-017
	// **Without context filters**: Returns workflow by ID (existing behavior).
	// **With context filters**: Returns workflow only if it matches the signal context.
	// Returns 404 if the workflow exists but does not match the context filters
	// (security gate - prevents info leakage by not distinguishing "not found" from "filtered out").
	// Emits `workflow.catalog.workflow_retrieved` audit event when context filters are present.
	//
	// GET /api/v1/workflows/{workflow_id}
	GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (GetWorkflowByIDRes, error)
	// HealthCheck invokes healthCheck operation.
	//
	// Returns 200 if service is healthy (database and Redis reachable).
	// Used by Kubernetes liveness probe (DD-007).
	//
	// GET /health
	HealthCheck(ctx context.Context) (HealthCheckRes, error)
	// ListAvailableActions invokes listAvailableActions operation.
	//
	// Step 1 of the three-step workflow discovery protocol.
	// Returns action types from the taxonomy that have active workflows matching
	// the provided signal context filters.
	// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
	// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
	// **Behavior**:
	// - Queries action_type_taxonomy joined with remediation_workflow_catalog
	// - Filters by active workflows matching signal context (severity, component, environment, priority)
	// - Returns action types with descriptions and workflow counts
	// - Paginated (default 10 per page)
	// - Emits `workflow.catalog.actions_listed` audit event (DD-WORKFLOW-014 v3.0).
	//
	// GET /api/v1/workflows/actions
	ListAvailableActions(ctx context.Context, params ListAvailableActionsParams) (ListAvailableActionsRes, error)
	// ListLegalHolds invokes listLegalHolds operation.
	//
	// Returns a list of all active legal holds across all audit events.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with array of active legal holds
	// - No holds: Returns empty array
	// **Authorization**: No authentication required (read-only operation)
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="list"}`.
	//
	// GET /api/v1/audit/legal-hold
	ListLegalHolds(ctx context.Context) (*ListLegalHoldsOK, error)
	// ListWorkflows invokes listWorkflows operation.
	//
	// List workflows with optional filters and pagination.
	// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
	//
	// GET /api/v1/workflows
	ListWorkflows(ctx context.Context, params ListWorkflowsParams) (ListWorkflowsRes, error)
	// ListWorkflowsByActionType invokes listWorkflowsByActionType operation.
	//
	// Step 2 of the three-step workflow discovery protocol.
	// Returns all active workflows matching the specified action type and
	// signal context filters.
	// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
	// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
	// **LLM Instruction**: The LLM MUST review ALL workflows (across all pages)
	// before selecting one. Do not select from an incomplete list.
	// **Behavior**:
	// - Filters by action_type + signal context (severity, component, environment, priority)
	// - Excludes disabled and deprecated workflows
	// - Returns workflow metadata including effectiveness data
	// - Paginated (default 10 per page)
	// - Emits `workflow.catalog.workflows_listed` audit event (DD-WORKFLOW-014 v3.0).
	//
	// GET /api/v1/workflows/actions/{action_type}
	ListWorkflowsByActionType(ctx context.Context, params ListWorkflowsByActionTypeParams) (ListWorkflowsByActionTypeRes, error)
	// LivenessCheck invokes livenessCheck operation.
	//
	// Returns 200 if service process is alive.
	// Does not check dependencies.
	// Used by Kubernetes liveness probe.
	//
	// GET /health/live
	LivenessCheck(ctx context.Context) error
	// PlaceLegalHold invokes placeLegalHold operation.
	//
	// Places a legal hold on all audit events for a given correlation_id.
	// Events with legal hold cannot be deleted (enforced by database trigger).
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
	// **Behavior**:
	// - Success: Returns 200 OK with legal hold metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who placed the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="place"}`
	// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
	//
	// POST /api/v1/audit/legal-hold
	PlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (PlaceLegalHoldRes, error)
	// QueryAuditEvents invokes queryAuditEvents operation.
	//
	// Query audit events with filters and pagination.
	//
	// GET /api/v1/audit/events
	QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (*AuditEventsQueryResponse, error)
	// ReadinessCheck invokes readinessCheck operation.
	//
	// Returns 200 if service is ready to accept traffic.
	// Returns 503 during graceful shutdown (DD-007 4-step pattern).
	// Used by Kubernetes readiness probe.
	//
	// GET /health/ready
	ReadinessCheck(ctx context.Context) (ReadinessCheckRes, error)
	// ReconstructRemediationRequest invokes reconstructRemediationRequest operation.
	//
	// Reconstructs a complete RemediationRequest CRD from audit trail events.
	// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
	// **Workflow**:
	// 1. Query audit events for given correlation_id
	// 2. Parse gateway and orchestrator events
	// 3. Map audit data to RR Spec/Status fields
	// 4. Build complete Kubernetes-compliant CRD
	// 5. Validate completeness and quality
	// **Use Cases**:
	// - Disaster recovery (recreate lost RRs from audit trail)
	// - Compliance audits (prove RR state at any point in time)
	// - Debugging (understand RR evolution from audit events)
	// **Returns**:
	// - Reconstructed RR in YAML format
	// - Validation result (completeness percentage, warnings, errors)
	// **Authentication**: Protected by OAuth-proxy in production/E2E.
	// Integration tests use mock X-Auth-Request-User header.
	//
	// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
	ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (ReconstructRemediationRequestRes, error)
	// ReleaseLegalHold invokes releaseLegalHold operation.
	//
	// Releases a legal hold on all audit events for a given correlation_id.
	// Events can be deleted after legal hold is released.
	// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
	// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
	// **Behavior**:
	// - Success: Returns 200 OK with release metadata
	// - Validation Error: Returns 400 Bad Request (RFC 7807)
	// - Not Found: Returns 404 Not Found if legal hold doesn't exist
	// - Unauthorized: Returns 401 if X-User-ID header missing
	// **Authorization**: Requires X-User-ID header to track who released the hold
	// **Metrics Emitted**:
	// - `datastorage_legal_hold_successes_total{operation="release"}`
	// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
	//
	// DELETE /api/v1/audit/legal-hold/{correlation_id}
	ReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (ReleaseLegalHoldRes, error)
	// UpdateWorkflow invokes updateWorkflow operation.
	//
	// Update mutable workflow fields (status, metrics).
	// Immutable fields (description, content, labels) require creating a new version.
	// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
	//
	// PATCH /api/v1/workflows/{workflow_id}
	UpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (UpdateWorkflowRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateAuditEvent invokes createAuditEvent operation.
//
// Persists a unified audit event to the audit_events table (ADR-034).
// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
// **Behavior**:
// - Success: Returns 201 Created with event_id
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
//
// POST /api/v1/audit/events
func (c *Client) CreateAuditEvent(ctx context.Context, request *AuditEventRequest) (CreateAuditEventRes, error) {
	res, err := c.sendCreateAuditEvent(ctx, request)
	return res, err
}

func (c *Client) sendCreateAuditEvent(ctx context.Context, request *AuditEventRequest) (res CreateAuditEventRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAuditEvent"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/events"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAuditEventOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAuditEventRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAuditEventResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAuditEventsBatch invokes createAuditEventsBatch operation.
//
// Write multiple audit events in a single request.
//
// POST /api/v1/audit/events/batch
func (c *Client) CreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (*BatchAuditEventResponse, error) {
	res, err := c.sendCreateAuditEventsBatch(ctx, request)
	return res, err
}

func (c *Client) sendCreateAuditEventsBatch(ctx context.Context, request []AuditEventRequest) (res *BatchAuditEventResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createAuditEventsBatch"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/events/batch"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAuditEventsBatchOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events/batch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAuditEventsBatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAuditEventsBatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNotificationAudit invokes createNotificationAudit operation.
//
// Persists a notification delivery attempt audit record.
// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
// **Behavior**:
// - Success: Returns 201 Created with created record
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Duplicate: Returns 409 Conflict (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
// **Metrics Emitted** (GAP-10):
// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
// - `datastorage_audit_lag_seconds{service="notification"}`
// - `datastorage_write_duration_seconds{table="notification_audit"}`
// - `datastorage_validation_failures_total{field="...", reason="..."}`.
//
// POST /api/v1/audit/notifications
func (c *Client) CreateNotificationAudit(ctx context.Context, request *NotificationAudit) (CreateNotificationAuditRes, error) {
	res, err := c.sendCreateNotificationAudit(ctx, request)
	return res, err
}

func (c *Client) sendCreateNotificationAudit(ctx context.Context, request *NotificationAudit) (res CreateNotificationAuditRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createNotificationAudit"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/notifications"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateNotificationAuditOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNotificationAuditRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateNotificationAuditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWorkflow invokes createWorkflow operation.
//
// Register a new workflow by providing an OCI image pullspec.
// Data Storage pulls the image, extracts /workflow-schema.yaml (ADR-043),
// validates the schema, and populates all catalog fields from it.
// **Business Requirement**: BR-WORKFLOW-017-001 (OCI-based workflow registration)
// **Design Decision**: DD-WORKFLOW-017 (Workflow Lifecycle Component Interactions).
//
// POST /api/v1/workflows
func (c *Client) CreateWorkflow(ctx context.Context, request *CreateWorkflowFromOCIRequest) (CreateWorkflowRes, error) {
	res, err := c.sendCreateWorkflow(ctx, request)
	return res, err
}

func (c *Client) sendCreateWorkflow(ctx context.Context, request *CreateWorkflowFromOCIRequest) (res CreateWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createWorkflow"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/workflows"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisableWorkflow invokes disableWorkflow operation.
//
// Convenience endpoint to disable a workflow (soft delete).
// Sets status to 'disabled' with timestamp and reason.
// **Design Decision**: DD-WORKFLOW-012 (Convenience endpoint for soft-delete).
//
// PATCH /api/v1/workflows/{workflow_id}/disable
func (c *Client) DisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (DisableWorkflowRes, error) {
	res, err := c.sendDisableWorkflow(ctx, request, params)
	return res, err
}

func (c *Client) sendDisableWorkflow(ctx context.Context, request OptWorkflowDisableRequest, params DisableWorkflowParams) (res DisableWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("disableWorkflow"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}/disable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DisableWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/disable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDisableWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDisableWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportAuditEvents invokes exportAuditEvents operation.
//
// Exports audit events matching the specified filters with cryptographic signatures
// for tamper detection and compliance verification.
// **Business Requirement**: BR-AUDIT-007 (Audit Export)
// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
// **Behavior**:
// - Success: Returns 200 OK with signed export (JSON or CSV)
// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
// **Export Formats**:
// - JSON: Complete event data with hash chain verification
// - CSV: Flattened tabular format for spreadsheet analysis
// **Hash Chain Verification**:
// - Each export includes hash chain integrity status
// - Tampered events flagged with `hash_chain_valid: false`
// - Chain verification performed at export time
// **Digital Signature**:
// - Export signed with service x509 certificate
// - Signature included in `export_metadata.signature` field
// - Detached signature available via `include_detached_signature=true`
// **Pagination**:
// - Use `offset` and `limit` for large result sets
// - Maximum limit: 10,000 events per export
// - Signature covers ALL pages (use same query for verification)
// **Metrics Emitted**:
// - `datastorage_export_successes_total{format="json|csv"}`
// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
//
// GET /api/v1/audit/export
func (c *Client) ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (ExportAuditEventsRes, error) {
	res, err := c.sendExportAuditEvents(ctx, params)
	return res, err
}

func (c *Client) sendExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (res ExportAuditEventsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exportAuditEvents"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/export"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExportAuditEventsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/export"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_time" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EndTime.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "correlation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "correlation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CorrelationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Format.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_detached_signature" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_detached_signature",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeDetachedSignature.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "redact_pii" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redact_pii",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RedactPii.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExportAuditEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEffectivenessScore invokes getEffectivenessScore operation.
//
// Computes the weighted effectiveness score for a given remediation lifecycle
// from component audit events in the audit trail.
// **Architecture**: Per ADR-EM-001 Principle 5, DataStorage computes the overall score.
// The Effectiveness Monitor emits raw component assessment events; this endpoint
// aggregates them and applies the DD-017 v2.1 scoring formula:
// score = (health_score * 0.40 + alert_score * 0.35 + metrics_score * 0.25) / total_weight
// **Business Requirements**: BR-EM-001 to BR-EM-004
// **Response includes**:
// - Weighted overall score (0.0 to 1.0)
// - Individual component scores (health, alert, metrics)
// - Hash comparison data (pre/post remediation spec hash per DD-EM-002)
// - Assessment status (no_data, in_progress, EffectivenessAssessed)
// **Authentication**: Protected by OAuth-proxy in production/E2E.
//
// GET /api/v1/effectiveness/{correlation_id}
func (c *Client) GetEffectivenessScore(ctx context.Context, params GetEffectivenessScoreParams) (GetEffectivenessScoreRes, error) {
	res, err := c.sendGetEffectivenessScore(ctx, params)
	return res, err
}

func (c *Client) sendGetEffectivenessScore(ctx context.Context, params GetEffectivenessScoreParams) (res GetEffectivenessScoreRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getEffectivenessScore"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/effectiveness/{correlation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEffectivenessScoreOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/effectiveness/"
	{
		// Encode "correlation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "correlation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CorrelationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEffectivenessScoreResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMetrics invokes getMetrics operation.
//
// Exposes Prometheus metrics in text format.
// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
// - `datastorage_audit_traces_total{service,status}` - Audit write operations
// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
// - `datastorage_write_duration_seconds{table}` - Database write latency
// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
//
// GET /metrics
func (c *Client) GetMetrics(ctx context.Context) (GetMetricsOK, error) {
	res, err := c.sendGetMetrics(ctx)
	return res, err
}

func (c *Client) sendGetMetrics(ctx context.Context) (res GetMetricsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getMetrics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/metrics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMetricsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRemediationHistoryContext invokes getRemediationHistoryContext operation.
//
// Returns structured remediation history context for LLM prompt enrichment.
// **Business Requirements**: BR-HAPI-016 (Remediation history context)
// **Design Document**: DD-HAPI-016
// **Behavior**:
// Aggregates `remediation.workflow_created` (RO) and `effectiveness.assessment.completed` (EM)
// audit events into structured remediation chains for a target resource.
// **Two-Tier Query Design**:
// - **Tier 1** (default 24h): Detailed remediation chain with health checks, metric deltas,
// and full effectiveness data for the target resource.
// - **Tier 2** (default 90d): Summary chain activated when `currentSpecHash` matches a
// historical `preRemediationSpecHash` beyond the Tier 1 window, indicating configuration
// regression.
// **Hash Comparison**: For each entry, performs three-way comparison of `currentSpecHash`
// against `preRemediationSpecHash` and `postRemediationSpecHash`.
// **Regression Detection**: Sets `regressionDetected: true` if any entry's
// `preRemediationSpecHash` matches `currentSpecHash`.
// **Authentication**: Protected by OAuth-proxy in production/E2E.
// Integration tests use mock X-Auth-Request-User header.
//
// GET /api/v1/remediation-history/context
func (c *Client) GetRemediationHistoryContext(ctx context.Context, params GetRemediationHistoryContextParams) (GetRemediationHistoryContextRes, error) {
	res, err := c.sendGetRemediationHistoryContext(ctx, params)
	return res, err
}

func (c *Client) sendGetRemediationHistoryContext(ctx context.Context, params GetRemediationHistoryContextParams) (res GetRemediationHistoryContextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getRemediationHistoryContext"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/remediation-history/context"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetRemediationHistoryContextOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/remediation-history/context"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "targetKind" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetKind",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.TargetKind))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "targetName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.TargetName))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "targetNamespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "targetNamespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.TargetNamespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "currentSpecHash" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "currentSpecHash",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CurrentSpecHash))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tier1Window" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tier1Window",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tier1Window.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tier2Window" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tier2Window",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Tier2Window.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRemediationHistoryContextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkflowByID invokes getWorkflowByID operation.
//
// Retrieve a specific workflow by its UUID.
// Step 3 of the three-step workflow discovery protocol when context filters are provided.
// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key)
// **Security Gate**: DD-WORKFLOW-016, DD-HAPI-017
// **Without context filters**: Returns workflow by ID (existing behavior).
// **With context filters**: Returns workflow only if it matches the signal context.
// Returns 404 if the workflow exists but does not match the context filters
// (security gate - prevents info leakage by not distinguishing "not found" from "filtered out").
// Emits `workflow.catalog.workflow_retrieved` audit event when context filters are present.
//
// GET /api/v1/workflows/{workflow_id}
func (c *Client) GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (GetWorkflowByIDRes, error) {
	res, err := c.sendGetWorkflowByID(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (res GetWorkflowByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getWorkflowByID"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkflowByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "severity" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "severity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Severity.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Component.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Environment.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "priority" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "priority",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Priority.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "custom_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detected_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detected_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetectedLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "remediation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "remediation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RemediationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkflowByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthCheck invokes healthCheck operation.
//
// Returns 200 if service is healthy (database and Redis reachable).
// Used by Kubernetes liveness probe (DD-007).
//
// GET /health
func (c *Client) HealthCheck(ctx context.Context) (HealthCheckRes, error) {
	res, err := c.sendHealthCheck(ctx)
	return res, err
}

func (c *Client) sendHealthCheck(ctx context.Context) (res HealthCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("healthCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HealthCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHealthCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListAvailableActions invokes listAvailableActions operation.
//
// Step 1 of the three-step workflow discovery protocol.
// Returns action types from the taxonomy that have active workflows matching
// the provided signal context filters.
// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
// **Behavior**:
// - Queries action_type_taxonomy joined with remediation_workflow_catalog
// - Filters by active workflows matching signal context (severity, component, environment, priority)
// - Returns action types with descriptions and workflow counts
// - Paginated (default 10 per page)
// - Emits `workflow.catalog.actions_listed` audit event (DD-WORKFLOW-014 v3.0).
//
// GET /api/v1/workflows/actions
func (c *Client) ListAvailableActions(ctx context.Context, params ListAvailableActionsParams) (ListAvailableActionsRes, error) {
	res, err := c.sendListAvailableActions(ctx, params)
	return res, err
}

func (c *Client) sendListAvailableActions(ctx context.Context, params ListAvailableActionsParams) (res ListAvailableActionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listAvailableActions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows/actions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListAvailableActionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows/actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "severity" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "severity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Severity)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Component))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Environment))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "priority" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "priority",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Priority)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "custom_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detected_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detected_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetectedLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "remediation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "remediation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RemediationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListAvailableActionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListLegalHolds invokes listLegalHolds operation.
//
// Returns a list of all active legal holds across all audit events.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with array of active legal holds
// - No holds: Returns empty array
// **Authorization**: No authentication required (read-only operation)
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="list"}`.
//
// GET /api/v1/audit/legal-hold
func (c *Client) ListLegalHolds(ctx context.Context) (*ListLegalHoldsOK, error) {
	res, err := c.sendListLegalHolds(ctx)
	return res, err
}

func (c *Client) sendListLegalHolds(ctx context.Context) (res *ListLegalHoldsOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listLegalHolds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListLegalHoldsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/legal-hold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListLegalHoldsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflows invokes listWorkflows operation.
//
// List workflows with optional filters and pagination.
// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
//
// GET /api/v1/workflows
func (c *Client) ListWorkflows(ctx context.Context, params ListWorkflowsParams) (ListWorkflowsRes, error) {
	res, err := c.sendListWorkflows(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflows(ctx context.Context, params ListWorkflowsParams) (res ListWorkflowsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listWorkflows"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWorkflowsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/workflows"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Environment.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "priority" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "priority",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Priority.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Component.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "workflow_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "workflow_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WorkflowName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWorkflowsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWorkflowsByActionType invokes listWorkflowsByActionType operation.
//
// Step 2 of the three-step workflow discovery protocol.
// Returns all active workflows matching the specified action type and
// signal context filters.
// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
// **LLM Instruction**: The LLM MUST review ALL workflows (across all pages)
// before selecting one. Do not select from an incomplete list.
// **Behavior**:
// - Filters by action_type + signal context (severity, component, environment, priority)
// - Excludes disabled and deprecated workflows
// - Returns workflow metadata including effectiveness data
// - Paginated (default 10 per page)
// - Emits `workflow.catalog.workflows_listed` audit event (DD-WORKFLOW-014 v3.0).
//
// GET /api/v1/workflows/actions/{action_type}
func (c *Client) ListWorkflowsByActionType(ctx context.Context, params ListWorkflowsByActionTypeParams) (ListWorkflowsByActionTypeRes, error) {
	res, err := c.sendListWorkflowsByActionType(ctx, params)
	return res, err
}

func (c *Client) sendListWorkflowsByActionType(ctx context.Context, params ListWorkflowsByActionTypeParams) (res ListWorkflowsByActionTypeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listWorkflowsByActionType"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/workflows/actions/{action_type}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWorkflowsByActionTypeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/workflows/actions/"
	{
		// Encode "action_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "action_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ActionType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "severity" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "severity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Severity)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Component))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "environment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Environment))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "priority" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "priority",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Priority)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "custom_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "custom_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CustomLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "detected_labels" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detected_labels",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DetectedLabels.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "remediation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "remediation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RemediationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWorkflowsByActionTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LivenessCheck invokes livenessCheck operation.
//
// Returns 200 if service process is alive.
// Does not check dependencies.
// Used by Kubernetes liveness probe.
//
// GET /health/live
func (c *Client) LivenessCheck(ctx context.Context) error {
	_, err := c.sendLivenessCheck(ctx)
	return err
}

func (c *Client) sendLivenessCheck(ctx context.Context) (res *LivenessCheckOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("livenessCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/live"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, LivenessCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/live"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeLivenessCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PlaceLegalHold invokes placeLegalHold operation.
//
// Places a legal hold on all audit events for a given correlation_id.
// Events with legal hold cannot be deleted (enforced by database trigger).
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
// **Behavior**:
// - Success: Returns 200 OK with legal hold metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who placed the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="place"}`
// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
//
// POST /api/v1/audit/legal-hold
func (c *Client) PlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (PlaceLegalHoldRes, error) {
	res, err := c.sendPlaceLegalHold(ctx, request)
	return res, err
}

func (c *Client) sendPlaceLegalHold(ctx context.Context, request *PlaceLegalHoldReq) (res PlaceLegalHoldRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("placeLegalHold"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PlaceLegalHoldOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/legal-hold"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePlaceLegalHoldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePlaceLegalHoldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// QueryAuditEvents invokes queryAuditEvents operation.
//
// Query audit events with filters and pagination.
//
// GET /api/v1/audit/events
func (c *Client) QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (*AuditEventsQueryResponse, error) {
	res, err := c.sendQueryAuditEvents(ctx, params)
	return res, err
}

func (c *Client) sendQueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (res *AuditEventsQueryResponse, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("queryAuditEvents"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/audit/events"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, QueryAuditEventsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/audit/events"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "event_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventCategory.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "event_outcome" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "event_outcome",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EventOutcome.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "severity" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "severity",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Severity.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "correlation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "correlation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CorrelationID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeQueryAuditEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadinessCheck invokes readinessCheck operation.
//
// Returns 200 if service is ready to accept traffic.
// Returns 503 during graceful shutdown (DD-007 4-step pattern).
// Used by Kubernetes readiness probe.
//
// GET /health/ready
func (c *Client) ReadinessCheck(ctx context.Context) (ReadinessCheckRes, error) {
	res, err := c.sendReadinessCheck(ctx)
	return res, err
}

func (c *Client) sendReadinessCheck(ctx context.Context) (res ReadinessCheckRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("readinessCheck"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health/ready"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReadinessCheckOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health/ready"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReadinessCheckResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReconstructRemediationRequest invokes reconstructRemediationRequest operation.
//
// Reconstructs a complete RemediationRequest CRD from audit trail events.
// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
// **Workflow**:
// 1. Query audit events for given correlation_id
// 2. Parse gateway and orchestrator events
// 3. Map audit data to RR Spec/Status fields
// 4. Build complete Kubernetes-compliant CRD
// 5. Validate completeness and quality
// **Use Cases**:
// - Disaster recovery (recreate lost RRs from audit trail)
// - Compliance audits (prove RR state at any point in time)
// - Debugging (understand RR evolution from audit events)
// **Returns**:
// - Reconstructed RR in YAML format
// - Validation result (completeness percentage, warnings, errors)
// **Authentication**: Protected by OAuth-proxy in production/E2E.
// Integration tests use mock X-Auth-Request-User header.
//
// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
func (c *Client) ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (ReconstructRemediationRequestRes, error) {
	res, err := c.sendReconstructRemediationRequest(ctx, params)
	return res, err
}

func (c *Client) sendReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (res ReconstructRemediationRequestRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("reconstructRemediationRequest"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/audit/remediation-requests/{correlation_id}/reconstruct"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReconstructRemediationRequestOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/audit/remediation-requests/"
	{
		// Encode "correlation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "correlation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CorrelationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/reconstruct"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReconstructRemediationRequestResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReleaseLegalHold invokes releaseLegalHold operation.
//
// Releases a legal hold on all audit events for a given correlation_id.
// Events can be deleted after legal hold is released.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with release metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if legal hold doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who released the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="release"}`
// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
//
// DELETE /api/v1/audit/legal-hold/{correlation_id}
func (c *Client) ReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (ReleaseLegalHoldRes, error) {
	res, err := c.sendReleaseLegalHold(ctx, request, params)
	return res, err
}

func (c *Client) sendReleaseLegalHold(ctx context.Context, request *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (res ReleaseLegalHoldRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("releaseLegalHold"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/audit/legal-hold/{correlation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ReleaseLegalHoldOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/audit/legal-hold/"
	{
		// Encode "correlation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "correlation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CorrelationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeReleaseLegalHoldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeReleaseLegalHoldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkflow invokes updateWorkflow operation.
//
// Update mutable workflow fields (status, metrics).
// Immutable fields (description, content, labels) require creating a new version.
// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
//
// PATCH /api/v1/workflows/{workflow_id}
func (c *Client) UpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (UpdateWorkflowRes, error) {
	res, err := c.sendUpdateWorkflow(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWorkflow(ctx context.Context, request *WorkflowUpdateRequest, params UpdateWorkflowParams) (res UpdateWorkflowRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("updateWorkflow"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/v1/workflows/{workflow_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateWorkflowOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/workflows/"
	{
		// Encode "workflow_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workflow_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WorkflowID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkflowRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateWorkflowResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
