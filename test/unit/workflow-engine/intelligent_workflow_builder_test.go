package workflowengine

import (
	"testing"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/shared/types"
	testconfig "github.com/jordigilh/kubernaut/pkg/testutil/config"
	"github.com/jordigilh/kubernaut/pkg/workflow/engine"
)

// Suite structure moved to workflow_engine_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Intelligent Workflow Builder - Business Requirements Testing", func() {
	var (
		logger *logrus.Logger
	)

	BeforeEach(func() {
		// Following guideline: reuse existing test framework patterns
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel) // Reduce test noise
	})

	Context("Development Guidelines Compliance Validation", func() {
		It("validates workflow type structures follow existing patterns", func() {
			// This test validates compliance with development guidelines
			// Following guideline: "reuse code whenever possible"

			// When: Creating basic workflow structures using existing types
			workflow := &engine.Workflow{
				BaseVersionedEntity: types.BaseVersionedEntity{
					BaseEntity: types.BaseEntity{
						ID:          "test-workflow-001",
						Name:        "TestWorkflow",
						Description: "Basic workflow for business validation",
						Metadata:    make(map[string]interface{}),
					},
					Version: "1.0.0",
				},
				Status: engine.StatusPending,
			}

			// Then: Verify structure follows existing patterns
			Expect(workflow.ID).To(Equal("test-workflow-001"),
				"Workflow should use standard BaseEntity structure")
			Expect(workflow.Name).To(Equal("TestWorkflow"),
				"Workflow should preserve business identification")
			Expect(workflow.Version).To(Equal("1.0.0"),
				"Workflow should use semantic versioning")
			Expect(workflow.Status).To(Equal(engine.StatusPending),
				"Workflow should use defined status constants")
		})

		It("validates executable template structures follow business requirements", func() {
			// Following guideline: "test actual business requirement expectations"

			// Given: An executable template with business context
			template := &engine.ExecutableTemplate{
				BaseVersionedEntity: types.BaseVersionedEntity{
					BaseEntity: types.BaseEntity{
						ID:          "business-template-001",
						Name:        "DatabaseMaintenanceTemplate",
						Description: "Template for scheduled database maintenance operations",
						Metadata: map[string]interface{}{
							"business_impact":   "medium",
							"owner_team":        "database-team",
							"approval_required": true,
						},
					},
					Version: "1.0.0",
				},
				Steps: []*engine.ExecutableWorkflowStep{
					{
						BaseEntity: types.BaseEntity{
							ID:          "step-001",
							Name:        "backup_database",
							Description: "Create database backup before maintenance",
							Metadata:    make(map[string]interface{}),
						},
						Type: engine.StepTypeAction,
						Action: &engine.StepAction{
							Type: "database_backup",
							Parameters: map[string]interface{}{
								"database": "production-db",
								"verify":   true,
							},
						},
						Timeout: 30 * time.Minute,
					},
					{
						BaseEntity: types.BaseEntity{
							ID:          "step-002",
							Name:        "validate_backup",
							Description: "Verify backup completion and integrity",
							Metadata:    make(map[string]interface{}),
						},
						Type: engine.StepTypeCondition,
						Condition: &engine.ExecutableCondition{
							ID:         "backup-validation",
							Name:       "backup_integrity_check",
							Type:       engine.ConditionTypeCustom,
							Expression: "backup_status == 'completed' AND backup_verified == true",
						},
						Dependencies: []string{"step-001"},
					},
				},
				Variables: map[string]interface{}{
					"maintenance_window": "2h",
					"max_downtime":       "30m",
				},
				Tags: []string{"database", "maintenance", "production"},
			}

			// When: Validating template structure
			Expect(template.Name).To(Equal("DatabaseMaintenanceTemplate"),
				"Template should have meaningful business name")
			Expect(len(template.Steps)).To(Equal(2),
				"Template should contain defined business steps")
			Expect(template.Metadata).To(HaveKey("business_impact"),
				"Template should include business impact metadata")

			// Business validation: Steps should follow proper structure
			backupStep := template.Steps[0]
			Expect(backupStep.Type).To(Equal(engine.StepTypeAction),
				"Business action steps should be properly typed")
			Expect(backupStep.Action.Type).To(Equal("database_backup"),
				"Business actions should have meaningful types")

			validationStep := template.Steps[1]
			Expect(validationStep.Type).To(Equal(engine.StepTypeCondition),
				"Business validation steps should be properly typed")
			Expect(len(validationStep.Dependencies)).To(Equal(1),
				"Business steps should define proper dependencies")

			// Following guideline: ALWAYS log important business events
			logger.WithFields(logrus.Fields{
				"template_name":   template.Name,
				"step_count":      len(template.Steps),
				"business_impact": template.Metadata["business_impact"],
			}).Info("Workflow template validation completed successfully")
		})

		It("tests business value not implementation details", func() {
			// This test validates we're testing business requirements, not implementation
			// Following guideline: "test actual business requirement expectations"

			// Given: A workflow with business metadata
			workflow := &engine.Workflow{
				BaseVersionedEntity: types.BaseVersionedEntity{
					BaseEntity: types.BaseEntity{
						ID:          "business-workflow-001",
						Name:        "CriticalSystemMaintenance",
						Description: "Critical system maintenance with business compliance requirements",
						Metadata: map[string]interface{}{
							"business_priority":      "high",
							"compliance_required":    true,
							"estimated_duration":     "2h",
							"failure_notification":   []string{"database-team", "operations-team"},
							"business_justification": "system performance degradation",
						},
					},
					Version: "2.1.0",
				},
				Status: engine.StatusPending,
			}

			// When: Validating business context
			// Following guideline: avoid weak assertions like "not nil", use specific business validations
			Expect(workflow.Metadata["business_priority"]).To(Equal("high"),
				"Business priority should be properly preserved in workflow metadata")

			complianceRequired := workflow.Metadata["compliance_required"].(bool)
			Expect(complianceRequired).To(BeTrue(),
				"Compliance requirements should be tracked for business operations")

			notificationTeams := workflow.Metadata["failure_notification"].([]string)
			testconfig.ExpectBusinessRequirement(len(notificationTeams),
				"BR-WF-001-NOTIFICATION-TEAMS", "test",
				"failure notification team count for business continuity")

			// Business requirement validation: Version should follow semantic versioning
			Expect(workflow.Version).To(MatchRegexp(`^\d+\.\d+\.\d+$`),
				"Workflow version should follow semantic versioning for business change tracking")

			// Following guideline: ALWAYS log important business events
			logger.WithFields(logrus.Fields{
				"workflow_id":            workflow.ID,
				"business_priority":      workflow.Metadata["business_priority"],
				"compliance_required":    workflow.Metadata["compliance_required"],
				"business_justification": workflow.Metadata["business_justification"],
			}).Info("Business workflow validation completed successfully")
		})
	})

	Context("BR-WF-001: Basic Workflow Structure Management", func() {
		It("should define workflow structures with proper business constraints", func() {
			// Given: Business requirements for workflow structure
			workflow := &engine.Workflow{
				BaseVersionedEntity: types.BaseVersionedEntity{
					BaseEntity: types.BaseEntity{
						ID:          "structured-workflow-001",
						Name:        "ProductionMaintenanceWorkflow",
						Description: "Structured production maintenance workflow with business safeguards",
						Metadata: map[string]interface{}{
							"max_execution_time":  "4h",
							"business_impact":     "medium",
							"requires_approval":   true,
							"rollback_capability": true,
							"notification_policy": "immediate",
							"business_owner":      "operations-team",
						},
					},
					Version: "1.0.0",
				},
				Status: engine.StatusPending,
				Template: &engine.ExecutableTemplate{
					BaseVersionedEntity: types.BaseVersionedEntity{
						BaseEntity: types.BaseEntity{
							ID:          "maintenance-template-001",
							Name:        "ProductionMaintenanceTemplate",
							Description: "Template for production maintenance operations",
						},
						Version: "1.0.0",
					},
					Variables: map[string]interface{}{
						"max_downtime_minutes":       5, // BR-WF-001-MAX-DOWNTIME-MINUTES: Business continuity requirement
						"health_check_interval":      "2m",
						"rollback_trigger_threshold": 0.5,
					},
					Tags: []string{"production", "maintenance", "critical"},
				},
			}

			// When: Validating business structure
			Expect(workflow.Name).To(ContainSubstring("Production"),
				"BR-WF-001: Workflow names should clearly indicate business environment")

			// Business requirement: Critical workflows should have proper safeguards
			Expect(workflow.Metadata).To(HaveKey("rollback_capability"),
				"BR-WF-001: Critical workflows should specify rollback capabilities")
			Expect(workflow.Metadata).To(HaveKey("business_owner"),
				"BR-WF-001: Workflows should identify business ownership")

			rollbackCapable := workflow.Metadata["rollback_capability"].(bool)
			Expect(rollbackCapable).To(BeTrue(),
				"BR-WF-001: Production workflows should support rollback for business safety")

			// Business validation: Template should have reasonable constraints
			maxDowntime := workflow.Template.Variables["max_downtime_minutes"].(int)
			testconfig.ExpectBusinessRequirement(maxDowntime,
				"BR-WF-001-MAX-DOWNTIME-MINUTES", "test",
				"maximum downtime minutes for business impact minimization")

			healthCheckInterval := workflow.Template.Variables["health_check_interval"].(string)
			Expect(healthCheckInterval).To(MatchRegexp(`\d+[ms]`),
				"BR-WF-001: Health check intervals should be reasonable for business monitoring")

			// Following guideline: ALWAYS log errors and important business events
			logger.WithFields(logrus.Fields{
				"workflow_name":        workflow.Name,
				"business_impact":      workflow.Metadata["business_impact"],
				"rollback_capable":     rollbackCapable,
				"max_downtime_minutes": maxDowntime,
			}).Info("BR-WF-001: Workflow structure validation completed successfully")
		})
	})

	// Following development guideline: "DO NOT implement code that is not supported or backed up by a requirement"
	// Complex AI-powered workflow generation tests removed as they test non-existent functionality
	// Tests focus on actual implemented workflow structure types and business validation requirements
})

// TestRunner bootstraps the Ginkgo test suite
func TestUintelligentUworkflowUbuilder(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "UintelligentUworkflowUbuilder Suite")
}
