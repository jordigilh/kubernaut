// Code generated by ogen, DO NOT EDIT.

package client

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AlternativeWorkflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AlternativeWorkflow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_id")
		e.Str(s.WorkflowID)
	}
	{
		if s.ExecutionBundle.Set {
			e.FieldStart("execution_bundle")
			s.ExecutionBundle.Encode(e)
		}
	}
	{
		e.FieldStart("confidence")
		e.Float64(s.Confidence)
	}
	{
		e.FieldStart("rationale")
		e.Str(s.Rationale)
	}
}

var jsonFieldsNameOfAlternativeWorkflow = [4]string{
	0: "workflow_id",
	1: "execution_bundle",
	2: "confidence",
	3: "rationale",
}

// Decode decodes AlternativeWorkflow from json.
func (s *AlternativeWorkflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AlternativeWorkflow to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WorkflowID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "execution_bundle":
			if err := func() error {
				s.ExecutionBundle.Reset()
				if err := s.ExecutionBundle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_bundle\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Confidence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "rationale":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Rationale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AlternativeWorkflow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAlternativeWorkflow) {
					name = jsonFieldsNameOfAlternativeWorkflow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AlternativeWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AlternativeWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BusinessClassification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BusinessClassification) encodeFields(e *jx.Encoder) {
	{
		if s.BusinessUnit.Set {
			e.FieldStart("businessUnit")
			s.BusinessUnit.Encode(e)
		}
	}
	{
		if s.ServiceOwner.Set {
			e.FieldStart("serviceOwner")
			s.ServiceOwner.Encode(e)
		}
	}
	{
		if s.Criticality.Set {
			e.FieldStart("criticality")
			s.Criticality.Encode(e)
		}
	}
	{
		if s.SlaRequirement.Set {
			e.FieldStart("slaRequirement")
			s.SlaRequirement.Encode(e)
		}
	}
}

var jsonFieldsNameOfBusinessClassification = [4]string{
	0: "businessUnit",
	1: "serviceOwner",
	2: "criticality",
	3: "slaRequirement",
}

// Decode decodes BusinessClassification from json.
func (s *BusinessClassification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BusinessClassification to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "businessUnit":
			if err := func() error {
				s.BusinessUnit.Reset()
				if err := s.BusinessUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessUnit\"")
			}
		case "serviceOwner":
			if err := func() error {
				s.ServiceOwner.Reset()
				if err := s.ServiceOwner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceOwner\"")
			}
		case "criticality":
			if err := func() error {
				s.Criticality.Reset()
				if err := s.Criticality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criticality\"")
			}
		case "slaRequirement":
			if err := func() error {
				s.SlaRequirement.Reset()
				if err := s.SlaRequirement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slaRequirement\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BusinessClassification")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BusinessClassification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BusinessClassification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnrichmentResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnrichmentResults) encodeFields(e *jx.Encoder) {
	{
		if s.KubernetesContext.Set {
			e.FieldStart("kubernetesContext")
			s.KubernetesContext.Encode(e)
		}
	}
	{
		if s.CustomLabels.Set {
			e.FieldStart("customLabels")
			s.CustomLabels.Encode(e)
		}
	}
	{
		if s.BusinessClassification.Set {
			e.FieldStart("businessClassification")
			s.BusinessClassification.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnrichmentResults = [3]string{
	0: "kubernetesContext",
	1: "customLabels",
	2: "businessClassification",
}

// Decode decodes EnrichmentResults from json.
func (s *EnrichmentResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrichmentResults to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubernetesContext":
			if err := func() error {
				s.KubernetesContext.Reset()
				if err := s.KubernetesContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubernetesContext\"")
			}
		case "customLabels":
			if err := func() error {
				s.CustomLabels.Reset()
				if err := s.CustomLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customLabels\"")
			}
		case "businessClassification":
			if err := func() error {
				s.BusinessClassification.Reset()
				if err := s.BusinessClassification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"businessClassification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrichmentResults")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnrichmentResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrichmentResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EnrichmentResultsCustomLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EnrichmentResultsCustomLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes EnrichmentResultsCustomLabels from json.
func (s *EnrichmentResultsCustomLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrichmentResultsCustomLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrichmentResultsCustomLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnrichmentResultsCustomLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrichmentResultsCustomLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EnrichmentResultsKubernetesContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EnrichmentResultsKubernetesContext) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes EnrichmentResultsKubernetesContext from json.
func (s *EnrichmentResultsKubernetesContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnrichmentResultsKubernetesContext to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnrichmentResultsKubernetesContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnrichmentResultsKubernetesContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnrichmentResultsKubernetesContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecutionFailure) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecutionFailure) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("failed_step_index")
		e.Int(s.FailedStepIndex)
	}
	{
		e.FieldStart("failed_step_name")
		e.Str(s.FailedStepName)
	}
	{
		e.FieldStart("reason")
		e.Str(s.Reason)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if s.ExitCode.Set {
			e.FieldStart("exit_code")
			s.ExitCode.Encode(e)
		}
	}
	{
		e.FieldStart("failed_at")
		e.Str(s.FailedAt)
	}
	{
		e.FieldStart("execution_time")
		e.Str(s.ExecutionTime)
	}
}

var jsonFieldsNameOfExecutionFailure = [7]string{
	0: "failed_step_index",
	1: "failed_step_name",
	2: "reason",
	3: "message",
	4: "exit_code",
	5: "failed_at",
	6: "execution_time",
}

// Decode decodes ExecutionFailure from json.
func (s *ExecutionFailure) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecutionFailure to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "failed_step_index":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.FailedStepIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_step_index\"")
			}
		case "failed_step_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FailedStepName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_step_name\"")
			}
		case "reason":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Reason = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "exit_code":
			if err := func() error {
				s.ExitCode.Reset()
				if err := s.ExitCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exit_code\"")
			}
		case "failed_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.FailedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_at\"")
			}
		case "execution_time":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ExecutionTime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecutionFailure")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecutionFailure) {
					name = jsonFieldsNameOfExecutionFailure[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecutionFailure) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecutionFailure) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTTPError = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes HTTPError from json.
func (s *HTTPError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTTPError) {
					name = jsonFieldsNameOfHTTPError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Detail != nil {
			e.FieldStart("detail")
			e.ArrStart()
			for _, elem := range s.Detail {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTTPValidationError = [1]string{
	0: "detail",
}

// Decode decodes HTTPValidationError from json.
func (s *HTTPValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail = make([]ValidationError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Detail = append(s.Detail, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HumanReviewReason as json.
func (s HumanReviewReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HumanReviewReason from json.
func (s *HumanReviewReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HumanReviewReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HumanReviewReason(v) {
	case HumanReviewReasonWorkflowNotFound:
		*s = HumanReviewReasonWorkflowNotFound
	case HumanReviewReasonImageMismatch:
		*s = HumanReviewReasonImageMismatch
	case HumanReviewReasonParameterValidationFailed:
		*s = HumanReviewReasonParameterValidationFailed
	case HumanReviewReasonNoMatchingWorkflows:
		*s = HumanReviewReasonNoMatchingWorkflows
	case HumanReviewReasonLowConfidence:
		*s = HumanReviewReasonLowConfidence
	case HumanReviewReasonLlmParsingError:
		*s = HumanReviewReasonLlmParsingError
	case HumanReviewReasonInvestigationInconclusive:
		*s = HumanReviewReasonInvestigationInconclusive
	case HumanReviewReasonRcaIncomplete:
		*s = HumanReviewReasonRcaIncomplete
	default:
		*s = HumanReviewReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HumanReviewReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HumanReviewReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON as json.
func (s IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostAcceptedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest as json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden as json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError as json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized as json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity as json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostApplicationJSONUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) {
					name = jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostBadRequestApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) {
					name = jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostForbiddenApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) {
					name = jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostInternalServerErrorApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) {
					name = jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnauthorizedApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON from json.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) {
					name = jsonFieldsNameOfIncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentAnalyzeEndpointAPIV1IncidentAnalyzePostUnprocessableEntityApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("remediation_id")
		e.Str(s.RemediationID)
	}
	{
		e.FieldStart("signal_type")
		e.Str(s.SignalType)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		e.FieldStart("signal_source")
		e.Str(s.SignalSource)
	}
	{
		e.FieldStart("resource_namespace")
		e.Str(s.ResourceNamespace)
	}
	{
		e.FieldStart("resource_kind")
		e.Str(s.ResourceKind)
	}
	{
		e.FieldStart("resource_name")
		e.Str(s.ResourceName)
	}
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("environment")
		e.Str(s.Environment)
	}
	{
		e.FieldStart("priority")
		e.Str(s.Priority)
	}
	{
		e.FieldStart("risk_tolerance")
		e.Str(s.RiskTolerance)
	}
	{
		e.FieldStart("business_category")
		e.Str(s.BusinessCategory)
	}
	{
		e.FieldStart("cluster_name")
		e.Str(s.ClusterName)
	}
	{
		if s.IsDuplicate.Set {
			e.FieldStart("is_duplicate")
			s.IsDuplicate.Encode(e)
		}
	}
	{
		if s.OccurrenceCount.Set {
			e.FieldStart("occurrence_count")
			s.OccurrenceCount.Encode(e)
		}
	}
	{
		if s.DeduplicationWindowMinutes.Set {
			e.FieldStart("deduplication_window_minutes")
			s.DeduplicationWindowMinutes.Encode(e)
		}
	}
	{
		if s.IsStorm.Set {
			e.FieldStart("is_storm")
			s.IsStorm.Encode(e)
		}
	}
	{
		if s.StormSignalCount.Set {
			e.FieldStart("storm_signal_count")
			s.StormSignalCount.Encode(e)
		}
	}
	{
		if s.StormWindowMinutes.Set {
			e.FieldStart("storm_window_minutes")
			s.StormWindowMinutes.Encode(e)
		}
	}
	{
		if s.StormType.Set {
			e.FieldStart("storm_type")
			s.StormType.Encode(e)
		}
	}
	{
		if s.AffectedResources.Set {
			e.FieldStart("affected_resources")
			s.AffectedResources.Encode(e)
		}
	}
	{
		if s.FiringTime.Set {
			e.FieldStart("firing_time")
			s.FiringTime.Encode(e)
		}
	}
	{
		if s.ReceivedTime.Set {
			e.FieldStart("received_time")
			s.ReceivedTime.Encode(e)
		}
	}
	{
		if s.FirstSeen.Set {
			e.FieldStart("first_seen")
			s.FirstSeen.Encode(e)
		}
	}
	{
		if s.LastSeen.Set {
			e.FieldStart("last_seen")
			s.LastSeen.Encode(e)
		}
	}
	{
		if s.SignalLabels.Set {
			e.FieldStart("signal_labels")
			s.SignalLabels.Encode(e)
		}
	}
	{
		if s.EnrichmentResults.Set {
			e.FieldStart("enrichment_results")
			s.EnrichmentResults.Encode(e)
		}
	}
	{
		if s.SignalMode.Set {
			e.FieldStart("signal_mode")
			s.SignalMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentRequest = [30]string{
	0:  "incident_id",
	1:  "remediation_id",
	2:  "signal_type",
	3:  "severity",
	4:  "signal_source",
	5:  "resource_namespace",
	6:  "resource_kind",
	7:  "resource_name",
	8:  "error_message",
	9:  "description",
	10: "environment",
	11: "priority",
	12: "risk_tolerance",
	13: "business_category",
	14: "cluster_name",
	15: "is_duplicate",
	16: "occurrence_count",
	17: "deduplication_window_minutes",
	18: "is_storm",
	19: "storm_signal_count",
	20: "storm_window_minutes",
	21: "storm_type",
	22: "affected_resources",
	23: "firing_time",
	24: "received_time",
	25: "first_seen",
	26: "last_seen",
	27: "signal_labels",
	28: "enrichment_results",
	29: "signal_mode",
}

// Decode decodes IncidentRequest from json.
func (s *IncidentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentRequest to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "remediation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RemediationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_id\"")
			}
		case "signal_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SignalType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "signal_source":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SignalSource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_source\"")
			}
		case "resource_namespace":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ResourceNamespace = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_namespace\"")
			}
		case "resource_kind":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ResourceKind = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_kind\"")
			}
		case "resource_name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ResourceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_name\"")
			}
		case "error_message":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "environment":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Environment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "priority":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Priority = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "risk_tolerance":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RiskTolerance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_tolerance\"")
			}
		case "business_category":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BusinessCategory = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_category\"")
			}
		case "cluster_name":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ClusterName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster_name\"")
			}
		case "is_duplicate":
			if err := func() error {
				s.IsDuplicate.Reset()
				if err := s.IsDuplicate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_duplicate\"")
			}
		case "occurrence_count":
			if err := func() error {
				s.OccurrenceCount.Reset()
				if err := s.OccurrenceCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"occurrence_count\"")
			}
		case "deduplication_window_minutes":
			if err := func() error {
				s.DeduplicationWindowMinutes.Reset()
				if err := s.DeduplicationWindowMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deduplication_window_minutes\"")
			}
		case "is_storm":
			if err := func() error {
				s.IsStorm.Reset()
				if err := s.IsStorm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_storm\"")
			}
		case "storm_signal_count":
			if err := func() error {
				s.StormSignalCount.Reset()
				if err := s.StormSignalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storm_signal_count\"")
			}
		case "storm_window_minutes":
			if err := func() error {
				s.StormWindowMinutes.Reset()
				if err := s.StormWindowMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storm_window_minutes\"")
			}
		case "storm_type":
			if err := func() error {
				s.StormType.Reset()
				if err := s.StormType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storm_type\"")
			}
		case "affected_resources":
			if err := func() error {
				s.AffectedResources.Reset()
				if err := s.AffectedResources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affected_resources\"")
			}
		case "firing_time":
			if err := func() error {
				s.FiringTime.Reset()
				if err := s.FiringTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firing_time\"")
			}
		case "received_time":
			if err := func() error {
				s.ReceivedTime.Reset()
				if err := s.ReceivedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_time\"")
			}
		case "first_seen":
			if err := func() error {
				s.FirstSeen.Reset()
				if err := s.FirstSeen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_seen\"")
			}
		case "last_seen":
			if err := func() error {
				s.LastSeen.Reset()
				if err := s.LastSeen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_seen\"")
			}
		case "signal_labels":
			if err := func() error {
				s.SignalLabels.Reset()
				if err := s.SignalLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_labels\"")
			}
		case "enrichment_results":
			if err := func() error {
				s.EnrichmentResults.Reset()
				if err := s.EnrichmentResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrichment_results\"")
			}
		case "signal_mode":
			if err := func() error {
				s.SignalMode.Reset()
				if err := s.SignalMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b01111101,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentRequest) {
					name = jsonFieldsNameOfIncidentRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IncidentRequestSignalLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IncidentRequestSignalLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes IncidentRequestSignalLabels from json.
func (s *IncidentRequestSignalLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentRequestSignalLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentRequestSignalLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentRequestSignalLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentRequestSignalLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IncidentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IncidentResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("analysis")
		e.Str(s.Analysis)
	}
	{
		e.FieldStart("root_cause_analysis")
		s.RootCauseAnalysis.Encode(e)
	}
	{
		if s.SelectedWorkflow.Set {
			e.FieldStart("selected_workflow")
			s.SelectedWorkflow.Encode(e)
		}
	}
	{
		e.FieldStart("confidence")
		e.Float64(s.Confidence)
	}
	{
		e.FieldStart("timestamp")
		e.Str(s.Timestamp)
	}
	{
		if s.NeedsHumanReview.Set {
			e.FieldStart("needs_human_review")
			s.NeedsHumanReview.Encode(e)
		}
	}
	{
		if s.HumanReviewReason.Set {
			e.FieldStart("human_review_reason")
			s.HumanReviewReason.Encode(e)
		}
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlternativeWorkflows != nil {
			e.FieldStart("alternative_workflows")
			e.ArrStart()
			for _, elem := range s.AlternativeWorkflows {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ValidationAttemptsHistory != nil {
			e.FieldStart("validation_attempts_history")
			e.ArrStart()
			for _, elem := range s.ValidationAttemptsHistory {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DetectedLabels.Set {
			e.FieldStart("detected_labels")
			s.DetectedLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfIncidentResponse = [12]string{
	0:  "incident_id",
	1:  "analysis",
	2:  "root_cause_analysis",
	3:  "selected_workflow",
	4:  "confidence",
	5:  "timestamp",
	6:  "needs_human_review",
	7:  "human_review_reason",
	8:  "warnings",
	9:  "alternative_workflows",
	10: "validation_attempts_history",
	11: "detected_labels",
}

// Decode decodes IncidentResponse from json.
func (s *IncidentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "analysis":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Analysis = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis\"")
			}
		case "root_cause_analysis":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RootCauseAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"root_cause_analysis\"")
			}
		case "selected_workflow":
			if err := func() error {
				s.SelectedWorkflow.Reset()
				if err := s.SelectedWorkflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_workflow\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Confidence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Timestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "needs_human_review":
			if err := func() error {
				s.NeedsHumanReview.Reset()
				if err := s.NeedsHumanReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_human_review\"")
			}
		case "human_review_reason":
			if err := func() error {
				s.HumanReviewReason.Reset()
				if err := s.HumanReviewReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_review_reason\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		case "alternative_workflows":
			if err := func() error {
				s.AlternativeWorkflows = make([]AlternativeWorkflow, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlternativeWorkflow
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlternativeWorkflows = append(s.AlternativeWorkflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alternative_workflows\"")
			}
		case "validation_attempts_history":
			if err := func() error {
				s.ValidationAttemptsHistory = make([]ValidationAttempt, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationAttempt
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ValidationAttemptsHistory = append(s.ValidationAttemptsHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validation_attempts_history\"")
			}
		case "detected_labels":
			if err := func() error {
				s.DetectedLabels.Reset()
				if err := s.DetectedLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detected_labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIncidentResponse) {
					name = jsonFieldsNameOfIncidentResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IncidentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IncidentResponseDetectedLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IncidentResponseDetectedLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes IncidentResponseDetectedLabels from json.
func (s *IncidentResponseDetectedLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseDetectedLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseDetectedLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseDetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseDetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IncidentResponseRootCauseAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IncidentResponseRootCauseAnalysis) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes IncidentResponseRootCauseAnalysis from json.
func (s *IncidentResponseRootCauseAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseRootCauseAnalysis to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseRootCauseAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseRootCauseAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseRootCauseAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IncidentResponseSelectedWorkflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IncidentResponseSelectedWorkflow) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes IncidentResponseSelectedWorkflow from json.
func (s *IncidentResponseSelectedWorkflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentResponseSelectedWorkflow to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IncidentResponseSelectedWorkflow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentResponseSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentResponseSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON as json.
func (s IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON from json.
func (s *IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IncidentSessionStatusEndpointAPIV1IncidentSessionSessionIDGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BusinessClassification as json.
func (o OptNilBusinessClassification) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BusinessClassification from json.
func (o *OptNilBusinessClassification) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBusinessClassification to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BusinessClassification
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBusinessClassification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBusinessClassification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnrichmentResults as json.
func (o OptNilEnrichmentResults) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrichmentResults from json.
func (o *OptNilEnrichmentResults) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnrichmentResults to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnrichmentResults
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnrichmentResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnrichmentResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnrichmentResultsCustomLabels as json.
func (o OptNilEnrichmentResultsCustomLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrichmentResultsCustomLabels from json.
func (o *OptNilEnrichmentResultsCustomLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnrichmentResultsCustomLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnrichmentResultsCustomLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(EnrichmentResultsCustomLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnrichmentResultsCustomLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnrichmentResultsCustomLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnrichmentResultsKubernetesContext as json.
func (o OptNilEnrichmentResultsKubernetesContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnrichmentResultsKubernetesContext from json.
func (o *OptNilEnrichmentResultsKubernetesContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEnrichmentResultsKubernetesContext to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnrichmentResultsKubernetesContext
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(EnrichmentResultsKubernetesContext)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEnrichmentResultsKubernetesContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEnrichmentResultsKubernetesContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HumanReviewReason as json.
func (o OptNilHumanReviewReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HumanReviewReason from json.
func (o *OptNilHumanReviewReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilHumanReviewReason to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v HumanReviewReason
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilHumanReviewReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilHumanReviewReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentRequestSignalLabels as json.
func (o OptNilIncidentRequestSignalLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IncidentRequestSignalLabels from json.
func (o *OptNilIncidentRequestSignalLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIncidentRequestSignalLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IncidentRequestSignalLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(IncidentRequestSignalLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIncidentRequestSignalLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIncidentRequestSignalLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseDetectedLabels as json.
func (o OptNilIncidentResponseDetectedLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IncidentResponseDetectedLabels from json.
func (o *OptNilIncidentResponseDetectedLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIncidentResponseDetectedLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IncidentResponseDetectedLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(IncidentResponseDetectedLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIncidentResponseDetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIncidentResponseDetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IncidentResponseSelectedWorkflow as json.
func (o OptNilIncidentResponseSelectedWorkflow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IncidentResponseSelectedWorkflow from json.
func (o *OptNilIncidentResponseSelectedWorkflow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilIncidentResponseSelectedWorkflow to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v IncidentResponseSelectedWorkflow
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(IncidentResponseSelectedWorkflow)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilIncidentResponseSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilIncidentResponseSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PreviousExecution as json.
func (o OptNilPreviousExecution) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PreviousExecution from json.
func (o *OptNilPreviousExecution) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPreviousExecution to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v PreviousExecution
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPreviousExecution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPreviousExecution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryResponseDetectedLabels as json.
func (o OptNilRecoveryResponseDetectedLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecoveryResponseDetectedLabels from json.
func (o *OptNilRecoveryResponseDetectedLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRecoveryResponseDetectedLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RecoveryResponseDetectedLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(RecoveryResponseDetectedLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRecoveryResponseDetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRecoveryResponseDetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryResponseRecoveryAnalysis as json.
func (o OptNilRecoveryResponseRecoveryAnalysis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecoveryResponseRecoveryAnalysis from json.
func (o *OptNilRecoveryResponseRecoveryAnalysis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRecoveryResponseRecoveryAnalysis to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RecoveryResponseRecoveryAnalysis
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(RecoveryResponseRecoveryAnalysis)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRecoveryResponseRecoveryAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRecoveryResponseRecoveryAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryResponseSelectedWorkflow as json.
func (o OptNilRecoveryResponseSelectedWorkflow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecoveryResponseSelectedWorkflow from json.
func (o *OptNilRecoveryResponseSelectedWorkflow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilRecoveryResponseSelectedWorkflow to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RecoveryResponseSelectedWorkflow
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(RecoveryResponseSelectedWorkflow)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilRecoveryResponseSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilRecoveryResponseSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Severity as json.
func (o OptNilSeverity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Severity from json.
func (o *OptNilSeverity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSeverity to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v Severity
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSeverity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSeverity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalMode as json.
func (o OptNilSignalMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SignalMode from json.
func (o *OptNilSignalMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSignalMode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SignalMode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSignalMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSignalMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryResponseMetadata as json.
func (o OptRecoveryResponseMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecoveryResponseMetadata from json.
func (o *OptRecoveryResponseMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecoveryResponseMetadata to nil")
	}
	o.Set = true
	o.Value = make(RecoveryResponseMetadata)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecoveryResponseMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecoveryResponseMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SelectedWorkflowSummaryParameters as json.
func (o OptSelectedWorkflowSummaryParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SelectedWorkflowSummaryParameters from json.
func (o *OptSelectedWorkflowSummaryParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSelectedWorkflowSummaryParameters to nil")
	}
	o.Set = true
	o.Value = make(SelectedWorkflowSummaryParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSelectedWorkflowSummaryParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSelectedWorkflowSummaryParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OriginalRCA) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OriginalRCA) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("summary")
		e.Str(s.Summary)
	}
	{
		e.FieldStart("signal_type")
		e.Str(s.SignalType)
	}
	{
		e.FieldStart("severity")
		s.Severity.Encode(e)
	}
	{
		if s.ContributingFactors != nil {
			e.FieldStart("contributing_factors")
			e.ArrStart()
			for _, elem := range s.ContributingFactors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfOriginalRCA = [4]string{
	0: "summary",
	1: "signal_type",
	2: "severity",
	3: "contributing_factors",
}

// Decode decodes OriginalRCA from json.
func (s *OriginalRCA) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OriginalRCA to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Summary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "signal_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SignalType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "severity":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "contributing_factors":
			if err := func() error {
				s.ContributingFactors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ContributingFactors = append(s.ContributingFactors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contributing_factors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OriginalRCA")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOriginalRCA) {
					name = jsonFieldsNameOfOriginalRCA[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OriginalRCA) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OriginalRCA) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreviousExecution) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreviousExecution) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_execution_ref")
		e.Str(s.WorkflowExecutionRef)
	}
	{
		e.FieldStart("original_rca")
		s.OriginalRca.Encode(e)
	}
	{
		e.FieldStart("selected_workflow")
		s.SelectedWorkflow.Encode(e)
	}
	{
		e.FieldStart("failure")
		s.Failure.Encode(e)
	}
	{
		if s.NaturalLanguageSummary.Set {
			e.FieldStart("natural_language_summary")
			s.NaturalLanguageSummary.Encode(e)
		}
	}
}

var jsonFieldsNameOfPreviousExecution = [5]string{
	0: "workflow_execution_ref",
	1: "original_rca",
	2: "selected_workflow",
	3: "failure",
	4: "natural_language_summary",
}

// Decode decodes PreviousExecution from json.
func (s *PreviousExecution) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreviousExecution to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_execution_ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WorkflowExecutionRef = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_execution_ref\"")
			}
		case "original_rca":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.OriginalRca.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_rca\"")
			}
		case "selected_workflow":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SelectedWorkflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_workflow\"")
			}
		case "failure":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Failure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure\"")
			}
		case "natural_language_summary":
			if err := func() error {
				s.NaturalLanguageSummary.Reset()
				if err := s.NaturalLanguageSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"natural_language_summary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreviousExecution")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreviousExecution) {
					name = jsonFieldsNameOfPreviousExecution[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreviousExecution) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreviousExecution) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON as json.
func (s RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostAcceptedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest as json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden as json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError as json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized as json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity as json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*HTTPError)(s)

	unwrapped.Encode(e)
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity to nil")
	}
	var unwrapped HTTPError
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostApplicationJSONUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) {
					name = jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostBadRequestApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) {
					name = jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostForbiddenApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) {
					name = jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostInternalServerErrorApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) {
					name = jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnauthorizedApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("detail")
		e.Str(s.Detail)
	}
	{
		e.FieldStart("status")
		e.Int(s.Status)
	}
	{
		e.FieldStart("instance")
		e.Str(s.Instance)
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON = [6]string{
	0: "type",
	1: "title",
	2: "detail",
	3: "status",
	4: "instance",
	5: "request_id",
}

// Decode decodes RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON from json.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "detail":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Detail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Status = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Instance = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) {
					name = jsonFieldsNameOfRecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryAnalyzeEndpointAPIV1RecoveryAnalyzePostUnprocessableEntityApplicationProblemJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("remediation_id")
		e.Str(s.RemediationID)
	}
	{
		if s.IsRecoveryAttempt.Set {
			e.FieldStart("is_recovery_attempt")
			s.IsRecoveryAttempt.Encode(e)
		}
	}
	{
		if s.RecoveryAttemptNumber.Set {
			e.FieldStart("recovery_attempt_number")
			s.RecoveryAttemptNumber.Encode(e)
		}
	}
	{
		if s.PreviousExecution.Set {
			e.FieldStart("previous_execution")
			s.PreviousExecution.Encode(e)
		}
	}
	{
		if s.EnrichmentResults.Set {
			e.FieldStart("enrichment_results")
			s.EnrichmentResults.Encode(e)
		}
	}
	{
		if s.SignalType.Set {
			e.FieldStart("signal_type")
			s.SignalType.Encode(e)
		}
	}
	{
		if s.Severity.Set {
			e.FieldStart("severity")
			s.Severity.Encode(e)
		}
	}
	{
		if s.ResourceNamespace.Set {
			e.FieldStart("resource_namespace")
			s.ResourceNamespace.Encode(e)
		}
	}
	{
		if s.ResourceKind.Set {
			e.FieldStart("resource_kind")
			s.ResourceKind.Encode(e)
		}
	}
	{
		if s.ResourceName.Set {
			e.FieldStart("resource_name")
			s.ResourceName.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.RiskTolerance.Set {
			e.FieldStart("risk_tolerance")
			s.RiskTolerance.Encode(e)
		}
	}
	{
		if s.BusinessCategory.Set {
			e.FieldStart("business_category")
			s.BusinessCategory.Encode(e)
		}
	}
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("cluster_name")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.SignalSource.Set {
			e.FieldStart("signal_source")
			s.SignalSource.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryRequest = [18]string{
	0:  "incident_id",
	1:  "remediation_id",
	2:  "is_recovery_attempt",
	3:  "recovery_attempt_number",
	4:  "previous_execution",
	5:  "enrichment_results",
	6:  "signal_type",
	7:  "severity",
	8:  "resource_namespace",
	9:  "resource_kind",
	10: "resource_name",
	11: "environment",
	12: "priority",
	13: "risk_tolerance",
	14: "business_category",
	15: "error_message",
	16: "cluster_name",
	17: "signal_source",
}

// Decode decodes RecoveryRequest from json.
func (s *RecoveryRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "remediation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RemediationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remediation_id\"")
			}
		case "is_recovery_attempt":
			if err := func() error {
				s.IsRecoveryAttempt.Reset()
				if err := s.IsRecoveryAttempt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_recovery_attempt\"")
			}
		case "recovery_attempt_number":
			if err := func() error {
				s.RecoveryAttemptNumber.Reset()
				if err := s.RecoveryAttemptNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_attempt_number\"")
			}
		case "previous_execution":
			if err := func() error {
				s.PreviousExecution.Reset()
				if err := s.PreviousExecution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_execution\"")
			}
		case "enrichment_results":
			if err := func() error {
				s.EnrichmentResults.Reset()
				if err := s.EnrichmentResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enrichment_results\"")
			}
		case "signal_type":
			if err := func() error {
				s.SignalType.Reset()
				if err := s.SignalType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_type\"")
			}
		case "severity":
			if err := func() error {
				s.Severity.Reset()
				if err := s.Severity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severity\"")
			}
		case "resource_namespace":
			if err := func() error {
				s.ResourceNamespace.Reset()
				if err := s.ResourceNamespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_namespace\"")
			}
		case "resource_kind":
			if err := func() error {
				s.ResourceKind.Reset()
				if err := s.ResourceKind.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_kind\"")
			}
		case "resource_name":
			if err := func() error {
				s.ResourceName.Reset()
				if err := s.ResourceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_name\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "risk_tolerance":
			if err := func() error {
				s.RiskTolerance.Reset()
				if err := s.RiskTolerance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"risk_tolerance\"")
			}
		case "business_category":
			if err := func() error {
				s.BusinessCategory.Reset()
				if err := s.BusinessCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_category\"")
			}
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "cluster_name":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster_name\"")
			}
		case "signal_source":
			if err := func() error {
				s.SignalSource.Reset()
				if err := s.SignalSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal_source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryRequest) {
					name = jsonFieldsNameOfRecoveryRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("incident_id")
		e.Str(s.IncidentID)
	}
	{
		e.FieldStart("can_recover")
		e.Bool(s.CanRecover)
	}
	{
		if s.Strategies != nil {
			e.FieldStart("strategies")
			e.ArrStart()
			for _, elem := range s.Strategies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PrimaryRecommendation.Set {
			e.FieldStart("primary_recommendation")
			s.PrimaryRecommendation.Encode(e)
		}
	}
	{
		e.FieldStart("analysis_confidence")
		e.Float64(s.AnalysisConfidence)
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		if s.SelectedWorkflow.Set {
			e.FieldStart("selected_workflow")
			s.SelectedWorkflow.Encode(e)
		}
	}
	{
		if s.RecoveryAnalysis.Set {
			e.FieldStart("recovery_analysis")
			s.RecoveryAnalysis.Encode(e)
		}
	}
	{
		if s.NeedsHumanReview.Set {
			e.FieldStart("needs_human_review")
			s.NeedsHumanReview.Encode(e)
		}
	}
	{
		if s.HumanReviewReason.Set {
			e.FieldStart("human_review_reason")
			s.HumanReviewReason.Encode(e)
		}
	}
	{
		if s.AlternativeWorkflows != nil {
			e.FieldStart("alternative_workflows")
			e.ArrStart()
			for _, elem := range s.AlternativeWorkflows {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DetectedLabels.Set {
			e.FieldStart("detected_labels")
			s.DetectedLabels.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryResponse = [13]string{
	0:  "incident_id",
	1:  "can_recover",
	2:  "strategies",
	3:  "primary_recommendation",
	4:  "analysis_confidence",
	5:  "warnings",
	6:  "metadata",
	7:  "selected_workflow",
	8:  "recovery_analysis",
	9:  "needs_human_review",
	10: "human_review_reason",
	11: "alternative_workflows",
	12: "detected_labels",
}

// Decode decodes RecoveryResponse from json.
func (s *RecoveryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "incident_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IncidentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"incident_id\"")
			}
		case "can_recover":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanRecover = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_recover\"")
			}
		case "strategies":
			if err := func() error {
				s.Strategies = make([]RecoveryStrategy, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RecoveryStrategy
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Strategies = append(s.Strategies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategies\"")
			}
		case "primary_recommendation":
			if err := func() error {
				s.PrimaryRecommendation.Reset()
				if err := s.PrimaryRecommendation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_recommendation\"")
			}
		case "analysis_confidence":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.AnalysisConfidence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis_confidence\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "selected_workflow":
			if err := func() error {
				s.SelectedWorkflow.Reset()
				if err := s.SelectedWorkflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_workflow\"")
			}
		case "recovery_analysis":
			if err := func() error {
				s.RecoveryAnalysis.Reset()
				if err := s.RecoveryAnalysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery_analysis\"")
			}
		case "needs_human_review":
			if err := func() error {
				s.NeedsHumanReview.Reset()
				if err := s.NeedsHumanReview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"needs_human_review\"")
			}
		case "human_review_reason":
			if err := func() error {
				s.HumanReviewReason.Reset()
				if err := s.HumanReviewReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"human_review_reason\"")
			}
		case "alternative_workflows":
			if err := func() error {
				s.AlternativeWorkflows = make([]AlternativeWorkflow, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AlternativeWorkflow
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AlternativeWorkflows = append(s.AlternativeWorkflows, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alternative_workflows\"")
			}
		case "detected_labels":
			if err := func() error {
				s.DetectedLabels.Reset()
				if err := s.DetectedLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detected_labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryResponse) {
					name = jsonFieldsNameOfRecoveryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RecoveryResponseDetectedLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RecoveryResponseDetectedLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RecoveryResponseDetectedLabels from json.
func (s *RecoveryResponseDetectedLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryResponseDetectedLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryResponseDetectedLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryResponseDetectedLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryResponseDetectedLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RecoveryResponseMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RecoveryResponseMetadata) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RecoveryResponseMetadata from json.
func (s *RecoveryResponseMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryResponseMetadata to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryResponseMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryResponseMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryResponseMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RecoveryResponseRecoveryAnalysis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RecoveryResponseRecoveryAnalysis) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RecoveryResponseRecoveryAnalysis from json.
func (s *RecoveryResponseRecoveryAnalysis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryResponseRecoveryAnalysis to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryResponseRecoveryAnalysis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryResponseRecoveryAnalysis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryResponseRecoveryAnalysis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RecoveryResponseSelectedWorkflow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RecoveryResponseSelectedWorkflow) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes RecoveryResponseSelectedWorkflow from json.
func (s *RecoveryResponseSelectedWorkflow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryResponseSelectedWorkflow to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryResponseSelectedWorkflow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryResponseSelectedWorkflow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryResponseSelectedWorkflow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON as json.
func (s RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON from json.
func (s *RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoverySessionStatusEndpointAPIV1RecoverySessionSessionIDGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecoveryStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecoveryStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("action_type")
		e.Str(s.ActionType)
	}
	{
		e.FieldStart("confidence")
		e.Float64(s.Confidence)
	}
	{
		e.FieldStart("rationale")
		e.Str(s.Rationale)
	}
	{
		e.FieldStart("estimated_risk")
		s.EstimatedRisk.Encode(e)
	}
	{
		if s.Prerequisites != nil {
			e.FieldStart("prerequisites")
			e.ArrStart()
			for _, elem := range s.Prerequisites {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KubectlCommand.Set {
			e.FieldStart("kubectl_command")
			s.KubectlCommand.Encode(e)
		}
	}
}

var jsonFieldsNameOfRecoveryStrategy = [6]string{
	0: "action_type",
	1: "confidence",
	2: "rationale",
	3: "estimated_risk",
	4: "prerequisites",
	5: "kubectl_command",
}

// Decode decodes RecoveryStrategy from json.
func (s *RecoveryStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ActionType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_type\"")
			}
		case "confidence":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Confidence = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"confidence\"")
			}
		case "rationale":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Rationale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		case "estimated_risk":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EstimatedRisk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"estimated_risk\"")
			}
		case "prerequisites":
			if err := func() error {
				s.Prerequisites = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Prerequisites = append(s.Prerequisites, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prerequisites\"")
			}
		case "kubectl_command":
			if err := func() error {
				s.KubectlCommand.Reset()
				if err := s.KubectlCommand.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubectl_command\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecoveryStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecoveryStrategy) {
					name = jsonFieldsNameOfRecoveryStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecoveryStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecoveryStrategyEstimatedRisk as json.
func (s RecoveryStrategyEstimatedRisk) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RecoveryStrategyEstimatedRisk from json.
func (s *RecoveryStrategyEstimatedRisk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecoveryStrategyEstimatedRisk to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RecoveryStrategyEstimatedRisk(v) {
	case RecoveryStrategyEstimatedRiskLow:
		*s = RecoveryStrategyEstimatedRiskLow
	case RecoveryStrategyEstimatedRiskMedium:
		*s = RecoveryStrategyEstimatedRiskMedium
	case RecoveryStrategyEstimatedRiskHigh:
		*s = RecoveryStrategyEstimatedRiskHigh
	default:
		*s = RecoveryStrategyEstimatedRisk(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RecoveryStrategyEstimatedRisk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecoveryStrategyEstimatedRisk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SelectedWorkflowSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SelectedWorkflowSummary) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("workflow_id")
		e.Str(s.WorkflowID)
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("execution_bundle")
		e.Str(s.ExecutionBundle)
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		e.FieldStart("rationale")
		e.Str(s.Rationale)
	}
}

var jsonFieldsNameOfSelectedWorkflowSummary = [5]string{
	0: "workflow_id",
	1: "version",
	2: "execution_bundle",
	3: "parameters",
	4: "rationale",
}

// Decode decodes SelectedWorkflowSummary from json.
func (s *SelectedWorkflowSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedWorkflowSummary to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "workflow_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WorkflowID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "execution_bundle":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ExecutionBundle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_bundle\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "rationale":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Rationale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectedWorkflowSummary")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSelectedWorkflowSummary) {
					name = jsonFieldsNameOfSelectedWorkflowSummary[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SelectedWorkflowSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectedWorkflowSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SelectedWorkflowSummaryParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SelectedWorkflowSummaryParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SelectedWorkflowSummaryParameters from json.
func (s *SelectedWorkflowSummaryParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SelectedWorkflowSummaryParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SelectedWorkflowSummaryParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SelectedWorkflowSummaryParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SelectedWorkflowSummaryParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Severity as json.
func (s Severity) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Severity from json.
func (s *Severity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Severity to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Severity(v) {
	case SeverityCritical:
		*s = SeverityCritical
	case SeverityHigh:
		*s = SeverityHigh
	case SeverityMedium:
		*s = SeverityMedium
	case SeverityLow:
		*s = SeverityLow
	case SeverityUnknown:
		*s = SeverityUnknown
	default:
		*s = Severity(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Severity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Severity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SignalMode as json.
func (s SignalMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SignalMode from json.
func (s *SignalMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SignalMode(v) {
	case SignalModeReactive:
		*s = SignalModeReactive
	case SignalModePredictive:
		*s = SignalModePredictive
	default:
		*s = SignalMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SignalMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationAttempt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationAttempt) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("attempt")
		e.Int(s.Attempt)
	}
	{
		if s.WorkflowID.Set {
			e.FieldStart("workflow_id")
			s.WorkflowID.Encode(e)
		}
	}
	{
		e.FieldStart("is_valid")
		e.Bool(s.IsValid)
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("timestamp")
		e.Str(s.Timestamp)
	}
}

var jsonFieldsNameOfValidationAttempt = [5]string{
	0: "attempt",
	1: "workflow_id",
	2: "is_valid",
	3: "errors",
	4: "timestamp",
}

// Decode decodes ValidationAttempt from json.
func (s *ValidationAttempt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationAttempt to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "attempt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Attempt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attempt\"")
			}
		case "workflow_id":
			if err := func() error {
				s.WorkflowID.Reset()
				if err := s.WorkflowID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_id\"")
			}
		case "is_valid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_valid\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Timestamp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationAttempt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationAttempt) {
					name = jsonFieldsNameOfValidationAttempt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationAttempt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationAttempt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loc")
		e.ArrStart()
		for _, elem := range s.Loc {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "loc",
	1: "msg",
	2: "type",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loc = make([]ValidationErrorLocItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorLocItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Loc = append(s.Loc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loc\"")
			}
		case "msg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorLocItem as json.
func (s ValidationErrorLocItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringValidationErrorLocItem:
		e.Str(s.String)
	case IntValidationErrorLocItem:
		e.Int(s.Int)
	}
}

// Decode decodes ValidationErrorLocItem from json.
func (s *ValidationErrorLocItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorLocItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorLocItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorLocItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
