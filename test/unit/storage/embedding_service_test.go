package storage

import (
	"context"
	"fmt"
	"math"
	"strings"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/storage/vector"
	. "github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to storage_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Local Embedding Service Unit Tests", func() {
	var (
		embeddingService *vector.LocalEmbeddingService
		logger           *logrus.Logger
		ctx              context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)
		embeddingService = vector.NewLocalEmbeddingService(384, logger)
		ctx = context.Background()
	})

	Context("Service Creation and Configuration", func() {
		It("should create service with specified dimension", func() {
			dimension := 512
			service := vector.NewLocalEmbeddingService(dimension, logger)

			Expect(service.GetEmbeddingDimension()).To(Equal(dimension), "BR-DATABASE-001-A: Embedding service must provide valid dimensions for vector storage operations")
		})

		It("should use default dimension for invalid input", func() {
			service := vector.NewLocalEmbeddingService(0, logger)

			Expect(service.GetEmbeddingDimension()).To(Equal(384), "Should use default dimension for zero input")

			service = vector.NewLocalEmbeddingService(-10, logger)
			Expect(service.GetEmbeddingDimension()).To(Equal(384), "Should use default dimension for negative input")
		})

		It("should initialize vocabulary during creation", func() {
			service := vector.NewLocalEmbeddingService(100, logger)

			// Test that vocabulary is working by generating embeddings for known terms
			embedding1, err := service.GenerateTextEmbedding(ctx, "pod deployment")
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := service.GenerateTextEmbedding(ctx, "random_unknown_terms_xyz")
			Expect(err).ToNot(HaveOccurred())

			// Known terms should produce different embeddings than unknown terms
			Expect(embedding1).ToNot(Equal(embedding2), "Known and unknown terms should produce different embeddings")
		})
	})

	Context("Text Embedding Generation", func() {
		It("should generate embedding with correct dimensions", func() {
			text := "Critical pod memory usage alert"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should generate normalized embeddings", func() {
			text := "High CPU usage in production namespace"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Calculate L2 norm
			var sumSquares float64
			for _, val := range embedding {
				sumSquares += val * val
			}
			norm := sumSquares // Should be close to 1.0 for normalized vector

			Expect(norm).To(BeNumerically("~", 1.0, 0.1), "Embedding should be normalized")
		})

		It("should handle empty text input", func() {
			embedding, err := embeddingService.GenerateTextEmbedding(ctx, "")
			Expect(err).ToNot(HaveOccurred(), "Should handle empty text without error")
			Expect(len(embedding)).To(Equal(384), "Should return embedding with correct dimension")

			// Should return zero embedding for empty input
			allZero := true
			for _, val := range embedding {
				if val != 0.0 {
					allZero = false
					break
				}
			}
			Expect(allZero).To(BeTrue(), "Empty text should produce zero embedding")
		})

		It("should generate consistent embeddings for same input", func() {
			text := "Memory alert in production deployment"

			embedding1, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).To(Equal(embedding2), "Should generate consistent embeddings for same input")
		})

		It("should generate different embeddings for different inputs", func() {
			text1 := "CPU usage alert"
			text2 := "Memory pressure warning"

			embedding1, err := embeddingService.GenerateTextEmbedding(ctx, text1)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateTextEmbedding(ctx, text2)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).ToNot(Equal(embedding2), "Different texts should produce different embeddings")
		})

		It("should handle Kubernetes-specific terminology", func() {
			kubernetesText := "pod deployment service ingress configmap secret namespace"
			regularText := "random text without kubernetes terms"

			k8sEmbedding, err := embeddingService.GenerateTextEmbedding(ctx, kubernetesText)
			Expect(err).ToNot(HaveOccurred())

			regularEmbedding, err := embeddingService.GenerateTextEmbedding(ctx, regularText)
			Expect(err).ToNot(HaveOccurred())

			Expect(k8sEmbedding).ToNot(Equal(regularEmbedding),
				"Kubernetes-specific terms should be handled differently")
		})

		It("should handle special characters and punctuation", func() {
			specialText := "alert: memory-usage > 80% in prod/namespace (critical)!"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, specialText)
			Expect(err).ToNot(HaveOccurred(), "Should handle special characters without error")
			Expect(len(embedding)).To(Equal(384), "Should produce correct dimension despite special characters")
		})
	})

	Context("Action Embedding Generation", func() {
		It("should generate embedding from action type and parameters", func() {
			actionType := "scale"
			parameters := map[string]interface{}{
				"replicas":   5,
				"target_cpu": "500m",
				"enabled":    true,
				"timeout":    30.5,
			}

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should generate action embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should handle various parameter types", func() {
			actionType := "restart"
			parameters := map[string]interface{}{
				"string_param":  "value",
				"int_param":     42,
				"int32_param":   int32(123),
				"int64_param":   int64(456),
				"float32_param": float32(1.5),
				"float64_param": 2.7,
				"bool_param":    true,
				"slice_param":   []string{"ignored"},                     // Should be ignored
				"map_param":     map[string]string{"ignored": "ignored"}, // Should be ignored
			}

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should handle various parameter types")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should generate different embeddings for different actions", func() {
			parameters := map[string]interface{}{"replicas": 3}

			scaleEmbedding, err := embeddingService.GenerateActionEmbedding(ctx, "scale", parameters)
			Expect(err).ToNot(HaveOccurred())

			restartEmbedding, err := embeddingService.GenerateActionEmbedding(ctx, "restart", parameters)
			Expect(err).ToNot(HaveOccurred())

			Expect(scaleEmbedding).ToNot(Equal(restartEmbedding),
				"Different action types should produce different embeddings")
		})

		It("should handle empty parameters", func() {
			actionType := "cleanup"

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, nil)
			Expect(err).ToNot(HaveOccurred(), "Should handle nil parameters")

			embedding2, err := embeddingService.GenerateActionEmbedding(ctx, actionType, map[string]interface{}{})
			Expect(err).ToNot(HaveOccurred(), "Should handle empty parameters")

			Expect(embedding).To(Equal(embedding2), "Nil and empty parameters should produce same result")
		})
	})

	Context("Context Embedding Generation", func() {
		It("should generate embedding from labels and metadata", func() {
			labels := map[string]string{
				"app":     "web-server",
				"version": "v1.2.3",
				"tier":    "production",
			}

			metadata := map[string]interface{}{
				"cpu_usage": 75.5,
				"memory_mb": 512,
				"healthy":   true,
			}

			embedding, err := embeddingService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should generate context embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should handle empty labels and metadata", func() {
			embedding1, err := embeddingService.GenerateContextEmbedding(ctx, nil, nil)
			Expect(err).ToNot(HaveOccurred(), "Should handle nil inputs")

			embedding2, err := embeddingService.GenerateContextEmbedding(ctx, map[string]string{}, map[string]interface{}{})
			Expect(err).ToNot(HaveOccurred(), "Should handle empty inputs")

			Expect(embedding1).To(Equal(embedding2), "Nil and empty inputs should produce same result")
		})

		It("should generate different embeddings for different contexts", func() {
			labels1 := map[string]string{"app": "frontend"}
			labels2 := map[string]string{"app": "backend"}

			embedding1, err := embeddingService.GenerateContextEmbedding(ctx, labels1, nil)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateContextEmbedding(ctx, labels2, nil)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).ToNot(Equal(embedding2), "Different contexts should produce different embeddings")
		})
	})

	Context("Embedding Combination", func() {
		var (
			embedding1, embedding2, embedding3 []float64
		)

		BeforeEach(func() {
			dimension := embeddingService.GetEmbeddingDimension()

			embedding1 = make([]float64, dimension)
			embedding2 = make([]float64, dimension)
			embedding3 = make([]float64, dimension)

			// Create test embeddings with known values
			for i := 0; i < dimension; i++ {
				embedding1[i] = 1.0
				embedding2[i] = 2.0
				embedding3[i] = 3.0
			}
		})

		It("should return zero embedding for no input", func() {
			combined := embeddingService.CombineEmbeddings()

			Expect(len(combined)).To(Equal(384), "Should return embedding with correct dimension")

			allZero := true
			for _, val := range combined {
				if val != 0.0 {
					allZero = false
					break
				}
			}
			Expect(allZero).To(BeTrue(), "Should return zero embedding for no input")
		})

		It("should return same embedding for single input", func() {
			combined := embeddingService.CombineEmbeddings(embedding1)

			Expect(combined).To(Equal(embedding1), "Should return same embedding for single input")
		})

		It("should combine multiple embeddings using weighted average", func() {
			combined := embeddingService.CombineEmbeddings(embedding1, embedding2)

			Expect(len(combined)).To(Equal(384), "Combined embedding should have correct dimension")

			// The result will be normalized, so we check proportions rather than exact values
			for i := 0; i < len(combined); i++ {
				Expect(combined[i]).To(BeNumerically(">", 0), "Combined values should be positive")
			}
		})

		It("should handle dimension mismatches gracefully", func() {
			wrongDimension := []float64{1.0, 2.0} // Wrong dimension

			combined := embeddingService.CombineEmbeddings(embedding1, wrongDimension, embedding2)

			Expect(len(combined)).To(Equal(384), "Should return correct dimension despite mismatch")
			// Should skip the mismatched embedding and combine the valid ones
		})

		It("should normalize the combined result", func() {
			combined := embeddingService.CombineEmbeddings(embedding1, embedding2, embedding3)

			// Calculate L2 norm
			var sumSquares float64
			for _, val := range combined {
				sumSquares += val * val
			}
			norm := sumSquares

			Expect(norm).To(BeNumerically("~", 1.0, 0.1), "Combined embedding should be normalized")
		})
	})
})

// BR-VDB-001-015: Embedding Algorithm Logic Tests (Phase 1 Implementation)
// Following UNIT_TEST_COVERAGE_EXTENSION_PLAN.md - Focus on pure algorithmic logic
var _ = Describe("BR-VDB-001-015: Embedding Algorithm Logic Tests", func() {
	var (
		embeddingService *vector.LocalEmbeddingService
		logger           *logrus.Logger
		ctx              context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)
		embeddingService = vector.NewLocalEmbeddingService(384, logger)
		ctx = context.Background()
	})

	// BR-VDB-001: Embedding Generation Algorithm Correctness
	Describe("BR-VDB-001: Embedding Generation Algorithm Correctness", func() {
		Context("when computing embeddings mathematically", func() {
			It("should produce consistent embeddings for identical content", func() {
				content := "critical memory leak in production namespace"

				embedding1, err := embeddingService.GenerateTextEmbedding(ctx, content)
				Expect(err).ToNot(HaveOccurred())

				embedding2, err := embeddingService.GenerateTextEmbedding(ctx, content)
				Expect(err).ToNot(HaveOccurred())

				Expect(embedding1).To(Equal(embedding2), "Identical content must produce identical embeddings")
				Expect(len(embedding1)).To(Equal(384), "Should maintain correct dimensionality")
			})

			It("should handle various input formats and sizes", func() {
				testCases := []struct {
					name    string
					content string
				}{
					{"single word", "kubernetes"},
					{"phrase", "pod memory usage"},
					{"sentence", "Critical alert detected in production environment."},
					{"paragraph", "The Kubernetes pod is experiencing high memory usage which may lead to OOM kills and service degradation. Immediate action is required to investigate and resolve this issue."},
					{"special chars", "alert: memory>80% (critical)!"},
					{"numbers", "CPU usage at 95.7% for 300 seconds"},
					{"empty", ""},
				}

				for _, tc := range testCases {
					By(fmt.Sprintf("Testing %s: '%s'", tc.name, tc.content))
					embedding, err := embeddingService.GenerateTextEmbedding(ctx, tc.content)
					Expect(err).ToNot(HaveOccurred(), "Should handle %s without error", tc.name)
					Expect(len(embedding)).To(Equal(384), "Should maintain dimensionality for %s", tc.name)
				}
			})

			It("should calculate embedding quality metrics accurately", func() {
				content := "high quality kubernetes deployment alert"

				embedding, err := embeddingService.GenerateTextEmbedding(ctx, content)
				Expect(err).ToNot(HaveOccurred())

				// Validate mathematical properties
				var sumSquares float64
				var absSum float64
				nonZeroCount := 0

				for _, val := range embedding {
					sumSquares += val * val
					absSum += val
					if val != 0.0 {
						nonZeroCount++
					}
				}

				// L2 norm should be approximately 1.0 (normalized)
				norm := sumSquares
				Expect(norm).To(BeNumerically("~", 1.0, 0.1), "Embedding should be L2 normalized")

				// Should have non-zero components for non-empty content
				Expect(nonZeroCount).To(BeNumerically(">", 0), "Non-empty content should produce non-zero embeddings")
			})
		})
	})

	// BR-VDB-005: Embedding Optimization Calculations
	Describe("BR-VDB-005: Embedding Optimization Calculations", func() {
		Context("when optimizing embedding parameters", func() {
			It("should calculate optimal dimension sizes mathematically", func() {
				// Test different dimension configurations
				testDimensions := []int{128, 256, 384, 512, 768}

				for _, dim := range testDimensions {
					service := vector.NewLocalEmbeddingService(dim, logger)
					actualDim := service.GetEmbeddingDimension()

					if dim <= 0 {
						Expect(actualDim).To(Equal(384), "Should use default for invalid dimensions")
					} else {
						Expect(actualDim).To(Equal(dim), "Should use specified valid dimension")
					}
				}
			})

			It("should optimize embedding quality metrics", func() {
				content := "optimization test content for quality metrics"

				embedding, err := embeddingService.GenerateTextEmbedding(ctx, content)
				Expect(err).ToNot(HaveOccurred())

				// Calculate quality metrics
				var variance float64
				var mean float64
				dimension := float64(len(embedding))

				// Calculate mean
				for _, val := range embedding {
					mean += val
				}
				mean /= dimension

				// Calculate variance
				for _, val := range embedding {
					variance += (val - mean) * (val - mean)
				}
				variance /= dimension

				// Quality metrics validation
				Expect(variance).To(BeNumerically(">", 0), "Should have non-zero variance for meaningful content")
				Expect(variance).To(BeNumerically("<", 1.0), "Variance should be reasonable for normalized vectors")
			})

			It("should balance quality vs performance algorithmically", func() {
				content := "performance quality balance test"

				// Measure embedding generation performance
				start := time.Now()
				embedding, err := embeddingService.GenerateTextEmbedding(ctx, content)
				duration := time.Since(start)

				Expect(err).ToNot(HaveOccurred())
				Expect(len(embedding)).To(Equal(384))

				// Performance requirement: should generate quickly for unit tests
				Expect(duration).To(BeNumerically("<", 100*time.Millisecond), "Should generate embeddings quickly")

				// Quality requirement: should produce meaningful representations
				nonZeroCount := 0
				for _, val := range embedding {
					if val != 0.0 {
						nonZeroCount++
					}
				}
				// The local embedding service uses a simpler approach - just validate it produces some non-zero values
				Expect(nonZeroCount).To(BeNumerically(">", 0), "Should produce at least some non-zero values for non-empty content")
			})
		})
	})

	// BR-VDB-010: Embedding Combination Algorithm Mathematics
	Describe("BR-VDB-010: Embedding Combination Algorithm Mathematics", func() {
		Context("when combining multiple embeddings using mathematical operations", func() {
			It("should implement weighted averaging algorithm correctly", func() {
				// Create test embeddings with known mathematical properties
				dim := embeddingService.GetEmbeddingDimension()
				embedding1 := make([]float64, dim)
				embedding2 := make([]float64, dim)

				// Initialize with known values for mathematical verification
				for i := 0; i < dim; i++ {
					embedding1[i] = 1.0 // All ones
					embedding2[i] = 3.0 // All threes
				}

				combined := embeddingService.CombineEmbeddings(embedding1, embedding2)

				// Mathematical verification: average should be 2.0 before normalization
				// After normalization, all components should be equal
				for i := 1; i < len(combined); i++ {
					Expect(combined[i]).To(BeNumerically("~", combined[0], 0.001),
						"All components should be equal after combining uniform vectors")
				}

				// Verify L2 normalization
				var sumSquares float64
				for _, val := range combined {
					sumSquares += val * val
				}
				Expect(sumSquares).To(BeNumerically("~", 1.0, 0.01), "Combined result should be L2 normalized")
			})

			It("should handle edge cases in combination algorithm", func() {
				dim := embeddingService.GetEmbeddingDimension()

				// Test case 1: Empty input
				zeroEmbedding := embeddingService.CombineEmbeddings()
				Expect(len(zeroEmbedding)).To(Equal(dim))
				for _, val := range zeroEmbedding {
					Expect(val).To(Equal(0.0), "Empty combination should produce zero vector")
				}

				// Test case 2: Single embedding
				testEmbedding := make([]float64, dim)
				for i := range testEmbedding {
					testEmbedding[i] = float64(i) / float64(dim) // Normalized sequence
				}

				singleCombined := embeddingService.CombineEmbeddings(testEmbedding)
				Expect(singleCombined).To(Equal(testEmbedding), "Single embedding should be returned unchanged")
			})

			It("should validate mathematical correctness with multiple embeddings", func() {
				dim := embeddingService.GetEmbeddingDimension()

				// Create embeddings with known mathematical properties
				embeddings := make([][]float64, 3)
				for i := range embeddings {
					embeddings[i] = make([]float64, dim)
					for j := 0; j < dim; j++ {
						embeddings[i][j] = float64(i + 1) // Values: 1, 2, 3
					}
				}

				combined := embeddingService.CombineEmbeddings(embeddings...)

				// Mathematical verification: all components should be equal (uniform average)
				for i := 1; i < len(combined); i++ {
					Expect(combined[i]).To(BeNumerically("~", combined[0], 0.001),
						"Components should be equal for uniform input vectors")
				}

				// Verify mathematical properties
				var sum float64
				for _, val := range combined {
					sum += val
				}
				Expect(sum).To(BeNumerically(">", 0), "Combined vector should have positive sum")
			})
		})
	})

	// BR-VDB-015: Embedding Validation Logic
	Describe("BR-VDB-015: Embedding Validation Logic", func() {
		Context("when validating embedding properties and constraints", func() {
			It("should validate input parameters thoroughly", func() {
				// Test various invalid inputs
				invalidInputs := []string{
					strings.Repeat("a", 10000), // Very long input
					"\x00\x01\x02",             // Binary data
					"🚀🎯📊",                      // Unicode emojis
				}

				for _, input := range invalidInputs {
					embedding, err := embeddingService.GenerateTextEmbedding(ctx, input)
					Expect(err).ToNot(HaveOccurred(), "Should handle edge case inputs gracefully")
					Expect(len(embedding)).To(Equal(384), "Should maintain dimension for all inputs")
				}
			})

			It("should validate output mathematical properties", func() {
				content := "validation test for mathematical properties"

				embedding, err := embeddingService.GenerateTextEmbedding(ctx, content)
				Expect(err).ToNot(HaveOccurred())

				// Validate mathematical constraints
				for i, val := range embedding {
					Expect(math.IsNaN(val)).To(BeFalse(), "Component %d should not be NaN", i)
					Expect(math.IsInf(val, 1)).To(BeFalse(), "Component %d should not be +Inf", i)
					Expect(math.IsInf(val, -1)).To(BeFalse(), "Component %d should not be -Inf", i)
				}

				// Validate normalization property
				var sumSquares float64
				for _, val := range embedding {
					sumSquares += val * val
				}
				Expect(sumSquares).To(BeNumerically("~", 1.0, 0.1), "Should be approximately normalized")
			})

			It("should ensure deterministic behavior for algorithmic reproducibility", func() {
				content := "deterministic behavior test"

				// Generate multiple embeddings
				embeddings := make([][]float64, 5)
				for i := range embeddings {
					var err error
					embeddings[i], err = embeddingService.GenerateTextEmbedding(ctx, content)
					Expect(err).ToNot(HaveOccurred())
				}

				// All should be identical (deterministic)
				reference := embeddings[0]
				for i := 1; i < len(embeddings); i++ {
					Expect(embeddings[i]).To(Equal(reference),
						"Embedding %d should be identical to reference for deterministic behavior", i)
				}
			})
		})
	})
})

var _ = Describe("Hybrid Embedding Service Unit Tests", func() {
	var (
		localService    *vector.LocalEmbeddingService
		externalService *MockEmbeddingGenerator
		hybridService   *vector.HybridEmbeddingService
		logger          *logrus.Logger
		ctx             context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)

		localService = vector.NewLocalEmbeddingService(384, logger)
		externalService = NewMockEmbeddingGenerator(384)
		hybridService = vector.NewHybridEmbeddingService(localService, externalService, logger)
		ctx = context.Background()
	})

	Context("Service Creation and Configuration", func() {
		It("should create hybrid service with local and external components", func() {
			Expect(hybridService.GetEmbeddingDimension()).To(Equal(384), "BR-DATABASE-001-A: Hybrid embedding service must provide valid dimensions for multi-backend vector storage operations")
		})

		It("should default to local service initially", func() {
			text := "test embedding"

			// Generate with hybrid service
			hybridEmbedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Generate with local service directly
			localEmbedding, err := localService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			Expect(hybridEmbedding).To(Equal(localEmbedding), "Should use local service by default")
		})

		It("should allow switching between local and external services", func() {
			hybridService.SetUseLocal(false) // Switch to external

			dimension := hybridService.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return external service dimension")

			hybridService.SetUseLocal(true) // Switch back to local
			dimension = hybridService.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return local service dimension")
		})
	})

	Context("Local Service Mode", func() {
		BeforeEach(func() {
			hybridService.SetUseLocal(true)
		})

		It("should use local service when configured", func() {
			text := "kubernetes pod alert"

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding via local service")
			Expect(len(embedding)).To(Equal(384), "Should return embedding with correct dimension")

			// Verify external service was not called
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(Equal(0), "Should not call external service when using local")
		})

		It("should use local service for action embeddings", func() {
			actionType := "scale"
			parameters := map[string]interface{}{"replicas": 5}

			embedding, err := hybridService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should generate action embedding via local service")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should use local service for context embeddings", func() {
			labels := map[string]string{"app": "test"}
			metadata := map[string]interface{}{"cpu": 50}

			embedding, err := hybridService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should generate context embedding via local service")
			Expect(len(embedding)).To(Equal(384))
		})
	})

	Context("External Service Mode", func() {
		BeforeEach(func() {
			hybridService.SetUseLocal(false)
		})

		It("should use external service when configured", func() {
			text := "external service test"
			expectedEmbedding := []float64{0.5, 0.6, 0.7}
			externalService.SetTextEmbeddingResult(expectedEmbedding, nil)

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding via external service")
			Expect(embedding).To(Equal(expectedEmbedding), "Should return external service result")

			// Verify external service was called
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(Equal(1), "Should call external service")
			Expect(externalCalls[0].Text).To(Equal(text), "Should pass correct text to external service")
		})

		It("should fallback to local service when external service fails", func() {
			text := "fallback test"
			externalService.SetTextEmbeddingResult(nil, fmt.Errorf("external service error"))

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service on external error")
			Expect(len(embedding)).To(Equal(384), "Should return valid embedding from local fallback")

			// Verify external service was attempted (should be >= 1 call due to mock implementation)
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(BeNumerically(">=", 1), "Should attempt external service first")
		})

		It("should fallback for action embeddings", func() {
			actionType := "restart"
			parameters := map[string]interface{}{"timeout": 30}

			externalService.SetActionEmbeddingResult(nil, fmt.Errorf("action embedding error"))

			embedding, err := hybridService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service for action embedding error")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should fallback for context embeddings", func() {
			labels := map[string]string{"tier": "production"}
			metadata := map[string]interface{}{"memory": 1024}

			externalService.SetContextEmbeddingResult(nil, fmt.Errorf("context embedding error"))

			embedding, err := hybridService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service for context embedding error")
			Expect(len(embedding)).To(Equal(384))
		})
	})

	Context("External Service Not Available", func() {
		var hybridServiceNoExternal *vector.HybridEmbeddingService

		BeforeEach(func() {
			hybridServiceNoExternal = vector.NewHybridEmbeddingService(localService, nil, logger)
			hybridServiceNoExternal.SetUseLocal(false) // Try to use external, but it's nil
		})

		It("should fallback to local service when external service is nil", func() {
			text := "no external service"

			embedding, err := hybridServiceNoExternal.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local when external is nil")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should return local service dimension when external is nil", func() {
			dimension := hybridServiceNoExternal.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return local dimension when external is nil")
		})
	})

	Context("Embedding Combination in Hybrid Service", func() {
		It("should delegate combination to local service", func() {
			embedding1 := make([]float64, 384)
			embedding2 := make([]float64, 384)

			// Fill with test values
			for i := range embedding1 {
				embedding1[i] = 1.0
				embedding2[i] = 2.0
			}

			combined := hybridService.CombineEmbeddings(embedding1, embedding2)

			// Should delegate to local service
			localCombined := localService.CombineEmbeddings(embedding1, embedding2)
			Expect(combined).To(Equal(localCombined), "Should delegate combination to local service")
		})
	})

	Context("Service State Management", func() {
		It("should track service mode changes", func() {
			// Start in local mode
			hybridService.SetUseLocal(true)
			dimension1 := hybridService.GetEmbeddingDimension()

			// Switch to external mode
			hybridService.SetUseLocal(false)
			dimension2 := hybridService.GetEmbeddingDimension()

			// Both should return same dimension in this test case, but behavior might differ
			Expect(dimension1).To(Equal(dimension2), "Dimension should be consistent")
		})

		It("should handle rapid mode switching", func() {
			text := "mode switching test"

			// Switch modes rapidly and ensure consistency
			for i := 0; i < 10; i++ {
				hybridService.SetUseLocal(i%2 == 0)

				embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
				Expect(err).ToNot(HaveOccurred(), "Should handle rapid mode switching")
				Expect(len(embedding)).To(Equal(384), "Should maintain consistent dimension")
			}
		})
	})
})
