---
globs: "*.go"
description: "Go coding standards and patterns specific to kubernaut"
---

# Go Coding Standards for Kubernaut

## Code Organization
- Use clear, descriptive names that reflect business domain (e.g., `EffectivenessAssessor`, `WorkflowEngine`)
- **MANDATORY**: Every component must serve a documented business requirement (BR-XXX-XXX)
- Group related functionality into cohesive packages following DDD principles
- Implement interfaces over concrete types for testability and flexibility
- **AVOID** duplicating structure names - use unique, business-aligned names

## Error Handling
- Always wrap errors with context using `fmt.Errorf("operation description: %w", err)`
- Use structured error types from [internal/errors/](mdc:internal/errors/) for consistent error categorization
- Log errors at the appropriate level with structured fields using logrus

## Context and Cancellation
- Always accept `context.Context` as first parameter for operations that can be cancelled
- Respect context cancellation in loops and long-running operations
- Use context for request-scoped values like trace IDs and user information

## Type System Guidelines
- **MANDATORY**: Avoid using `any` or `interface{}` unless absolutely necessary
- **ALWAYS** use structured field values with specific types
- **AVOID** local type definitions to resolve import cycles
- Use shared types from [pkg/shared/types/](mdc:pkg/shared/types/) package instead
- Prefer strongly-typed interfaces that reflect business domain concepts

## Testing Patterns
- **MANDATORY**: Follow Test-Driven Development (TDD) - write tests first per [00-project-guidelines.mdc](mdc:.cursor/rules/00-project-guidelines.mdc)
- Use Ginkgo/Gomega BDD testing framework as established in [test/](mdc:test/)
- Follow three-tier testing strategy: unit (pure logic), integration (cross-component), e2e (full workflow)
- **PREFER REAL BUSINESS LOGIC**: Use actual components from pkg/ over mocks for non-external dependencies
- Use mock factories from [pkg/testutil/mock_factory.go](mdc:pkg/testutil/mock_factory.go) only when scenario requires it (external services, error simulation, performance)
- Test scenarios must validate business outcomes, not implementation details
- **ALL tests must reference specific business requirements** (BR-XXX-XXX format)

## üéØ **MOCK USAGE DECISION MATRIX - EXPLICIT GUIDELINES**

### **WHEN TO MOCK - MANDATORY CRITERIA**

#### **‚úÖ ALWAYS MOCK: External Services**
```go
// External AI APIs
mockHolmesGPT := &MockHolmesGPTClient{}

// External databases (when testing business logic)
mockVectorDB := &MockVectorDatabase{}

// External Kubernetes APIs (for unit tests)
mockK8sClient := &MockKubernetesClient{}

// Network services
mockHTTPClient := &MockHTTPClient{}
```

#### **‚úÖ ALWAYS MOCK: Error Simulation**
```go
// Simulate AI service failures
llmClient.SetError(errors.New("AI service unavailable"))

// Simulate database connection errors
dbClient.SetConnectionError(errors.New("connection timeout"))

// Simulate Kubernetes API failures
k8sClient.SetError(errors.New("unauthorized"))
```

#### **‚úÖ ALWAYS MOCK: Performance Testing**
```go
// Simulate slow AI responses
aiClient.SetLatency(10 * time.Second)

// Simulate database query timeouts
dbClient.SetQueryTimeout(5 * time.Second)

// Control timing for concurrency tests
mockTimer := &MockTimer{}
```

### **WHEN TO USE REAL COMPONENTS - MANDATORY CRITERIA**

#### **‚úÖ ALWAYS REAL: Business Logic**
```go
// Real business algorithms
effectivenessCalculator := effectiveness.New() // Real calculation

// Real workflow generation logic
workflowBuilder := engine.NewIntelligentWorkflowBuilder() // Real business logic

// Real AI analysis algorithms (with mocked external calls)
contextOptimizer := llm.NewContextOptimizer(mockLLMAPI, realConfig) // Real + Mock
```

#### **‚úÖ ALWAYS REAL: Integration Between Components**
```go
// Real component integration
workflowEngine := engine.New(realProcessor, realAnalyzer) // Real integration

// Real data flow
processor.SetAnalyzer(realAnalyzer) // Real wiring

// Real configuration handling
config := config.Load(realConfigFile) // Real config parsing
```

#### **‚úÖ ALWAYS REAL: Context Usage**
```go
// Real context handling
ctx := context.WithTimeout(context.Background(), 30*time.Second) // Real context

// Real context cancellation
result := component.Process(ctx, data) // Test real context behavior

// Real context value propagation
ctx = context.WithValue(ctx, "traceID", "test-123") // Real context values
```

### **DECISION ALGORITHM - AUTOMATED GUIDANCE**

```bash
#!/bin/bash
# mock-usage-decision.sh - Automated mock usage guidance

COMPONENT="$1"
TEST_TYPE="$2"  # unit, integration, e2e

echo "üéØ Mock Usage Decision for: $COMPONENT in $TEST_TYPE test"

# Decision tree
if [[ "$COMPONENT" == *"Client"* && "$COMPONENT" == *"Holmes"* ]]; then
    echo "‚úÖ MOCK: External AI service"
elif [[ "$COMPONENT" == *"K8s"* && "$TEST_TYPE" == "unit" ]]; then
    echo "‚úÖ MOCK: External Kubernetes API for unit test"
elif [[ "$COMPONENT" == *"Calculator"* || "$COMPONENT" == *"Analyzer"* ]]; then
    echo "‚úÖ REAL: Business logic component"
elif [[ "$COMPONENT" == *"Engine"* || "$COMPONENT" == *"Processor"* ]]; then
    echo "‚úÖ REAL: Core business component"
elif [[ "$COMPONENT" == *"Config"* ]]; then
    echo "‚úÖ REAL: Configuration handling"
else
    echo "‚ùì UNCLEAR: Review decision matrix in Rule 02"
    echo "Guidelines:"
    echo "- External services ‚Üí MOCK"
    echo "- Business logic ‚Üí REAL"
    echo "- Error simulation ‚Üí MOCK"
    echo "- Integration testing ‚Üí REAL"
fi
```

### **MOCK USAGE VALIDATION - AUTOMATED DETECTION**

```bash
#!/bin/bash
# validate-mock-usage.sh - Detect mock usage violations

echo "üîç Validating mock usage compliance..."

# Check for over-mocking of business logic
BUSINESS_MOCKS=$(grep -r "Mock.*Calculator\|Mock.*Analyzer\|Mock.*Engine" test/ --include="*_test.go" | wc -l)
TOTAL_BUSINESS=$(grep -r "Calculator\|Analyzer\|Engine" test/ --include="*_test.go" | wc -l)

if [ "$BUSINESS_MOCKS" -gt "$((TOTAL_BUSINESS / 2))" ]; then
    echo "‚ùå MOCK VIOLATION: Over-mocking business logic components"
    echo "üîß Rule: Use real business components, mock external services only"
    exit 1
fi

# Check for under-mocking of external services
EXTERNAL_REAL=$(grep -r "holmesgpt\.NewClient\|k8s\.NewClient" test/ --include="*_test.go" | wc -l)
if [ "$EXTERNAL_REAL" -gt 5 ]; then
    echo "‚ùå MOCK VIOLATION: Using real external services in tests"
    echo "üîß Rule: Mock external services for reliable testing"
    exit 1
fi

# Check for context mocking
CONTEXT_MOCKS=$(grep -r "MockContext\|&context\." test/ --include="*_test.go" | wc -l)
if [ "$CONTEXT_MOCKS" -gt 0 ]; then
    echo "‚ùå MOCK VIOLATION: Mocking context.Context"
    echo "üîß Rule: Use real context.Context - it's designed for testing"
    exit 1
fi

echo "‚úÖ Mock usage validation passed"
```

### **MOCK USAGE ANTI-PATTERNS**

#### **‚ùå ANTI-PATTERN 1: Over-Mocking Business Logic**
```go
// WRONG: Mocking core business components
mockWorkflowEngine := &MockWorkflowEngine{}  // ‚ùå Business logic should be real
mockCalculator := &MockCalculator{}          // ‚ùå Business logic should be real

// CORRECT: Use real business logic, mock externals
realWorkflowEngine := engine.New(mockAIClient, realConfig)  // ‚úÖ Real business + Mock external
realCalculator := effectiveness.New()                      // ‚úÖ Real business logic
```

#### **‚ùå ANTI-PATTERN 2: Under-Mocking External Services**
```go
// WRONG: Using real external services
holmesClient := holmesgpt.NewClient(realConfig)  // ‚ùå Real external service
k8sClient := k8s.NewClient(realKubeConfig)       // ‚ùå Real external service

// CORRECT: Mock external services
mockHolmesClient := testutil.NewMockHolmesGPTClient()  // ‚úÖ Mock external
mockK8sClient := testutil.NewMockKubernetesClient()    // ‚úÖ Mock external
```

#### **‚ùå ANTI-PATTERN 3: Context Mocking**
```go
// WRONG: Mocking context
mockCtx := &MockContext{}  // ‚ùå Context should never be mocked

// CORRECT: Use real context
ctx := context.WithTimeout(context.Background(), 30*time.Second)  // ‚úÖ Real context
```

## AI/ML Integration Patterns
- Use interfaces for AI providers to support multiple LLM backends (OpenAI, Anthropic, Ollama, etc.)
- Implement retry logic with exponential backoff for AI API calls
- Always validate AI responses before acting on them
- Use confidence scores to make decisions about AI recommendations

## Kubernetes Client Patterns
- Use the shared client from [pkg/platform/k8s/client.go](mdc:pkg/platform/k8s/client.go)
- Implement safety checks before performing destructive operations
- Always use dry-run mode when possible for validation
- Handle Kubernetes API rate limiting gracefully

## Database Access
- Use connection pooling and prepared statements for PostgreSQL operations
- Implement proper transaction management for multi-step operations
- Use separate connections for vector database operations
- Handle database migrations through [migrations/](mdc:migrations/) directory

## Concurrency
- Use worker pools for parallel processing with proper resource limits
- Implement circuit breakers for external service calls
- Use sync.Once for expensive initialization operations
- Prefer channels over shared memory for communication between goroutines

## Configuration
- Use YAML configuration files in [config/](mdc:config/) directory
- Implement environment variable overrides for deployment flexibility
- Validate configuration at startup with clear error messages
- Use defaults that work for local development