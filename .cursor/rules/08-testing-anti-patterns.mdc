---
globs: "*_test.go,test/**/*"
description: "Critical testing anti-patterns to avoid in kubernaut development"
---

# Testing Anti-Patterns - CRITICAL REFERENCE WITH AUTOMATED DETECTION

## ü§ñ **AUTOMATED ANTI-PATTERN DETECTION - MANDATORY**

### Detection Scripts - MANDATORY
Run these checks before ANY test commit:

```bash
# Run comprehensive cursor rule validation
# Prevention through APDC methodology and design patterns

# Individual pattern checks:
# 1. NULL-TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeEmpty())\|ToNot(BeNil())" {} \;
# VIOLATION: Any matches = immediate rejection

# 2. STATIC DATA TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \;
# VIOLATION: Testing hardcoded strings = immediate rejection

# 3. LIBRARY TESTING DETECTION
find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \;
# VIOLATION: Testing libraries instead of business logic = immediate rejection

# 4. BUSINESS LOGIC INTEGRATION CHECK
for file in $(find test/ -name "*_test.go"); do
  if ! grep -q "github.com/jordigilh/kubernaut/pkg/" "$file"; then
    echo "VIOLATION: $file - No business logic imports"
  fi
done
```

### Enforcement Levels - MANDATORY
- **LEVEL 1 - BLOCK COMPILATION**: Tests with anti-patterns MUST NOT compile
- **LEVEL 2 - PRE-COMMIT GATE**: Git hooks prevent commits with violations
- **LEVEL 3 - CI/CD GATE**: Pipeline fails on cursor rule violations

### Git Hook Integration - MANDATORY
```bash
#!/bin/bash
# .git/hooks/pre-commit (MANDATORY)

# Run cursor rule validation
# Prevention through APDC methodology and design patterns
if [ $? -ne 0 ]; then
    echo "‚ùå Cursor rule violations detected. Commit blocked."
    exit 1
fi

echo "‚úÖ All cursor rule validations passed"
```

---

## üö® **CRITICAL ANTI-PATTERNS - IMMEDIATE REJECTION**

### **ANTI-PATTERN 1: NULL-TESTING (MOST CRITICAL)**

**Definition**: Testing for basic existence rather than business outcomes

**‚ùå VIOLATION EXAMPLES**:
```go
// NULL-TESTING: Tests nothing meaningful
Expect(result).ToNot(BeNil())           // ‚ùå VIOLATION
Expect(result).ToNot(BeEmpty())         // ‚ùå VIOLATION
Expect(len(items)).To(BeNumerically(">", 0))  // ‚ùå VIOLATION
Expect(err).To(BeNil())                 // ‚ùå VIOLATION (weak error testing)
```

**‚úÖ CORRECT BUSINESS TESTING**:
```go
// BUSINESS OUTCOME TESTING: Tests meaningful business results
Expect(workflow.Template.SafetyValidation).To(ContainElement("resource-limits"))
Expect(analysis.ConfidenceScore).To(BeNumerically(">=", 0.8))
Expect(recommendation.Actions).To(HaveLen(3))
Expect(result.BusinessMetrics.SuccessRate).To(BeNumerically(">", 0.9))
```

**Automated Detection**:
```bash
# Detect NULL-TESTING violations
grep -r "ToNot(BeNil())\|ToNot(BeEmpty())\|BeNumerically(\">\".*0)" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 2: STATIC DATA TESTING**

**Definition**: Testing hardcoded values instead of business logic

**‚ùå VIOLATION EXAMPLES**:
```go
// STATIC DATA TESTING: Tests hardcoded strings
input := "test-alert-name"               // ‚ùå VIOLATION: Hardcoded test data
Expect(result.Name).To(Equal("test-alert-name"))  // ‚ùå VIOLATION: Static assertion

config := Config{Endpoint: "http://test"}  // ‚ùå VIOLATION: Hardcoded config
Expect(client.endpoint).To(Equal("http://test"))  // ‚ùå VIOLATION: Static testing
```

**‚úÖ CORRECT DYNAMIC TESTING**:
```go
// DYNAMIC BUSINESS TESTING: Tests business logic with realistic data
alertData := testutil.GenerateRealisticAlert()  // ‚úÖ CORRECT: Dynamic test data
workflow, err := engine.CreateWorkflow(ctx, alertData)
Expect(workflow.Template.Actions).To(ContainElement(
    MatchFields(IgnoreExtras, Fields{
        "Type": Equal("scale-deployment"),
        "Target": Equal(alertData.Resource.Name),
    }),
))
```

**Automated Detection**:
```bash
# Detect STATIC DATA TESTING violations
grep -r ".*:= \".*\".*Expect(" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 3: LIBRARY TESTING**

**Definition**: Testing external libraries instead of business logic

**‚ùå VIOLATION EXAMPLES**:
```go
// LIBRARY TESTING: Tests external library behavior
logger := logrus.New()                   // ‚ùå VIOLATION: Testing logrus
logger.SetLevel(logrus.InfoLevel)
Expect(logger.Level).To(Equal(logrus.InfoLevel))  // ‚ùå VIOLATION: Library testing

ctx := context.WithTimeout(context.Background(), time.Second)  // ‚ùå VIOLATION
Expect(ctx.Err()).To(BeNil())           // ‚ùå VIOLATION: Testing context library
```

**‚úÖ CORRECT BUSINESS TESTING**:
```go
// BUSINESS LOGIC TESTING: Tests our business components
analyticsEngine := insights.NewAnalyticsEngine(config)  // ‚úÖ CORRECT: Business component
riskAssessment, err := analyticsEngine.AssessWorkflowRisk(workflow)
Expect(riskAssessment.RiskLevel).To(BeNumerically("<", 0.3))  // ‚úÖ CORRECT: Business outcome
```

**Automated Detection**:
```bash
# Detect LIBRARY TESTING violations
grep -r "logrus\.New()\|context\.With\|os\.Set\|time\.Now()" test/ --include="*_test.go"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 4: MOCK OVERUSE**

**Definition**: Mocking business logic instead of external dependencies

**AUTHORITY**: See comprehensive mock usage matrix in [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc#mock-usage-decision-matrix---authoritative-source) for correct mock usage patterns.

**‚ùå VIOLATION EXAMPLES**:
```go
// MOCK OVERUSE: Mocking business logic
mockWorkflowEngine := &MockWorkflowEngine{}  // ‚ùå VIOLATION: Business logic mocked
mockAnalytics := &MockAnalyticsEngine{}     // ‚ùå VIOLATION: Business logic mocked
mockSafety := &MockSafetyFramework{}        // ‚ùå VIOLATION: Business logic mocked
```

**‚úÖ CORRECT MOCK USAGE**:
```go
// CORRECT MOCKING: Mock external dependencies only
mockLLMClient := mocks.NewMockLLMClient()    // ‚úÖ CORRECT: External AI service
mockK8sClient := mocks.NewMockKubernetesClient()  // ‚úÖ CORRECT: External infrastructure

// Use REAL business logic
workflowEngine := engine.NewIntelligentWorkflowBuilder(mockLLMClient, mockK8sClient)
analyticsEngine := insights.NewAnalyticsEngine(realConfig)  // ‚úÖ CORRECT: Real business logic
```

**Automated Detection**:
```bash
# Detect MOCK OVERUSE violations
grep -r "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" test/ --include="*_test.go" | grep -v "LLM\|K8s\|Database"
# Any matches = IMMEDIATE REJECTION
```

### **ANTI-PATTERN 5: HTTP SERVER IN INTEGRATION TESTS (CRITICAL)**

**Definition**: Using HTTP server/endpoint in integration tests instead of calling business logic directly

**SEVERITY**: Critical - Violates testing tier boundaries (per [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc))

**DISCOVERED**: 2026-01-12 during RR Reconstruction feature development

**WHY THIS IS WRONG**:
- Integration tests MUST test business logic with real infrastructure (database, etc.)
- HTTP layer testing belongs in E2E tests (10-15% coverage tier)
- Using HTTP server conflates integration and E2E testing tiers
- Prevents proper testing pyramid architecture

**‚ùå VIOLATION EXAMPLES**:
```go
// ‚ùå WRONG: Integration test using HTTP server
testServer, err := server.NewServer(db.DB, redisClient, logger)
req := httptest.NewRequest(http.MethodPost, "/api/v1/endpoint", nil)
rr := httptest.NewRecorder()
testServer.ServeHTTP(rr, req)                    // ‚ùå VIOLATION: HTTP testing in integration tests

// Asserting HTTP responses in integration tests
Expect(rr.Code).To(Equal(http.StatusOK))         // ‚ùå VIOLATION: Testing HTTP status codes
var response map[string]interface{}
json.Unmarshal(rr.Body.Bytes(), &response)       // ‚ùå VIOLATION: Testing JSON serialization
```

**‚úÖ CORRECT INTEGRATION TESTING**:
```go
// ‚úÖ CORRECT: Integration test calls business logic directly
// Test with REAL database, REAL business components
events, err := reconstruction.QueryAuditEventsForReconstruction(ctx, db.DB, logger, correlationID)
Expect(err).ToNot(HaveOccurred())

parsedData := make([]reconstruction.ParsedAuditData, 0, len(events))
for _, event := range events {
    parsed, err := reconstruction.ParseAuditEvent(event)
    Expect(err).ToNot(HaveOccurred())
    parsedData = append(parsedData, *parsed)
}

rrFields, err := reconstruction.MergeAuditData(parsedData)
Expect(err).ToNot(HaveOccurred())

rr, err := reconstruction.BuildRemediationRequest(correlationID, rrFields)
Expect(err).ToNot(HaveOccurred())

// Assert business outcomes, NOT HTTP responses
Expect(rr.Spec.SignalName).To(Equal("HighCPU"))
Expect(rr.Status.TimeoutConfig.Global.Duration).To(Equal(time.Hour))
```

**‚úÖ CORRECT E2E TESTING (For HTTP Layer)**:
```go
// ‚úÖ CORRECT: E2E test uses OpenAPI client for HTTP endpoint
client, _ := ogenclient.NewClient("http://data-storage-service:8080")
response, err := client.ReconstructRemediationRequest(ctx, ogenclient.ReconstructRemediationRequestParams{
    CorrelationID: correlationID,
})

// Assert HTTP-level concerns
Expect(err).ToNot(HaveOccurred())
Expect(response.RemediationRequestYaml).ToNot(BeEmpty())
Expect(response.Validation.IsValid).To(BeTrue())
```

**TESTING TIER DECISION MATRIX**:

| Question | Unit | Integration | E2E |
|----------|------|-------------|-----|
| Uses httptest.NewRecorder()? | ‚ùå Never | ‚ùå Never | ‚úÖ Yes |
| Uses testServer.ServeHTTP()? | ‚ùå Never | ‚ùå Never | ‚úÖ Yes |
| Calls business logic directly? | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |
| Uses OpenAPI client? | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| Tests HTTP status codes? | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| Tests JSON serialization? | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| Uses real database? | ‚ùå No (mock) | ‚úÖ Yes | ‚úÖ Yes |

**Automated Detection**:
```bash
# Detect HTTP SERVER usage in integration tests
grep -r "testServer\.ServeHTTP\|httptest\.NewRecorder\|NewServer.*http" test/integration/ --include="*_test.go"
# Any matches in test/integration/ = IMMEDIATE REJECTION

# Verify integration tests call business logic directly
grep -r "\.Query.*ForReconstruction\|\.Parse.*Event\|\.Build.*Request\|\.Validate.*RR" test/integration/ --include="*_test.go"
# No matches = MISSING BUSINESS LOGIC CALLS
```

**REFERENCE AUTHORITY**:
- **Testing Strategy**: [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) - Testing pyramid and tier boundaries
- **Testing Tiers Guide**: `docs/development/SOC2/RECONSTRUCTION_TESTING_TIERS.md` - Detailed tier specifications
- **Coverage Standards**: [15-testing-coverage-standards.mdc](mdc:.cursor/rules/15-testing-coverage-standards.mdc) - >50% integration coverage requirement

**IMPACT**:
- ‚ùå Incorrect: 3 integration tests using HTTP server (VIOLATED testing tier boundaries)
- ‚úÖ Corrected: 5 integration tests calling business logic directly (COMPLIANT with testing tiers)

---

## üîß **AUTOMATED VALIDATION SCRIPTS**

### **Master Validation Script**
```bash
#!/bin/bash
# scripts/cursor-rule-validator.sh

set -e

echo "üîç CURSOR RULE VALIDATION - TESTING ANTI-PATTERNS"

VIOLATIONS=0

# 1. NULL-TESTING DETECTION
echo "Checking for NULL-TESTING violations..."
NULL_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeNil())\|ToNot(BeEmpty())\|BeNumerically(\">\".*0)" {} \; | wc -l)
if [ "$NULL_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå NULL-TESTING violations found: $NULL_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "ToNot(BeNil())\|ToNot(BeEmpty())" {} \;
    VIOLATIONS=$((VIOLATIONS + NULL_VIOLATIONS))
fi

# 2. STATIC DATA TESTING DETECTION
echo "Checking for STATIC DATA TESTING violations..."
STATIC_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \; | wc -l)
if [ "$STATIC_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå STATIC DATA TESTING violations found: $STATIC_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n ".*:= \".*\".*Expect(" {} \;
    VIOLATIONS=$((VIOLATIONS + STATIC_VIOLATIONS))
fi

# 3. LIBRARY TESTING DETECTION
echo "Checking for LIBRARY TESTING violations..."
LIBRARY_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \; | wc -l)
if [ "$LIBRARY_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå LIBRARY TESTING violations found: $LIBRARY_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "logrus\.New()\|context\.With\|os\.Set" {} \;
    VIOLATIONS=$((VIOLATIONS + LIBRARY_VIOLATIONS))
fi

# 4. BUSINESS LOGIC INTEGRATION CHECK
echo "Checking for BUSINESS LOGIC integration..."
MISSING_BUSINESS_LOGIC=0
for file in $(find test/ -name "*_test.go"); do
    if ! grep -q "github.com/jordigilh/kubernaut/pkg/" "$file"; then
        echo "‚ùå MISSING BUSINESS LOGIC: $file"
        MISSING_BUSINESS_LOGIC=$((MISSING_BUSINESS_LOGIC + 1))
    fi
done
VIOLATIONS=$((VIOLATIONS + MISSING_BUSINESS_LOGIC))

# 5. MOCK OVERUSE DETECTION
echo "Checking for MOCK OVERUSE violations..."
MOCK_VIOLATIONS=$(find test/ -name "*_test.go" -exec grep -H -n "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" {} \; | grep -v "LLM\|K8s\|Database" | wc -l)
if [ "$MOCK_VIOLATIONS" -gt 0 ]; then
    echo "‚ùå MOCK OVERUSE violations found: $MOCK_VIOLATIONS"
    find test/ -name "*_test.go" -exec grep -H -n "Mock.*Engine\|Mock.*Analytics\|Mock.*Safety" {} \; | grep -v "LLM\|K8s\|Database"
    VIOLATIONS=$((VIOLATIONS + MOCK_VIOLATIONS))
fi

# FINAL RESULT
if [ "$VIOLATIONS" -gt 0 ]; then
    echo ""
    echo "üö® TOTAL VIOLATIONS: $VIOLATIONS"
    echo "‚ùå CURSOR RULE VALIDATION FAILED"
    echo ""
    echo "üîß REMEDIATION REQUIRED:"
    echo "1. Replace NULL-TESTING with business outcome assertions"
    echo "2. Replace static data with dynamic test data generators"
    echo "3. Replace library testing with business logic testing"
    echo "4. Add business logic imports to all test files"
    echo "5. Replace business logic mocks with real components"
    echo ""
    exit 1
else
    echo "‚úÖ ALL CURSOR RULE VALIDATIONS PASSED"
    exit 0
fi
```

### **Pre-Commit Hook Installation**
```bash
#!/bin/bash
# scripts/install-cursor-rule-hooks.sh

echo "Installing cursor rule validation hooks..."

# Create pre-commit hook
cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# Cursor rule validation pre-commit hook

echo "üîç Running cursor rule validation..."

# Run cursor rule validator
# Prevention through APDC methodology and design patterns
if [ $? -ne 0 ]; then
    echo "‚ùå Cursor rule violations detected. Commit blocked."
    echo "üîß Fix violations and try again."
    exit 1
fi

echo "‚úÖ Cursor rule validation passed"
EOF

# Make hook executable
chmod +x .git/hooks/pre-commit

echo "‚úÖ Cursor rule hooks installed successfully"
```

---

## üìã **ANTI-PATTERN REMEDIATION GUIDE**

### **NULL-TESTING ‚Üí BUSINESS OUTCOME TESTING**
```go
// ‚ùå BEFORE: NULL-TESTING
Expect(result).ToNot(BeNil())

// ‚úÖ AFTER: BUSINESS OUTCOME TESTING
Expect(result.WorkflowTemplate.SafetyChecks).To(ContainElement("resource-validation"))
Expect(result.ConfidenceScore).To(BeNumerically(">=", 0.8))
```

### **STATIC DATA ‚Üí DYNAMIC DATA**
```go
// ‚ùå BEFORE: STATIC DATA
input := "test-alert"
Expect(output.Name).To(Equal("test-alert"))

// ‚úÖ AFTER: DYNAMIC DATA
alertData := testutil.GenerateRealisticAlert()
workflow, err := engine.CreateWorkflow(ctx, alertData)
Expect(workflow.SourceAlert.ID).To(Equal(alertData.ID))
```

### **LIBRARY TESTING ‚Üí BUSINESS TESTING**
```go
// ‚ùå BEFORE: LIBRARY TESTING
logger := logrus.New()
Expect(logger.Level).To(Equal(logrus.InfoLevel))

// ‚úÖ AFTER: BUSINESS TESTING
analyticsEngine := insights.NewAnalyticsEngine(config)
metrics, err := analyticsEngine.CalculateEffectiveness(workflow)
Expect(metrics.SuccessRate).To(BeNumerically(">", 0.9))
```

### **MOCK OVERUSE ‚Üí REAL BUSINESS LOGIC**
```go
// ‚ùå BEFORE: MOCK OVERUSE
mockEngine := &MockWorkflowEngine{}

// ‚úÖ AFTER: REAL BUSINESS LOGIC
mockLLMClient := mocks.NewMockLLMClient()  // Mock external only
realEngine := engine.NewIntelligentWorkflowBuilder(mockLLMClient, realConfig)
```

---

## üéØ **QUALITY GATES**

### **Commit-Level Gates**
- **Gate 1**: No NULL-TESTING patterns allowed
- **Gate 2**: No static data testing allowed
- **Gate 3**: No library testing allowed
- **Gate 4**: Business logic integration required
- **Gate 5**: Proper mock usage enforced

### **CI/CD-Level Gates**
- **Pipeline Gate**: All cursor rule validations must pass
- **Coverage Gate**: Business logic coverage requirements met
- **Quality Gate**: Anti-pattern detection score = 0

### **Release-Level Gates**
- **Final Validation**: Complete anti-pattern scan
- **Business Logic Audit**: All tests validate business outcomes
- **Mock Usage Audit**: External dependencies only

---

## üîó **INTEGRATION WITH OTHER RULES**

**Enforces**: [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) pyramid testing approach
**Supports**: [00-core-development-methodology.mdc](mdc:.cursor/rules/00-core-development-methodology.mdc) TDD methodology
**Validates**: [12-ai-ml-development-methodology.mdc](mdc:.cursor/rules/12-ai-ml-development-methodology.mdc) AI testing patterns
**Priority**: ENFORCEMENT - Automated quality gates that prevent anti-pattern violations