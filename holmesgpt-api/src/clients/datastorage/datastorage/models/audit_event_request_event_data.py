# coding: utf-8

"""
    Data Storage Service API

    Data Storage Service provides REST API access to audit trail persistence.  **Business Requirements**: - BR-STORAGE-001 to BR-STORAGE-020: Audit write API - BR-STORAGE-021: Incident query API (READ) - BR-STORAGE-024: RFC 7807 error responses - BR-AUDIT-006: Legal hold capability (SOC2 Gap #8)  **Design Decisions**: - ADR-031: OpenAPI 3.0+ specification for all stateless REST APIs - ADR-032: Data Access Layer Isolation (only Data Storage connects to PostgreSQL) - DD-009: Dead Letter Queue fallback on database errors - DD-AUTH-004: OAuth-proxy sidecar for authentication/authorization - DD-AUTH-005: Client authentication pattern (ServiceAccount tokens)  **Architecture**: This service is the **ONLY** service that directly accesses PostgreSQL. All other services (Context API, Effectiveness Monitor, etc.) access data through this REST API Gateway.  **Authentication & Authorization (Production/E2E)**: All requests to DataStorage are protected by an OAuth-proxy sidecar:  1. **Client Authentication**: Services authenticate with Kubernetes ServiceAccount tokens    - Token mounted at: `/var/run/secrets/kubernetes.io/serviceaccount/token`    - Clients inject: `Authorization: Bearer <token>` header    - See DD-AUTH-005 for client implementation patterns  2. **OAuth-Proxy Validation**: The sidecar validates requests    - Validates JWT token signature and expiration    - Performs Subject Access Review (SAR) to check RBAC permissions    - Injects `X-Auth-Request-User` header with authenticated user identity    - Returns HTTP 401 if token invalid, HTTP 403 if SAR fails  3. **Handler Enforcement**: DataStorage handlers extract user identity    - Legal hold operations REQUIRE `X-Auth-Request-User` header    - HTTP 401 returned if header missing (authentication failed)    - User identity stored in audit events for SOC2 compliance  **Routing Flow**: ``` Client → data-storage-service:8080 (Service)        ↓      oauth-proxy:8080 (validates token + SAR)        ↓      DataStorage:8081 (X-Auth-Request-User header) ```  **Integration Tests**: Integration tests run without oauth-proxy. Use `testutil.NewMockUserTransport()` to inject mock `X-Auth-Request-User` headers directly.  **SOC2 Compliance**: - All legal hold operations attributed to authenticated users - Audit trail captures placed_by/released_by from X-Auth-Request-User - Unauthorized access blocked at oauth-proxy layer (defense-in-depth) 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
from inspect import getfullargspec
import json
import pprint
import re  # noqa: F401

from typing import Any, List, Optional
from pydantic import BaseModel, Field, StrictStr, ValidationError, field_validator
from datastorage.models.ai_analysis_approval_decision_payload import AIAnalysisApprovalDecisionPayload
from datastorage.models.ai_analysis_audit_payload import AIAnalysisAuditPayload
from datastorage.models.ai_analysis_error_payload import AIAnalysisErrorPayload
from datastorage.models.ai_analysis_holmes_gpt_call_payload import AIAnalysisHolmesGPTCallPayload
from datastorage.models.ai_analysis_phase_transition_payload import AIAnalysisPhaseTransitionPayload
from datastorage.models.ai_analysis_rego_evaluation_payload import AIAnalysisRegoEvaluationPayload
from datastorage.models.gateway_audit_payload import GatewayAuditPayload
from datastorage.models.holmes_gpt_response_payload import HolmesGPTResponsePayload
from datastorage.models.llm_request_payload import LLMRequestPayload
from datastorage.models.llm_response_payload import LLMResponsePayload
from datastorage.models.llm_tool_call_payload import LLMToolCallPayload
from datastorage.models.notification_audit_payload import NotificationAuditPayload
from datastorage.models.notification_message_acknowledged_payload import NotificationMessageAcknowledgedPayload
from datastorage.models.notification_message_escalated_payload import NotificationMessageEscalatedPayload
from datastorage.models.notification_message_failed_payload import NotificationMessageFailedPayload
from datastorage.models.notification_message_sent_payload import NotificationMessageSentPayload
from datastorage.models.remediation_approval_audit_payload import RemediationApprovalAuditPayload
from datastorage.models.remediation_orchestrator_audit_payload import RemediationOrchestratorAuditPayload
from datastorage.models.remediation_request_webhook_audit_payload import RemediationRequestWebhookAuditPayload
from datastorage.models.signal_processing_audit_payload import SignalProcessingAuditPayload
from datastorage.models.workflow_catalog_created_payload import WorkflowCatalogCreatedPayload
from datastorage.models.workflow_catalog_updated_payload import WorkflowCatalogUpdatedPayload
from datastorage.models.workflow_execution_audit_payload import WorkflowExecutionAuditPayload
from datastorage.models.workflow_execution_webhook_audit_payload import WorkflowExecutionWebhookAuditPayload
from datastorage.models.workflow_search_audit_payload import WorkflowSearchAuditPayload
from datastorage.models.workflow_validation_payload import WorkflowValidationPayload
from typing import Union, Any, List, TYPE_CHECKING, Optional, Dict
from typing_extensions import Literal
from pydantic import StrictStr, Field
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

AUDITEVENTREQUESTEVENTDATA_ONE_OF_SCHEMAS = ["AIAnalysisApprovalDecisionPayload", "AIAnalysisAuditPayload", "AIAnalysisErrorPayload", "AIAnalysisHolmesGPTCallPayload", "AIAnalysisPhaseTransitionPayload", "AIAnalysisRegoEvaluationPayload", "GatewayAuditPayload", "HolmesGPTResponsePayload", "LLMRequestPayload", "LLMResponsePayload", "LLMToolCallPayload", "NotificationAuditPayload", "NotificationMessageAcknowledgedPayload", "NotificationMessageEscalatedPayload", "NotificationMessageFailedPayload", "NotificationMessageSentPayload", "RemediationApprovalAuditPayload", "RemediationOrchestratorAuditPayload", "RemediationRequestWebhookAuditPayload", "SignalProcessingAuditPayload", "WorkflowCatalogCreatedPayload", "WorkflowCatalogUpdatedPayload", "WorkflowExecutionAuditPayload", "WorkflowExecutionWebhookAuditPayload", "WorkflowSearchAuditPayload", "WorkflowValidationPayload"]

class AuditEventRequestEventData(BaseModel):
    """
    Service-specific event data as structured type. V2.0: Typed schemas documented below for API validation. Go client uses interface{} for clean code ergonomics. See DD-AUDIT-004 for structured type requirements. 
    """
    # data type: GatewayAuditPayload
    oneof_schema_1_validator: Optional[GatewayAuditPayload] = None
    # data type: RemediationOrchestratorAuditPayload
    oneof_schema_2_validator: Optional[RemediationOrchestratorAuditPayload] = None
    # data type: SignalProcessingAuditPayload
    oneof_schema_3_validator: Optional[SignalProcessingAuditPayload] = None
    # data type: AIAnalysisAuditPayload
    oneof_schema_4_validator: Optional[AIAnalysisAuditPayload] = None
    # data type: WorkflowExecutionAuditPayload
    oneof_schema_5_validator: Optional[WorkflowExecutionAuditPayload] = None
    # data type: NotificationAuditPayload
    oneof_schema_6_validator: Optional[NotificationAuditPayload] = None
    # data type: WorkflowExecutionWebhookAuditPayload
    oneof_schema_7_validator: Optional[WorkflowExecutionWebhookAuditPayload] = None
    # data type: RemediationApprovalAuditPayload
    oneof_schema_8_validator: Optional[RemediationApprovalAuditPayload] = None
    # data type: WorkflowSearchAuditPayload
    oneof_schema_9_validator: Optional[WorkflowSearchAuditPayload] = None
    # data type: WorkflowCatalogCreatedPayload
    oneof_schema_10_validator: Optional[WorkflowCatalogCreatedPayload] = None
    # data type: WorkflowCatalogUpdatedPayload
    oneof_schema_11_validator: Optional[WorkflowCatalogUpdatedPayload] = None
    # data type: AIAnalysisPhaseTransitionPayload
    oneof_schema_12_validator: Optional[AIAnalysisPhaseTransitionPayload] = None
    # data type: AIAnalysisHolmesGPTCallPayload
    oneof_schema_13_validator: Optional[AIAnalysisHolmesGPTCallPayload] = None
    # data type: AIAnalysisApprovalDecisionPayload
    oneof_schema_14_validator: Optional[AIAnalysisApprovalDecisionPayload] = None
    # data type: AIAnalysisRegoEvaluationPayload
    oneof_schema_15_validator: Optional[AIAnalysisRegoEvaluationPayload] = None
    # data type: AIAnalysisErrorPayload
    oneof_schema_16_validator: Optional[AIAnalysisErrorPayload] = None
    # data type: NotificationMessageSentPayload
    oneof_schema_17_validator: Optional[NotificationMessageSentPayload] = None
    # data type: NotificationMessageFailedPayload
    oneof_schema_18_validator: Optional[NotificationMessageFailedPayload] = None
    # data type: NotificationMessageAcknowledgedPayload
    oneof_schema_19_validator: Optional[NotificationMessageAcknowledgedPayload] = None
    # data type: NotificationMessageEscalatedPayload
    oneof_schema_20_validator: Optional[NotificationMessageEscalatedPayload] = None
    # data type: HolmesGPTResponsePayload
    oneof_schema_21_validator: Optional[HolmesGPTResponsePayload] = None
    # data type: LLMRequestPayload
    oneof_schema_22_validator: Optional[LLMRequestPayload] = None
    # data type: LLMResponsePayload
    oneof_schema_23_validator: Optional[LLMResponsePayload] = None
    # data type: LLMToolCallPayload
    oneof_schema_24_validator: Optional[LLMToolCallPayload] = None
    # data type: WorkflowValidationPayload
    oneof_schema_25_validator: Optional[WorkflowValidationPayload] = None
    # data type: RemediationRequestWebhookAuditPayload
    oneof_schema_26_validator: Optional[RemediationRequestWebhookAuditPayload] = None
    actual_instance: Optional[Union[AIAnalysisApprovalDecisionPayload, AIAnalysisAuditPayload, AIAnalysisErrorPayload, AIAnalysisHolmesGPTCallPayload, AIAnalysisPhaseTransitionPayload, AIAnalysisRegoEvaluationPayload, GatewayAuditPayload, HolmesGPTResponsePayload, LLMRequestPayload, LLMResponsePayload, LLMToolCallPayload, NotificationAuditPayload, NotificationMessageAcknowledgedPayload, NotificationMessageEscalatedPayload, NotificationMessageFailedPayload, NotificationMessageSentPayload, RemediationApprovalAuditPayload, RemediationOrchestratorAuditPayload, RemediationRequestWebhookAuditPayload, SignalProcessingAuditPayload, WorkflowCatalogCreatedPayload, WorkflowCatalogUpdatedPayload, WorkflowExecutionAuditPayload, WorkflowExecutionWebhookAuditPayload, WorkflowSearchAuditPayload, WorkflowValidationPayload]] = None
    one_of_schemas: List[str] = Literal["AIAnalysisApprovalDecisionPayload", "AIAnalysisAuditPayload", "AIAnalysisErrorPayload", "AIAnalysisHolmesGPTCallPayload", "AIAnalysisPhaseTransitionPayload", "AIAnalysisRegoEvaluationPayload", "GatewayAuditPayload", "HolmesGPTResponsePayload", "LLMRequestPayload", "LLMResponsePayload", "LLMToolCallPayload", "NotificationAuditPayload", "NotificationMessageAcknowledgedPayload", "NotificationMessageEscalatedPayload", "NotificationMessageFailedPayload", "NotificationMessageSentPayload", "RemediationApprovalAuditPayload", "RemediationOrchestratorAuditPayload", "RemediationRequestWebhookAuditPayload", "SignalProcessingAuditPayload", "WorkflowCatalogCreatedPayload", "WorkflowCatalogUpdatedPayload", "WorkflowExecutionAuditPayload", "WorkflowExecutionWebhookAuditPayload", "WorkflowSearchAuditPayload", "WorkflowValidationPayload"]

    model_config = {
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    discriminator_value_class_map: Dict[str, str] = {
    }

    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = AuditEventRequestEventData.model_construct()
        error_messages = []
        match = 0
        # validate data type: GatewayAuditPayload
        if not isinstance(v, GatewayAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `GatewayAuditPayload`")
        else:
            match += 1
        # validate data type: RemediationOrchestratorAuditPayload
        if not isinstance(v, RemediationOrchestratorAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `RemediationOrchestratorAuditPayload`")
        else:
            match += 1
        # validate data type: SignalProcessingAuditPayload
        if not isinstance(v, SignalProcessingAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `SignalProcessingAuditPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisAuditPayload
        if not isinstance(v, AIAnalysisAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisAuditPayload`")
        else:
            match += 1
        # validate data type: WorkflowExecutionAuditPayload
        if not isinstance(v, WorkflowExecutionAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowExecutionAuditPayload`")
        else:
            match += 1
        # validate data type: NotificationAuditPayload
        if not isinstance(v, NotificationAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `NotificationAuditPayload`")
        else:
            match += 1
        # validate data type: WorkflowExecutionWebhookAuditPayload
        if not isinstance(v, WorkflowExecutionWebhookAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowExecutionWebhookAuditPayload`")
        else:
            match += 1
        # validate data type: RemediationApprovalAuditPayload
        if not isinstance(v, RemediationApprovalAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `RemediationApprovalAuditPayload`")
        else:
            match += 1
        # validate data type: WorkflowSearchAuditPayload
        if not isinstance(v, WorkflowSearchAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowSearchAuditPayload`")
        else:
            match += 1
        # validate data type: WorkflowCatalogCreatedPayload
        if not isinstance(v, WorkflowCatalogCreatedPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowCatalogCreatedPayload`")
        else:
            match += 1
        # validate data type: WorkflowCatalogUpdatedPayload
        if not isinstance(v, WorkflowCatalogUpdatedPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowCatalogUpdatedPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisPhaseTransitionPayload
        if not isinstance(v, AIAnalysisPhaseTransitionPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisPhaseTransitionPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisHolmesGPTCallPayload
        if not isinstance(v, AIAnalysisHolmesGPTCallPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisHolmesGPTCallPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisApprovalDecisionPayload
        if not isinstance(v, AIAnalysisApprovalDecisionPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisApprovalDecisionPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisRegoEvaluationPayload
        if not isinstance(v, AIAnalysisRegoEvaluationPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisRegoEvaluationPayload`")
        else:
            match += 1
        # validate data type: AIAnalysisErrorPayload
        if not isinstance(v, AIAnalysisErrorPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `AIAnalysisErrorPayload`")
        else:
            match += 1
        # validate data type: NotificationMessageSentPayload
        if not isinstance(v, NotificationMessageSentPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `NotificationMessageSentPayload`")
        else:
            match += 1
        # validate data type: NotificationMessageFailedPayload
        if not isinstance(v, NotificationMessageFailedPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `NotificationMessageFailedPayload`")
        else:
            match += 1
        # validate data type: NotificationMessageAcknowledgedPayload
        if not isinstance(v, NotificationMessageAcknowledgedPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `NotificationMessageAcknowledgedPayload`")
        else:
            match += 1
        # validate data type: NotificationMessageEscalatedPayload
        if not isinstance(v, NotificationMessageEscalatedPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `NotificationMessageEscalatedPayload`")
        else:
            match += 1
        # validate data type: HolmesGPTResponsePayload
        if not isinstance(v, HolmesGPTResponsePayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `HolmesGPTResponsePayload`")
        else:
            match += 1
        # validate data type: LLMRequestPayload
        if not isinstance(v, LLMRequestPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LLMRequestPayload`")
        else:
            match += 1
        # validate data type: LLMResponsePayload
        if not isinstance(v, LLMResponsePayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LLMResponsePayload`")
        else:
            match += 1
        # validate data type: LLMToolCallPayload
        if not isinstance(v, LLMToolCallPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `LLMToolCallPayload`")
        else:
            match += 1
        # validate data type: WorkflowValidationPayload
        if not isinstance(v, WorkflowValidationPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `WorkflowValidationPayload`")
        else:
            match += 1
        # validate data type: RemediationRequestWebhookAuditPayload
        if not isinstance(v, RemediationRequestWebhookAuditPayload):
            error_messages.append(f"Error! Input type `{type(v)}` is not `RemediationRequestWebhookAuditPayload`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in AuditEventRequestEventData with oneOf schemas: AIAnalysisApprovalDecisionPayload, AIAnalysisAuditPayload, AIAnalysisErrorPayload, AIAnalysisHolmesGPTCallPayload, AIAnalysisPhaseTransitionPayload, AIAnalysisRegoEvaluationPayload, GatewayAuditPayload, HolmesGPTResponsePayload, LLMRequestPayload, LLMResponsePayload, LLMToolCallPayload, NotificationAuditPayload, NotificationMessageAcknowledgedPayload, NotificationMessageEscalatedPayload, NotificationMessageFailedPayload, NotificationMessageSentPayload, RemediationApprovalAuditPayload, RemediationOrchestratorAuditPayload, RemediationRequestWebhookAuditPayload, SignalProcessingAuditPayload, WorkflowCatalogCreatedPayload, WorkflowCatalogUpdatedPayload, WorkflowExecutionAuditPayload, WorkflowExecutionWebhookAuditPayload, WorkflowSearchAuditPayload, WorkflowValidationPayload. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in AuditEventRequestEventData with oneOf schemas: AIAnalysisApprovalDecisionPayload, AIAnalysisAuditPayload, AIAnalysisErrorPayload, AIAnalysisHolmesGPTCallPayload, AIAnalysisPhaseTransitionPayload, AIAnalysisRegoEvaluationPayload, GatewayAuditPayload, HolmesGPTResponsePayload, LLMRequestPayload, LLMResponsePayload, LLMToolCallPayload, NotificationAuditPayload, NotificationMessageAcknowledgedPayload, NotificationMessageEscalatedPayload, NotificationMessageFailedPayload, NotificationMessageSentPayload, RemediationApprovalAuditPayload, RemediationOrchestratorAuditPayload, RemediationRequestWebhookAuditPayload, SignalProcessingAuditPayload, WorkflowCatalogCreatedPayload, WorkflowCatalogUpdatedPayload, WorkflowExecutionAuditPayload, WorkflowExecutionWebhookAuditPayload, WorkflowSearchAuditPayload, WorkflowValidationPayload. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into GatewayAuditPayload
        try:
            instance.actual_instance = GatewayAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into RemediationOrchestratorAuditPayload
        try:
            instance.actual_instance = RemediationOrchestratorAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into SignalProcessingAuditPayload
        try:
            instance.actual_instance = SignalProcessingAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisAuditPayload
        try:
            instance.actual_instance = AIAnalysisAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowExecutionAuditPayload
        try:
            instance.actual_instance = WorkflowExecutionAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into NotificationAuditPayload
        try:
            instance.actual_instance = NotificationAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowExecutionWebhookAuditPayload
        try:
            instance.actual_instance = WorkflowExecutionWebhookAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into RemediationApprovalAuditPayload
        try:
            instance.actual_instance = RemediationApprovalAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowSearchAuditPayload
        try:
            instance.actual_instance = WorkflowSearchAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowCatalogCreatedPayload
        try:
            instance.actual_instance = WorkflowCatalogCreatedPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowCatalogUpdatedPayload
        try:
            instance.actual_instance = WorkflowCatalogUpdatedPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisPhaseTransitionPayload
        try:
            instance.actual_instance = AIAnalysisPhaseTransitionPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisHolmesGPTCallPayload
        try:
            instance.actual_instance = AIAnalysisHolmesGPTCallPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisApprovalDecisionPayload
        try:
            instance.actual_instance = AIAnalysisApprovalDecisionPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisRegoEvaluationPayload
        try:
            instance.actual_instance = AIAnalysisRegoEvaluationPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into AIAnalysisErrorPayload
        try:
            instance.actual_instance = AIAnalysisErrorPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into NotificationMessageSentPayload
        try:
            instance.actual_instance = NotificationMessageSentPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into NotificationMessageFailedPayload
        try:
            instance.actual_instance = NotificationMessageFailedPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into NotificationMessageAcknowledgedPayload
        try:
            instance.actual_instance = NotificationMessageAcknowledgedPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into NotificationMessageEscalatedPayload
        try:
            instance.actual_instance = NotificationMessageEscalatedPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into HolmesGPTResponsePayload
        try:
            instance.actual_instance = HolmesGPTResponsePayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LLMRequestPayload
        try:
            instance.actual_instance = LLMRequestPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LLMResponsePayload
        try:
            instance.actual_instance = LLMResponsePayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into LLMToolCallPayload
        try:
            instance.actual_instance = LLMToolCallPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into WorkflowValidationPayload
        try:
            instance.actual_instance = WorkflowValidationPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into RemediationRequestWebhookAuditPayload
        try:
            instance.actual_instance = RemediationRequestWebhookAuditPayload.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into AuditEventRequestEventData with oneOf schemas: AIAnalysisApprovalDecisionPayload, AIAnalysisAuditPayload, AIAnalysisErrorPayload, AIAnalysisHolmesGPTCallPayload, AIAnalysisPhaseTransitionPayload, AIAnalysisRegoEvaluationPayload, GatewayAuditPayload, HolmesGPTResponsePayload, LLMRequestPayload, LLMResponsePayload, LLMToolCallPayload, NotificationAuditPayload, NotificationMessageAcknowledgedPayload, NotificationMessageEscalatedPayload, NotificationMessageFailedPayload, NotificationMessageSentPayload, RemediationApprovalAuditPayload, RemediationOrchestratorAuditPayload, RemediationRequestWebhookAuditPayload, SignalProcessingAuditPayload, WorkflowCatalogCreatedPayload, WorkflowCatalogUpdatedPayload, WorkflowExecutionAuditPayload, WorkflowExecutionWebhookAuditPayload, WorkflowSearchAuditPayload, WorkflowValidationPayload. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into AuditEventRequestEventData with oneOf schemas: AIAnalysisApprovalDecisionPayload, AIAnalysisAuditPayload, AIAnalysisErrorPayload, AIAnalysisHolmesGPTCallPayload, AIAnalysisPhaseTransitionPayload, AIAnalysisRegoEvaluationPayload, GatewayAuditPayload, HolmesGPTResponsePayload, LLMRequestPayload, LLMResponsePayload, LLMToolCallPayload, NotificationAuditPayload, NotificationMessageAcknowledgedPayload, NotificationMessageEscalatedPayload, NotificationMessageFailedPayload, NotificationMessageSentPayload, RemediationApprovalAuditPayload, RemediationOrchestratorAuditPayload, RemediationRequestWebhookAuditPayload, SignalProcessingAuditPayload, WorkflowCatalogCreatedPayload, WorkflowCatalogUpdatedPayload, WorkflowExecutionAuditPayload, WorkflowExecutionWebhookAuditPayload, WorkflowSearchAuditPayload, WorkflowValidationPayload. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        to_json = getattr(self.actual_instance, "to_json", None)
        if callable(to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Dict:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        to_dict = getattr(self.actual_instance, "to_dict", None)
        if callable(to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


