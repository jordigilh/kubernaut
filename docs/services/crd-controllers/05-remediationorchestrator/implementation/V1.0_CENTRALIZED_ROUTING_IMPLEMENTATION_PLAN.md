# V1.0 Implementation Plan: RO Centralized Routing

**Date**: December 14, 2025
**Last Updated**: December 15, 2025
**Target Version**: V1.0
**Confidence**: 98%
**Timeline**: 4 weeks (Jan 11, 2026 target)
**Status**: ‚úÖ **VALIDATED** - Ready for Implementation

---

## üîó **Critical Extension Documents**

**‚≠ê REQUIRED READING**:
- **`V1.0_BLOCKED_PHASE_ROUTING_EXTENSION_V1.0.md`** - Fixes Gateway deduplication gap (integrated into Days 2-5)
- **`DD-RO-002-ADDENDUM-blocked-phase-semantics.md`** - Authoritative design decision for Blocked phase semantics

**Problem Fixed**: Original V1.0 design used terminal `Skipped` phase, which broke Gateway deduplication causing RR flood.

**Solution**: Use non-terminal `Blocked` phase with `BlockReason` enum for all temporary blocking scenarios.

**Integration**: Extension adds ~45 minutes to Days 2-5 implementation time. See extension document for detailed implementation.

---

## üéØ Executive Summary

### Objective

Move ALL routing decisions from WorkflowExecution (WE) to RemediationOrchestrator (RO), establishing clean separation: **RO routes, WE executes**.

### Key Changes

| Component | Change | LOC Delta | Complexity |
|-----------|--------|-----------|------------|
| **RO Controller** | Add routing logic | +400 lines | Medium |
| **RO Helpers** | New `routing.go` | +250 lines | Medium |
| **WE Controller** | Remove routing logic | -170 lines | Low |
| **RR CRD** | Add skip fields | +15 lines | Low |
| **WE CRD** | Remove SkipDetails | -20 lines | Low |
| **Tests** | 18 new tests | +600 lines | Medium |

**Net Impact**: +1075 LOC, -190 LOC = **+885 LOC total**

### Success Metrics

```yaml
Architectural:
  - Controllers with routing: 2 ‚Üí 1 (50% reduction) ‚úÖ
  - WE complexity: -57% ‚úÖ
  - Single source of truth: RR.Status ‚úÖ

Operational:
  - Debug time: -66% (single controller) ‚úÖ
  - Skip reason consistency: 100% ‚úÖ
  - E2E test complexity: -30% ‚úÖ

Performance:
  - Query latency: 2-20ms (validated) ‚úÖ
  - No caching layer needed ‚úÖ
  - Resource efficiency: +22% (fewer downstream CRDs) ‚úÖ
```

---

## üìÖ Timeline Overview

### 4-Week Schedule

```
Week 1: Foundation + RO Implementation
  Day 1: CRD updates + field index setup + DD-RO-XXX
  Day 2-3: RO routing logic implementation (includes exponential backoff)
  Day 4-5: RO unit tests (34 tests including exponential backoff)

Week 2: WE Simplification + Integration Tests
  Day 6-7: WE simplification (remove CheckCooldown)
  Day 8-9: Integration tests
  Day 10: Dev environment testing

Week 3: Staging Validation
  Day 11-12: Staging deployment + E2E tests
  Day 13-14: Load testing + chaos testing
  Day 15: Bug fixes + refinement

Week 4: V1.0 Launch
  Day 16-17: Documentation finalization
  Day 18: Pre-production validation
  Day 19: Production deployment
  Day 20: Monitoring + success metrics validation
```

---

## üìã Detailed Daily Plan

### **WEEK 1: Foundation + RO Implementation**

---

#### **Day 1: CRD Updates + Field Index Setup + Design Docs**

**Duration**: 8 hours
**Owner**: RO Team
**Dependencies**: None
**Blockers**: None

##### Task 1.1: Update RemediationRequest CRD (2h)

**File**: `api/remediation/v1alpha1/remediationrequest_types.go`

**Changes**:
```go
// RemediationRequestStatus defines the observed state
type RemediationRequestStatus struct {
    // ... existing fields ...

    // NEW FIELDS FOR CENTRALIZED ROUTING (v1.0)

    // SkipReason indicates why the remediation was skipped (if applicable)
    // Possible values: RecentlyRemediated, ResourceBusy, ExponentialBackoff,
    //                  ExhaustedRetries, PreviousExecutionFailed
    // +optional
    SkipReason string `json:"skipReason,omitempty"`

    // SkipMessage provides human-readable details about the skip
    // +optional
    SkipMessage string `json:"skipMessage,omitempty"`

    // BlockedUntil indicates when a temporarily skipped RR can be retried
    // For RecentlyRemediated, ResourceBusy, ExponentialBackoff
    // +optional
    BlockedUntil *metav1.Time `json:"blockedUntil,omitempty"`

    // BlockingWorkflowExecution references the WFE causing skip (if applicable)
    // +optional
    BlockingWorkflowExecution string `json:"blockingWorkflowExecution,omitempty"`

    // DuplicateOf links this RR to the parent RR (for cooldown-based skips)
    // +optional
    DuplicateOf string `json:"duplicateOf,omitempty"`
}
```

**Validation**:
```bash
# Generate CRD manifests
make manifests

# Verify CRD changes
git diff config/crd/bases/remediation.kubernaut.ai_remediationrequests.yaml

# Expected: 5 new fields in status section
```

**Deliverable**: Updated CRD with routing fields ‚úÖ

---

##### Task 1.2: Update WorkflowExecution CRD (1h)

**File**: `api/workflowexecution/v1alpha1/workflowexecution_types.go`

**Changes**:
```go
// WorkflowExecutionStatus defines the observed state
type WorkflowExecutionStatus struct {
    // ... existing fields ...

    // REMOVE (no longer needed - RO handles routing):
    // - SkipDetails *SkipDetails `json:"skipDetails,omitempty"`
    // - Phase "Skipped" (not used anymore)

    // Phase values: Pending, Running, Completed, Failed
    // "Skipped" removed - RO handles routing before WFE creation
    Phase string `json:"phase,omitempty"`
}

// REMOVE entire SkipDetails struct (no longer needed)
// type SkipDetails struct { ... }
```

**Validation**:
```bash
# Generate CRD manifests
make manifests

# Verify SkipDetails removed
git diff config/crd/bases/workflowexecution.kubernaut.ai_workflowexecutions.yaml

# Expected: skipDetails field removed
```

**Deliverable**: Simplified WE CRD ‚úÖ

---

##### Task 1.3: Add Field Index in RO Controller (1h)

**File**: `internal/controller/remediationorchestrator/remediationrequest_controller.go`

**Changes**:
```go
// SetupWithManager sets up the controller with the Manager
func (r *RemediationRequestReconciler) SetupWithManager(mgr ctrl.Manager) error {
    // NEW: Index WorkflowExecution by spec.targetResource
    // Pattern from WE controller (lines 508-518)
    if err := mgr.GetFieldIndexer().IndexField(
        context.Background(),
        &workflowexecutionv1.WorkflowExecution{},
        "spec.targetResource",
        func(obj client.Object) []string {
            wfe := obj.(*workflowexecutionv1.WorkflowExecution)
            return []string{wfe.Spec.TargetResource}
        },
    ); err != nil {
        return fmt.Errorf("failed to index WorkflowExecution by targetResource: %w", err)
    }

    // ... existing setup (watches, predicates, etc.)

    return ctrl.NewControllerManagedBy(mgr).
        For(&remediationv1.RemediationRequest{}).
        // ... existing watches ...
        Complete(r)
}
```

**Test**:
```go
// Verify index works in unit test
It("should use targetResource field index", func() {
    wfe1 := createWFE("pod/app-1")
    wfe2 := createWFE("pod/app-2")

    // Query by field selector
    wfeList := &workflowexecutionv1.WorkflowExecutionList{}
    err := r.List(ctx, wfeList,
        client.MatchingFields{"spec.targetResource": "pod/app-1"})

    Expect(err).ToNot(HaveOccurred())
    Expect(wfeList.Items).To(HaveLen(1))
    Expect(wfeList.Items[0].Name).To(Equal(wfe1.Name))
})
```

**Deliverable**: Field index configured ‚úÖ

---

##### Task 1.4: Create DD-RO-XXX Design Decision (3h)

**File**: `docs/architecture/decisions/DD-RO-002-centralized-routing-responsibility.md`

**Content Outline**:
```markdown
# DD-RO-002: Centralized Routing Responsibility

**Status**: ‚úÖ Approved
**Version**: 1.0
**Date**: December 15, 2025
**Confidence**: 98%

## Decision Summary

RemediationOrchestrator owns ALL routing decisions. WorkflowExecution
becomes pure executor with no routing logic.

## Context

[From TRIAGE_RO_CENTRALIZED_ROUTING_PROPOSAL.md]

## Decision

RO makes 5 routing checks BEFORE creating WorkflowExecution:
1. Previous Execution Failure (PERMANENT BLOCK)
2. Exhausted Retries (PERMANENT BLOCK)
3. Exponential Backoff (TEMPORARY SKIP)
4. Regular Cooldown (TEMPORARY SKIP)
5. Resource Lock (TEMPORARY SKIP)

## Technical Design

[Implementation details from answers]

## Integration Points

- Updates DD-WE-004 (exponential backoff ownership)
- Updates DD-WE-001 (resource locking ownership)
- Updates BR-WE-010 (cooldown ownership)

## Success Metrics

[From implementation plan]
```

**Review Process**:
1. Draft document (2h)
2. Self-review (30min)
3. Commit to docs/architecture/decisions/ (30min)

**Deliverable**: DD-RO-002 published ‚úÖ

---

##### Task 1.5: Update Existing DDs (1h)

**Files to Update**:
1. `docs/architecture/decisions/DD-WE-004-exponential-backoff-cooldown.md`
2. `docs/architecture/decisions/DD-WE-001-resource-locking-safety.md`
3. `docs/requirements/BR-WE-010-cooldown-prevent-redundant-sequential-execution.md`

**Changes**: Add ownership transfer note:
```markdown
## Ownership Transfer (V1.0)

**Date**: December 15, 2025
**Decision**: DD-RO-002

The logic described in this document has been moved to RemediationOrchestrator
for centralized routing. WorkflowExecution no longer implements this check.

**Implementation**: See `pkg/remediationorchestrator/helpers/routing.go`

**Rationale**: Clean separation of concerns - RO routes, WE executes.
```

**Deliverable**: 3 DDs updated ‚úÖ

---

**Day 1 Deliverables**:
- ‚úÖ RR CRD updated with skip fields
- ‚úÖ WE CRD simplified (SkipDetails removed)
- ‚úÖ Field index configured in RO
- ‚úÖ DD-RO-002 created
- ‚úÖ 3 existing DDs updated

**Day 1 Validation**:
```bash
# CRDs regenerate successfully
make manifests
echo $? # Expected: 0

# Build succeeds
make build-remediationorchestrator
echo $? # Expected: 0

# Unit tests pass (existing tests)
make test-unit-remediationorchestrator
echo $? # Expected: 0
```

---

#### **Day 2-3: RO Routing Logic Implementation**

**Duration**: 16 hours (2 days √ó 8h)
**Owner**: RO Team
**Dependencies**: Day 1 complete
**Blockers**: None

##### Task 2.1: Create Routing Helpers File (8h - Day 2)

**File**: `pkg/remediationorchestrator/helpers/routing.go` (NEW)

**Structure** (~250 lines):
```go
package helpers

import (
    "context"
    "fmt"
    "time"

    remediationv1 "github.com/jordigilh/kubernaut/api/remediation/v1alpha1"
    workflowexecutionv1 "github.com/jordigilh/kubernaut/api/workflowexecution/v1alpha1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/log"
)

// FindMostRecentTerminalWFE finds the most recent completed/failed WFE
// for the given target resource and workflow ID.
// Pattern from WE controller lines 783-834
func FindMostRecentTerminalWFE(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
    workflowID string,  // Empty string = match ANY workflow
) (*workflowexecutionv1.WorkflowExecution, error) {
    log := log.FromContext(ctx)

    wfeList := &workflowexecutionv1.WorkflowExecutionList{}

    // Try field selector first (lines 791-799 pattern)
    listOpts := []client.ListOption{
        client.InNamespace(namespace),
        client.MatchingFields{"spec.targetResource": targetResource},
    }

    err := c.List(ctx, wfeList, listOpts...)
    if err != nil {
        // Fallback to full list if index unavailable
        log.V(1).Info("Field selector failed, falling back to full list",
            "error", err, "targetResource", targetResource)

        if err := c.List(ctx, wfeList, client.InNamespace(namespace)); err != nil {
            return nil, fmt.Errorf("failed to list WorkflowExecutions: %w", err)
        }

        // In-memory filter by targetResource
        filtered := []workflowexecutionv1.WorkflowExecution{}
        for _, wfe := range wfeList.Items {
            if wfe.Spec.TargetResource == targetResource {
                filtered = append(filtered, wfe)
            }
        }
        wfeList.Items = filtered
    }

    // Find most recent terminal WFE (lines 802-831 pattern)
    var mostRecent *workflowexecutionv1.WorkflowExecution

    for i := range wfeList.Items {
        wfe := &wfeList.Items[i]

        // Filter: Terminal phases only
        if wfe.Status.Phase != "Completed" && wfe.Status.Phase != "Failed" {
            continue
        }

        // CRITICAL: Filter out nil CompletionTime (lines 822-824 pattern)
        if wfe.Status.CompletionTime == nil {
            log.V(1).Info("Skipping terminal WFE with nil CompletionTime",
                "wfe", wfe.Name, "phase", wfe.Status.Phase)
            continue
        }

        // Filter by workflowID if specified
        if workflowID != "" && wfe.Spec.WorkflowRef.WorkflowID != workflowID {
            continue
        }

        // Track most recent
        if mostRecent == nil ||
           wfe.Status.CompletionTime.After(mostRecent.Status.CompletionTime.Time) {
            mostRecent = wfe
        }
    }

    return mostRecent, nil
}

// CheckPreviousExecutionFailure checks if the most recent WFE failed during execution
// Priority: HIGHEST (check FIRST)
// Pattern from WE controller lines 652-674
func CheckPreviousExecutionFailure(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
    workflowID string,
) (blocked bool, blockingWFE *workflowexecutionv1.WorkflowExecution, err error) {
    recentWFE, err := FindMostRecentTerminalWFE(ctx, c, namespace, targetResource, workflowID)
    if err != nil {
        return false, nil, err
    }
    if recentWFE == nil {
        return false, nil, nil  // No history
    }

    // Check wasExecutionFailure (PERMANENT BLOCK)
    if recentWFE.Status.Phase == "Failed" &&
       recentWFE.Status.FailureDetails != nil &&
       recentWFE.Status.FailureDetails.WasExecutionFailure {
        return true, recentWFE, nil
    }

    return false, nil, nil
}

// CheckExhaustedRetries checks if max consecutive failures reached
// Priority: SECOND (check after execution failure)
// Pattern from WE controller lines 680-702
func CheckExhaustedRetries(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
    workflowID string,
    maxConsecutiveFailures int,
) (exhausted bool, blockingWFE *workflowexecutionv1.WorkflowExecution, err error) {
    recentWFE, err := FindMostRecentTerminalWFE(ctx, c, namespace, targetResource, workflowID)
    if err != nil {
        return false, nil, err
    }
    if recentWFE == nil {
        return false, nil, nil
    }

    // Check consecutive failures (PERMANENT BLOCK)
    if recentWFE.Status.ConsecutiveFailures >= int32(maxConsecutiveFailures) {
        return true, recentWFE, nil
    }

    return false, nil, nil
}

// CheckExponentialBackoff checks if WFE is in exponential backoff window
// Priority: THIRD (check after exhausted retries)
// Pattern from WE controller lines 708-732
func CheckExponentialBackoff(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
    workflowID string,
) (inBackoff bool, blockingWFE *workflowexecutionv1.WorkflowExecution, remaining time.Duration, err error) {
    recentWFE, err := FindMostRecentTerminalWFE(ctx, c, namespace, targetResource, workflowID)
    if err != nil {
        return false, nil, 0, err
    }
    if recentWFE == nil {
        return false, nil, 0, nil
    }

    // Check NextAllowedExecution (TEMPORARY SKIP)
    if recentWFE.Status.NextAllowedExecution != nil {
        now := time.Now()
        if now.Before(recentWFE.Status.NextAllowedExecution.Time) {
            remaining := time.Until(recentWFE.Status.NextAllowedExecution.Time)
            return true, recentWFE, remaining, nil
        }
    }

    return false, nil, 0, nil
}

// CheckWorkflowCooldown checks if same workflow executed recently on same target
// Priority: FOURTH (check after exponential backoff)
// Pattern from WE controller lines 739-773
func CheckWorkflowCooldown(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
    workflowID string,
    cooldownDuration time.Duration,
) (inCooldown bool, recentWFE *workflowexecutionv1.WorkflowExecution, remaining time.Duration, err error) {
    log := log.FromContext(ctx)

    recentWFE, err = FindMostRecentTerminalWFE(ctx, c, namespace, targetResource, "")  // ANY workflow
    if err != nil {
        return false, nil, 0, err
    }
    if recentWFE == nil {
        return false, nil, 0, nil
    }

    // CRITICAL: Check workflowID match (line 741 pattern)
    if recentWFE.Spec.WorkflowRef.WorkflowID != workflowID {
        log.V(1).Info("Different workflow on same target - ALLOWED",
            "recentWorkflow", recentWFE.Spec.WorkflowRef.WorkflowID,
            "currentWorkflow", workflowID,
            "targetResource", targetResource)
        return false, nil, 0, nil  // Different workflow - ALLOW
    }

    // Same workflow - check cooldown
    timeSinceCompletion := time.Since(recentWFE.Status.CompletionTime.Time)
    if timeSinceCompletion < cooldownDuration {
        remaining := cooldownDuration - timeSinceCompletion
        return true, recentWFE, remaining, nil
    }

    return false, nil, 0, nil
}

// CheckResourceLock checks if another WFE is currently running on same target
// Priority: FIFTH (check last)
// Pattern from WE controller lines 561-622
func CheckResourceLock(
    ctx context.Context,
    c client.Client,
    namespace string,
    targetResource string,
) (locked bool, activeWFE *workflowexecutionv1.WorkflowExecution, err error) {
    wfeList := &workflowexecutionv1.WorkflowExecutionList{}

    // Try field selector first
    listOpts := []client.ListOption{
        client.InNamespace(namespace),
        client.MatchingFields{"spec.targetResource": targetResource},
    }

    err = c.List(ctx, wfeList, listOpts...)
    if err != nil {
        // Fallback to full list
        if err := c.List(ctx, wfeList, client.InNamespace(namespace)); err != nil {
            return false, nil, fmt.Errorf("failed to list WorkflowExecutions: %w", err)
        }

        // In-memory filter
        filtered := []workflowexecutionv1.WorkflowExecution{}
        for _, wfe := range wfeList.Items {
            if wfe.Spec.TargetResource == targetResource {
                filtered = append(filtered, wfe)
            }
        }
        wfeList.Items = filtered
    }

    // Find Running or Pending WFE
    for i := range wfeList.Items {
        wfe := &wfeList.Items[i]
        if wfe.Status.Phase == "Running" || wfe.Status.Phase == "Pending" {
            return true, wfe, nil
        }
    }

    return false, nil, nil
}
```

**Validation**:
```bash
# Build succeeds
go build ./pkg/remediationorchestrator/helpers/...
echo $? # Expected: 0

# Lint passes
golangci-lint run ./pkg/remediationorchestrator/helpers/...
echo $? # Expected: 0
```

**Deliverable**: routing.go with 5 check functions ‚úÖ

---

##### Task 2.2: Update RO Controller - reconcileAnalyzing (8h - Day 3)

**File**: `internal/controller/remediationorchestrator/remediationrequest_controller.go`

**Changes**:
```go
import (
    // ... existing imports ...
    rohelpers "github.com/jordigilh/kubernaut/pkg/remediationorchestrator/helpers"
)

// reconcileAnalyzing handles RR in Analyzing phase
// NEW: Add routing checks BEFORE creating WorkflowExecution
func (r *RemediationRequestReconciler) reconcileAnalyzing(
    ctx context.Context,
    rr *remediationv1.RemediationRequest,
) (ctrl.Result, error) {
    log := log.FromContext(ctx).WithValues("phase", "Analyzing")

    // Get AIAnalysis result
    aiAnalysis := &aianalysisv1.AIAnalysis{}
    if err := r.Get(ctx, client.ObjectKey{
        Name:      rr.Status.AIAnalysisRef.Name,
        Namespace: rr.Namespace,
    }, aiAnalysis); err != nil {
        return ctrl.Result{}, err
    }

    // Wait for AIAnalysis completion
    if aiAnalysis.Status.Phase != "Completed" {
        if aiAnalysis.Status.Phase == "Failed" {
            return r.transitionToFailed(ctx, rr, "AIAnalysis failed")
        }
        return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
    }

    // Extract target and workflow from AI result
    targetResource := aiAnalysis.Status.TargetResource
    workflowID := aiAnalysis.Status.RecommendedWorkflow.WorkflowID

    log = log.WithValues(
        "targetResource", targetResource,
        "workflowID", workflowID,
    )

    // ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    // ‚ïë  ROUTING DECISION: Should I create WorkflowExecution?   ‚ïë
    // ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

    // Check 1: Previous Execution Failure (PERMANENT BLOCK)
    log.V(1).Info("Checking previous execution failure")
    if blocked, wfe, err := rohelpers.CheckPreviousExecutionFailure(
        ctx, r.Client, rr.Namespace, targetResource, workflowID,
    ); err != nil {
        return ctrl.Result{}, fmt.Errorf("failed to check previous execution failure: %w", err)
    } else if blocked {
        log.Info("Blocked: Previous execution failure",
            "blockingWFE", wfe.Name,
            "failureTime", wfe.Status.CompletionTime)
        return r.failRR(ctx, rr, "PreviousExecutionFailed", wfe,
            "Previous execution failed during workflow run. Manual intervention required.")
    }

    // Check 2: Exhausted Retries (PERMANENT BLOCK)
    log.V(1).Info("Checking exhausted retries")
    if exhausted, wfe, err := rohelpers.CheckExhaustedRetries(
        ctx, r.Client, rr.Namespace, targetResource, workflowID,
        r.Config.MaxConsecutiveFailures,  // Default: 3
    ); err != nil {
        return ctrl.Result{}, fmt.Errorf("failed to check exhausted retries: %w", err)
    } else if exhausted {
        log.Info("Blocked: Exhausted retries",
            "blockingWFE", wfe.Name,
            "consecutiveFailures", wfe.Status.ConsecutiveFailures)
        return r.failRR(ctx, rr, "ExhaustedRetries", wfe,
            fmt.Sprintf("Max consecutive failures (%d) reached. Manual intervention required.",
                r.Config.MaxConsecutiveFailures))
    }

    // Check 3: Exponential Backoff (TEMPORARY SKIP)
    log.V(1).Info("Checking exponential backoff")
    if inBackoff, wfe, remaining, err := rohelpers.CheckExponentialBackoff(
        ctx, r.Client, rr.Namespace, targetResource, workflowID,
    ); err != nil {
        return ctrl.Result{}, fmt.Errorf("failed to check exponential backoff: %w", err)
    } else if inBackoff {
        log.Info("Skipped: Exponential backoff active",
            "blockingWFE", wfe.Name,
            "nextAllowedExecution", wfe.Status.NextAllowedExecution.Time,
            "remaining", remaining)
        return r.skipRR(ctx, rr, "ExponentialBackoff", wfe, remaining,
            fmt.Sprintf("Backoff active. Next allowed: %v", wfe.Status.NextAllowedExecution.Time))
    }

    // Check 4: Regular Cooldown (TEMPORARY SKIP)
    log.V(1).Info("Checking workflow cooldown")
    if inCooldown, wfe, remaining, err := rohelpers.CheckWorkflowCooldown(
        ctx, r.Client, rr.Namespace, targetResource, workflowID,
        r.Config.WorkflowCooldownDuration,  // Default: 5 minutes
    ); err != nil {
        return ctrl.Result{}, fmt.Errorf("failed to check workflow cooldown: %w", err)
    } else if inCooldown {
        log.Info("Skipped: Workflow cooldown active",
            "recentWFE", wfe.Name,
            "completionTime", wfe.Status.CompletionTime.Time,
            "remaining", remaining)
        return r.skipRR(ctx, rr, "RecentlyRemediated", wfe, remaining,
            fmt.Sprintf("Same workflow executed recently. Cooldown: %s remaining", remaining.Round(time.Second)))
    }

    // Check 5: Resource Lock (TEMPORARY SKIP)
    log.V(1).Info("Checking resource lock")
    if locked, wfe, err := rohelpers.CheckResourceLock(
        ctx, r.Client, rr.Namespace, targetResource,
    ); err != nil {
        return ctrl.Result{}, fmt.Errorf("failed to check resource lock: %w", err)
    } else if locked {
        log.Info("Skipped: Resource locked",
            "activeWFE", wfe.Name,
            "wfePhase", wfe.Status.Phase)
        return r.skipRR(ctx, rr, "ResourceBusy", wfe, 0,
            fmt.Sprintf("Another workflow is running on target: %s", wfe.Name))
    }

    // All checks passed - create WorkflowExecution
    log.Info("All routing checks passed - creating WorkflowExecution")
    return r.createWorkflowExecution(ctx, rr, aiAnalysis)
}

// failRR marks RR as Failed (for permanent blocks)
func (r *RemediationRequestReconciler) failRR(
    ctx context.Context,
    rr *remediationv1.RemediationRequest,
    reason string,
    blockingWFE *workflowexecutionv1.WorkflowExecution,
    message string,
) (ctrl.Result, error) {
    rr.Status.OverallPhase = "Failed"
    rr.Status.SkipReason = reason
    rr.Status.SkipMessage = message
    rr.Status.BlockingWorkflowExecution = blockingWFE.Name
    rr.Status.RequiresManualReview = true

    if err := r.Status().Update(ctx, rr); err != nil {
        return ctrl.Result{}, err
    }

    // Emit metric
    metrics.RemediationRequestSkipTotal.
        WithLabelValues(rr.Namespace, reason).Inc()

    // Create manual review notification
    return r.createManualReviewNotification(ctx, rr, reason, message)
}

// skipRR marks RR as Skipped (for temporary blocks)
func (r *RemediationRequestReconciler) skipRR(
    ctx context.Context,
    rr *remediationv1.RemediationRequest,
    reason string,
    blockingWFE *workflowexecutionv1.WorkflowExecution,
    requeueAfter time.Duration,
    message string,
) (ctrl.Result, error) {
    rr.Status.OverallPhase = "Skipped"
    rr.Status.SkipReason = reason
    rr.Status.SkipMessage = message
    rr.Status.BlockingWorkflowExecution = blockingWFE.Name

    if requeueAfter > 0 {
        blockedUntil := metav1.NewTime(time.Now().Add(requeueAfter))
        rr.Status.BlockedUntil = &blockedUntil
    }

    if err := r.Status().Update(ctx, rr); err != nil {
        return ctrl.Result{}, err
    }

    // Emit metric
    metrics.RemediationRequestSkipTotal.
        WithLabelValues(rr.Namespace, reason).Inc()

    // Track as duplicate if applicable
    if reason == "RecentlyRemediated" || reason == "ResourceBusy" {
        // Find parent RR from blocking WFE
        parentRR := r.findParentRR(ctx, blockingWFE)
        if parentRR != nil {
            rr.Status.DuplicateOf = parentRR.Name
            r.trackDuplicateOnParent(ctx, parentRR, rr)
        }
    }

    // Requeue after cooldown/backoff expires
    if requeueAfter > 0 {
        return ctrl.Result{RequeueAfter: requeueAfter}, nil
    }

    // Resource lock: Poll every 30 seconds
    return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
}
```

**Validation**:
```bash
# Build succeeds
make build-remediationorchestrator
echo $? # Expected: 0

# Existing tests still pass
make test-unit-remediationorchestrator
echo $? # Expected: 0 (or specific failures to fix in Day 4-5)
```

**Deliverable**: reconcileAnalyzing with 5 routing checks ‚úÖ

---

**Days 2-3 Deliverables**:
- ‚úÖ routing.go with 5 helper functions (~250 lines)
- ‚úÖ reconcileAnalyzing updated with routing checks
- ‚úÖ failRR and skipRR helper functions
- ‚úÖ Metrics emitted for skip reasons

---

#### **Day 4-5: RO Unit Tests**

**Duration**: 16 hours (2 days √ó 8h)
**Owner**: RO Team + QA
**Dependencies**: Days 2-3 complete
**Blockers**: None

##### Task 3.1: Unit Tests for Routing Helpers (10h - Days 4-5)

**File**: `test/unit/remediationorchestrator/routing_test.go` (NEW)

**Test Structure** (~400 lines, 15 tests):

```go
package remediationorchestrator_test

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    // ... imports ...
)

var _ = Describe("RO Routing Helpers", func() {
    var (
        ctx     context.Context
        client  client.Client
        rr      *remediationv1.RemediationRequest
        wfe1    *workflowexecutionv1.WorkflowExecution
    )

    BeforeEach(func() {
        ctx = context.Background()

        // Use fake client with field index
        // Pattern from WE controller_test.go:386-400
        client = fake.NewClientBuilder().
            WithScheme(scheme.Scheme).
            WithIndex(&workflowexecutionv1.WorkflowExecution{},
                "spec.targetResource",
                func(obj client.Object) []string {
                    wfe := obj.(*workflowexecutionv1.WorkflowExecution)
                    return []string{wfe.Spec.TargetResource}
                }).
            Build()
    })

    // Test FindMostRecentTerminalWFE
    Context("FindMostRecentTerminalWFE", func() {
        It("should return nil when no WFEs exist", func() {
            wfe, err := rohelpers.FindMostRecentTerminalWFE(
                ctx, client, "default", "pod/myapp", "restart-pod")
            Expect(err).ToNot(HaveOccurred())
            Expect(wfe).To(BeNil())
        })

        It("should return most recent terminal WFE", func() {
            // Create 3 WFEs with different completion times
            // Pattern from WE controller_test.go:620-698
            wfe1 := createCompletedWFE("wfe-1", "pod/myapp", "restart-pod", -10*time.Minute)
            wfe2 := createCompletedWFE("wfe-2", "pod/myapp", "restart-pod", -5*time.Minute)
            wfe3 := createCompletedWFE("wfe-3", "pod/myapp", "restart-pod", -2*time.Minute)

            Expect(client.Create(ctx, wfe1)).To(Succeed())
            Expect(client.Create(ctx, wfe2)).To(Succeed())
            Expect(client.Create(ctx, wfe3)).To(Succeed())

            // Should return wfe3 (most recent)
            wfe, err := rohelpers.FindMostRecentTerminalWFE(
                ctx, client, "default", "pod/myapp", "restart-pod")
            Expect(err).ToNot(HaveOccurred())
            Expect(wfe).ToNot(BeNil())
            Expect(wfe.Name).To(Equal("wfe-3"))
        })

        It("should filter out WFEs with nil CompletionTime", func() {
            // Pattern from WE controller_test.go:620-698
            wfeBad := createWFE("wfe-bad", "pod/myapp", "restart-pod")
            wfeBad.Status.Phase = "Completed"
            wfeBad.Status.CompletionTime = nil  // Data inconsistency

            wfeGood := createCompletedWFE("wfe-good", "pod/myapp", "restart-pod", -2*time.Minute)

            Expect(client.Create(ctx, wfeBad)).To(Succeed())
            Expect(client.Create(ctx, wfeGood)).To(Succeed())

            // Should return wfeGood (wfeBad filtered out)
            wfe, err := rohelpers.FindMostRecentTerminalWFE(
                ctx, client, "default", "pod/myapp", "restart-pod")
            Expect(err).ToNot(HaveOccurred())
            Expect(wfe).ToNot(BeNil())
            Expect(wfe.Name).To(Equal("wfe-good"))
        })
    })

    // Test CheckWorkflowCooldown
    Context("CheckWorkflowCooldown", func() {
        It("should skip if same workflow within cooldown", func() {
            // Create completed WFE 2 minutes ago
            wfe := createCompletedWFE("wfe-1", "pod/myapp", "restart-pod", -2*time.Minute)
            Expect(client.Create(ctx, wfe)).To(Succeed())

            // Check cooldown (default: 5 minutes)
            inCooldown, recentWFE, remaining, err := rohelpers.CheckWorkflowCooldown(
                ctx, client, "default", "pod/myapp", "restart-pod", 5*time.Minute)

            Expect(err).ToNot(HaveOccurred())
            Expect(inCooldown).To(BeTrue())
            Expect(recentWFE).ToNot(BeNil())
            Expect(recentWFE.Name).To(Equal("wfe-1"))
            Expect(remaining).To(BeNumerically(">", 2*time.Minute))
            Expect(remaining).To(BeNumerically("<", 4*time.Minute))
        })

        It("should ALLOW different workflow on same target", func() {
            // Pattern from WE controller_test.go:473-516
            // Create completed WFE for workflow-A
            wfe := createCompletedWFE("wfe-1", "pod/myapp", "restart-pod", -2*time.Minute)
            Expect(client.Create(ctx, wfe)).To(Succeed())

            // Check different workflow (workflow-B)
            inCooldown, _, _, err := rohelpers.CheckWorkflowCooldown(
                ctx, client, "default", "pod/myapp", "scale-deployment", 5*time.Minute)

            Expect(err).ToNot(HaveOccurred())
            Expect(inCooldown).To(BeFalse())  // ALLOW different workflow
        })

        It("should allow if cooldown expired", func() {
            // Create completed WFE 10 minutes ago (beyond 5-min cooldown)
            wfe := createCompletedWFE("wfe-1", "pod/myapp", "restart-pod", -10*time.Minute)
            Expect(client.Create(ctx, wfe)).To(Succeed())

            inCooldown, _, _, err := rohelpers.CheckWorkflowCooldown(
                ctx, client, "default", "pod/myapp", "restart-pod", 5*time.Minute)

            Expect(err).ToNot(HaveOccurred())
            Expect(inCooldown).To(BeFalse())  // Cooldown expired
        })
    })

    // Test CheckPreviousExecutionFailure
    Context("CheckPreviousExecutionFailure", func() {
        It("should block if previous execution failed", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", true)  // wasExecutionFailure=true
            Expect(client.Create(ctx, wfe)).To(Succeed())

            blocked, blockingWFE, err := rohelpers.CheckPreviousExecutionFailure(
                ctx, client, "default", "pod/myapp", "restart-pod")

            Expect(err).ToNot(HaveOccurred())
            Expect(blocked).To(BeTrue())
            Expect(blockingWFE).ToNot(BeNil())
            Expect(blockingWFE.Name).To(Equal("wfe-1"))
        })

        It("should NOT block if previous failure was pre-execution", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", false)  // wasExecutionFailure=false
            Expect(client.Create(ctx, wfe)).To(Succeed())

            blocked, _, err := rohelpers.CheckPreviousExecutionFailure(
                ctx, client, "default", "pod/myapp", "restart-pod")

            Expect(err).ToNot(HaveOccurred())
            Expect(blocked).To(BeFalse())  // Pre-execution failures are retried
        })
    })

    // Test CheckExhaustedRetries
    Context("CheckExhaustedRetries", func() {
        It("should block if consecutive failures >= max", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", false)
            wfe.Status.ConsecutiveFailures = 3
            Expect(client.Create(ctx, wfe)).To(Succeed())

            exhausted, blockingWFE, err := rohelpers.CheckExhaustedRetries(
                ctx, client, "default", "pod/myapp", "restart-pod", 3)  // max=3

            Expect(err).ToNot(HaveOccurred())
            Expect(exhausted).To(BeTrue())
            Expect(blockingWFE).ToNot(BeNil())
        })

        It("should NOT block if consecutive failures < max", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", false)
            wfe.Status.ConsecutiveFailures = 2
            Expect(client.Create(ctx, wfe)).To(Succeed())

            exhausted, _, err := rohelpers.CheckExhaustedRetries(
                ctx, client, "default", "pod/myapp", "restart-pod", 3)  // max=3

            Expect(err).ToNot(HaveOccurred())
            Expect(exhausted).To(BeFalse())
        })
    })

    // Test CheckExponentialBackoff
    Context("CheckExponentialBackoff", func() {
        It("should skip if in backoff window", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", false)
            nextAllowed := metav1.NewTime(time.Now().Add(5 * time.Minute))
            wfe.Status.NextAllowedExecution = &nextAllowed
            Expect(client.Create(ctx, wfe)).To(Succeed())

            inBackoff, blockingWFE, remaining, err := rohelpers.CheckExponentialBackoff(
                ctx, client, "default", "pod/myapp", "restart-pod")

            Expect(err).ToNot(HaveOccurred())
            Expect(inBackoff).To(BeTrue())
            Expect(blockingWFE).ToNot(BeNil())
            Expect(remaining).To(BeNumerically(">", 4*time.Minute))
        })

        It("should NOT skip if backoff expired", func() {
            wfe := createFailedWFE("wfe-1", "pod/myapp", "restart-pod", false)
            nextAllowed := metav1.NewTime(time.Now().Add(-1 * time.Minute))  // Past
            wfe.Status.NextAllowedExecution = &nextAllowed
            Expect(client.Create(ctx, wfe)).To(Succeed())

            inBackoff, _, _, err := rohelpers.CheckExponentialBackoff(
                ctx, client, "default", "pod/myapp", "restart-pod")

            Expect(err).ToNot(HaveOccurred())
            Expect(inBackoff).To(BeFalse())
        })
    })

    // Test CheckResourceLock
    Context("CheckResourceLock", func() {
        It("should detect Running WFE", func() {
            wfe := createWFE("wfe-1", "pod/myapp", "restart-pod")
            wfe.Status.Phase = "Running"
            Expect(client.Create(ctx, wfe)).To(Succeed())

            locked, activeWFE, err := rohelpers.CheckResourceLock(
                ctx, client, "default", "pod/myapp")

            Expect(err).ToNot(HaveOccurred())
            Expect(locked).To(BeTrue())
            Expect(activeWFE).ToNot(BeNil())
            Expect(activeWFE.Name).To(Equal("wfe-1"))
        })

        It("should detect Pending WFE", func() {
            wfe := createWFE("wfe-1", "pod/myapp", "restart-pod")
            wfe.Status.Phase = "Pending"
            Expect(client.Create(ctx, wfe)).To(Succeed())

            locked, activeWFE, err := rohelpers.CheckResourceLock(
                ctx, client, "default", "pod/myapp")

            Expect(err).ToNot(HaveOccurred())
            Expect(locked).To(BeTrue())
            Expect(activeWFE).ToNot(BeNil())
        })

        It("should NOT detect terminal WFEs", func() {
            wfe := createCompletedWFE("wfe-1", "pod/myapp", "restart-pod", -2*time.Minute)
            Expect(client.Create(ctx, wfe)).To(Succeed())

            locked, _, err := rohelpers.CheckResourceLock(
                ctx, client, "default", "pod/myapp")

            Expect(err).ToNot(HaveOccurred())
            Expect(locked).To(BeFalse())  // Terminal WFE doesn't lock
        })
    })
})

// Test helpers
func createCompletedWFE(name, target, workflowID string, offset time.Duration) *workflowexecutionv1.WorkflowExecution {
    completionTime := metav1.NewTime(time.Now().Add(offset))
    return &workflowexecutionv1.WorkflowExecution{
        ObjectMeta: metav1.ObjectMeta{
            Name:      name,
            Namespace: "default",
        },
        Spec: workflowexecutionv1.WorkflowExecutionSpec{
            TargetResource: target,
            WorkflowRef: workflowexecutionv1.WorkflowRef{
                WorkflowID: workflowID,
            },
        },
        Status: workflowexecutionv1.WorkflowExecutionStatus{
            Phase:          "Completed",
            CompletionTime: &completionTime,
        },
    }
}

func createFailedWFE(name, target, workflowID string, wasExecutionFailure bool) *workflowexecutionv1.WorkflowExecution {
    completionTime := metav1.NewTime(time.Now().Add(-2 * time.Minute))
    wfe := &workflowexecutionv1.WorkflowExecution{
        ObjectMeta: metav1.ObjectMeta{
            Name:      name,
            Namespace: "default",
        },
        Spec: workflowexecutionv1.WorkflowExecutionSpec{
            TargetResource: target,
            WorkflowRef: workflowexecutionv1.WorkflowRef{
                WorkflowID: workflowID,
            },
        },
        Status: workflowexecutionv1.WorkflowExecutionStatus{
            Phase:          "Failed",
            CompletionTime: &completionTime,
            FailureDetails: &workflowexecutionv1.FailureDetails{
                WasExecutionFailure: wasExecutionFailure,
            },
        },
    }
    return wfe
}
```

**Run Tests**:
```bash
# Run routing helper tests
ginkgo -v test/unit/remediationorchestrator/routing_test.go

# Expected: 15 tests pass
```

**Deliverable**: 15 routing helper unit tests ‚úÖ

---

##### Task 3.2: Integration Tests for RO (6h - Day 5)

**File**: `test/integration/remediationorchestrator/cooldown_integration_test.go` (NEW)

**Test Scenarios** (3 tests):
1. Signal cooldown prevents SP creation
2. Workflow cooldown prevents WE creation
3. Resource lock prevents concurrent WE creation

**Deliverable**: 3 integration tests ‚úÖ

---

**Days 4-5 Deliverables**:
- ‚úÖ 15 routing helper unit tests
- ‚úÖ 3 integration tests
- ‚úÖ All tests passing

**Days 4-5 Validation**:
```bash
# Unit tests pass
make test-unit-remediationorchestrator
echo $? # Expected: 0

# Integration tests pass
make test-integration-remediationorchestrator
echo $? # Expected: 0

# Coverage >90%
go test -cover ./pkg/remediationorchestrator/helpers/...
# Expected: coverage: >90.0% of statements
```

---

### **WEEK 2: WE Simplification + Integration Tests**

---

#### **Day 6-7: WE Simplification**

**Duration**: 16 hours
**Owner**: WE Team
**Dependencies**: Week 1 complete
**Blockers**: None

##### Task 4.1: Remove CheckCooldown from WE (4h - Day 6)

**File**: `internal/controller/workflowexecution/workflowexecution_controller.go`

**Changes**:
```go
// REMOVE these functions (lines 637-776):
// - CheckCooldown()
// - findMostRecentTerminalWFE() (if only used by CheckCooldown)

// KEEP:
// - HandleAlreadyExists() (lines 841-887) ‚Üê Execution-time safety

// UPDATE reconcilePending (simplify):
func (r *WorkflowExecutionReconciler) reconcilePending(
    ctx context.Context,
    wfe *workflowexecutionv1.WorkflowExecution,
) (ctrl.Result, error) {
    log := log.FromContext(ctx).WithValues("wfe", wfe.Name, "phase", "Pending")

    // NO ROUTING LOGIC ‚úÖ

    // 1. Validate spec
    if err := r.validateSpec(ctx, wfe); err != nil {
        return r.transitionToFailed(ctx, wfe, fmt.Errorf("spec validation failed: %w", err))
    }

    // 2. Build PipelineRun
    pr, err := r.buildPipelineRun(ctx, wfe)
    if err != nil {
        return r.transitionToFailed(ctx, wfe, fmt.Errorf("failed to build PipelineRun: %w", err))
    }

    // 3. Create PipelineRun
    if err := r.Create(ctx, pr); err != nil {
        // Handle execution-time collision (DD-WE-003 Layer 2)
        if apierrors.IsAlreadyExists(err) {
            return r.HandleAlreadyExists(ctx, wfe, pr, err)
        }
        return r.transitionToFailed(ctx, wfe, fmt.Errorf("failed to create PipelineRun: %w", err))
    }

    log.Info("PipelineRun created successfully", "pipelineRun", pr.Name)

    // 4. Transition to Running
    return r.transitionToRunning(ctx, wfe, pr)
}
```

**LOC Impact**:
- Before: ~300 lines (routing + execution)
- After: ~130 lines (execution only)
- **Reduction: -170 lines** (-57%)

**Deliverable**: WE simplified (CheckCooldown removed) ‚úÖ

---

##### Task 4.2: Remove MarkSkipped from WE (2h - Day 6)

**File**: Same file

**Changes**:
```go
// REMOVE MarkSkipped function (lines 994-1061)
// No longer needed - RO handles skipping

// KEEP MarkFailed (still used for execution failures)
```

**Deliverable**: MarkSkipped removed ‚úÖ

---

##### Task 4.3: Update WE Unit Tests (6h - Day 7)

**File**: `test/unit/workflowexecution/controller_test.go`

**Changes**:
```go
// REMOVE tests for routing logic:
// - TestCheckCooldown_* (all variants)
// - TestSkipDetails_*
// - TestRecentlyRemediated_*
// - TestResourceLock_* (if testing WE.CheckCooldown)

// KEEP tests for:
// - TestReconcilePending_CreatePipelineRun ‚úÖ
// - TestReconcilePending_SpecValidation ‚úÖ
// - TestHandleAlreadyExists_* ‚úÖ
// - TestPipelineRunMonitoring_* ‚úÖ
// - TestFailureHandling_* ‚úÖ
```

**Expected Test Count**:
- Before: ~50 tests
- After: ~35 tests (-15 routing tests moved to RO)

**Deliverable**: WE unit tests updated ‚úÖ

---

##### Task 4.4: Update WE Metrics (2h - Day 7)

**File**: `pkg/workflowexecution/metrics/prometheus.go`

**Changes**:
```go
// REMOVE metrics for skipping:
// - WorkflowExecutionSkipTotal (moved to RO)
// - WorkflowExecutionBackoffSkipTotal (moved to RO)

// KEEP metrics for execution:
// - WorkflowExecutionTotal ‚úÖ
// - WorkflowExecutionDuration ‚úÖ
// - PipelineRunCreationTotal ‚úÖ
```

**Deliverable**: WE metrics cleaned up ‚úÖ

---

##### Task 4.5: Update WE Documentation (2h - Day 7)

**Files**:
1. `docs/services/crd-controllers/03-workflowexecution/reconciliation-phases.md`
2. `docs/services/crd-controllers/03-workflowexecution/controller-implementation.md`

**Changes**: Remove cooldown check sections, reference DD-RO-002

**Deliverable**: WE docs updated ‚úÖ

---

**Days 6-7 Deliverables**:
- ‚úÖ CheckCooldown removed from WE (-170 lines)
- ‚úÖ MarkSkipped removed from WE
- ‚úÖ WE unit tests updated (-15 tests)
- ‚úÖ WE metrics cleaned up
- ‚úÖ WE documentation updated

**Days 6-7 Validation**:
```bash
# Build succeeds
make build-workflowexecution
echo $? # Expected: 0

# Unit tests pass
make test-unit-workflowexecution
echo $? # Expected: 0

# Lint passes
golangci-lint run ./internal/controller/workflowexecution/...
echo $? # Expected: 0
```

---

#### **Day 8-9: Integration Tests**

**Duration**: 16 hours
**Owner**: QA Team
**Dependencies**: Days 6-7 complete
**Blockers**: None

##### Task 5.1: End-to-End Skip Flow Tests (8h - Day 8)

**File**: `test/integration/e2e/routing_skip_flows_test.go` (NEW)

**Scenarios**:
1. Signal ‚Üí RO checks signal cooldown ‚Üí Skip (no SP created)
2. Signal ‚Üí SP ‚Üí AI ‚Üí RO checks workflow cooldown ‚Üí Skip (no WE created)
3. Signal ‚Üí SP ‚Üí AI ‚Üí RO checks resource lock ‚Üí Skip (no WE created)
4. Signal ‚Üí SP ‚Üí AI ‚Üí RO checks execution failure ‚Üí Fail (no WE created)
5. Signal ‚Üí SP ‚Üí AI ‚Üí RO checks backoff ‚Üí Skip (no WE created)

**Deliverable**: 5 E2E skip flow tests ‚úÖ

---

##### Task 5.2: Concurrent Signal Tests (4h - Day 9)

**File**: `test/integration/e2e/concurrent_signals_test.go` (NEW)

**Scenarios**:
1. Two RRs with same fingerprint arrive simultaneously
2. RR arrives while WFE is Running on same target
3. Multiple RRs with different fingerprints, same target

**Deliverable**: 3 concurrent signal tests ‚úÖ

---

##### Task 5.3: Performance Tests (4h - Day 9)

**File**: `test/performance/routing_query_performance_test.go` (NEW)

**Scenarios**:
1. Query performance with 10 WFEs (baseline)
2. Query performance with 100 WFEs (normal load)
3. Query performance with 500 WFEs (storm scenario)
4. Fallback performance (no field index)

**Deliverable**: 4 performance tests ‚úÖ

---

**Days 8-9 Deliverables**:
- ‚úÖ 5 E2E skip flow tests
- ‚úÖ 3 concurrent signal tests
- ‚úÖ 4 performance tests
- ‚úÖ Total: 12 integration/performance tests

---

#### **Day 10: Dev Environment Testing**

**Duration**: 8 hours
**Owner**: RO Team + WE Team + QA
**Dependencies**: Days 8-9 complete
**Blockers**: None

##### Task 6.1: Deploy to Dev Cluster (2h)

**Actions**:
1. Build all images
2. Update CRDs
3. Deploy controllers
4. Verify pods running

**Deliverable**: Dev deployment complete ‚úÖ

---

##### Task 6.2: Manual Testing (4h)

**Test Scenarios**:
1. Create signal ‚Üí Verify RO routing checks
2. Create duplicate signal ‚Üí Verify skip
3. Create concurrent signals ‚Üí Verify resource lock
4. Trigger workflow failure ‚Üí Verify permanent block
5. Check RR.Status fields populated correctly

**Deliverable**: Manual test checklist completed ‚úÖ

---

##### Task 6.3: Log Analysis (2h)

**Actions**:
1. Review RO logs for routing decisions
2. Verify no WE.SkipDetails references
3. Check metrics emitted correctly
4. Validate query latency

**Deliverable**: Log analysis report ‚úÖ

---

**Day 10 Deliverables**:
- ‚úÖ Dev deployment successful
- ‚úÖ Manual testing complete
- ‚úÖ Log analysis confirms correct behavior

---

### **WEEK 3: Staging Validation**

---

#### **Day 11-12: Staging Deployment + E2E Tests**

**Duration**: 16 hours
**Owner**: DevOps + QA
**Dependencies**: Week 2 complete
**Blockers**: None

##### Task 7.1: Staging Deployment (4h - Day 11)

**Actions**:
1. Deploy to staging cluster
2. Run smoke tests
3. Verify monitoring dashboards

**Deliverable**: Staging deployment complete ‚úÖ

---

##### Task 7.2: E2E Test Suite (8h - Days 11-12)

**Scenarios**: Run all E2E tests from Days 8-9 in staging

**Deliverable**: All E2E tests passing in staging ‚úÖ

---

##### Task 7.3: Bug Triage (4h - Day 12)

**Actions**:
1. Triage any failures
2. Create bug tickets
3. Prioritize fixes

**Deliverable**: Bug triage complete ‚úÖ

---

#### **Day 13-14: Load Testing + Chaos Testing**

**Duration**: 16 hours
**Owner**: QA + DevOps
**Dependencies**: Days 11-12 complete
**Blockers**: None

##### Task 8.1: Load Testing (8h - Day 13)

**Scenarios**:
1. 100 signals/minute for 10 minutes
2. 1000 signals/minute for 5 minutes (storm)
3. 50 concurrent remediation requests

**Metrics to Validate**:
- Query latency <20ms (p95)
- No query failures
- Skip rate matches expected

**Deliverable**: Load test results ‚úÖ

---

##### Task 8.2: Chaos Testing (8h - Day 14)

**Scenarios**:
1. Kill RO pod mid-reconciliation
2. WFE completes while RO is checking cooldown
3. Delete WFE while RO is querying
4. Kubernetes API server slow response

**Deliverable**: Chaos test results ‚úÖ

---

#### **Day 15: Bug Fixes + Refinement**

**Duration**: 8 hours
**Owner**: RO Team + WE Team
**Dependencies**: Days 13-14 complete
**Blockers**: None

**Actions**:
1. Fix any bugs discovered in load/chaos testing
2. Performance tuning if needed
3. Re-run failed tests
4. Confirm all tests green

**Deliverable**: All bugs fixed, tests green ‚úÖ

---

### **WEEK 4: V1.0 Launch**

---

#### **Day 16-17: Documentation Finalization**

**Duration**: 16 hours
**Owner**: Tech Writer + RO Team
**Dependencies**: Week 3 complete
**Blockers**: None

##### Task 9.1: User Documentation (8h - Day 16)

**Files**:
1. `docs/user-guide/routing-decisions.md` (NEW)
2. `docs/user-guide/debugging-skip-reasons.md` (NEW)
3. `docs/user-guide/troubleshooting.md` (UPDATE)

**Deliverable**: User docs complete ‚úÖ

---

##### Task 9.2: Operator Documentation (4h - Day 17)

**Files**:
1. `docs/operations/monitoring-routing-metrics.md` (NEW)
2. `docs/operations/dashboards.md` (UPDATE)

**Deliverable**: Operator docs complete ‚úÖ

---

##### Task 9.3: API Documentation (4h - Day 17)

**Files**:
1. Update OpenAPI specs for RR.Status fields
2. Generate API docs

**Deliverable**: API docs updated ‚úÖ

---

#### **Day 18: Pre-Production Validation**

**Duration**: 8 hours
**Owner**: DevOps + QA
**Dependencies**: Days 16-17 complete
**Blockers**: None

**Actions**:
1. Final smoke test in staging
2. Verify monitoring dashboards
3. Review deployment checklist
4. Get stakeholder sign-off

**Deliverable**: Production readiness confirmed ‚úÖ

---

#### **Day 19: Production Deployment**

**Duration**: 8 hours
**Owner**: DevOps
**Dependencies**: Day 18 complete
**Blockers**: None

**Timeline**:
```
09:00 - Deploy CRD updates
10:00 - Deploy RO controller
11:00 - Deploy WE controller
12:00 - Verify deployments
13:00 - Enable monitoring alerts
14:00 - Monitor for 2 hours
16:00 - Declare launch successful
```

**Deliverable**: V1.0 deployed to production ‚úÖ

---

#### **Day 20: Monitoring + Success Metrics**

**Duration**: 8 hours
**Owner**: All Teams
**Dependencies**: Day 19 complete
**Blockers**: None

**Actions**:
1. Monitor metrics for 24 hours
2. Validate success metrics
3. Create launch retrospective
4. Celebrate! üéâ

**Success Metrics Validation**:
```yaml
Architectural:
  - Controllers with routing: 1 (RO only) ‚úÖ
  - WE complexity: -57% ‚úÖ
  - Skip reason consistency: 100% ‚úÖ

Operational:
  - No routing-related incidents ‚úÖ
  - Query latency <20ms (p95) ‚úÖ
  - All tests green ‚úÖ

Performance:
  - Resource efficiency: +22% (fewer downstream CRDs) ‚úÖ
  - Debug time: -66% (single controller) ‚úÖ
```

**Deliverable**: V1.0 launch successful ‚úÖ

---

## üìä Success Criteria

### Code Quality

```yaml
Build:
  - All services build successfully ‚úÖ
  - No compilation errors ‚úÖ
  - Lint passes (golangci-lint) ‚úÖ

Tests:
  - Unit test coverage >90% ‚úÖ
  - Integration test coverage >85% ‚úÖ
  - All tests passing ‚úÖ

Code Review:
  - All PRs reviewed and approved ‚úÖ
  - No high-severity issues ‚úÖ
```

### Functional Requirements

```yaml
Routing Logic:
  - All 5 checks implemented ‚úÖ
  - Priority order preserved ‚úÖ
  - Edge cases handled ‚úÖ

CRD Updates:
  - RR.Status has skip fields ‚úÖ
  - WE.Status.SkipDetails removed ‚úÖ
  - CRDs validate correctly ‚úÖ

Metrics:
  - RR skip metrics emitted ‚úÖ
  - WE skip metrics removed ‚úÖ
  - Dashboards updated ‚úÖ
```

### Performance Requirements

```yaml
Query Performance:
  - p50 latency <5ms ‚úÖ
  - p95 latency <20ms ‚úÖ
  - p99 latency <50ms ‚úÖ

Resource Efficiency:
  - Fewer SP/AI/WE created (40% reduction for duplicates) ‚úÖ
  - No performance regressions ‚úÖ
```

### Operational Requirements

```yaml
Monitoring:
  - Dashboards updated ‚úÖ
  - Alerts configured ‚úÖ
  - Logs structured correctly ‚úÖ

Documentation:
  - User docs complete ‚úÖ
  - Operator docs complete ‚úÖ
  - API docs updated ‚úÖ
```

---

## üö® Risk Mitigation

### Risk 1: Field Index Not Available

**Mitigation**: Graceful fallback to full list scan (implemented in helpers)

**Test**: Performance test with index disabled

---

### Risk 2: Race Conditions

**Mitigation**:
- Comprehensive concurrent signal tests
- Chaos testing
- Eventually consistent design

---

### Risk 3: Query Performance Degradation

**Mitigation**:
- Load testing with 1000 RRs
- Performance monitoring
- Query latency alerts

---

## üìã Daily Standup Template

```yaml
Date: [Day X]
Owner: [Team]

Completed Yesterday:
  - [Task 1]
  - [Task 2]

Planned Today:
  - [Task 1]
  - [Task 2]

Blockers:
  - [None / Blocker description]

Metrics:
  - Tests passing: X/Y
  - Coverage: Z%
  - Build status: Green/Red
```

---

## üéØ Definition of Done

### Per Task

- [ ] Code implemented and committed
- [ ] Unit tests written and passing
- [ ] Code reviewed and approved
- [ ] Documentation updated
- [ ] No lint errors

### Per Week

- [ ] All tasks completed
- [ ] All tests passing
- [ ] Integration tests passing
- [ ] No high-severity bugs
- [ ] Weekly demo complete

### For V1.0 Launch

- [ ] All 4 weeks completed
- [ ] All tests passing (unit + integration + E2E)
- [ ] Performance validated
- [ ] Documentation complete
- [ ] Production deployed
- [ ] Success metrics validated

---

**Document Version**: 1.0
**Last Updated**: December 14, 2025
**Status**: üìã READY FOR REVIEW
**Confidence**: 98%
**Timeline**: 4 weeks (Jan 11, 2026 target)
**Next Step**: Review with team, then begin Day 1 implementation

