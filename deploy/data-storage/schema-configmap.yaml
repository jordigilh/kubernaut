apiVersion: v1
data:
  001_initial_schema.sql: "-- Initial schema for Action History Storage\n-- Migration:
    001_initial_schema.sql\n\n-- Enable required extensions\nCREATE EXTENSION IF NOT
    EXISTS \"uuid-ossp\";\n\n-- 1. Resource References Table\nCREATE TABLE resource_references
    (\n    id BIGSERIAL PRIMARY KEY,\n    resource_uid VARCHAR(36) UNIQUE NOT NULL,
    -- Kubernetes UID\n    api_version VARCHAR(100) NOT NULL,\n    kind VARCHAR(100)
    NOT NULL,\n    name VARCHAR(253) NOT NULL,\n    namespace VARCHAR(63),\n    created_at
    TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n    deleted_at TIMESTAMP WITH TIME ZONE,
    -- For soft deletion tracking\n    last_seen TIMESTAMP WITH TIME ZONE DEFAULT
    NOW(),\n    \n    -- Constraints\n    UNIQUE(namespace, kind, name)\n);\n\n--
    Indexes for resource_references\nCREATE INDEX idx_resource_kind ON resource_references
    (kind);\nCREATE INDEX idx_resource_namespace ON resource_references (namespace);\nCREATE
    INDEX idx_resource_last_seen ON resource_references (last_seen);\nCREATE INDEX
    idx_resource_uid ON resource_references (resource_uid);\n\n-- 2. Action Histories
    Table\nCREATE TABLE action_histories (\n    id BIGSERIAL PRIMARY KEY,\n    resource_id
    BIGINT NOT NULL REFERENCES resource_references(id) ON DELETE CASCADE,\n    \n
    \   -- Retention configuration\n    max_actions INTEGER DEFAULT 1000,\n    max_age_days
    INTEGER DEFAULT 30,\n    compaction_strategy VARCHAR(20) DEFAULT 'pattern-aware',
    -- oldest-first, effectiveness-based, pattern-aware\n    \n    -- Analysis configuration
    \ \n    oscillation_window_minutes INTEGER DEFAULT 120,\n    effectiveness_threshold
    DECIMAL(3,2) DEFAULT 0.70,\n    pattern_min_occurrences INTEGER DEFAULT 3,\n    \n
    \   -- Status tracking\n    total_actions INTEGER DEFAULT 0,\n    last_action_at
    TIMESTAMP WITH TIME ZONE,\n    last_analysis_at TIMESTAMP WITH TIME ZONE,\n    next_analysis_at
    TIMESTAMP WITH TIME ZONE,\n    \n    created_at TIMESTAMP WITH TIME ZONE DEFAULT
    NOW(),\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n    \n    -- Constraints\n
    \   UNIQUE(resource_id)\n);\n\n-- Indexes for action_histories\nCREATE INDEX idx_ah_last_action
    ON action_histories (last_action_at);\nCREATE INDEX idx_ah_next_analysis ON action_histories
    (next_analysis_at);\nCREATE INDEX idx_ah_resource_id ON action_histories (resource_id);\n\n--
    3. Resource Action Traces Table (will be partitioned)\nCREATE TABLE resource_action_traces
    (\n    id BIGSERIAL,\n    action_history_id BIGINT NOT NULL REFERENCES action_histories(id)
    ON DELETE CASCADE,\n    \n    -- Action identification\n    action_id VARCHAR(64)
    NOT NULL, -- UUID for this specific action\n    correlation_id VARCHAR(64), --
    For tracing across systems\n    \n    -- Timing information\n    action_timestamp
    TIMESTAMP WITH TIME ZONE NOT NULL,\n    execution_start_time TIMESTAMP WITH TIME
    ZONE,\n    execution_end_time TIMESTAMP WITH TIME ZONE,\n    execution_duration_ms
    INTEGER,\n    \n    -- Alert context\n    alert_name VARCHAR(200) NOT NULL,\n
    \   alert_severity VARCHAR(20) NOT NULL, -- info, warning, critical\n    alert_labels
    JSONB,\n    alert_annotations JSONB,\n    alert_firing_time TIMESTAMP WITH TIME
    ZONE,\n    \n    -- AI model information\n    model_used VARCHAR(100) NOT NULL,\n
    \   routing_tier VARCHAR(20), -- route1, route2, route3\n    model_confidence
    DECIMAL(4,3) NOT NULL, -- 0.000-1.000\n    model_reasoning TEXT,\n    alternative_actions
    JSONB, -- [{\"action\": \"scale_deployment\", \"confidence\": 0.85}]\n    \n    --
    Action details\n    action_type VARCHAR(50) NOT NULL,\n    action_parameters JSONB,
    -- {\"replicas\": 5, \"memory\": \"2Gi\"}\n    \n    -- Resource state capture\n
    \   resource_state_before JSONB,\n    resource_state_after JSONB,\n    \n    --
    Execution tracking\n    execution_status VARCHAR(20) DEFAULT 'pending', -- pending,
    executing, completed, failed, rolled-back\n    execution_error TEXT,\n    kubernetes_operations
    JSONB, -- [{\"operation\": \"patch\", \"resource\": \"deployment/webapp\", \"result\":
    \"success\"}]\n    \n    -- Effectiveness assessment\n    effectiveness_score
    DECIMAL(4,3), -- 0.000-1.000, calculated after execution\n    effectiveness_criteria
    JSONB, -- {\"alert_resolved\": true, \"target_metric_improved\": true}\n    effectiveness_assessed_at
    TIMESTAMP WITH TIME ZONE,\n    effectiveness_assessment_method VARCHAR(20), --
    automated, manual, ml-derived\n    effectiveness_notes TEXT,\n    \n    -- Follow-up
    tracking\n    follow_up_actions JSONB, -- [{\"action_id\": \"uuid\", \"relation\":
    \"correction\"}]\n    \n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n
    \   updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n    \n    -- Primary key
    includes timestamp for partitioning\n    PRIMARY KEY (id, action_timestamp)\n)
    PARTITION BY RANGE (action_timestamp);\n\n-- Indexes for resource_action_traces
    (will be inherited by partitions)\nCREATE INDEX idx_rat_action_history ON resource_action_traces
    (action_history_id);\nCREATE INDEX idx_rat_action_type ON resource_action_traces
    (action_type);\nCREATE INDEX idx_rat_model_used ON resource_action_traces (model_used);\nCREATE
    INDEX idx_rat_alert_name ON resource_action_traces (alert_name);\nCREATE INDEX
    idx_rat_execution_status ON resource_action_traces (execution_status);\nCREATE
    INDEX idx_rat_effectiveness_score ON resource_action_traces (effectiveness_score);\nCREATE
    INDEX idx_rat_correlation_id ON resource_action_traces (correlation_id);\n\n--
    Composite indexes for common queries\nCREATE INDEX idx_rat_history_timestamp ON
    resource_action_traces (action_history_id, action_timestamp);\nCREATE INDEX idx_rat_type_timestamp
    ON resource_action_traces (action_type, action_timestamp);\nCREATE INDEX idx_rat_model_effectiveness
    ON resource_action_traces (model_used, effectiveness_score);\n\n-- GIN indexes
    for JSONB queries\nCREATE INDEX idx_rat_alert_labels_gin ON resource_action_traces
    USING GIN (alert_labels);\nCREATE INDEX idx_rat_action_parameters_gin ON resource_action_traces
    USING GIN (action_parameters);\nCREATE INDEX idx_rat_resource_state_gin ON resource_action_traces
    USING GIN (resource_state_before);\n\n-- Partial indexes for active data\nCREATE
    INDEX idx_rat_pending_actions ON resource_action_traces (action_timestamp) \n
    \   WHERE execution_status IN ('pending', 'executing');\n\n-- 4. Create initial
    partitions for resource_action_traces\n-- Current month\nCREATE TABLE resource_action_traces_y2025m08
    \n    PARTITION OF resource_action_traces\n    FOR VALUES FROM ('2025-08-01')
    TO ('2025-09-01');\n\n-- Next month\nCREATE TABLE resource_action_traces_y2025m09
    \n    PARTITION OF resource_action_traces\n    FOR VALUES FROM ('2025-09-01')
    TO ('2025-10-01');\n\n-- Previous month (for testing)\nCREATE TABLE resource_action_traces_y2025m07
    \n    PARTITION OF resource_action_traces\n    FOR VALUES FROM ('2025-07-01')
    TO ('2025-08-01');\n\n-- 5. Oscillation Patterns Table\nCREATE TABLE oscillation_patterns
    (\n    id BIGSERIAL PRIMARY KEY,\n    \n    -- Pattern definition\n    pattern_type
    VARCHAR(50) NOT NULL, -- scale-oscillation, resource-thrashing, ineffective-loop,
    cascading-failure\n    pattern_name VARCHAR(200) NOT NULL,\n    description TEXT,\n
    \   \n    -- Detection criteria\n    min_occurrences INTEGER NOT NULL DEFAULT
    3,\n    time_window_minutes INTEGER NOT NULL DEFAULT 120,\n    action_sequence
    JSONB, -- [\"scale_deployment\", \"scale_deployment\", \"scale_deployment\"]\n
    \   threshold_config JSONB, -- {\"confidence_drop\": 0.2, \"effectiveness_threshold\":
    0.3}\n    \n    -- Resource scope\n    resource_types TEXT[], -- [\"Deployment\",
    \"StatefulSet\"]\n    namespaces TEXT[], -- [\"production\", \"staging\"] \n    label_selectors
    JSONB, -- {\"app\": \"webapp\", \"tier\": \"frontend\"}\n    \n    -- Prevention
    strategy\n    prevention_strategy VARCHAR(50) NOT NULL, -- block-action, escalate-human,
    alternative-action, cooling-period\n    prevention_parameters JSONB, -- {\"cooling_period_minutes\":
    30, \"escalation_webhook\": \"...\"}\n    \n    -- Alerting configuration\n    alerting_enabled
    BOOLEAN DEFAULT true,\n    alert_severity VARCHAR(20) DEFAULT 'warning',\n    alert_channels
    TEXT[], -- [\"slack\", \"pagerduty\"]\n    \n    -- Pattern statistics\n    total_detections
    INTEGER DEFAULT 0,\n    prevention_success_rate DECIMAL(4,3),\n    false_positive_rate
    DECIMAL(4,3),\n    last_detection_at TIMESTAMP WITH TIME ZONE,\n    \n    -- Lifecycle\n
    \   active BOOLEAN DEFAULT true,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT
    NOW(),\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Indexes
    for oscillation_patterns\nCREATE INDEX idx_op_pattern_type ON oscillation_patterns
    (pattern_type);\nCREATE INDEX idx_op_active_patterns ON oscillation_patterns (active);\nCREATE
    INDEX idx_op_last_detection ON oscillation_patterns (last_detection_at);\n\n--
    6. Oscillation Detections Table\nCREATE TABLE oscillation_detections (\n    id
    BIGSERIAL PRIMARY KEY,\n    pattern_id BIGINT NOT NULL REFERENCES oscillation_patterns(id)
    ON DELETE CASCADE,\n    resource_id BIGINT NOT NULL REFERENCES resource_references(id)
    ON DELETE CASCADE,\n    \n    detected_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT
    NOW(),\n    confidence DECIMAL(4,3) NOT NULL, -- 0.000-1.000\n    action_count
    INTEGER NOT NULL,\n    time_span_minutes INTEGER NOT NULL,\n    \n    -- Pattern
    evidence\n    matching_actions BIGINT[], -- Array of action_trace IDs that matched
    the pattern\n    pattern_evidence JSONB, -- Detailed evidence for the detection\n
    \   \n    -- Prevention outcome\n    prevention_applied BOOLEAN DEFAULT false,\n
    \   prevention_action VARCHAR(50), -- blocked, escalated, alternative-suggested\n
    \   prevention_details JSONB,\n    prevention_successful BOOLEAN,\n    \n    --
    Resolution tracking\n    resolved BOOLEAN DEFAULT false,\n    resolved_at TIMESTAMP
    WITH TIME ZONE,\n    resolution_method VARCHAR(50), -- timeout, manual-intervention,
    automatic\n    resolution_notes TEXT,\n    \n    created_at TIMESTAMP WITH TIME
    ZONE DEFAULT NOW()\n);\n\n-- Indexes for oscillation_detections\nCREATE INDEX
    idx_od_pattern_resource ON oscillation_detections (pattern_id, resource_id);\nCREATE
    INDEX idx_od_detected_at ON oscillation_detections (detected_at);\nCREATE INDEX
    idx_od_unresolved ON oscillation_detections (resolved) WHERE resolved = false;\n\n--
    7. Action Effectiveness Metrics Table\nCREATE TABLE action_effectiveness_metrics
    (\n    id BIGSERIAL PRIMARY KEY,\n    \n    -- Scope definition\n    scope_type
    VARCHAR(50) NOT NULL, -- global, namespace, resource-type, alert-type, model\n
    \   scope_value VARCHAR(200), -- specific value for the scope\n    metric_period
    VARCHAR(20) NOT NULL, -- 1h, 24h, 7d, 30d\n    \n    -- Time range for this metric\n
    \   period_start TIMESTAMP WITH TIME ZONE NOT NULL,\n    period_end TIMESTAMP
    WITH TIME ZONE NOT NULL,\n    \n    -- Effectiveness by action type\n    action_type
    VARCHAR(50) NOT NULL,\n    sample_size INTEGER NOT NULL,\n    average_score DECIMAL(4,3)
    NOT NULL,\n    median_score DECIMAL(4,3),\n    std_deviation DECIMAL(4,3),\n    confidence_interval_lower
    DECIMAL(4,3),\n    confidence_interval_upper DECIMAL(4,3),\n    \n    -- Trend
    analysis\n    trend_direction VARCHAR(20), -- improving, stable, declining\n    trend_confidence
    DECIMAL(4,3),\n    \n    -- Statistical significance\n    min_sample_size_met
    BOOLEAN,\n    statistical_significance DECIMAL(4,3),\n    \n    created_at TIMESTAMP
    WITH TIME ZONE DEFAULT NOW(),\n    \n    -- Ensure uniqueness and enable efficient
    queries\n    UNIQUE(scope_type, scope_value, metric_period, period_start, action_type)\n);\n\n--
    Indexes for action_effectiveness_metrics\nCREATE INDEX idx_aem_scope_period ON
    action_effectiveness_metrics (scope_type, scope_value, metric_period);\nCREATE
    INDEX idx_aem_period_range ON action_effectiveness_metrics (period_start, period_end);\nCREATE
    INDEX idx_aem_action_effectiveness ON action_effectiveness_metrics (action_type,
    average_score);\n\n-- 8. Retention Operations Table\nCREATE TABLE retention_operations
    (\n    id BIGSERIAL PRIMARY KEY,\n    action_history_id BIGINT NOT NULL REFERENCES
    action_histories(id) ON DELETE CASCADE,\n    \n    operation_type VARCHAR(30)
    NOT NULL, -- cleanup, archive, compact\n    strategy_used VARCHAR(30) NOT NULL,
    -- oldest-first, effectiveness-based, pattern-aware\n    \n    -- Operation details\n
    \   records_before INTEGER NOT NULL,\n    records_after INTEGER NOT NULL,\n    records_deleted
    INTEGER NOT NULL,\n    records_archived INTEGER,\n    \n    -- Criteria used\n
    \   retention_criteria JSONB, -- {\"max_age_days\": 30, \"min_effectiveness\":
    0.1}\n    preserved_criteria JSONB, -- {\"pattern_examples\": 5, \"high_effectiveness\":
    10}\n    \n    operation_start TIMESTAMP WITH TIME ZONE NOT NULL,\n    operation_end
    TIMESTAMP WITH TIME ZONE,\n    operation_duration_ms INTEGER,\n    operation_status
    VARCHAR(20) DEFAULT 'running', -- running, completed, failed\n    error_message
    TEXT,\n    \n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Indexes
    for retention_operations\nCREATE INDEX idx_ro_action_history_ops ON retention_operations
    (action_history_id);\nCREATE INDEX idx_ro_operation_time ON retention_operations
    (operation_start);\n\n-- 9. Insert default oscillation patterns\nINSERT INTO oscillation_patterns
    (\n    pattern_type, pattern_name, description, min_occurrences, time_window_minutes,\n
    \   threshold_config, prevention_strategy, prevention_parameters\n) VALUES \n(\n
    \   'scale-oscillation',\n    'Scale Up/Down Oscillation',\n    'Rapid alternating
    scale up and scale down operations within a short time window',\n    3,\n    120,\n
    \   '{\"min_direction_changes\": 2, \"max_time_between_actions\": 30, \"effectiveness_threshold\":
    0.5}',\n    'cooling-period',\n    '{\"cooling_period_minutes\": 30, \"escalate_after\":
    3}'\n),\n(\n    'resource-thrashing',\n    'Resource/Scale Thrashing',\n    'Alternating
    between resource adjustments and scaling decisions',\n    2,\n    90,\n    '{\"action_types\":
    [\"increase_resources\", \"scale_deployment\"], \"effectiveness_threshold\": 0.6}',\n
    \   'alternative-action',\n    '{\"suggest_alternatives\": true, \"block_conflicting\":
    true}'\n),\n(\n    'ineffective-loop',\n    'Ineffective Action Loop',\n    'Repeated
    actions with consistently low effectiveness scores',\n    4,\n    180,\n    '{\"effectiveness_threshold\":
    0.3, \"min_repetitions\": 3}',\n    'escalate-human',\n    '{\"escalation_webhook\":
    null, \"require_approval\": true}'\n),\n(\n    'cascading-failure',\n    'Cascading
    Failure Pattern',\n    'Actions that trigger more alerts than they resolve',\n
    \   2,\n    60,\n    '{\"new_alerts_threshold\": 1.5, \"recurrence_rate_threshold\":
    0.4}',\n    'block-action',\n    '{\"block_duration_minutes\": 60, \"require_manual_override\":
    true}'\n);\n\n-- 10. Create function for automatic partition creation\nCREATE
    OR REPLACE FUNCTION create_monthly_partitions()\nRETURNS void AS $$\nDECLARE\n
    \   start_date date;\n    end_date date;\n    table_name text;\nBEGIN\n    --
    Create partition for next month\n    start_date := date_trunc('month', CURRENT_DATE
    + interval '1 month');\n    end_date := start_date + interval '1 month';\n    table_name
    := 'resource_action_traces_y' || \n                  to_char(start_date, 'YYYY')
    || 'm' || \n                  to_char(start_date, 'MM');\n    \n    EXECUTE format('CREATE
    TABLE IF NOT EXISTS %I \n                   PARTITION OF resource_action_traces\n
    \                  FOR VALUES FROM (%L) TO (%L)',\n                   table_name,
    start_date, end_date);\n                   \n    RAISE NOTICE 'Created partition:
    %', table_name;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- 11. Create trigger function
    to update updated_at columns\nCREATE OR REPLACE FUNCTION update_updated_at()\nRETURNS
    TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ LANGUAGE
    plpgsql;\n\n-- Create triggers for updated_at\nCREATE TRIGGER update_action_histories_updated_at\n
    \   BEFORE UPDATE ON action_histories\n    FOR EACH ROW\n    EXECUTE FUNCTION
    update_updated_at();\n\nCREATE TRIGGER update_resource_action_traces_updated_at\n
    \   BEFORE UPDATE ON resource_action_traces\n    FOR EACH ROW\n    EXECUTE FUNCTION
    update_updated_at();\n\nCREATE TRIGGER update_oscillation_patterns_updated_at\n
    \   BEFORE UPDATE ON oscillation_patterns\n    FOR EACH ROW\n    EXECUTE FUNCTION
    update_updated_at();\n\n-- 12. Create views for common queries\nCREATE VIEW action_history_summary
    AS\nSELECT \n    rr.namespace,\n    rr.kind,\n    rr.name,\n    ah.total_actions,\n
    \   ah.last_action_at,\n    COUNT(rat.id) as recent_actions_24h,\n    AVG(rat.effectiveness_score)
    as avg_effectiveness_24h,\n    COUNT(DISTINCT rat.action_type) as action_types_used\nFROM
    resource_references rr\nJOIN action_histories ah ON ah.resource_id = rr.id\nLEFT
    JOIN resource_action_traces rat ON rat.action_history_id = ah.id \n    AND rat.action_timestamp
    > NOW() - INTERVAL '24 hours'\nGROUP BY rr.id, rr.namespace, rr.kind, rr.name,
    ah.total_actions, ah.last_action_at;\n\n-- Summary statistics\nCREATE VIEW oscillation_detection_summary
    AS\nSELECT \n    pattern_type,\n    COUNT(*) as total_detections,\n    COUNT(*)
    FILTER (WHERE prevention_applied = true) as preventions_applied,\n    COUNT(*)
    FILTER (WHERE prevention_successful = true) as successful_preventions,\n    AVG(confidence)
    as avg_confidence,\n    MAX(detected_at) as last_detection\nFROM oscillation_detections
    od\nJOIN oscillation_patterns op ON od.pattern_id = op.id\nGROUP BY pattern_type;\n\n--
    Grant permissions (for development)\nGRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA
    public TO slm_user;\nGRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO
    slm_user;\nGRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO slm_user;"
  002_fix_partitioning.sql: "-- Fix partitioning issues in resource_action_traces
    table\n-- Migration: 002_fix_partitioning.sql\n\n-- Drop the problematic partitioned
    table and recreate it properly\nDROP TABLE IF EXISTS resource_action_traces CASCADE;\n\n--
    3. Resource Action Traces Table (partitioned by timestamp)\nCREATE TABLE resource_action_traces
    (\n    id BIGSERIAL,\n    action_history_id BIGINT NOT NULL REFERENCES action_histories(id)
    ON DELETE CASCADE,\n    \n    -- Action identification\n    action_id VARCHAR(64)
    NOT NULL, -- UUID for this specific action\n    correlation_id VARCHAR(64), --
    For tracing across systems\n    \n    -- Timing information\n    action_timestamp
    TIMESTAMP WITH TIME ZONE NOT NULL,\n    execution_start_time TIMESTAMP WITH TIME
    ZONE,\n    execution_end_time TIMESTAMP WITH TIME ZONE,\n    execution_duration_ms
    INTEGER,\n    \n    -- Alert context\n    alert_name VARCHAR(200) NOT NULL,\n
    \   alert_severity VARCHAR(20) NOT NULL, -- info, warning, critical\n    alert_labels
    JSONB,\n    alert_annotations JSONB,\n    alert_firing_time TIMESTAMP WITH TIME
    ZONE,\n    \n    -- AI model information\n    model_used VARCHAR(100) NOT NULL,\n
    \   routing_tier VARCHAR(20), -- route1, route2, route3\n    model_confidence
    DECIMAL(4,3) NOT NULL, -- 0.000-1.000\n    model_reasoning TEXT,\n    alternative_actions
    JSONB, -- [{\"action\": \"scale_deployment\", \"confidence\": 0.85}]\n    \n    --
    Action details\n    action_type VARCHAR(50) NOT NULL,\n    action_parameters JSONB,
    -- {\"replicas\": 5, \"memory\": \"2Gi\"}\n    \n    -- Resource state capture\n
    \   resource_state_before JSONB,\n    resource_state_after JSONB,\n    \n    --
    Execution tracking\n    execution_status VARCHAR(20) DEFAULT 'pending', -- pending,
    executing, completed, failed, rolled-back\n    execution_error TEXT,\n    kubernetes_operations
    JSONB, -- [{\"operation\": \"patch\", \"resource\": \"deployment/webapp\", \"result\":
    \"success\"}]\n    \n    -- Effectiveness assessment\n    effectiveness_score
    DECIMAL(4,3), -- 0.000-1.000, calculated after execution\n    effectiveness_criteria
    JSONB, -- {\"alert_resolved\": true, \"target_metric_improved\": true}\n    effectiveness_assessed_at
    TIMESTAMP WITH TIME ZONE,\n    effectiveness_assessment_method VARCHAR(20), --
    automated, manual, ml-derived\n    effectiveness_notes TEXT,\n    \n    -- Follow-up
    tracking\n    follow_up_actions JSONB, -- [{\"action_id\": \"uuid\", \"relation\":
    \"correction\"}]\n    \n    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n
    \   updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n    \n    -- Primary key
    includes timestamp for partitioning\n    PRIMARY KEY (id, action_timestamp),\n
    \   -- Unique constraint must include partition key\n    UNIQUE (action_id, action_timestamp)\n)
    PARTITION BY RANGE (action_timestamp);\n\n-- Create initial partitions for resource_action_traces\n--
    Previous month\nCREATE TABLE resource_action_traces_y2025m07 \n    PARTITION OF
    resource_action_traces\n    FOR VALUES FROM ('2025-07-01') TO ('2025-08-01');\n\n--
    Current month\nCREATE TABLE resource_action_traces_y2025m08 \n    PARTITION OF
    resource_action_traces\n    FOR VALUES FROM ('2025-08-01') TO ('2025-09-01');\n\n--
    Next month\nCREATE TABLE resource_action_traces_y2025m09 \n    PARTITION OF resource_action_traces\n
    \   FOR VALUES FROM ('2025-09-01') TO ('2025-10-01');\n\n-- Future month (for
    testing edge cases)\nCREATE TABLE resource_action_traces_y2025m10 \n    PARTITION
    OF resource_action_traces\n    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');\n\n--
    Create indexes on the partitioned table (will be inherited by partitions)\nCREATE
    INDEX idx_rat_action_history ON resource_action_traces (action_history_id, action_timestamp);\nCREATE
    INDEX idx_rat_action_type ON resource_action_traces (action_type, action_timestamp);\nCREATE
    INDEX idx_rat_model_used ON resource_action_traces (model_used, action_timestamp);\nCREATE
    INDEX idx_rat_alert_name ON resource_action_traces (alert_name, action_timestamp);\nCREATE
    INDEX idx_rat_execution_status ON resource_action_traces (execution_status) WHERE
    execution_status IN ('pending', 'executing');\nCREATE INDEX idx_rat_effectiveness_score
    ON resource_action_traces (effectiveness_score) WHERE effectiveness_score IS NOT
    NULL;\nCREATE INDEX idx_rat_correlation_id ON resource_action_traces (correlation_id)
    WHERE correlation_id IS NOT NULL;\n\n-- GIN indexes for JSONB queries\nCREATE
    INDEX idx_rat_alert_labels_gin ON resource_action_traces USING GIN (alert_labels);\nCREATE
    INDEX idx_rat_action_parameters_gin ON resource_action_traces USING GIN (action_parameters);\nCREATE
    INDEX idx_rat_resource_state_gin ON resource_action_traces USING GIN (resource_state_before);\n\n--
    Recreate the views that depend on resource_action_traces\nDROP VIEW IF EXISTS
    action_history_summary;\nCREATE VIEW action_history_summary AS\nSELECT \n    rr.namespace,\n
    \   rr.kind,\n    rr.name,\n    ah.total_actions,\n    ah.last_action_at,\n    COUNT(rat.id)
    as recent_actions_24h,\n    AVG(rat.effectiveness_score) as avg_effectiveness_24h,\n
    \   COUNT(DISTINCT rat.action_type) as action_types_used\nFROM resource_references
    rr\nJOIN action_histories ah ON ah.resource_id = rr.id\nLEFT JOIN resource_action_traces
    rat ON rat.action_history_id = ah.id \n    AND rat.action_timestamp > NOW() -
    INTERVAL '24 hours'\nGROUP BY rr.id, rr.namespace, rr.kind, rr.name, ah.total_actions,
    ah.last_action_at;\n\n-- Create trigger for updated_at on the new table\nCREATE
    TRIGGER update_resource_action_traces_updated_at\n    BEFORE UPDATE ON resource_action_traces\n
    \   FOR EACH ROW\n    EXECUTE FUNCTION update_updated_at();"
  003_stored_procedures.sql: "-- Migration: 003_stored_procedures.sql\n-- Replace
    hardcoded queries with PostgreSQL stored procedures for better performance and
    maintainability\n\n-- =============================================================================\n--
    OSCILLATION DETECTION PROCEDURES\n-- =============================================================================\n\n--
    1. Scale Oscillation Detection\nCREATE OR REPLACE FUNCTION detect_scale_oscillation(\n
    \   p_namespace VARCHAR(63),\n    p_kind VARCHAR(100), \n    p_name VARCHAR(253),\n
    \   p_window_minutes INTEGER DEFAULT 120\n)\nRETURNS TABLE (\n    direction_changes
    INTEGER,\n    first_change TIMESTAMP WITH TIME ZONE,\n    last_change TIMESTAMP
    WITH TIME ZONE,\n    avg_effectiveness DECIMAL(4,3),\n    duration_minutes DECIMAL(10,2),\n
    \   severity VARCHAR(20),\n    action_sequence JSONB\n) AS $$\nBEGIN\n    RETURN
    QUERY\n    WITH scale_actions AS (\n        SELECT \n            rat.id,\n            rat.action_timestamp,\n
    \           rat.action_parameters->>'replicas' as replica_count,\n            LAG(rat.action_parameters->>'replicas')
    OVER (\n                PARTITION BY ah.resource_id \n                ORDER BY
    rat.action_timestamp\n            ) as prev_replica_count,\n            LAG(rat.action_timestamp)
    OVER (\n                PARTITION BY ah.resource_id \n                ORDER BY
    rat.action_timestamp  \n            ) as prev_timestamp,\n            COALESCE(rat.effectiveness_score,
    0.0) as effectiveness_score\n        FROM resource_action_traces rat\n        JOIN
    action_histories ah ON rat.action_history_id = ah.id\n        JOIN resource_references
    rr ON ah.resource_id = rr.id\n        WHERE rat.action_type = 'scale_deployment'\n
    \       AND rr.namespace = p_namespace \n        AND rr.kind = p_kind \n        AND
    rr.name = p_name\n        AND rat.action_timestamp > NOW() - INTERVAL '1 minute'
    * p_window_minutes\n    ),\n    direction_changes AS (\n        SELECT \n            id,\n
    \           action_timestamp,\n            replica_count::int,\n            prev_replica_count::int,\n
    \           prev_timestamp,\n            effectiveness_score,\n            CASE
    \n                WHEN replica_count::int > prev_replica_count::int THEN 'up'\n
    \               WHEN replica_count::int < prev_replica_count::int THEN 'down'\n
    \               ELSE 'none'\n            END as direction,\n            LAG(CASE
    \n                WHEN replica_count::int > prev_replica_count::int THEN 'up'\n
    \               WHEN replica_count::int < prev_replica_count::int THEN 'down'\n
    \               ELSE 'none'\n            END) OVER (ORDER BY action_timestamp)
    as prev_direction\n        FROM scale_actions\n        WHERE prev_replica_count
    IS NOT NULL\n    ),\n    oscillation_analysis AS (\n        SELECT \n            COUNT(*)
    FILTER (WHERE direction != prev_direction AND direction != 'none' AND prev_direction
    != 'none') as direction_changes,\n            MIN(action_timestamp) as first_change,\n
    \           MAX(action_timestamp) as last_change,\n            AVG(effectiveness_score)
    as avg_effectiveness,\n            EXTRACT(EPOCH FROM (MAX(action_timestamp) -
    MIN(action_timestamp)))/60 as duration_minutes,\n            array_agg(\n                json_build_object(\n
    \                   'timestamp', action_timestamp,\n                    'replica_count',
    replica_count,\n                    'direction', direction,\n                    'effectiveness',
    effectiveness_score\n                ) ORDER BY action_timestamp\n            )
    as action_sequence\n        FROM direction_changes\n    )\n    SELECT \n        oa.direction_changes::INTEGER,\n
    \       oa.first_change,\n        oa.last_change,\n        oa.avg_effectiveness::DECIMAL(4,3),\n
    \       oa.duration_minutes::DECIMAL(10,2),\n        CASE \n            WHEN oa.direction_changes
    >= 4 AND oa.duration_minutes <= 60 AND oa.avg_effectiveness < 0.5 THEN 'critical'\n
    \           WHEN oa.direction_changes >= 3 AND oa.duration_minutes <= 120 AND
    oa.avg_effectiveness < 0.7 THEN 'high'\n            WHEN oa.direction_changes
    >= 2 AND oa.duration_minutes <= 180 THEN 'medium'\n            ELSE 'low'\n        END::VARCHAR(20)
    as severity,\n        to_jsonb(oa.action_sequence) as action_sequence\n    FROM
    oscillation_analysis oa\n    WHERE oa.direction_changes >= 2;\nEND;\n$$ LANGUAGE
    plpgsql STABLE SECURITY DEFINER;\n\n-- 2. Resource Thrashing Detection\nCREATE
    OR REPLACE FUNCTION detect_resource_thrashing(\n    p_namespace VARCHAR(63),\n
    \   p_kind VARCHAR(100),\n    p_name VARCHAR(253), \n    p_window_minutes INTEGER
    DEFAULT 120\n)\nRETURNS TABLE (\n    thrashing_transitions INTEGER,\n    total_actions
    INTEGER,\n    first_action TIMESTAMP WITH TIME ZONE,\n    last_action TIMESTAMP
    WITH TIME ZONE,\n    avg_effectiveness DECIMAL(4,3),\n    avg_time_gap_minutes
    DECIMAL(10,2),\n    severity VARCHAR(20)\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH
    resource_actions AS (\n        SELECT \n            rat.action_timestamp,\n            rat.action_type,\n
    \           rat.action_parameters,\n            rat.effectiveness_score,\n            LAG(rat.action_type)
    OVER (\n                PARTITION BY ah.resource_id \n                ORDER BY
    rat.action_timestamp\n            ) as prev_action_type,\n            LAG(rat.action_timestamp)
    OVER (\n                PARTITION BY ah.resource_id \n                ORDER BY
    rat.action_timestamp\n            ) as prev_timestamp\n        FROM resource_action_traces
    rat\n        JOIN action_histories ah ON rat.action_history_id = ah.id\n        JOIN
    resource_references rr ON ah.resource_id = rr.id\n        WHERE rat.action_type
    IN ('increase_resources', 'scale_deployment')\n        AND rr.namespace = p_namespace
    \n        AND rr.kind = p_kind \n        AND rr.name = p_name\n        AND rat.action_timestamp
    > NOW() - INTERVAL '1 minute' * p_window_minutes\n    ),\n    thrashing_patterns
    AS (\n        SELECT \n            action_timestamp,\n            action_type,\n
    \           prev_action_type,\n            COALESCE(effectiveness_score, 0.0)
    as effectiveness_score,\n            EXTRACT(EPOCH FROM (action_timestamp - prev_timestamp))/60
    as time_gap_minutes,\n            CASE \n                WHEN (action_type = 'increase_resources'
    AND prev_action_type = 'scale_deployment') OR\n                     (action_type
    = 'scale_deployment' AND prev_action_type = 'increase_resources')\n                THEN
    1 ELSE 0\n            END as is_thrashing_transition\n        FROM resource_actions\n
    \       WHERE prev_action_type IS NOT NULL\n        AND action_timestamp - prev_timestamp
    < INTERVAL '45 minutes'\n    ),\n    thrashing_analysis AS (\n        SELECT \n
    \           COUNT(*) FILTER (WHERE is_thrashing_transition = 1) as thrashing_transitions,\n
    \           COUNT(*) as total_actions,\n            MIN(action_timestamp) as first_action,\n
    \           MAX(action_timestamp) as last_action,\n            AVG(effectiveness_score)
    as avg_effectiveness,\n            AVG(time_gap_minutes) as avg_time_gap_minutes\n
    \       FROM thrashing_patterns\n    )\n    SELECT \n        ta.thrashing_transitions::INTEGER,\n
    \       ta.total_actions::INTEGER,\n        ta.first_action,\n        ta.last_action,\n
    \       ta.avg_effectiveness::DECIMAL(4,3),\n        ta.avg_time_gap_minutes::DECIMAL(10,2),\n
    \       CASE \n            WHEN ta.thrashing_transitions >= 3 AND ta.avg_effectiveness
    < 0.6 THEN 'critical'\n            WHEN ta.thrashing_transitions >= 2 AND ta.avg_effectiveness
    < 0.7 THEN 'high'\n            WHEN ta.thrashing_transitions >= 1 AND ta.avg_time_gap_minutes
    < 15 THEN 'medium'\n            ELSE 'low'\n        END::VARCHAR(20) as severity\n
    \   FROM thrashing_analysis ta\n    WHERE ta.thrashing_transitions >= 1;\nEND;\n$$
    LANGUAGE plpgsql STABLE SECURITY DEFINER;\n\n-- 3. Ineffective Loop Detection\nCREATE
    OR REPLACE FUNCTION detect_ineffective_loops(\n    p_namespace VARCHAR(63),\n
    \   p_kind VARCHAR(100),\n    p_name VARCHAR(253),\n    p_window_minutes INTEGER
    DEFAULT 120\n)\nRETURNS TABLE (\n    action_type VARCHAR(50),\n    repetition_count
    INTEGER,\n    avg_effectiveness DECIMAL(4,3),\n    effectiveness_stddev DECIMAL(4,3),\n
    \   first_occurrence TIMESTAMP WITH TIME ZONE,\n    last_occurrence TIMESTAMP
    WITH TIME ZONE,\n    span_minutes DECIMAL(10,2),\n    severity VARCHAR(20),\n
    \   effectiveness_trend DECIMAL(6,3),\n    effectiveness_scores DECIMAL(4,3)[],\n
    \   timestamps TIMESTAMP WITH TIME ZONE[]\n) AS $$\nBEGIN\n    RETURN QUERY\n
    \   WITH repeated_actions AS (\n        SELECT \n            rat.action_type,\n
    \           COUNT(*) as repetition_count,\n            AVG(COALESCE(rat.effectiveness_score,
    0.0)) as avg_effectiveness,\n            STDDEV(COALESCE(rat.effectiveness_score,
    0.0)) as effectiveness_stddev,\n            MIN(rat.action_timestamp) as first_occurrence,\n
    \           MAX(rat.action_timestamp) as last_occurrence,\n            EXTRACT(EPOCH
    FROM (MAX(rat.action_timestamp) - MIN(rat.action_timestamp)))/60 as span_minutes,\n
    \           array_agg(COALESCE(rat.effectiveness_score, 0.0) ORDER BY rat.action_timestamp)
    as effectiveness_scores,\n            array_agg(rat.action_timestamp ORDER BY
    rat.action_timestamp) as timestamps\n        FROM resource_action_traces rat\n
    \       JOIN action_histories ah ON rat.action_history_id = ah.id\n        JOIN
    resource_references rr ON ah.resource_id = rr.id\n        WHERE rr.namespace =
    p_namespace \n        AND rr.kind = p_kind \n        AND rr.name = p_name\n        AND
    rat.action_timestamp > NOW() - INTERVAL '1 minute' * p_window_minutes\n        GROUP
    BY rat.action_type\n    ),\n    ineffective_patterns AS (\n        SELECT \n            ra.action_type,\n
    \           ra.repetition_count,\n            ra.avg_effectiveness,\n            COALESCE(ra.effectiveness_stddev,
    0.0) as effectiveness_stddev,\n            ra.first_occurrence,\n            ra.last_occurrence,\n
    \           ra.span_minutes,\n            ra.effectiveness_scores,\n            ra.timestamps,\n
    \           CASE \n                WHEN ra.repetition_count >= 5 AND ra.avg_effectiveness
    < 0.3 THEN 'critical'\n                WHEN ra.repetition_count >= 4 AND ra.avg_effectiveness
    < 0.5 THEN 'high'\n                WHEN ra.repetition_count >= 3 AND ra.avg_effectiveness
    < 0.6 THEN 'medium'\n                WHEN ra.repetition_count >= 2 AND ra.avg_effectiveness
    < 0.4 THEN 'low'\n                ELSE 'none'\n            END as severity,\n
    \           CASE \n                WHEN ra.repetition_count >= 3 THEN\n                    (ra.effectiveness_scores[array_length(ra.effectiveness_scores,
    1)] - ra.effectiveness_scores[1]) / \n                    GREATEST(ra.effectiveness_scores[1],
    0.1)\n                ELSE 0\n            END as effectiveness_trend\n        FROM
    repeated_actions ra\n        WHERE ra.repetition_count >= 2\n    )\n    SELECT
    \n        ip.action_type,\n        ip.repetition_count::INTEGER,\n        ip.avg_effectiveness::DECIMAL(4,3),\n
    \       ip.effectiveness_stddev::DECIMAL(4,3),\n        ip.first_occurrence,\n
    \       ip.last_occurrence,\n        ip.span_minutes::DECIMAL(10,2),\n        ip.severity::VARCHAR(20),\n
    \       ip.effectiveness_trend::DECIMAL(6,3),\n        ip.effectiveness_scores::DECIMAL(4,3)[],\n
    \       ip.timestamps\n    FROM ineffective_patterns ip\n    WHERE ip.severity
    != 'none'\n    ORDER BY \n        CASE ip.severity \n            WHEN 'critical'
    THEN 1 \n            WHEN 'high' THEN 2 \n            WHEN 'medium' THEN 3 \n
    \           ELSE 4 \n        END,\n        ip.avg_effectiveness ASC;\nEND;\n$$
    LANGUAGE plpgsql STABLE SECURITY DEFINER;\n\n-- 4. Cascading Failure Detection
    \ \nCREATE OR REPLACE FUNCTION detect_cascading_failures(\n    p_namespace VARCHAR(63),\n
    \   p_kind VARCHAR(100),\n    p_name VARCHAR(253),\n    p_window_minutes INTEGER
    DEFAULT 120\n)\nRETURNS TABLE (\n    action_type VARCHAR(50),\n    total_actions
    INTEGER,\n    avg_new_alerts DECIMAL(6,2),\n    recurrence_rate DECIMAL(4,3),\n
    \   avg_effectiveness DECIMAL(4,3),\n    actions_causing_cascades INTEGER,\n    max_alerts_triggered
    INTEGER,\n    severity VARCHAR(20)\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH
    action_outcomes AS (\n        SELECT \n            rat.id,\n            rat.action_timestamp,\n
    \           rat.action_type,\n            rat.alert_name as original_alert,\n
    \           COALESCE(rat.effectiveness_score, 0.0) as effectiveness_score,\n            (\n
    \               SELECT COUNT(DISTINCT rat2.alert_name)\n                FROM resource_action_traces
    rat2\n                JOIN action_histories ah2 ON rat2.action_history_id = ah2.id\n
    \               WHERE ah2.resource_id = ah.resource_id\n                AND rat2.action_timestamp
    BETWEEN rat.action_timestamp AND rat.action_timestamp + INTERVAL '30 minutes'\n
    \               AND rat2.alert_name != rat.alert_name\n            ) as new_alerts_triggered,\n
    \           (\n                SELECT COUNT(*)\n                FROM resource_action_traces
    rat3\n                JOIN action_histories ah3 ON rat3.action_history_id = ah3.id\n
    \               WHERE ah3.resource_id = ah.resource_id\n                AND rat3.action_timestamp
    > rat.action_timestamp\n                AND rat3.alert_name = rat.alert_name\n
    \               LIMIT 1\n            ) as original_alert_recurred\n        FROM
    resource_action_traces rat\n        JOIN action_histories ah ON rat.action_history_id
    = ah.id\n        JOIN resource_references rr ON ah.resource_id = rr.id\n        WHERE
    rr.namespace = p_namespace \n        AND rr.kind = p_kind \n        AND rr.name
    = p_name\n        AND rat.action_timestamp > NOW() - INTERVAL '1 minute' * p_window_minutes\n
    \   ),\n    cascading_analysis AS (\n        SELECT \n            ao.action_type,\n
    \           COUNT(*) as total_actions,\n            AVG(ao.new_alerts_triggered::float)
    as avg_new_alerts,\n            AVG(CASE WHEN ao.original_alert_recurred > 0 THEN
    1.0 ELSE 0.0 END) as recurrence_rate,\n            AVG(ao.effectiveness_score)
    as avg_effectiveness,\n            SUM(CASE WHEN ao.new_alerts_triggered > 0 THEN
    1 ELSE 0 END) as actions_causing_cascades,\n            MAX(ao.new_alerts_triggered)
    as max_alerts_triggered\n        FROM action_outcomes ao\n        GROUP BY ao.action_type\n
    \   )\n    SELECT \n        ca.action_type,\n        ca.total_actions::INTEGER,\n
    \       ca.avg_new_alerts::DECIMAL(6,2),\n        ca.recurrence_rate::DECIMAL(4,3),\n
    \       ca.avg_effectiveness::DECIMAL(4,3),\n        ca.actions_causing_cascades::INTEGER,\n
    \       ca.max_alerts_triggered::INTEGER,\n        CASE \n            WHEN ca.avg_new_alerts
    > 2.0 AND ca.recurrence_rate > 0.5 THEN 'critical'\n            WHEN ca.avg_new_alerts
    > 1.5 OR ca.recurrence_rate > 0.7 THEN 'high'\n            WHEN ca.avg_new_alerts
    > 1.0 OR ca.recurrence_rate > 0.4 THEN 'medium'\n            WHEN ca.actions_causing_cascades
    > 0 THEN 'low'\n            ELSE 'none'\n        END::VARCHAR(20) as severity\n
    \   FROM cascading_analysis ca\n    WHERE ca.actions_causing_cascades > 0\n    ORDER
    BY ca.avg_new_alerts DESC, ca.recurrence_rate DESC;\nEND;\n$$ LANGUAGE plpgsql
    STABLE SECURITY DEFINER;\n\n-- =============================================================================\n--
    ACTION HISTORY MANAGEMENT PROCEDURES\n-- =============================================================================\n\n--
    5. Get Action History with Filters\nCREATE OR REPLACE FUNCTION get_action_traces(\n
    \   p_namespace VARCHAR(63),\n    p_kind VARCHAR(100),\n    p_name VARCHAR(253),\n
    \   p_action_type VARCHAR(50) DEFAULT NULL,\n    p_model_used VARCHAR(100) DEFAULT
    NULL,\n    p_time_start TIMESTAMP WITH TIME ZONE DEFAULT NULL,\n    p_time_end
    TIMESTAMP WITH TIME ZONE DEFAULT NULL,\n    p_limit INTEGER DEFAULT 50,\n    p_offset
    INTEGER DEFAULT 0\n)\nRETURNS TABLE (\n    action_id VARCHAR(64),\n    action_timestamp
    TIMESTAMP WITH TIME ZONE,\n    action_type VARCHAR(50),\n    model_used VARCHAR(100),\n
    \   model_confidence DECIMAL(4,3),\n    execution_status VARCHAR(20),\n    effectiveness_score
    DECIMAL(4,3),\n    model_reasoning TEXT,\n    action_parameters JSONB,\n    alert_name
    VARCHAR(200),\n    alert_severity VARCHAR(20)\n) AS $$\nBEGIN\n    RETURN QUERY\n
    \   SELECT \n        rat.action_id,\n        rat.action_timestamp,\n        rat.action_type,\n
    \       rat.model_used,\n        rat.model_confidence,\n        rat.execution_status,\n
    \       rat.effectiveness_score,\n        rat.model_reasoning,\n        rat.action_parameters,\n
    \       rat.alert_name,\n        rat.alert_severity\n    FROM resource_action_traces
    rat\n    JOIN action_histories ah ON rat.action_history_id = ah.id\n    JOIN resource_references
    rr ON ah.resource_id = rr.id\n    WHERE rr.namespace = p_namespace \n    AND rr.kind
    = p_kind \n    AND rr.name = p_name\n    AND (p_action_type IS NULL OR rat.action_type
    = p_action_type)\n    AND (p_model_used IS NULL OR rat.model_used = p_model_used)\n
    \   AND (p_time_start IS NULL OR rat.action_timestamp >= p_time_start)\n    AND
    (p_time_end IS NULL OR rat.action_timestamp <= p_time_end)\n    ORDER BY rat.action_timestamp
    DESC\n    LIMIT p_limit\n    OFFSET p_offset;\nEND;\n$$ LANGUAGE plpgsql STABLE
    SECURITY DEFINER;\n\n-- 6. Get Action Effectiveness Metrics\nCREATE OR REPLACE
    FUNCTION get_action_effectiveness(\n    p_namespace VARCHAR(63),\n    p_kind VARCHAR(100),\n
    \   p_name VARCHAR(253),\n    p_action_type VARCHAR(50) DEFAULT NULL,\n    p_time_start
    TIMESTAMP WITH TIME ZONE DEFAULT NOW() - INTERVAL '7 days',\n    p_time_end TIMESTAMP
    WITH TIME ZONE DEFAULT NOW()\n)\nRETURNS TABLE (\n    action_type VARCHAR(50),\n
    \   sample_size INTEGER,\n    avg_effectiveness DECIMAL(4,3),\n    stddev_effectiveness
    DECIMAL(4,3),\n    min_effectiveness DECIMAL(4,3),\n    max_effectiveness DECIMAL(4,3),\n
    \   success_rate DECIMAL(4,3)\n) AS $$\nBEGIN\n    RETURN QUERY\n    SELECT \n
    \       rat.action_type,\n        COUNT(*)::INTEGER as sample_size,\n        AVG(rat.effectiveness_score)::DECIMAL(4,3)
    as avg_effectiveness,\n        STDDEV(rat.effectiveness_score)::DECIMAL(4,3) as
    stddev_effectiveness,\n        MIN(rat.effectiveness_score)::DECIMAL(4,3) as min_effectiveness,\n
    \       MAX(rat.effectiveness_score)::DECIMAL(4,3) as max_effectiveness,\n        AVG(CASE
    WHEN rat.execution_status = 'completed' THEN 1.0 ELSE 0.0 END)::DECIMAL(4,3) as
    success_rate\n    FROM resource_action_traces rat\n    JOIN action_histories ah
    ON rat.action_history_id = ah.id\n    JOIN resource_references rr ON ah.resource_id
    = rr.id\n    WHERE rr.namespace = p_namespace \n    AND rr.kind = p_kind \n    AND
    rr.name = p_name\n    AND rat.effectiveness_score IS NOT NULL\n    AND rat.action_timestamp
    BETWEEN p_time_start AND p_time_end\n    AND (p_action_type IS NULL OR rat.action_type
    = p_action_type)\n    GROUP BY rat.action_type\n    HAVING COUNT(*) >= 1\n    ORDER
    BY avg_effectiveness DESC;\nEND;\n$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;\n\n--
    7. Store Oscillation Detection Result\nCREATE OR REPLACE FUNCTION store_oscillation_detection(\n
    \   p_pattern_id INTEGER,\n    p_namespace VARCHAR(63),\n    p_kind VARCHAR(100),\n
    \   p_name VARCHAR(253),\n    p_confidence DECIMAL(4,3),\n    p_action_count INTEGER,\n
    \   p_time_span_minutes INTEGER,\n    p_pattern_evidence JSONB,\n    p_prevention_action
    VARCHAR(50) DEFAULT NULL\n)\nRETURNS INTEGER AS $$\nDECLARE\n    v_resource_id
    INTEGER;\n    v_detection_id INTEGER;\nBEGIN\n    -- Get or create resource reference\n
    \   SELECT id INTO v_resource_id\n    FROM resource_references \n    WHERE namespace
    = p_namespace AND kind = p_kind AND name = p_name;\n    \n    IF v_resource_id
    IS NULL THEN\n        INSERT INTO resource_references (resource_uid, api_version,
    kind, name, namespace, last_seen)\n        VALUES (gen_random_uuid()::text, 'apps/v1',
    p_kind, p_name, p_namespace, NOW())\n        RETURNING id INTO v_resource_id;\n
    \   END IF;\n    \n    -- Insert oscillation detection\n    INSERT INTO oscillation_detections
    (\n        pattern_id, resource_id, detected_at, confidence, action_count,\n        time_span_minutes,
    pattern_evidence, prevention_applied,\n        prevention_action\n    ) VALUES
    (\n        p_pattern_id, v_resource_id, NOW(), p_confidence, p_action_count,\n
    \       p_time_span_minutes, p_pattern_evidence, \n        p_prevention_action
    IS NOT NULL,\n        p_prevention_action\n    ) RETURNING id INTO v_detection_id;\n
    \   \n    RETURN v_detection_id;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n--
    =============================================================================\n--
    SECURITY AND PERFORMANCE OPTIMIZATIONS\n-- =============================================================================\n\n--
    Create indexes for procedure performance\nCREATE INDEX IF NOT EXISTS idx_rat_resource_action_time
    \nON resource_action_traces (action_history_id, action_type, action_timestamp
    DESC);\n\nCREATE INDEX IF NOT EXISTS idx_rat_effectiveness_analysis\nON resource_action_traces
    (action_type, effectiveness_score, action_timestamp)\nWHERE effectiveness_score
    IS NOT NULL;\n\n-- Grant execute permissions (adjust as needed for your environment)\nGRANT
    EXECUTE ON FUNCTION detect_scale_oscillation(VARCHAR, VARCHAR, VARCHAR, INTEGER)
    TO slm_user;\nGRANT EXECUTE ON FUNCTION detect_resource_thrashing(VARCHAR, VARCHAR,
    VARCHAR, INTEGER) TO slm_user;\nGRANT EXECUTE ON FUNCTION detect_ineffective_loops(VARCHAR,
    VARCHAR, VARCHAR, INTEGER) TO slm_user;\nGRANT EXECUTE ON FUNCTION detect_cascading_failures(VARCHAR,
    VARCHAR, VARCHAR, INTEGER) TO slm_user;\nGRANT EXECUTE ON FUNCTION get_action_traces(VARCHAR,
    VARCHAR, VARCHAR, VARCHAR, VARCHAR, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME
    ZONE, INTEGER, INTEGER) TO slm_user;\nGRANT EXECUTE ON FUNCTION get_action_effectiveness(VARCHAR,
    VARCHAR, VARCHAR, VARCHAR, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE)
    TO slm_user;\nGRANT EXECUTE ON FUNCTION store_oscillation_detection(INTEGER, VARCHAR,
    VARCHAR, VARCHAR, DECIMAL, INTEGER, INTEGER, JSONB, VARCHAR) TO slm_user;\n\n--
    Add helpful comments\nCOMMENT ON FUNCTION detect_scale_oscillation IS 'Detects
    scale oscillation patterns for a resource within a time window';\nCOMMENT ON FUNCTION
    detect_resource_thrashing IS 'Detects resource thrashing between scale and resource
    adjustment actions';\nCOMMENT ON FUNCTION detect_ineffective_loops IS 'Identifies
    repeated actions with low effectiveness scores';\nCOMMENT ON FUNCTION detect_cascading_failures
    IS 'Detects actions that trigger more alerts than they resolve';\nCOMMENT ON FUNCTION
    get_action_traces IS 'Retrieves filtered action history for a resource';\nCOMMENT
    ON FUNCTION get_action_effectiveness IS 'Calculates effectiveness metrics for
    actions on a resource';\nCOMMENT ON FUNCTION store_oscillation_detection IS 'Stores
    oscillation detection results with proper resource management';\n\n-- =============================================================================\n--
    DETECTOR BASE PROCEDURES\n-- =============================================================================\n\n--
    8. Get Resource Actions Base\nCREATE OR REPLACE FUNCTION get_resource_actions_base(\n
    \   p_namespace VARCHAR(63),\n    p_kind VARCHAR(100),\n    p_name VARCHAR(253),\n
    \   p_window_minutes INTEGER DEFAULT NULL\n)\nRETURNS TABLE (\n    trace_id BIGINT,\n
    \   action_timestamp TIMESTAMP WITH TIME ZONE,\n    action_type VARCHAR(50),\n
    \   action_parameters JSONB,\n    effectiveness_score DECIMAL(4,3),\n    model_confidence
    DECIMAL(4,3),\n    execution_status VARCHAR(20)\n) AS $$\nBEGIN\n    RETURN QUERY\n
    \   SELECT \n        rat.id as trace_id,\n        rat.action_timestamp,\n        rat.action_type,\n
    \       rat.action_parameters,\n        rat.effectiveness_score,\n        rat.model_confidence,\n
    \       rat.execution_status\n    FROM resource_action_traces rat\n    JOIN action_histories
    ah ON rat.action_history_id = ah.id\n    JOIN resource_references rr ON ah.resource_id
    = rr.id\n    WHERE rr.namespace = p_namespace \n    AND rr.kind = p_kind \n    AND
    rr.name = p_name\n    AND (p_window_minutes IS NULL OR rat.action_timestamp >
    NOW() - INTERVAL '1 minute' * p_window_minutes)\n    ORDER BY rat.action_timestamp
    DESC;\nEND;\n$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;\n\n-- 9. Get Resource
    ID\nCREATE OR REPLACE FUNCTION get_resource_id(\n    p_namespace VARCHAR(63),\n
    \   p_kind VARCHAR(100),\n    p_name VARCHAR(253)\n)\nRETURNS INTEGER AS $$\nDECLARE\n
    \   v_resource_id INTEGER;\nBEGIN\n    SELECT id INTO v_resource_id\n    FROM
    resource_references \n    WHERE namespace = p_namespace AND kind = p_kind AND
    name = p_name;\n    \n    IF v_resource_id IS NULL THEN\n        RAISE EXCEPTION
    'Resource not found: namespace=%, kind=%, name=%', p_namespace, p_kind, p_name;\n
    \   END IF;\n    \n    RETURN v_resource_id;\nEND;\n$$ LANGUAGE plpgsql STABLE
    SECURITY DEFINER;\n\n-- 10. Action Oscillation Analysis\nCREATE OR REPLACE FUNCTION
    analyze_action_oscillation(\n    p_namespace VARCHAR(63),\n    p_kind VARCHAR(100),\n
    \   p_name VARCHAR(253),\n    p_window_minutes INTEGER DEFAULT 120\n)\nRETURNS
    TABLE (\n    action_timestamp TIMESTAMP WITH TIME ZONE,\n    action_type VARCHAR(50),\n
    \   effectiveness_score DECIMAL(4,3),\n    prev_timestamp TIMESTAMP WITH TIME
    ZONE,\n    prev_action_type VARCHAR(50),\n    time_gap_minutes DECIMAL(10,2),\n
    \   action_sequence_position INTEGER\n) AS $$\nBEGIN\n    RETURN QUERY\n    WITH
    action_analysis AS (\n        SELECT \n            rat.action_timestamp,\n            rat.action_type,\n
    \           rat.effectiveness_score,\n            LAG(rat.action_timestamp) OVER
    (ORDER BY rat.action_timestamp) as prev_timestamp,\n            LAG(rat.action_type)
    OVER (ORDER BY rat.action_timestamp) as prev_action_type,\n            ROW_NUMBER()
    OVER (ORDER BY rat.action_timestamp) as sequence_position\n        FROM resource_action_traces
    rat\n        JOIN action_histories ah ON rat.action_history_id = ah.id\n        JOIN
    resource_references rr ON ah.resource_id = rr.id\n        WHERE rr.namespace =
    p_namespace \n        AND rr.kind = p_kind \n        AND rr.name = p_name\n        AND
    rat.action_timestamp > NOW() - INTERVAL '1 minute' * p_window_minutes\n    )\n
    \   SELECT \n        aa.action_timestamp,\n        aa.action_type,\n        aa.effectiveness_score,\n
    \       aa.prev_timestamp,\n        aa.prev_action_type,\n        CASE \n            WHEN
    aa.prev_timestamp IS NOT NULL THEN\n                EXTRACT(EPOCH FROM (aa.action_timestamp
    - aa.prev_timestamp))/60\n            ELSE 0\n        END::DECIMAL(10,2) as time_gap_minutes,\n
    \       aa.sequence_position::INTEGER as action_sequence_position\n    FROM action_analysis
    aa\n    ORDER BY aa.action_timestamp;\nEND;\n$$ LANGUAGE plpgsql STABLE SECURITY
    DEFINER;\n\n-- Grant execute permissions\nGRANT EXECUTE ON FUNCTION get_resource_actions_base(VARCHAR,
    VARCHAR, VARCHAR, INTEGER) TO slm_user;\nGRANT EXECUTE ON FUNCTION get_resource_id(VARCHAR,
    VARCHAR, VARCHAR) TO slm_user;\nGRANT EXECUTE ON FUNCTION analyze_action_oscillation(VARCHAR,
    VARCHAR, VARCHAR, INTEGER) TO slm_user;\n\n-- Add helpful comments\nCOMMENT ON
    FUNCTION get_resource_actions_base IS 'Retrieves base resource action data with
    optional time window filtering';\nCOMMENT ON FUNCTION get_resource_id IS 'Gets
    the database ID for a resource reference with error handling';\nCOMMENT ON FUNCTION
    analyze_action_oscillation IS 'Analyzes action sequences for oscillation patterns
    with timing gaps';"
  004_add_effectiveness_assessment_due.sql: |
    -- Add missing effectiveness_assessment_due column
    -- Migration: 004_add_effectiveness_assessment_due.sql

    -- Add effectiveness_assessment_due column to resource_action_traces table
    ALTER TABLE resource_action_traces
    ADD COLUMN effectiveness_assessment_due TIMESTAMP WITH TIME ZONE;

    -- Create index for the new column for efficient queries
    CREATE INDEX idx_rat_effectiveness_due ON resource_action_traces (effectiveness_assessment_due);

    -- Update the partition tables as well (they inherit from the parent)
    -- The column will be automatically added to existing partitions since they inherit the schema
  005_vector_schema.sql: |
    -- Vector Database Schema for AI-driven Action Pattern Recognition
    -- Date: 2025-01-03
    -- Description: Adds pgvector extension and action_patterns table for vector-based pattern storage

    -- Enable pgvector extension for vector operations
    CREATE EXTENSION IF NOT EXISTS vector;

    -- Create action_patterns table for storing action patterns as vectors
    CREATE TABLE action_patterns (
        id VARCHAR(255) PRIMARY KEY,
        action_type VARCHAR(255) NOT NULL,
        alert_name VARCHAR(255) NOT NULL,
        alert_severity VARCHAR(50) NOT NULL,
        namespace VARCHAR(255),
        resource_type VARCHAR(255),
        resource_name VARCHAR(255),

        -- Complex data stored as JSONB
        action_parameters JSONB,
        context_labels JSONB,
        pre_conditions JSONB,
        post_conditions JSONB,
        effectiveness_data JSONB,
        metadata JSONB,

        -- Vector embedding for similarity search (384 dimensions for sentence-transformers/all-MiniLM-L6-v2)
        embedding vector(384),

        -- Timestamps
        created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
    );

    -- Create vector similarity index using IVFFlat for efficient similarity search
    -- Lists parameter is set to 100, good for up to 100K vectors
    CREATE INDEX action_patterns_embedding_idx
    ON action_patterns
    USING ivfflat (embedding vector_l2_ops)
    WITH (lists = 100);

    -- Traditional indexes for filtering and performance
    CREATE INDEX action_patterns_action_type_idx ON action_patterns(action_type);
    CREATE INDEX action_patterns_alert_name_idx ON action_patterns(alert_name);
    CREATE INDEX action_patterns_alert_severity_idx ON action_patterns(alert_severity);
    CREATE INDEX action_patterns_namespace_idx ON action_patterns(namespace);
    CREATE INDEX action_patterns_resource_type_idx ON action_patterns(resource_type);
    CREATE INDEX action_patterns_created_at_idx ON action_patterns(created_at);

    -- Partial index for patterns with effectiveness data
    CREATE INDEX action_patterns_effectiveness_score_idx
    ON action_patterns((effectiveness_data->>'score'))
    WHERE effectiveness_data->>'score' IS NOT NULL;

    -- GIN indexes for JSONB fields to enable efficient JSON queries
    CREATE INDEX action_patterns_action_parameters_gin_idx ON action_patterns USING gin(action_parameters);
    CREATE INDEX action_patterns_context_labels_gin_idx ON action_patterns USING gin(context_labels);
    CREATE INDEX action_patterns_metadata_gin_idx ON action_patterns USING gin(metadata);

    -- Function to automatically update updated_at timestamp
    CREATE OR REPLACE FUNCTION update_action_patterns_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = NOW();
        RETURN NEW;
    END;
    $$ language plpgsql;

    -- Trigger to automatically update updated_at on row updates
    CREATE TRIGGER action_patterns_updated_at_trigger
        BEFORE UPDATE ON action_patterns
        FOR EACH ROW
        EXECUTE FUNCTION update_action_patterns_updated_at();

    -- Create view for pattern analytics
    CREATE VIEW pattern_analytics_summary AS
    SELECT
        COUNT(*) as total_patterns,
        COUNT(DISTINCT action_type) as unique_action_types,
        COUNT(DISTINCT alert_name) as unique_alert_names,
        COUNT(DISTINCT alert_severity) as unique_severities,
        COUNT(DISTINCT namespace) as unique_namespaces,
        COUNT(DISTINCT resource_type) as unique_resource_types,
        AVG((effectiveness_data->>'score')::float) as avg_effectiveness_score,
        COUNT(*) FILTER (WHERE effectiveness_data->>'score' IS NOT NULL) as patterns_with_effectiveness,
        MIN(created_at) as oldest_pattern,
        MAX(created_at) as newest_pattern
    FROM action_patterns;

    -- Add comments for documentation
    COMMENT ON TABLE action_patterns IS 'Stores action patterns with vector embeddings for AI-driven pattern recognition';
    COMMENT ON COLUMN action_patterns.embedding IS 'Vector embedding (384-dimensional) for similarity search using pgvector';
    COMMENT ON COLUMN action_patterns.effectiveness_data IS 'JSONB containing effectiveness metrics and scoring data';
    COMMENT ON INDEX action_patterns_embedding_idx IS 'IVFFlat index for efficient vector similarity search using L2 distance';
  006_effectiveness_assessment.sql: |
    -- Migration: Add AI Effectiveness Assessment Tables
    -- Created: Phase 1 Implementation - Business Logic Enhancement
    -- Purpose: Enable real AI learning from action outcomes

    -- Table for pending action assessments
    CREATE TABLE IF NOT EXISTS action_assessments (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        trace_id VARCHAR(255) NOT NULL,
        action_type VARCHAR(100) NOT NULL,
        context_hash VARCHAR(64) NOT NULL,
        alert_name VARCHAR(255) NOT NULL,
        namespace VARCHAR(255) NOT NULL,
        resource_name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP WITH TIME ZONE NOT NULL,
        scheduled_for TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW() + INTERVAL '5 minutes',
        status VARCHAR(50) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        completed_at TIMESTAMP WITH TIME ZONE
    );

    -- Indexes for action_assessments
    CREATE INDEX IF NOT EXISTS idx_action_assessments_status_scheduled ON action_assessments(status, scheduled_for) WHERE status = 'pending';
    CREATE INDEX IF NOT EXISTS idx_action_assessments_trace_id ON action_assessments(trace_id);
    CREATE INDEX IF NOT EXISTS idx_action_assessments_context ON action_assessments(action_type, context_hash);

    -- Table for storing effectiveness assessment results
    CREATE TABLE IF NOT EXISTS effectiveness_results (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        trace_id VARCHAR(255) NOT NULL UNIQUE,
        action_type VARCHAR(100) NOT NULL,
        overall_score FLOAT NOT NULL CHECK (overall_score >= 0 AND overall_score <= 1),
        alert_resolved BOOLEAN NOT NULL,
        metric_delta JSONB,
        side_effects INTEGER DEFAULT 0,
        confidence FLOAT NOT NULL CHECK (confidence >= 0 AND confidence <= 1),
        assessed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        recommended_adjustments JSONB,
        learning_contribution FLOAT NOT NULL DEFAULT 0.5 CHECK (learning_contribution >= 0 AND learning_contribution <= 1),
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    );

    -- Indexes for effectiveness_results
    CREATE INDEX IF NOT EXISTS idx_effectiveness_results_action_type ON effectiveness_results(action_type);
    CREATE INDEX IF NOT EXISTS idx_effectiveness_results_assessed_at ON effectiveness_results(assessed_at);
    CREATE INDEX IF NOT EXISTS idx_effectiveness_results_score ON effectiveness_results(overall_score);

    -- Table for action confidence scores (core learning mechanism)
    CREATE TABLE IF NOT EXISTS action_confidence_scores (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        action_type VARCHAR(100) NOT NULL,
        context_hash VARCHAR(64) NOT NULL, -- Hash of alert context for grouping similar scenarios
        base_confidence FLOAT NOT NULL CHECK (base_confidence >= 0 AND base_confidence <= 1),
        adjusted_confidence FLOAT NOT NULL CHECK (adjusted_confidence >= 0 AND adjusted_confidence <= 1),
        adjustment_reason TEXT,
        effectiveness_samples INTEGER DEFAULT 0,
        last_updated TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        UNIQUE(action_type, context_hash)
    );

    -- Indexes for action_confidence_scores
    CREATE INDEX IF NOT EXISTS idx_action_confidence_context ON action_confidence_scores(action_type, context_hash);
    CREATE INDEX IF NOT EXISTS idx_action_confidence_updated ON action_confidence_scores(last_updated);

    -- Table for action outcome history (for learning algorithms)
    CREATE TABLE IF NOT EXISTS action_outcomes (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        trace_id VARCHAR(255) NOT NULL,
        action_type VARCHAR(100) NOT NULL,
        context_hash VARCHAR(64) NOT NULL,
        success BOOLEAN NOT NULL,
        alert_resolved BOOLEAN NOT NULL,
        side_effects INTEGER DEFAULT 0,
        effectiveness_score FLOAT NOT NULL CHECK (effectiveness_score >= 0 AND effectiveness_score <= 1),
        execution_time BIGINT, -- Duration in nanoseconds
        metrics_before JSONB,
        metrics_after JSONB,
        failure_reason TEXT,
        executed_at TIMESTAMP WITH TIME ZONE NOT NULL,
        assessed_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
    );

    -- Indexes for action_outcomes
    CREATE INDEX IF NOT EXISTS idx_action_outcomes_context ON action_outcomes(action_type, context_hash);
    CREATE INDEX IF NOT EXISTS idx_action_outcomes_executed_at ON action_outcomes(executed_at);
    CREATE INDEX IF NOT EXISTS idx_action_outcomes_success ON action_outcomes(success);
    CREATE INDEX IF NOT EXISTS idx_action_outcomes_effectiveness ON action_outcomes(effectiveness_score);

    -- Table for tracking alternative action recommendations
    CREATE TABLE IF NOT EXISTS action_alternatives (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        failed_action_type VARCHAR(100) NOT NULL,
        context_hash VARCHAR(64) NOT NULL,
        alternative_action_type VARCHAR(100) NOT NULL,
        success_rate FLOAT NOT NULL DEFAULT 0.5 CHECK (success_rate >= 0 AND success_rate <= 1),
        sample_size INTEGER NOT NULL DEFAULT 0,
        last_success_at TIMESTAMP WITH TIME ZONE,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
        UNIQUE(failed_action_type, context_hash, alternative_action_type)
    );

    -- Indexes for action_alternatives
    CREATE INDEX IF NOT EXISTS idx_action_alternatives_failed ON action_alternatives(failed_action_type, context_hash);
    CREATE INDEX IF NOT EXISTS idx_action_alternatives_success_rate ON action_alternatives(success_rate DESC);

    -- View for easy querying of effectiveness trends
    CREATE OR REPLACE VIEW effectiveness_trends AS
    SELECT
        action_type,
        DATE_TRUNC('day', assessed_at) as assessment_date,
        COUNT(*) as total_assessments,
        AVG(overall_score) as avg_effectiveness,
        AVG(confidence) as avg_confidence,
        COUNT(CASE WHEN alert_resolved THEN 1 END) as alerts_resolved,
        COUNT(CASE WHEN alert_resolved THEN 1 END)::FLOAT / COUNT(*) as resolution_rate
    FROM effectiveness_results
    GROUP BY action_type, DATE_TRUNC('day', assessed_at)
    ORDER BY action_type, assessment_date;

    -- View for low-confidence actions requiring attention
    CREATE OR REPLACE VIEW low_confidence_actions AS
    SELECT
        acs.action_type,
        acs.context_hash,
        acs.adjusted_confidence,
        acs.adjustment_reason,
        acs.effectiveness_samples,
        acs.last_updated,
        COALESCE(recent_outcomes.recent_success_rate, 0) as recent_success_rate,
        COALESCE(recent_outcomes.recent_samples, 0) as recent_samples
    FROM action_confidence_scores acs
    LEFT JOIN (
        SELECT
            action_type,
            context_hash,
            AVG(CASE WHEN success THEN 1.0 ELSE 0.0 END) as recent_success_rate,
            COUNT(*) as recent_samples
        FROM action_outcomes
        WHERE executed_at > NOW() - INTERVAL '7 days'
        GROUP BY action_type, context_hash
    ) recent_outcomes ON acs.action_type = recent_outcomes.action_type
                     AND acs.context_hash = recent_outcomes.context_hash
    WHERE acs.adjusted_confidence < 0.5
    ORDER BY acs.adjusted_confidence ASC, acs.last_updated DESC;

    -- Function to automatically create assessment when action trace is created
    CREATE OR REPLACE FUNCTION create_assessment_for_action_trace()
    RETURNS TRIGGER AS $$
    BEGIN
        -- Only create assessment for completed actions
        IF NEW.execution_status = 'completed' THEN
            INSERT INTO action_assessments (
                trace_id,
                action_type,
                context_hash,
                alert_name,
                namespace,
                resource_name,
                executed_at,
                scheduled_for
            ) VALUES (
                NEW.id::VARCHAR,
                NEW.action_type,
                -- Simple context hash based on action type + alert
                encode(sha256(CONCAT(NEW.action_type, ':', COALESCE(NEW.alert_name, 'no-alert'))::bytea), 'hex'),
                COALESCE(NEW.alert_name, 'no-alert'),
                'unknown', -- Default namespace until we can join with resource_references
                'unknown', -- Default resource name until we can join with resource_references
                COALESCE(NEW.execution_end_time, NEW.action_timestamp),
                NOW() + INTERVAL '5 minutes' -- Schedule assessment 5 minutes after execution
            );
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Trigger to automatically create assessments for new action traces
    -- Note: This assumes resource_action_traces table exists from previous migrations
    DO $$
    BEGIN
        IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'resource_action_traces') THEN
            DROP TRIGGER IF EXISTS trigger_create_assessment_for_action_trace ON resource_action_traces;
            CREATE TRIGGER trigger_create_assessment_for_action_trace
                AFTER UPDATE ON resource_action_traces
                FOR EACH ROW
                EXECUTE FUNCTION create_assessment_for_action_trace();
        END IF;
    END $$;

    -- Insert some default confidence scores for common action types
    INSERT INTO action_confidence_scores (action_type, context_hash, base_confidence, adjusted_confidence, adjustment_reason)
    VALUES
        ('restart_pod', 'default', 0.7, 0.7, 'Default confidence for pod restarts'),
        ('scale_deployment', 'default', 0.75, 0.75, 'Default confidence for deployment scaling'),
        ('delete_pod', 'default', 0.6, 0.6, 'Default confidence for pod deletion'),
        ('rollback_deployment', 'default', 0.8, 0.8, 'Default confidence for deployment rollback')
    ON CONFLICT (action_type, context_hash) DO NOTHING;

    -- Add comments for documentation
    COMMENT ON TABLE action_assessments IS 'Pending effectiveness assessments for completed actions';
    COMMENT ON TABLE effectiveness_results IS 'Results of AI effectiveness assessments for learning';
    COMMENT ON TABLE action_confidence_scores IS 'Dynamic confidence scores that improve through learning';
    COMMENT ON TABLE action_outcomes IS 'Historical outcomes for training ML algorithms';
    COMMENT ON TABLE action_alternatives IS 'Alternative actions for failed patterns';
    COMMENT ON VIEW effectiveness_trends IS 'Daily trends in action effectiveness for monitoring';
    COMMENT ON VIEW low_confidence_actions IS 'Actions requiring attention due to poor performance';

    -- Create indexes for performance
    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_action_outcomes_learning_query
        ON action_outcomes(action_type, context_hash, executed_at DESC);

    CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_effectiveness_results_learning_query
        ON effectiveness_results(action_type, assessed_at DESC);

    COMMIT;
  006_update_vector_dimensions.sql: |
    -- Update Vector Database Schema for 384-dim Embeddings (Ramalama/20B LLM)
    -- Date: 2025-09-26
    -- Description: Updates action_patterns table to use 384-dimensional embeddings for ramalama provider
    -- Business Requirement: BR-AI-VDB-001 - Support ramalama provider with 20B LLM embeddings

    -- Drop existing vector index (required before altering column)
    DROP INDEX IF EXISTS action_patterns_embedding_idx;

    -- Update embedding column to use 384 dimensions (ramalama/20B LLM standard)
    ALTER TABLE action_patterns
    ALTER COLUMN embedding TYPE vector(384);

    -- Recreate vector similarity index with 384 dimensions
    CREATE INDEX action_patterns_embedding_idx
    ON action_patterns
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 50);

    -- Add comment for documentation
    COMMENT ON COLUMN action_patterns.embedding IS 'Vector embedding (384 dimensions) for ramalama provider with 20B LLM';
  007_add_context_column.sql: |
    -- Add missing context column to action_patterns table
    -- Migration: 007_add_context_column.sql
    -- Required for disaster recovery backup operations (BR-2B: Database schema consistency)

    -- Add context column for storing action context information
    ALTER TABLE action_patterns
    ADD COLUMN IF NOT EXISTS context TEXT;

    -- Create index for context searches
    CREATE INDEX IF NOT EXISTS action_patterns_context_idx ON action_patterns(context);

    -- Update view to include context information
    CREATE OR REPLACE VIEW pattern_analytics_summary AS
    SELECT
        COUNT(*) as total_patterns,
        COUNT(DISTINCT action_type) as unique_action_types,
        COUNT(DISTINCT alert_name) as unique_alert_names,
        COUNT(DISTINCT alert_severity) as unique_severities,
        COUNT(DISTINCT namespace) as unique_namespaces,
        COUNT(DISTINCT resource_type) as unique_resource_types,
        COUNT(DISTINCT context) as unique_contexts,
        AVG((effectiveness_data->>'score')::float) as avg_effectiveness_score,
        COUNT(*) FILTER (WHERE effectiveness_data->>'score' IS NOT NULL) as patterns_with_effectiveness,
        COUNT(*) FILTER (WHERE context IS NOT NULL) as patterns_with_context,
        MIN(created_at) as oldest_pattern,
        MAX(created_at) as newest_pattern
    FROM action_patterns;

    -- Add comment for new column
    COMMENT ON COLUMN action_patterns.context IS 'Textual context information for action pattern execution';
  99-init-vector.sql: ""
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: data-storage-schema-files
  namespace: kubernaut-system
