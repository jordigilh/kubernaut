package models

import (
	"encoding/json"
	"time"
)

// ========================================
// ACTION TRACE MODEL (ADR-033: Multi-Dimensional Success Tracking)
// ðŸ“‹ Authority: migrations/012_adr033_multidimensional_tracking.sql
// ðŸ“‹ Design Decision: DD-012 (Goose Database Migration Management)
// ========================================
//
// ActionTrace represents a single remediation action execution trace.
// This model maps directly to the resource_action_traces PostgreSQL table.
//
// ADR-033: Multi-Dimensional Success Tracking
// Tracks remediation effectiveness across three dimensions:
// 1. Incident Type (PRIMARY) - What problem was being solved
// 2. Playbook (SECONDARY) - Which remediation pattern was used
// 3. Action Type (TERTIARY) - Specific action executed
//
// Business Requirements:
// - BR-STORAGE-001 to BR-STORAGE-020: Complete signal audit trail
// - BR-STORAGE-031-01: Incident-type success rate aggregation
// - BR-STORAGE-031-02: Playbook success rate aggregation
// - BR-STORAGE-031-04: AI execution mode tracking
// - BR-STORAGE-031-05: Multi-dimensional success rate queries
// - BR-REMEDIATION-015: Populate incident type during execution
// - BR-REMEDIATION-016: Populate playbook metadata during execution
// - BR-REMEDIATION-017: Track AI execution mode flags
//
// ========================================

// ActionTrace represents a remediation action execution audit record
type ActionTrace struct {
	// ========================================
	// CORE FIELDS (Pre-ADR-033)
	// ========================================

	// ID is the unique identifier for the audit record (auto-generated by database)
	ID int64 `json:"id" db:"id"`

	// ActionID is the unique identifier for this action execution
	ActionID string `json:"action_id" db:"action_id" validate:"required,max=255"`

	// ActionType is the type of action executed (e.g., "restart_pod", "scale_deployment")
	// NOTE: This is the TERTIARY dimension for success tracking (ADR-033)
	ActionType string `json:"action_type" db:"action_type" validate:"required,max=100"`

	// ActionTimestamp is when the action was executed
	ActionTimestamp time.Time `json:"action_timestamp" db:"action_timestamp" validate:"required"`

	// Status is the execution status (e.g., "completed", "failed", "pending")
	Status string `json:"status" db:"status" validate:"required,oneof=completed failed pending in_progress cancelled"`

	// ResourceType is the Kubernetes resource type (e.g., "Pod", "Deployment")
	ResourceType string `json:"resource_type,omitempty" db:"resource_type" validate:"max=100"`

	// ResourceName is the name of the Kubernetes resource
	ResourceName string `json:"resource_name,omitempty" db:"resource_name" validate:"max=255"`

	// ResourceNamespace is the namespace of the Kubernetes resource
	ResourceNamespace string `json:"resource_namespace,omitempty" db:"resource_namespace" validate:"max=255"`

	// CreatedAt is the timestamp when the audit record was created
	CreatedAt time.Time `json:"created_at" db:"created_at"`

	// UpdatedAt is the timestamp when the audit record was last updated
	UpdatedAt time.Time `json:"updated_at" db:"updated_at"`

	// ========================================
	// ADR-033: DIMENSION 1 - INCIDENT TYPE (PRIMARY)
	// ========================================
	// WHY PRIMARY? AI learns which playbooks work for specific problems
	// Example: "pod-oom-killer" incident â†’ "memory-increase-restart" playbook = 92% success

	// IncidentType is the PRIMARY dimension for success tracking
	// Examples: "pod-oom-killer", "high-cpu-usage", "disk-pressure", "network-timeout"
	// BR-STORAGE-031-01: Used for incident-type success rate aggregation
	// BR-REMEDIATION-015: Populated by RemediationExecutor during execution
	IncidentType string `json:"incident_type" db:"incident_type" validate:"max=100"`

	// AlertName is the original Prometheus alert name (can serve as incident_type proxy)
	// Examples: "PodOOMKilled", "HighCPUUsage", "DiskPressure"
	// BR-STORAGE-031-01: Alternative grouping dimension if incident_type not populated
	AlertName string `json:"alert_name,omitempty" db:"alert_name" validate:"max=255"`

	// IncidentSeverity is the severity level of the incident
	// Values: "critical", "warning", "info"
	// BR-STORAGE-031-01: Used for severity-based filtering in aggregations
	IncidentSeverity string `json:"incident_severity" db:"incident_severity" validate:"oneof=critical warning info ''"`

	// ========================================
	// ADR-033: DIMENSION 2 - REMEDIATION PLAYBOOK (SECONDARY)
	// ========================================
	// WHY SECONDARY? Tracks which remediation patterns work best
	// Example: "disk-cleanup-v2" playbook for "disk-pressure" = 88% success

	// PlaybookID is the SECONDARY dimension for success tracking
	// Examples: "pod-oom-recovery", "disk-cleanup", "network-retry"
	// BR-STORAGE-031-02: Used for playbook success rate aggregation
	// BR-REMEDIATION-016: Populated by RemediationExecutor during execution
	PlaybookID string `json:"playbook_id" db:"playbook_id" validate:"max=64"`

	// PlaybookVersion is the semantic version of the playbook
	// Examples: "v1.0", "v1.2", "v2.0"
	// BR-STORAGE-031-02: Used for version-specific success rate tracking
	// BR-REMEDIATION-016: Populated by Playbook Catalog during selection
	PlaybookVersion string `json:"playbook_version" db:"playbook_version" validate:"max=20"`

	// PlaybookStepNumber is the step position within a multi-step playbook
	// Values: 1, 2, 3, ... (NULL for single-step playbooks)
	// BR-REMEDIATION-016: Used to group all steps in a single playbook execution
	PlaybookStepNumber *int `json:"playbook_step_number,omitempty" db:"playbook_step_number" validate:"omitempty,min=1"`

	// PlaybookExecutionID groups all actions in a single playbook run
	// Same ID is used across all steps in a multi-step playbook
	// BR-REMEDIATION-016: Enables playbook-level success tracking (not step-level)
	PlaybookExecutionID string `json:"playbook_execution_id" db:"playbook_execution_id" validate:"max=64"`

	// ========================================
	// ADR-033: AI EXECUTION MODE (HYBRID MODEL)
	// ========================================
	// WHY? Tracks how AI selected the remediation approach
	// 90-95% catalog selection | 4-9% playbook chaining | <1% manual escalation

	// AISelectedPlaybook indicates AI selected a single playbook from the catalog
	// TRUE for 90-95% of cases (standard catalog-based remediation)
	// BR-STORAGE-031-04: Used to track AI execution mode distribution
	// BR-REMEDIATION-017: Populated by RemediationExecutor based on AI decision
	AISelectedPlaybook bool `json:"ai_selected_playbook" db:"ai_selected_playbook"`

	// AIChainedPlaybooks indicates AI chained multiple catalog playbooks
	// TRUE for 4-9% of cases (complex problems requiring multiple remediation steps)
	// BR-STORAGE-031-04: Used to identify advanced AI composition scenarios
	// BR-REMEDIATION-017: Populated when AI composes multi-playbook solution
	AIChainedPlaybooks bool `json:"ai_chained_playbooks" db:"ai_chained_playbooks"`

	// AIManualEscalation indicates AI escalated to human operator
	// TRUE for <1% of cases (novel problems requiring human expertise)
	// BR-STORAGE-031-04: Used to identify cases where AI couldn't remediate
	// BR-REMEDIATION-017: Populated when AI determines manual intervention needed
	AIManualEscalation bool `json:"ai_manual_escalation" db:"ai_manual_escalation"`

	// AIPlaybookCustomization stores parameters customized by AI for this specific incident
	// Format: JSON object with parameter overrides
	// Example: {"timeout": "300s", "retry_count": 5, "resource_limits": {"memory": "2Gi"}}
	// BR-STORAGE-031-04: Used to analyze AI parameter tuning effectiveness
	// BR-REMEDIATION-017: Populated when AI customizes playbook parameters
	AIPlaybookCustomization json.RawMessage `json:"ai_playbook_customization,omitempty" db:"ai_playbook_customization"`
}

// TableName returns the PostgreSQL table name for this model
func (a *ActionTrace) TableName() string {
	return "resource_action_traces"
}

// Validate performs business logic validation on the ActionTrace struct
func (a *ActionTrace) Validate() error {
	// Validation is handled by struct tags and the validator package
	// Additional business logic validation can be added here if needed
	return nil
}

// ========================================
// ADR-033: HELPER METHODS FOR SUCCESS TRACKING
// ========================================

// IsSuccessful returns true if the action completed successfully
// Used for success rate calculations (BR-STORAGE-031-01, BR-STORAGE-031-02)
func (a *ActionTrace) IsSuccessful() bool {
	return a.Status == "completed"
}

// IsFailed returns true if the action failed
// Used for failure rate calculations and error analysis
func (a *ActionTrace) IsFailed() bool {
	return a.Status == "failed"
}

// HasIncidentContext returns true if incident-type tracking fields are populated
// BR-STORAGE-031-01: Determines if record can be used for incident-type aggregation
func (a *ActionTrace) HasIncidentContext() bool {
	return a.IncidentType != "" || a.AlertName != ""
}

// HasPlaybookContext returns true if playbook tracking fields are populated
// BR-STORAGE-031-02: Determines if record can be used for playbook aggregation
func (a *ActionTrace) HasPlaybookContext() bool {
	return a.PlaybookID != "" && a.PlaybookVersion != ""
}

// GetAIExecutionMode returns a human-readable AI execution mode
// BR-STORAGE-031-04: Used for reporting and analytics dashboards
func (a *ActionTrace) GetAIExecutionMode() string {
	if a.AIManualEscalation {
		return "manual_escalation"
	}
	if a.AIChainedPlaybooks {
		return "chained_playbooks"
	}
	if a.AISelectedPlaybook {
		return "catalog_selection"
	}
	return "unknown"
}

// GetEffectiveIncidentType returns the incident type, falling back to alert name
// BR-STORAGE-031-01: Provides backward compatibility for records without incident_type
func (a *ActionTrace) GetEffectiveIncidentType() string {
	if a.IncidentType != "" {
		return a.IncidentType
	}
	return a.AlertName
}
