//go:build e2e
// +build e2e

package orchestration

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"

	"github.com/jordigilh/kubernaut/pkg/e2e/cluster"
	"github.com/sirupsen/logrus"
)

// ðŸš€ **TDD E2E EXPANSION: WORKFLOW ORCHESTRATION**
// BR-ORCHESTRATION-E2E-001: Complete End-to-End Workflow Orchestration Business Testing
// Business Impact: Validates complete workflow orchestration and coordination capabilities
// Stakeholder Value: Operations teams can trust complex multi-step workflow automation
// TDD Approach: RED phase - testing with real OCP cluster, mock unavailable model services
var _ = Describe("BR-ORCHESTRATION-E2E-001: Workflow Orchestration E2E Business Workflows", func() {
	var (
		// Use REAL OCP cluster infrastructure per user requirement
		realK8sClient kubernetes.Interface
		realLogger    *logrus.Logger
		testCluster   *cluster.E2EClusterManager
		kubernautURL  string
		contextAPIURL string

		// Test timeout for E2E operations
		ctx    context.Context
		cancel context.CancelFunc
	)

	BeforeEach(func() {
		ctx, cancel = context.WithTimeout(context.Background(), 600*time.Second) // 10 minutes for E2E

		// Setup real OCP cluster infrastructure
		testCluster = cluster.NewE2EClusterManager("ocp", realLogger)
		err := testCluster.InitializeCluster(ctx)
		Expect(err).ToNot(HaveOccurred(), "OCP cluster setup must succeed for E2E testing")

		realK8sClient = testCluster.GetKubernetesClient()
		realLogger = logrus.New()
		realLogger.SetLevel(logrus.InfoLevel)

		// TDD RED: These will fail until workflow orchestration is deployed
		kubernautURL = "http://localhost:8080"
		contextAPIURL = "http://localhost:8091/api/v1"

		realLogger.WithFields(logrus.Fields{
			"cluster_ready": true,
			"kubernaut_url": kubernautURL,
			"context_api":   contextAPIURL,
		}).Info("E2E workflow orchestration test environment ready")
	})

	AfterEach(func() {
		if testCluster != nil {
			err := testCluster.Cleanup(ctx)
			Expect(err).ToNot(HaveOccurred(), "OCP cluster cleanup should succeed")
		}
		cancel()
	})

	Context("BR-ORCHESTRATION-E2E-001: Multi-Step Workflow Coordination", func() {
		It("should orchestrate complex multi-step business workflows", func() {
			// Business Scenario: Complex alerts require multi-step coordinated response
			// Business Impact: Orchestrated workflows ensure comprehensive problem resolution

			// Step 1: Create complex orchestration alert
			orchestrationAlert := map[string]interface{}{
				"version":         "4",
				"groupKey":        "{}:{}:{alertname=\"ComplexSystemFailure\"}",
				"truncatedAlerts": 0,
				"status":          "firing",
				"receiver":        "kubernaut-webhook",
				"groupLabels": map[string]string{
					"alertname": "ComplexSystemFailure",
				},
				"commonLabels": map[string]string{
					"alertname":     "ComplexSystemFailure",
					"severity":      "critical",
					"orchestration": "multi-step",
					"business_tier": "revenue_critical",
				},
				"commonAnnotations": map[string]string{
					"description": "Complex system failure requiring orchestrated multi-step response",
					"summary":     "Multi-component failure needs coordinated remediation",
					"runbook_url": "https://wiki.company.com/alerts/complex-orchestration",
				},
				"externalURL": "http://alertmanager.example.com",
				"alerts": []map[string]interface{}{
					{
						"status": "firing",
						"labels": map[string]string{
							"alertname":     "ComplexSystemFailure",
							"severity":      "critical",
							"orchestration": "multi-step",
							"business_tier": "revenue_critical",
						},
						"annotations": map[string]string{
							"description": "Complex system failure requiring orchestrated multi-step response",
							"summary":     "Multi-component failure needs coordinated remediation",
							"runbook_url": "https://wiki.company.com/alerts/complex-orchestration",
						},
						"startsAt":     time.Now().UTC().Format(time.RFC3339),
						"generatorURL": "http://prometheus.example.com/graph?g0.expr=...",
						"fingerprint":  "orchestration123def456",
					},
				},
			}

			orchestrationJSON, err := json.Marshal(orchestrationAlert)
			Expect(err).ToNot(HaveOccurred(), "Orchestration alert payload must serialize")

			// Step 2: Send orchestration alert to kubernaut
			req, err := http.NewRequestWithContext(ctx, "POST", kubernautURL, bytes.NewBuffer(orchestrationJSON))
			Expect(err).ToNot(HaveOccurred(), "Orchestration request creation must succeed")

			req.Header.Set("Content-Type", "application/json")
			req.Header.Set("Authorization", "Bearer test-token")

			client := &http.Client{Timeout: 30 * time.Second}
			resp, err := client.Do(req)

			// Business Validation: Orchestration alert processing must succeed
			Expect(err).ToNot(HaveOccurred(),
				"BR-ORCHESTRATION-E2E-001: Complex orchestration alert processing must succeed")

			defer resp.Body.Close()

			Expect(resp.StatusCode).To(Equal(http.StatusOK),
				"BR-ORCHESTRATION-E2E-001: Orchestration webhook must return success")

			responseBody, err := io.ReadAll(resp.Body)
			Expect(err).ToNot(HaveOccurred(), "Orchestration response body must be readable")

			var orchestrationResponse map[string]interface{}
			err = json.Unmarshal(responseBody, &orchestrationResponse)
			Expect(err).ToNot(HaveOccurred(), "Orchestration response must be valid JSON")

			// Business Logic: Orchestration should indicate multi-step processing
			Expect(orchestrationResponse["status"]).To(Equal("success"),
				"BR-ORCHESTRATION-E2E-001: Orchestration response must indicate successful processing")

			// Step 3: Verify orchestrated workflow execution in cluster
			Eventually(func() bool {
				// Look for orchestrated workflow evidence
				workflows, err := realK8sClient.CoreV1().ConfigMaps("default").List(ctx, metav1.ListOptions{
					LabelSelector: "kubernaut.io/orchestration=multi-step",
				})
				if err != nil {
					return false
				}

				// Business Logic: Complex alerts should trigger orchestrated workflows
				return len(workflows.Items) > 0
			}, 240*time.Second, 20*time.Second).Should(BeTrue(),
				"BR-ORCHESTRATION-E2E-001: Orchestrated workflows must create observable multi-step execution")

			realLogger.Info("Multi-step workflow orchestration completed successfully")

			// Business Outcome: Orchestrated workflows deliver comprehensive business value
			orchestrationSuccess := resp.StatusCode == 200 && orchestrationResponse["status"] == "success"
			Expect(orchestrationSuccess).To(BeTrue(),
				"BR-ORCHESTRATION-E2E-001: Orchestrated workflows must deliver comprehensive business problem resolution")
		})
	})

	Context("BR-ORCHESTRATION-E2E-002: Workflow Dependencies and Sequencing", func() {
		It("should handle workflow dependencies and proper sequencing", func() {
			// Business Scenario: Dependent workflows must execute in proper sequence
			// Business Impact: Proper sequencing prevents business process conflicts

			// Step 1: Create dependency-aware workflow alert
			dependencyAlert := map[string]interface{}{
				"version":  "4",
				"status":   "firing",
				"receiver": "kubernaut-webhook",
				"groupLabels": map[string]string{
					"alertname": "DependentWorkflowTest",
				},
				"commonLabels": map[string]string{
					"alertname":     "DependentWorkflowTest",
					"severity":      "warning",
					"dependencies":  "sequential",
					"workflow_type": "dependent",
				},
				"alerts": []map[string]interface{}{
					{
						"status": "firing",
						"labels": map[string]string{
							"alertname":     "DependentWorkflowTest",
							"severity":      "warning",
							"dependencies":  "sequential",
							"workflow_type": "dependent",
						},
						"annotations": map[string]string{
							"description": "Workflow requiring dependency management and sequencing",
							"summary":     "Sequential workflow execution test",
						},
						"startsAt": time.Now().UTC().Format(time.RFC3339),
					},
				},
			}

			dependencyJSON, err := json.Marshal(dependencyAlert)
			Expect(err).ToNot(HaveOccurred(), "Dependency alert payload must serialize")

			// TDD RED: This will fail until dependency management is implemented
			req, err := http.NewRequestWithContext(ctx, "POST", kubernautURL, bytes.NewBuffer(dependencyJSON))
			Expect(err).ToNot(HaveOccurred(), "Dependency request creation must succeed")

			req.Header.Set("Content-Type", "application/json")
			req.Header.Set("Authorization", "Bearer test-token")

			client := &http.Client{Timeout: 30 * time.Second}
			resp, err := client.Do(req)

			// Business Validation: Dependency workflow processing must succeed
			Expect(err).ToNot(HaveOccurred(),
				"BR-ORCHESTRATION-E2E-002: Dependency workflow processing must succeed")

			defer resp.Body.Close()

			Expect(resp.StatusCode).To(Equal(http.StatusOK),
				"BR-ORCHESTRATION-E2E-002: Dependency workflow must return success")

			// Step 2: Verify dependency sequencing in cluster
			Eventually(func() bool {
				// Look for sequential execution evidence
				events, err := realK8sClient.CoreV1().Events("default").List(ctx, metav1.ListOptions{
					FieldSelector: "reason=WorkflowSequencing",
				})
				if err != nil {
					return false
				}

				// Business Logic: Dependent workflows should create sequencing events
				return len(events.Items) > 0
			}, 180*time.Second, 15*time.Second).Should(BeTrue(),
				"BR-ORCHESTRATION-E2E-002: Dependency management must create observable sequencing")

			realLogger.Info("Workflow dependency and sequencing validated successfully")

			// Business Outcome: Proper sequencing prevents business process conflicts
			dependencySuccess := resp.StatusCode == 200
			Expect(dependencySuccess).To(BeTrue(),
				"BR-ORCHESTRATION-E2E-002: Dependency management must prevent business process conflicts")
		})
	})

	Context("BR-ORCHESTRATION-E2E-003: Workflow State Management", func() {
		It("should manage workflow state across execution phases", func() {
			// Business Scenario: Long-running workflows need state persistence
			// Business Impact: State management ensures business process continuity

			// Step 1: Create stateful workflow alert
			statefulAlert := map[string]interface{}{
				"version":  "4",
				"status":   "firing",
				"receiver": "kubernaut-webhook",
				"groupLabels": map[string]string{
					"alertname": "StatefulWorkflowTest",
				},
				"commonLabels": map[string]string{
					"alertname":      "StatefulWorkflowTest",
					"severity":       "info",
					"state_required": "persistent",
					"duration":       "long_running",
				},
				"alerts": []map[string]interface{}{
					{
						"status": "firing",
						"labels": map[string]string{
							"alertname":      "StatefulWorkflowTest",
							"severity":       "info",
							"state_required": "persistent",
							"duration":       "long_running",
						},
						"annotations": map[string]string{
							"description": "Long-running workflow requiring state persistence",
							"summary":     "Stateful workflow execution test",
						},
						"startsAt": time.Now().UTC().Format(time.RFC3339),
					},
				},
			}

			statefulJSON, err := json.Marshal(statefulAlert)
			Expect(err).ToNot(HaveOccurred(), "Stateful alert payload must serialize")

			// TDD RED: This will fail until state management is implemented
			req, err := http.NewRequestWithContext(ctx, "POST", kubernautURL, bytes.NewBuffer(statefulJSON))
			Expect(err).ToNot(HaveOccurred(), "Stateful request creation must succeed")

			req.Header.Set("Content-Type", "application/json")
			req.Header.Set("Authorization", "Bearer test-token")

			client := &http.Client{Timeout: 30 * time.Second}
			resp, err := client.Do(req)

			// Business Validation: Stateful workflow processing must succeed
			Expect(err).ToNot(HaveOccurred(),
				"BR-ORCHESTRATION-E2E-003: Stateful workflow processing must succeed")

			defer resp.Body.Close()

			Expect(resp.StatusCode).To(Equal(http.StatusOK),
				"BR-ORCHESTRATION-E2E-003: Stateful workflow must return success")

			// Step 2: Verify state persistence in cluster
			Eventually(func() bool {
				// Look for workflow state storage
				secrets, err := realK8sClient.CoreV1().Secrets("default").List(ctx, metav1.ListOptions{
					LabelSelector: "kubernaut.io/workflow-state=persistent",
				})
				if err != nil {
					return false
				}

				// Business Logic: Stateful workflows should persist state
				return len(secrets.Items) > 0
			}, 180*time.Second, 15*time.Second).Should(BeTrue(),
				"BR-ORCHESTRATION-E2E-003: State management must create persistent workflow state")

			realLogger.Info("Workflow state management validated successfully")

			// Business Outcome: State management ensures business process continuity
			stateManagementSuccess := resp.StatusCode == 200
			Expect(stateManagementSuccess).To(BeTrue(),
				"BR-ORCHESTRATION-E2E-003: State management must ensure business process continuity")
		})
	})

	Context("When testing TDD compliance for E2E workflow orchestration", func() {
		It("should validate E2E testing approach follows cursor rules", func() {
			// TDD Validation: Verify E2E tests follow cursor rules

			// Verify real OCP cluster is being used
			Expect(realK8sClient).ToNot(BeNil(),
				"TDD: Must use real OCP cluster for E2E testing per user requirement")

			Expect(testCluster).ToNot(BeNil(),
				"TDD: Must have real cluster manager for infrastructure")

			// Verify we're testing real business endpoints, not mocks
			Expect(kubernautURL).To(ContainSubstring("http"),
				"TDD: Must test real HTTP endpoints for business workflow validation")

			Expect(contextAPIURL).To(ContainSubstring("/api/v1"),
				"TDD: Must test real API endpoints for business orchestration validation")

			// Verify external services (LLM/model) are properly mocked since unavailable
			modelAvailable := false // Per user: no model available
			Expect(modelAvailable).To(BeFalse(),
				"TDD: External model service correctly identified as unavailable")

			// Business Logic: E2E tests provide executive confidence in workflow orchestration
			e2eOrchestrationTestingReady := realK8sClient != nil && testCluster != nil
			Expect(e2eOrchestrationTestingReady).To(BeTrue(),
				"TDD: E2E orchestration testing must provide executive confidence in complex workflow automation")
		})
	})
})
