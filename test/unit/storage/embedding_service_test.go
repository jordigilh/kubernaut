package storage

import (
	"context"
	"fmt"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/storage/vector"
	. "github.com/jordigilh/kubernaut/pkg/testutil/mocks"
)

// Suite structure moved to storage_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Local Embedding Service Unit Tests", func() {
	var (
		embeddingService *vector.LocalEmbeddingService
		logger           *logrus.Logger
		ctx              context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)
		embeddingService = vector.NewLocalEmbeddingService(384, logger)
		ctx = context.Background()
	})

	Context("Service Creation and Configuration", func() {
		It("should create service with specified dimension", func() {
			dimension := 512
			service := vector.NewLocalEmbeddingService(dimension, logger)

			Expect(service).ToNot(BeNil(), "Should create service successfully")
			Expect(service.GetEmbeddingDimension()).To(Equal(dimension), "Should use specified dimension")
		})

		It("should use default dimension for invalid input", func() {
			service := vector.NewLocalEmbeddingService(0, logger)

			Expect(service.GetEmbeddingDimension()).To(Equal(384), "Should use default dimension for zero input")

			service = vector.NewLocalEmbeddingService(-10, logger)
			Expect(service.GetEmbeddingDimension()).To(Equal(384), "Should use default dimension for negative input")
		})

		It("should initialize vocabulary during creation", func() {
			service := vector.NewLocalEmbeddingService(100, logger)

			// Test that vocabulary is working by generating embeddings for known terms
			embedding1, err := service.GenerateTextEmbedding(ctx, "pod deployment")
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := service.GenerateTextEmbedding(ctx, "random_unknown_terms_xyz")
			Expect(err).ToNot(HaveOccurred())

			// Known terms should produce different embeddings than unknown terms
			Expect(embedding1).ToNot(Equal(embedding2), "Known and unknown terms should produce different embeddings")
		})
	})

	Context("Text Embedding Generation", func() {
		It("should generate embedding with correct dimensions", func() {
			text := "Critical pod memory usage alert"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should generate normalized embeddings", func() {
			text := "High CPU usage in production namespace"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Calculate L2 norm
			var sumSquares float64
			for _, val := range embedding {
				sumSquares += val * val
			}
			norm := sumSquares // Should be close to 1.0 for normalized vector

			Expect(norm).To(BeNumerically("~", 1.0, 0.1), "Embedding should be normalized")
		})

		It("should handle empty text input", func() {
			embedding, err := embeddingService.GenerateTextEmbedding(ctx, "")
			Expect(err).ToNot(HaveOccurred(), "Should handle empty text without error")
			Expect(len(embedding)).To(Equal(384), "Should return embedding with correct dimension")

			// Should return zero embedding for empty input
			allZero := true
			for _, val := range embedding {
				if val != 0.0 {
					allZero = false
					break
				}
			}
			Expect(allZero).To(BeTrue(), "Empty text should produce zero embedding")
		})

		It("should generate consistent embeddings for same input", func() {
			text := "Memory alert in production deployment"

			embedding1, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).To(Equal(embedding2), "Should generate consistent embeddings for same input")
		})

		It("should generate different embeddings for different inputs", func() {
			text1 := "CPU usage alert"
			text2 := "Memory pressure warning"

			embedding1, err := embeddingService.GenerateTextEmbedding(ctx, text1)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateTextEmbedding(ctx, text2)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).ToNot(Equal(embedding2), "Different texts should produce different embeddings")
		})

		It("should handle Kubernetes-specific terminology", func() {
			kubernetesText := "pod deployment service ingress configmap secret namespace"
			regularText := "random text without kubernetes terms"

			k8sEmbedding, err := embeddingService.GenerateTextEmbedding(ctx, kubernetesText)
			Expect(err).ToNot(HaveOccurred())

			regularEmbedding, err := embeddingService.GenerateTextEmbedding(ctx, regularText)
			Expect(err).ToNot(HaveOccurred())

			Expect(k8sEmbedding).ToNot(Equal(regularEmbedding),
				"Kubernetes-specific terms should be handled differently")
		})

		It("should handle special characters and punctuation", func() {
			specialText := "alert: memory-usage > 80% in prod/namespace (critical)!"

			embedding, err := embeddingService.GenerateTextEmbedding(ctx, specialText)
			Expect(err).ToNot(HaveOccurred(), "Should handle special characters without error")
			Expect(len(embedding)).To(Equal(384), "Should produce correct dimension despite special characters")
		})
	})

	Context("Action Embedding Generation", func() {
		It("should generate embedding from action type and parameters", func() {
			actionType := "scale"
			parameters := map[string]interface{}{
				"replicas":   5,
				"target_cpu": "500m",
				"enabled":    true,
				"timeout":    30.5,
			}

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should generate action embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should handle various parameter types", func() {
			actionType := "restart"
			parameters := map[string]interface{}{
				"string_param":  "value",
				"int_param":     42,
				"int32_param":   int32(123),
				"int64_param":   int64(456),
				"float32_param": float32(1.5),
				"float64_param": 2.7,
				"bool_param":    true,
				"slice_param":   []string{"ignored"},                     // Should be ignored
				"map_param":     map[string]string{"ignored": "ignored"}, // Should be ignored
			}

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should handle various parameter types")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should generate different embeddings for different actions", func() {
			parameters := map[string]interface{}{"replicas": 3}

			scaleEmbedding, err := embeddingService.GenerateActionEmbedding(ctx, "scale", parameters)
			Expect(err).ToNot(HaveOccurred())

			restartEmbedding, err := embeddingService.GenerateActionEmbedding(ctx, "restart", parameters)
			Expect(err).ToNot(HaveOccurred())

			Expect(scaleEmbedding).ToNot(Equal(restartEmbedding),
				"Different action types should produce different embeddings")
		})

		It("should handle empty parameters", func() {
			actionType := "cleanup"

			embedding, err := embeddingService.GenerateActionEmbedding(ctx, actionType, nil)
			Expect(err).ToNot(HaveOccurred(), "Should handle nil parameters")

			embedding2, err := embeddingService.GenerateActionEmbedding(ctx, actionType, map[string]interface{}{})
			Expect(err).ToNot(HaveOccurred(), "Should handle empty parameters")

			Expect(embedding).To(Equal(embedding2), "Nil and empty parameters should produce same result")
		})
	})

	Context("Context Embedding Generation", func() {
		It("should generate embedding from labels and metadata", func() {
			labels := map[string]string{
				"app":     "web-server",
				"version": "v1.2.3",
				"tier":    "production",
			}

			metadata := map[string]interface{}{
				"cpu_usage": 75.5,
				"memory_mb": 512,
				"healthy":   true,
			}

			embedding, err := embeddingService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should generate context embedding without error")
			Expect(len(embedding)).To(Equal(384), "Should generate embedding with correct dimension")
		})

		It("should handle empty labels and metadata", func() {
			embedding1, err := embeddingService.GenerateContextEmbedding(ctx, nil, nil)
			Expect(err).ToNot(HaveOccurred(), "Should handle nil inputs")

			embedding2, err := embeddingService.GenerateContextEmbedding(ctx, map[string]string{}, map[string]interface{}{})
			Expect(err).ToNot(HaveOccurred(), "Should handle empty inputs")

			Expect(embedding1).To(Equal(embedding2), "Nil and empty inputs should produce same result")
		})

		It("should generate different embeddings for different contexts", func() {
			labels1 := map[string]string{"app": "frontend"}
			labels2 := map[string]string{"app": "backend"}

			embedding1, err := embeddingService.GenerateContextEmbedding(ctx, labels1, nil)
			Expect(err).ToNot(HaveOccurred())

			embedding2, err := embeddingService.GenerateContextEmbedding(ctx, labels2, nil)
			Expect(err).ToNot(HaveOccurred())

			Expect(embedding1).ToNot(Equal(embedding2), "Different contexts should produce different embeddings")
		})
	})

	Context("Embedding Combination", func() {
		var (
			embedding1, embedding2, embedding3 []float64
		)

		BeforeEach(func() {
			dimension := embeddingService.GetEmbeddingDimension()

			embedding1 = make([]float64, dimension)
			embedding2 = make([]float64, dimension)
			embedding3 = make([]float64, dimension)

			// Create test embeddings with known values
			for i := 0; i < dimension; i++ {
				embedding1[i] = 1.0
				embedding2[i] = 2.0
				embedding3[i] = 3.0
			}
		})

		It("should return zero embedding for no input", func() {
			combined := embeddingService.CombineEmbeddings()

			Expect(len(combined)).To(Equal(384), "Should return embedding with correct dimension")

			allZero := true
			for _, val := range combined {
				if val != 0.0 {
					allZero = false
					break
				}
			}
			Expect(allZero).To(BeTrue(), "Should return zero embedding for no input")
		})

		It("should return same embedding for single input", func() {
			combined := embeddingService.CombineEmbeddings(embedding1)

			Expect(combined).To(Equal(embedding1), "Should return same embedding for single input")
		})

		It("should combine multiple embeddings using weighted average", func() {
			combined := embeddingService.CombineEmbeddings(embedding1, embedding2)

			Expect(len(combined)).To(Equal(384), "Combined embedding should have correct dimension")

			// The result will be normalized, so we check proportions rather than exact values
			for i := 0; i < len(combined); i++ {
				Expect(combined[i]).To(BeNumerically(">", 0), "Combined values should be positive")
			}
		})

		It("should handle dimension mismatches gracefully", func() {
			wrongDimension := []float64{1.0, 2.0} // Wrong dimension

			combined := embeddingService.CombineEmbeddings(embedding1, wrongDimension, embedding2)

			Expect(len(combined)).To(Equal(384), "Should return correct dimension despite mismatch")
			// Should skip the mismatched embedding and combine the valid ones
		})

		It("should normalize the combined result", func() {
			combined := embeddingService.CombineEmbeddings(embedding1, embedding2, embedding3)

			// Calculate L2 norm
			var sumSquares float64
			for _, val := range combined {
				sumSquares += val * val
			}
			norm := sumSquares

			Expect(norm).To(BeNumerically("~", 1.0, 0.1), "Combined embedding should be normalized")
		})
	})
})

var _ = Describe("Hybrid Embedding Service Unit Tests", func() {
	var (
		localService    *vector.LocalEmbeddingService
		externalService *MockEmbeddingGenerator
		hybridService   *vector.HybridEmbeddingService
		logger          *logrus.Logger
		ctx             context.Context
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)

		localService = vector.NewLocalEmbeddingService(384, logger)
		externalService = NewMockEmbeddingGenerator(384)
		hybridService = vector.NewHybridEmbeddingService(localService, externalService, logger)
		ctx = context.Background()
	})

	Context("Service Creation and Configuration", func() {
		It("should create hybrid service with local and external components", func() {
			Expect(hybridService).ToNot(BeNil(), "Should create hybrid service successfully")
			Expect(hybridService.GetEmbeddingDimension()).To(Equal(384), "Should return correct dimension")
		})

		It("should default to local service initially", func() {
			text := "test embedding"

			// Generate with hybrid service
			hybridEmbedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			// Generate with local service directly
			localEmbedding, err := localService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred())

			Expect(hybridEmbedding).To(Equal(localEmbedding), "Should use local service by default")
		})

		It("should allow switching between local and external services", func() {
			hybridService.SetUseLocal(false) // Switch to external

			dimension := hybridService.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return external service dimension")

			hybridService.SetUseLocal(true) // Switch back to local
			dimension = hybridService.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return local service dimension")
		})
	})

	Context("Local Service Mode", func() {
		BeforeEach(func() {
			hybridService.SetUseLocal(true)
		})

		It("should use local service when configured", func() {
			text := "kubernetes pod alert"

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding via local service")
			Expect(len(embedding)).To(Equal(384), "Should return embedding with correct dimension")

			// Verify external service was not called
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(Equal(0), "Should not call external service when using local")
		})

		It("should use local service for action embeddings", func() {
			actionType := "scale"
			parameters := map[string]interface{}{"replicas": 5}

			embedding, err := hybridService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should generate action embedding via local service")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should use local service for context embeddings", func() {
			labels := map[string]string{"app": "test"}
			metadata := map[string]interface{}{"cpu": 50}

			embedding, err := hybridService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should generate context embedding via local service")
			Expect(len(embedding)).To(Equal(384))
		})
	})

	Context("External Service Mode", func() {
		BeforeEach(func() {
			hybridService.SetUseLocal(false)
		})

		It("should use external service when configured", func() {
			text := "external service test"
			expectedEmbedding := []float64{0.5, 0.6, 0.7}
			externalService.SetTextEmbeddingResult(expectedEmbedding, nil)

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should generate embedding via external service")
			Expect(embedding).To(Equal(expectedEmbedding), "Should return external service result")

			// Verify external service was called
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(Equal(1), "Should call external service")
			Expect(externalCalls[0].Text).To(Equal(text), "Should pass correct text to external service")
		})

		It("should fallback to local service when external service fails", func() {
			text := "fallback test"
			externalService.SetTextEmbeddingResult(nil, fmt.Errorf("external service error"))

			embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service on external error")
			Expect(len(embedding)).To(Equal(384), "Should return valid embedding from local fallback")

			// Verify both services were called
			externalCalls := externalService.GetTextEmbeddingCalls()
			Expect(len(externalCalls)).To(Equal(1), "Should attempt external service first")
		})

		It("should fallback for action embeddings", func() {
			actionType := "restart"
			parameters := map[string]interface{}{"timeout": 30}

			externalService.SetActionEmbeddingResult(nil, fmt.Errorf("action embedding error"))

			embedding, err := hybridService.GenerateActionEmbedding(ctx, actionType, parameters)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service for action embedding error")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should fallback for context embeddings", func() {
			labels := map[string]string{"tier": "production"}
			metadata := map[string]interface{}{"memory": 1024}

			externalService.SetContextEmbeddingResult(nil, fmt.Errorf("context embedding error"))

			embedding, err := hybridService.GenerateContextEmbedding(ctx, labels, metadata)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local service for context embedding error")
			Expect(len(embedding)).To(Equal(384))
		})
	})

	Context("External Service Not Available", func() {
		var hybridServiceNoExternal *vector.HybridEmbeddingService

		BeforeEach(func() {
			hybridServiceNoExternal = vector.NewHybridEmbeddingService(localService, nil, logger)
			hybridServiceNoExternal.SetUseLocal(false) // Try to use external, but it's nil
		})

		It("should fallback to local service when external service is nil", func() {
			text := "no external service"

			embedding, err := hybridServiceNoExternal.GenerateTextEmbedding(ctx, text)
			Expect(err).ToNot(HaveOccurred(), "Should fallback to local when external is nil")
			Expect(len(embedding)).To(Equal(384))
		})

		It("should return local service dimension when external is nil", func() {
			dimension := hybridServiceNoExternal.GetEmbeddingDimension()
			Expect(dimension).To(Equal(384), "Should return local dimension when external is nil")
		})
	})

	Context("Embedding Combination in Hybrid Service", func() {
		It("should delegate combination to local service", func() {
			embedding1 := make([]float64, 384)
			embedding2 := make([]float64, 384)

			// Fill with test values
			for i := range embedding1 {
				embedding1[i] = 1.0
				embedding2[i] = 2.0
			}

			combined := hybridService.CombineEmbeddings(embedding1, embedding2)

			// Should delegate to local service
			localCombined := localService.CombineEmbeddings(embedding1, embedding2)
			Expect(combined).To(Equal(localCombined), "Should delegate combination to local service")
		})
	})

	Context("Service State Management", func() {
		It("should track service mode changes", func() {
			// Start in local mode
			hybridService.SetUseLocal(true)
			dimension1 := hybridService.GetEmbeddingDimension()

			// Switch to external mode
			hybridService.SetUseLocal(false)
			dimension2 := hybridService.GetEmbeddingDimension()

			// Both should return same dimension in this test case, but behavior might differ
			Expect(dimension1).To(Equal(dimension2), "Dimension should be consistent")
		})

		It("should handle rapid mode switching", func() {
			text := "mode switching test"

			// Switch modes rapidly and ensure consistency
			for i := 0; i < 10; i++ {
				hybridService.SetUseLocal(i%2 == 0)

				embedding, err := hybridService.GenerateTextEmbedding(ctx, text)
				Expect(err).ToNot(HaveOccurred(), "Should handle rapid mode switching")
				Expect(len(embedding)).To(Equal(384), "Should maintain consistent dimension")
			}
		})
	})
})
