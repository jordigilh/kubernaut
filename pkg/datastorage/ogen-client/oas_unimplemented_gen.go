// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"

	ht "github.com/ogen-go/ogen/http"
)

// UnimplementedHandler is no-op Handler which returns http.ErrNotImplemented.
type UnimplementedHandler struct{}

var _ Handler = UnimplementedHandler{}

// CreateAuditEvent implements createAuditEvent operation.
//
// Persists a unified audit event to the audit_events table (ADR-034).
// **Business Requirement**: BR-STORAGE-033 (Unified audit trail)
// **Behavior**:
// - Success: Returns 201 Created with event_id
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009).
//
// POST /api/v1/audit/events
func (UnimplementedHandler) CreateAuditEvent(ctx context.Context, req *AuditEventRequest) (r CreateAuditEventRes, _ error) {
	return r, ht.ErrNotImplemented
}

// CreateAuditEventsBatch implements createAuditEventsBatch operation.
//
// Write multiple audit events in a single request.
//
// POST /api/v1/audit/events/batch
func (UnimplementedHandler) CreateAuditEventsBatch(ctx context.Context, req []AuditEventRequest) (r *BatchAuditEventResponse, _ error) {
	return r, ht.ErrNotImplemented
}

// CreateNotificationAudit implements createNotificationAudit operation.
//
// Persists a notification delivery attempt audit record.
// **Business Requirement**: BR-STORAGE-001 (Notification audit persistence)
// **Behavior**:
// - Success: Returns 201 Created with created record
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Duplicate: Returns 409 Conflict (RFC 7807)
// - Database Error: Returns 202 Accepted (DLQ fallback, DD-009)
// **Metrics Emitted** (GAP-10):
// - `datastorage_audit_traces_total{service="notification", status="success|failure|dlq_fallback"}`
// - `datastorage_audit_lag_seconds{service="notification"}`
// - `datastorage_write_duration_seconds{table="notification_audit"}`
// - `datastorage_validation_failures_total{field="...", reason="..."}`.
//
// POST /api/v1/audit/notifications
func (UnimplementedHandler) CreateNotificationAudit(ctx context.Context, req *NotificationAudit) (r CreateNotificationAuditRes, _ error) {
	return r, ht.ErrNotImplemented
}

// CreateWorkflow implements createWorkflow operation.
//
// Register a new workflow by providing an OCI image pullspec.
// Data Storage pulls the image, extracts /workflow-schema.yaml (ADR-043),
// validates the schema, and populates all catalog fields from it.
// **Business Requirement**: BR-WORKFLOW-017-001 (OCI-based workflow registration)
// **Design Decision**: DD-WORKFLOW-017 (Workflow Lifecycle Component Interactions).
//
// POST /api/v1/workflows
func (UnimplementedHandler) CreateWorkflow(ctx context.Context, req *CreateWorkflowFromOCIRequest) (r CreateWorkflowRes, _ error) {
	return r, ht.ErrNotImplemented
}

// DisableWorkflow implements disableWorkflow operation.
//
// Convenience endpoint to disable a workflow (soft delete).
// Sets status to 'disabled' with timestamp and reason.
// **Design Decision**: DD-WORKFLOW-012 (Convenience endpoint for soft-delete).
//
// PATCH /api/v1/workflows/{workflow_id}/disable
func (UnimplementedHandler) DisableWorkflow(ctx context.Context, req OptWorkflowDisableRequest, params DisableWorkflowParams) (r DisableWorkflowRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ExportAuditEvents implements exportAuditEvents operation.
//
// Exports audit events matching the specified filters with cryptographic signatures
// for tamper detection and compliance verification.
// **Business Requirement**: BR-AUDIT-007 (Audit Export)
// **SOC2 Requirements**: CC8.1 (Audit Export), AU-9 (Audit Protection)
// **Behavior**:
// - Success: Returns 200 OK with signed export (JSON or CSV)
// - Validation Error: Returns 400 Bad Request (invalid date range, etc.)
// - Unauthorized: Returns 401 if X-Auth-Request-User header missing
// - Too Many Records: Returns 413 Payload Too Large (>10,000 events, use pagination)
// **Authorization**: Requires X-Auth-Request-User header (oauth-proxy authenticated)
// **Export Formats**:
// - JSON: Complete event data with hash chain verification
// - CSV: Flattened tabular format for spreadsheet analysis
// **Hash Chain Verification**:
// - Each export includes hash chain integrity status
// - Tampered events flagged with `hash_chain_valid: false`
// - Chain verification performed at export time
// **Digital Signature**:
// - Export signed with service x509 certificate
// - Signature included in `export_metadata.signature` field
// - Detached signature available via `include_detached_signature=true`
// **Pagination**:
// - Use `offset` and `limit` for large result sets
// - Maximum limit: 10,000 events per export
// - Signature covers ALL pages (use same query for verification)
// **Metrics Emitted**:
// - `datastorage_export_successes_total{format="json|csv"}`
// - `datastorage_export_failures_total{reason="unauthorized|validation|..."}`.
//
// GET /api/v1/audit/export
func (UnimplementedHandler) ExportAuditEvents(ctx context.Context, params ExportAuditEventsParams) (r ExportAuditEventsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetEffectivenessScore implements getEffectivenessScore operation.
//
// Computes the weighted effectiveness score for a given remediation lifecycle
// from component audit events in the audit trail.
// **Architecture**: Per ADR-EM-001 Principle 5, DataStorage computes the overall score.
// The Effectiveness Monitor emits raw component assessment events; this endpoint
// aggregates them and applies the DD-017 v2.1 scoring formula:
// score = (health_score * 0.40 + alert_score * 0.35 + metrics_score * 0.25) / total_weight
// **Business Requirements**: BR-EM-001 to BR-EM-004
// **Response includes**:
// - Weighted overall score (0.0 to 1.0)
// - Individual component scores (health, alert, metrics)
// - Hash comparison data (pre/post remediation spec hash per DD-EM-002)
// - Assessment status (no_data, in_progress, EffectivenessAssessed)
// **Authentication**: Protected by OAuth-proxy in production/E2E.
//
// GET /api/v1/effectiveness/{correlation_id}
func (UnimplementedHandler) GetEffectivenessScore(ctx context.Context, params GetEffectivenessScoreParams) (r GetEffectivenessScoreRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetMetrics implements getMetrics operation.
//
// Exposes Prometheus metrics in text format.
// **Metrics Exposed** (BR-STORAGE-019, GAP-10):
// - `datastorage_audit_traces_total{service,status}` - Audit write operations
// - `datastorage_audit_lag_seconds{service}` - Time between event and audit write
// - `datastorage_write_duration_seconds{table}` - Database write latency
// - `datastorage_validation_failures_total{field,reason}` - Validation errors.
//
// GET /metrics
func (UnimplementedHandler) GetMetrics(ctx context.Context) (r GetMetricsOK, _ error) {
	return r, ht.ErrNotImplemented
}

// GetRemediationHistoryContext implements getRemediationHistoryContext operation.
//
// Returns structured remediation history context for LLM prompt enrichment.
// **Business Requirements**: BR-HAPI-016 (Remediation history context)
// **Design Document**: DD-HAPI-016
// **Behavior**:
// Aggregates `remediation.workflow_created` (RO) and `effectiveness.assessment.completed` (EM)
// audit events into structured remediation chains for a target resource.
// **Two-Tier Query Design**:
// - **Tier 1** (default 24h): Detailed remediation chain with health checks, metric deltas,
// and full effectiveness data for the target resource.
// - **Tier 2** (default 90d): Summary chain activated when `currentSpecHash` matches a
// historical `preRemediationSpecHash` beyond the Tier 1 window, indicating configuration
// regression.
// **Hash Comparison**: For each entry, performs three-way comparison of `currentSpecHash`
// against `preRemediationSpecHash` and `postRemediationSpecHash`.
// **Regression Detection**: Sets `regressionDetected: true` if any entry's
// `preRemediationSpecHash` matches `currentSpecHash`.
// **Authentication**: Protected by OAuth-proxy in production/E2E.
// Integration tests use mock X-Auth-Request-User header.
//
// GET /api/v1/remediation-history/context
func (UnimplementedHandler) GetRemediationHistoryContext(ctx context.Context, params GetRemediationHistoryContextParams) (r GetRemediationHistoryContextRes, _ error) {
	return r, ht.ErrNotImplemented
}

// GetWorkflowByID implements getWorkflowByID operation.
//
// Retrieve a specific workflow by its UUID.
// Step 3 of the three-step workflow discovery protocol when context filters are provided.
// **Design Decision**: DD-WORKFLOW-002 v3.0 (UUID primary key)
// **Security Gate**: DD-WORKFLOW-016, DD-HAPI-017
// **Without context filters**: Returns workflow by ID (existing behavior).
// **With context filters**: Returns workflow only if it matches the signal context.
// Returns 404 if the workflow exists but does not match the context filters
// (security gate - prevents info leakage by not distinguishing "not found" from "filtered out").
// Emits `workflow.catalog.workflow_retrieved` audit event when context filters are present.
//
// GET /api/v1/workflows/{workflow_id}
func (UnimplementedHandler) GetWorkflowByID(ctx context.Context, params GetWorkflowByIDParams) (r GetWorkflowByIDRes, _ error) {
	return r, ht.ErrNotImplemented
}

// HealthCheck implements healthCheck operation.
//
// Returns 200 if service is healthy (database and Redis reachable).
// Used by Kubernetes liveness probe (DD-007).
//
// GET /health
func (UnimplementedHandler) HealthCheck(ctx context.Context) (r HealthCheckRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ListAvailableActions implements listAvailableActions operation.
//
// Step 1 of the three-step workflow discovery protocol.
// Returns action types from the taxonomy that have active workflows matching
// the provided signal context filters.
// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
// **Behavior**:
// - Queries action_type_taxonomy joined with remediation_workflow_catalog
// - Filters by active workflows matching signal context (severity, component, environment, priority)
// - Returns action types with descriptions and workflow counts
// - Paginated (default 10 per page)
// - Emits `workflow.catalog.actions_listed` audit event (DD-WORKFLOW-014 v3.0).
//
// GET /api/v1/workflows/actions
func (UnimplementedHandler) ListAvailableActions(ctx context.Context, params ListAvailableActionsParams) (r ListAvailableActionsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ListLegalHolds implements listLegalHolds operation.
//
// Returns a list of all active legal holds across all audit events.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with array of active legal holds
// - No holds: Returns empty array
// **Authorization**: No authentication required (read-only operation)
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="list"}`.
//
// GET /api/v1/audit/legal-hold
func (UnimplementedHandler) ListLegalHolds(ctx context.Context) (r *ListLegalHoldsOK, _ error) {
	return r, ht.ErrNotImplemented
}

// ListWorkflows implements listWorkflows operation.
//
// List workflows with optional filters and pagination.
// **Business Requirement**: BR-STORAGE-014 (Workflow Catalog Management).
//
// GET /api/v1/workflows
func (UnimplementedHandler) ListWorkflows(ctx context.Context, params ListWorkflowsParams) (r ListWorkflowsRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ListWorkflowsByActionType implements listWorkflowsByActionType operation.
//
// Step 2 of the three-step workflow discovery protocol.
// Returns all active workflows matching the specified action type and
// signal context filters.
// **Authority**: DD-WORKFLOW-016 (Action-Type Workflow Catalog Indexing)
// **Business Requirement**: BR-HAPI-017-001 (Three-Step Tool Implementation)
// **LLM Instruction**: The LLM MUST review ALL workflows (across all pages)
// before selecting one. Do not select from an incomplete list.
// **Behavior**:
// - Filters by action_type + signal context (severity, component, environment, priority)
// - Excludes disabled and deprecated workflows
// - Returns workflow metadata including effectiveness data
// - Paginated (default 10 per page)
// - Emits `workflow.catalog.workflows_listed` audit event (DD-WORKFLOW-014 v3.0).
//
// GET /api/v1/workflows/actions/{action_type}
func (UnimplementedHandler) ListWorkflowsByActionType(ctx context.Context, params ListWorkflowsByActionTypeParams) (r ListWorkflowsByActionTypeRes, _ error) {
	return r, ht.ErrNotImplemented
}

// LivenessCheck implements livenessCheck operation.
//
// Returns 200 if service process is alive.
// Does not check dependencies.
// Used by Kubernetes liveness probe.
//
// GET /health/live
func (UnimplementedHandler) LivenessCheck(ctx context.Context) error {
	return ht.ErrNotImplemented
}

// PlaceLegalHold implements placeLegalHold operation.
//
// Places a legal hold on all audit events for a given correlation_id.
// Events with legal hold cannot be deleted (enforced by database trigger).
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement for Sarbanes-Oxley, HIPAA)
// **Behavior**:
// - Success: Returns 200 OK with legal hold metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if correlation_id doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who placed the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="place"}`
// - `datastorage_legal_hold_failures_total{reason="missing_correlation_id|unauthorized|..."}`.
//
// POST /api/v1/audit/legal-hold
func (UnimplementedHandler) PlaceLegalHold(ctx context.Context, req *PlaceLegalHoldReq) (r PlaceLegalHoldRes, _ error) {
	return r, ht.ErrNotImplemented
}

// QueryAuditEvents implements queryAuditEvents operation.
//
// Query audit events with filters and pagination.
//
// GET /api/v1/audit/events
func (UnimplementedHandler) QueryAuditEvents(ctx context.Context, params QueryAuditEventsParams) (r *AuditEventsQueryResponse, _ error) {
	return r, ht.ErrNotImplemented
}

// ReadinessCheck implements readinessCheck operation.
//
// Returns 200 if service is ready to accept traffic.
// Returns 503 during graceful shutdown (DD-007 4-step pattern).
// Used by Kubernetes readiness probe.
//
// GET /health/ready
func (UnimplementedHandler) ReadinessCheck(ctx context.Context) (r ReadinessCheckRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ReconstructRemediationRequest implements reconstructRemediationRequest operation.
//
// Reconstructs a complete RemediationRequest CRD from audit trail events.
// **Business Requirement**: BR-AUDIT-006 (SOC2 compliance)
// **Workflow**:
// 1. Query audit events for given correlation_id
// 2. Parse gateway and orchestrator events
// 3. Map audit data to RR Spec/Status fields
// 4. Build complete Kubernetes-compliant CRD
// 5. Validate completeness and quality
// **Use Cases**:
// - Disaster recovery (recreate lost RRs from audit trail)
// - Compliance audits (prove RR state at any point in time)
// - Debugging (understand RR evolution from audit events)
// **Returns**:
// - Reconstructed RR in YAML format
// - Validation result (completeness percentage, warnings, errors)
// **Authentication**: Protected by OAuth-proxy in production/E2E.
// Integration tests use mock X-Auth-Request-User header.
//
// POST /api/v1/audit/remediation-requests/{correlation_id}/reconstruct
func (UnimplementedHandler) ReconstructRemediationRequest(ctx context.Context, params ReconstructRemediationRequestParams) (r ReconstructRemediationRequestRes, _ error) {
	return r, ht.ErrNotImplemented
}

// ReleaseLegalHold implements releaseLegalHold operation.
//
// Releases a legal hold on all audit events for a given correlation_id.
// Events can be deleted after legal hold is released.
// **Business Requirement**: BR-AUDIT-006 (Legal Hold & Retention)
// **SOC2 Gap**: Gap #8 (Legal Hold enforcement)
// **Behavior**:
// - Success: Returns 200 OK with release metadata
// - Validation Error: Returns 400 Bad Request (RFC 7807)
// - Not Found: Returns 404 Not Found if legal hold doesn't exist
// - Unauthorized: Returns 401 if X-User-ID header missing
// **Authorization**: Requires X-User-ID header to track who released the hold
// **Metrics Emitted**:
// - `datastorage_legal_hold_successes_total{operation="release"}`
// - `datastorage_legal_hold_failures_total{reason="unauthorized|not_found|..."}`.
//
// DELETE /api/v1/audit/legal-hold/{correlation_id}
func (UnimplementedHandler) ReleaseLegalHold(ctx context.Context, req *ReleaseLegalHoldReq, params ReleaseLegalHoldParams) (r ReleaseLegalHoldRes, _ error) {
	return r, ht.ErrNotImplemented
}

// UpdateWorkflow implements updateWorkflow operation.
//
// Update mutable workflow fields (status, metrics).
// Immutable fields (description, content, labels) require creating a new version.
// **Design Decision**: DD-WORKFLOW-012 (Mutable vs Immutable Fields).
//
// PATCH /api/v1/workflows/{workflow_id}
func (UnimplementedHandler) UpdateWorkflow(ctx context.Context, req *WorkflowUpdateRequest, params UpdateWorkflowParams) (r UpdateWorkflowRes, _ error) {
	return r, ht.ErrNotImplemented
}
