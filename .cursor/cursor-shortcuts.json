{
	"shortcuts": [
		{
			"name": "TDD-Enhanced Build Error Investigation",
			"trigger": "/investigate-build",
			"description": "Comprehensive TDD-compliant build error analysis with dependency mapping",
			"command": "TDD-ENHANCED BUILD ERROR INVESTIGATION:\n\n## MANDATORY TDD INVESTIGATION PROTOCOL\n\n### PHASE 1: COMPREHENSIVE CHECKPOINT D ANALYSIS\n1. **MANDATORY**: Execute complete symbol analysis:\n   ```bash\n   # HALT: Comprehensive undefined symbol analysis\n   codebase_search \"[undefined_symbol] usage patterns and dependencies\"\n   grep -r \"[undefined_symbol]\" . --include=\"*.go\" -n\n   # Find constructor and factory patterns\n   grep -r \"New[SymbolName]\\|Create[SymbolName]\" . --include=\"*.go\"\n   ```\n\n2. **DEPENDENCY CHAIN MAPPING**: Map complete dependency relationships\n3. **BUSINESS INTEGRATION CHECK**: Verify main application usage\n   ```bash\n   # HALT: Check main application integration\n   grep -r \"[ComponentName]\" cmd/ --include=\"*.go\"\n   ```\n\n### PHASE 2: TDD-COMPLIANT ANALYSIS REPORT\nPresent findings in mandatory format:\n```\nüö® TDD BUILD ERROR INVESTIGATION:\nSymbol: [undefined_symbol]\nReferences Found: [N files]\nDependency Chain: [complete mapping]\nMain App Integration: [yes/no/partial]\nBusiness Requirements: [BR-XXX-XXX mapping]\nComplexity Scope: [minimal/medium/extensive]\n\nTDD-COMPLIANT OPTIONS:\nA) Reuse existing implementation ([details])\nB) Enhance existing code ([scope])\nC) Create minimal implementation ([justification required])\nD) Alternative approach ([suggestion])\n```\n\n### PHASE 3: MANDATORY APPROVAL PROCESS\n- **NO implementation** without explicit user approval\n- **COMPLETE analysis** before presenting options\n- **TDD methodology** compliance in all recommendations\n- **Integration preservation** in all solutions\n\n## INVESTIGATION SUCCESS CRITERIA:\n- ‚úÖ Complete dependency chain mapped\n- ‚úÖ All references analyzed\n- ‚úÖ Business integration verified\n- ‚úÖ TDD-compliant options presented\n- ‚úÖ User approval required before any implementation\n\nNote: Investigation phase NEVER implements - only analyzes and presents TDD-compliant options.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"investigation",
				"tdd-enhanced",
				"analysis"
			]
		},
		{
			"name": "TDD-Enhanced Quick Build Error Fix",
			"trigger": "/quick-build",
			"description": "Fast build error investigation with mandatory TDD validation",
			"command": "TDD-ENHANCED QUICK BUILD ERROR ANALYSIS:\n\n## MANDATORY TDD VALIDATION (RAPID)\n1. **CHECKPOINT D (Rapid)**: Quick but comprehensive symbol analysis:\n   ```bash\n   # HALT: Validate undefined symbols\n   codebase_search \"[undefined_symbol] usage patterns\"\n   grep -r \"[undefined_symbol]\" . --include=\"*.go\" -n\n   ```\n\n2. **RAPID ANALYSIS**: Present streamlined options with TDD compliance:\n   ```\n   üö® QUICK BUILD ERROR ANALYSIS:\n   Error: [build_error]\n   Symbol Status: [existing/missing/wrong_signature]\n   TDD-Compliant Options:\n   A) Use existing implementation (reuse pattern)\n   B) Fix import/signature (no new code)\n   C) Escalate to full TDD analysis (complex case)\n   ```\n\n3. **MANDATORY APPROVAL**: Ask for approval before ANY changes\n\n## TDD-COMPLIANT RAPID REMEDIATION:\n- ‚úÖ **REUSE existing code** (no new implementations)\n- ‚úÖ **VALIDATE before fixing** (mandatory checkpoints)\n- ‚úÖ **PRESERVE integration** (main app usage maintained)\n- ‚ùå **FORBIDDEN**: Skip validation for \"simple\" cases\n- ‚ùå **FORBIDDEN**: Assume types exist without verification\n\n## SUCCESS CRITERIA:\n- ‚úÖ TDD checkpoints executed (even in rapid mode)\n- ‚úÖ Build errors resolved through existing patterns\n- ‚úÖ No methodology violations\n- ‚úÖ User approval obtained\n\nNote: Quick mode accelerates execution but NEVER bypasses TDD methodology.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"quick",
				"tdd-enhanced"
			]
		},
		{
			"name": "Fix Build Issues",
			"trigger": "/fix-build",
			"description": "Systematically fix build errors following TDD methodology with comprehensive testing strategy validation",
			"command": "You are tasked with fixing build errors following the mandatory TDD REFACTOR methodology from @00-core-development-methodology.mdc and @03-testing-strategy.mdc.\n\nCRITICAL: You MUST follow this exact sequence to prevent cascade failures and ensure testing strategy compliance:\n\n## PHASE 1: COMPREHENSIVE BUILD ERROR ANALYSIS (CHECKPOINT D)\n1. **MANDATORY**: Run comprehensive lint check to identify ALL build errors:\n   ```bash\n   golangci-lint run --timeout=10m --max-issues-per-linter=0 --max-same-issues=0\n   ```\n\n2. **MANDATORY**: For EACH undefined symbol, execute CHECKPOINT D analysis:\n   ```bash\n   # HALT: Execute comprehensive symbol analysis\n   codebase_search \"[undefined_symbol] usage patterns and dependencies\"\n   grep -r \"[undefined_symbol]\" . --include=\"*.go\" -n\n   # Find constructor patterns\n   grep -r \"New[SymbolName]\\|Create[SymbolName]\" . --include=\"*.go\"\n   ```\n\n3. **MANDATORY**: Present complete analysis in this format:\n   ```\n   üö® UNDEFINED SYMBOL ANALYSIS:\n   Symbol: [undefined_symbol]\n   References found: [N files]\n   Dependent infrastructure: [list missing types/functions]\n   Scope: [minimal/medium/extensive]\n\n   OPTIONS:\n   A) Implement complete infrastructure ([X] files affected)\n   B) Create minimal stub (may break [Y] files)\n   C) Alternative approach: [suggest]\n   ```\n\n4. **MANDATORY**: Ask for user approval before ANY implementation.\n\n## PHASE 2: SYSTEMATIC VALIDATION (CHECKPOINTS A, B, C + TESTING STRATEGY)\n\n### CHECKPOINT A: Type Reference Validation\n**TRIGGER**: About to reference any struct field or type\n**MANDATORY ACTION**:\n```bash\n# HALT: Validate type definition exists\nread_file [target_file]\n# RULE: Verify all imports and type definitions exist before referencing\n```\n\n### CHECKPOINT B-ENHANCED: Function Reference + Testing Framework Validation\n**TRIGGER**: About to call any function OR fix any test file\n**MANDATORY ACTION**:\n```bash\n# HALT: Validate function signature\ngrep -r \"func.*[FunctionName]\" . --include=\"*.go\" -A 3\n# RULE: Verify function exists and signature matches before calling\n\n# MANDATORY TESTING STRATEGY VALIDATION (if test file):\nif [[ \"[target_file]\" == *\"_test.go\" ]]; then\n    # HALT: Validate Ginkgo/Gomega BDD framework compliance\n    grep -r \"func Test.*testing\\.T\" [target_file]\n    if [ $? -eq 0 ]; then\n        echo \"‚ùå VIOLATION: Standard Go testing found - MUST use Ginkgo/Gomega BDD framework\"\n        echo \"REQUIRED: Convert to Describe/It pattern with business requirement mapping\"\n        exit 1\n    fi\n    \n    # HALT: Validate BDD structure exists\n    grep -r \"Describe\\|It\\|BeforeEach\\|Expect\" [target_file]\n    if [ $? -ne 0 ]; then\n        echo \"‚ùå VIOLATION: Missing Ginkgo/Gomega BDD structure\"\n        echo \"REQUIRED: Use Describe(), It(), BeforeEach(), Expect() patterns\"\n        exit 1\n    fi\n    \n    # HALT: Validate business requirement mapping\n    grep -r \"BR-.*-.*:\" [target_file]\n    if [ $? -ne 0 ]; then\n        echo \"‚ùå VIOLATION: Missing business requirement mapping in test descriptions\"\n        echo \"REQUIRED: All test descriptions must reference BR-XXX-XXX requirements\"\n        exit 1\n    fi\nfi\n```\n\n### CHECKPOINT C: Import Validation\n**TRIGGER**: About to use any package\n**MANDATORY ACTION**:\n```bash\n# HALT: Validate import exists\ngrep -r \"import.*[PackageName]\" [target_file]\n# RULE: Verify import statement exists before using package types\n```\n\n## PHASE 3: TDD REFACTOR COMPLIANCE + TESTING STRATEGY ENFORCEMENT\n\n### MANDATORY REFACTOR RULES:\n1. **ENHANCE existing code only** - NO new types/methods/files\n2. **REUSE existing functions** - NO duplication across files\n3. **PRESERVE integration** - Main application usage MUST be maintained\n4. **VALIDATE before change** - Use tools to verify before editing\n5. **ENFORCE BDD framework** - ALL test files MUST use Ginkgo/Gomega\n6. **PREVENT mock creation** - REUSE existing mocks from pkg/testutil/\n\n### FORBIDDEN ACTIONS:\n- ‚ùå Creating new interfaces without business requirement\n- ‚ùå Duplicating functions across test files\n- ‚ùå Using `interface{}` instead of proper types\n- ‚ùå Removing files without dependency analysis\n- ‚ùå Assuming imports/types exist without validation\n- ‚ùå Using standard Go testing instead of Ginkgo/Gomega BDD\n- ‚ùå Creating local mocks instead of using pkg/testutil/mock_factory.go\n- ‚ùå Adding mocks to integration/e2e tests (use real components)\n\n## PHASE 4: SYSTEMATIC REMEDIATION + TESTING STRATEGY COMPLIANCE\n\n### For Missing Imports:\n1. **VALIDATE**: Check if import should exist: `grep -r \"import.*[package]\" [file]`\n2. **ADD**: Only if missing: Add proper import statement\n3. **VERIFY**: Confirm package is available: `go list [package]`\n\n### For Missing Functions:\n1. **SEARCH**: Find existing equivalent: `codebase_search \"similar [function] implementations\"`\n2. **REUSE**: Use existing function if available\n3. **MINIMAL**: Create only if no alternative exists\n\n### For Type Mismatches:\n1. **READ**: Actual function signature: `grep -r \"func.*[FunctionName]\" . -A 3`\n2. **MATCH**: Update call to match signature exactly\n3. **VALIDATE**: Confirm types are compatible\n\n### For Test-Related Build Errors (MANDATORY TESTING STRATEGY COMPLIANCE):\n1. **GINKGO/GOMEGA CONVERSION** (if standard Go testing found):\n   ```bash\n   # MANDATORY: Convert func Test* to Ginkgo/Gomega BDD\n   # FROM: func TestComponentName(t *testing.T) {\n   # TO:   var _ = Describe(\"BR-XXX-XXX: Component Business Requirement\", func() {\n   #           It(\"should [business behavior]\", func() {\n   #               Expect([business_outcome]).To([matcher])\n   ```\n\n2. **MOCK REUSE ENFORCEMENT**:\n   ```bash\n   # HALT: Check for new mock creation\n   grep -r \"type.*Mock.*struct\" [test_files] --include=\"*_test.go\"\n   if [ $? -eq 0 ]; then\n       echo \"‚ùå VIOLATION: New mock creation detected\"\n       echo \"REQUIRED: Use existing mocks from pkg/testutil/mock_factory.go\"\n       exit 1\n   fi\n   \n   # MANDATORY: Use existing mock factory\n   find pkg/testutil/mocks/ -name \"*Mock*\" -type f\n   echo \"‚úÖ AVAILABLE MOCKS: Use these instead of creating new ones\"\n   ```\n\n3. **TEST TYPE MOCK VALIDATION**:\n   ```bash\n   # HALT: Validate appropriate mock usage by test type\n   if [[ \"[test_file]\" == *\"integration\"* ]]; then\n       grep -r \"Mock.*Client\\|Mock.*Database\" [test_file] --include=\"*_test.go\"\n       if [ $? -eq 0 ]; then\n           echo \"‚ö†Ô∏è  WARNING: Integration tests should minimize mocking\"\n           echo \"PREFERRED: Use real business components, mock only external APIs\"\n       fi\n   fi\n   \n   if [[ \"[test_file]\" == *\"e2e\"* ]]; then\n       mock_count=$(grep -r \"Mock\" [test_file] --include=\"*_test.go\" | wc -l)\n       if [ \"$mock_count\" -gt 3 ]; then\n           echo \"‚ùå VIOLATION: E2E tests should use minimal mocking\"\n           echo \"REQUIRED: Use real business workflows, mock only external services\"\n           exit 1\n       fi\n   fi\n   ```\n\n## PHASE 5: VERIFICATION + TESTING STRATEGY VALIDATION\n\n### MANDATORY CHECKS:\n1. **Build Validation**: `go build ./...`\n2. **Lint Compliance**: `golangci-lint run --timeout=5m`\n3. **Test Compilation**: `go test -c ./test/...`\n4. **Integration Preserved**: `grep -r \"[ComponentName]\" cmd/ --include=\"*.go\"`\n5. **BDD Framework Compliance**: `grep -r \"Describe\\|It\\|Expect\" test/ --include=\"*_test.go\" | wc -l`\n6. **Mock Usage Validation**: `./scripts/validate-test-mock-usage.sh [affected_test_files]`\n7. **Business Requirement Mapping**: `grep -r \"BR-.*-.*:\" test/ --include=\"*_test.go\"`\n\n### SUCCESS CRITERIA:\n- ‚úÖ All build errors resolved\n- ‚úÖ No new lint errors introduced\n- ‚úÖ All tests compile successfully\n- ‚úÖ Main application integration preserved\n- ‚úÖ No function duplication across files\n- ‚úÖ All test files use Ginkgo/Gomega BDD framework\n- ‚úÖ No new local mocks created (existing mocks reused)\n- ‚úÖ Integration/E2E tests use appropriate mock levels\n- ‚úÖ All tests map to business requirements (BR-XXX-XXX)\n\n## EMERGENCY PROTOCOLS:\n\n### If Cascade Failures Occur:\n1. **STOP** immediately\n2. **RESTORE** any deleted files: `git checkout HEAD -- [file]`\n3. **ANALYZE** full dependency chain before proceeding\n4. **ASK** for user guidance on approach\n\n### If Testing Strategy Violations Detected:\n1. **HALT** current approach\n2. **REPORT** specific testing strategy violation\n3. **PROVIDE** exact conversion requirements (standard Go ‚Üí Ginkgo/Gomega)\n4. **REQUEST** approval for testing framework conversion\n5. **RESTART** from PHASE 2 with proper BDD compliance\n\n### If Methodology Violations Detected:\n1. **HALT** current approach\n2. **REPORT** specific violation\n3. **REQUEST** approval for corrective action\n4. **RESTART** from PHASE 1 with proper methodology\n\n## CONFIDENCE ASSESSMENT (REQUIRED):\nAfter completion, provide:\n```\nBuild Fix Confidence: [60-100]%\nMethodology Compliance: ‚úÖ/‚ùå All checkpoints executed (A,B,C,D)\nTesting Strategy Compliance: ‚úÖ/‚ùå Ginkgo/Gomega BDD framework enforced\nMock Usage Compliance: ‚úÖ/‚ùå Existing mocks reused, no new local mocks\nIntegration Preserved: ‚úÖ/‚ùå Main application usage maintained\nBusiness Requirement Mapping: ‚úÖ/‚ùå All tests reference BR-XXX-XXX\nRisk Assessment: [Description of remaining risks]\n```\n\nRemember: The goal is not just to fix build errors, but to do so while maintaining code quality, following TDD methodology, enforcing testing strategy compliance, and preventing future cascade failures.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"fix",
				"tdd",
				"methodology",
				"systematic",
				"validation"
			]
		},
		{
			"name": "Smart TDD-Compliant Build Fix",
			"trigger": "/smart-fix",
			"description": "Automatically detects context and applies TDD-compliant fix strategy",
			"command": "SMART BUILD FIX WITH MANDATORY TDD COMPLIANCE:\n\n## PHASE 1: INTELLIGENT CONTEXT DETECTION\n1. **MANDATORY**: Analyze file context:\n   ```bash\n   # Detect file type and complexity\n   file_type=$(echo \"[current_file]\" | grep -E \"test|main|pkg\")\n   error_count=$(golangci-lint run [current_file] 2>&1 | wc -l)\n   ```\n\n2. **CONTEXT-AWARE CHECKPOINT SELECTION**:\n   - **Simple imports** (‚â§3 errors): CHECKPOINT A + C only\n   - **Type mismatches** (‚â§5 errors): CHECKPOINT A + B + rapid D\n   - **Complex issues** (>5 errors): Full CHECKPOINT D analysis\n   - **Test files**: Additional business requirement validation\n   - **Main app files**: Additional integration validation\n\n3. **MANDATORY VALIDATION MATRIX**:\n   ```\n   Context: [detected_context]\n   Error Count: [N]\n   Required Checkpoints: [A/B/C/D]\n   Estimated Complexity: [simple/medium/complex]\n   Recommended Approach: [quick/standard/comprehensive]\n   ```\n\n4. **SMART ESCALATION**: Automatically use appropriate fix level:\n   - **Simple**: Enhanced quick fix with checkpoints\n   - **Medium**: Component-focused fix with full validation\n   - **Complex**: Full /fix-build methodology\n\n## MANDATORY COMPLIANCE:\n- ‚úÖ **ALL variants** enforce mandatory checkpoints\n- ‚úÖ **NO shortcuts** that bypass TDD methodology\n- ‚úÖ **AUTOMATIC escalation** when complexity exceeds threshold\n- ‚úÖ **USER approval** required for all changes\n\nNote: Smart detection ENHANCES methodology compliance, never bypasses it.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"smart",
				"tdd-compliant",
				"context-aware"
			]
		},
		{
			"name": "TDD-Compliant Fix My Build",
			"trigger": "/fix-my-build",
			"description": "Natural language trigger for TDD-compliant build fixing",
			"command": "I'll help you fix your build errors systematically following mandatory TDD methodology.\n\n## MANDATORY TDD PROCESS:\n1. **CHECKPOINT D**: Comprehensive error analysis first\n2. **VALIDATION**: Verify all type definitions and imports exist\n3. **DISCOVERY**: Search for existing implementations to reuse\n4. **APPROVAL**: Get your approval before making any changes\n5. **INTEGRATION**: Ensure main application integration preserved\n\nLet me start by analyzing what's broken using the mandatory TDD validation checkpoints.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"natural",
				"tdd-compliant"
			]
		},
		{
			"name": "Progressive TDD-Compliant Build Fix",
			"trigger": "/fix-build-staged",
			"description": "Fix build errors in progressive stages with mandatory TDD compliance",
			"command": "PROGRESSIVE BUILD FIX WITH MANDATORY TDD COMPLIANCE:\n\n## STAGE PROGRESSION WITH CHECKPOINTS\n\n### STAGE 1: VALIDATION FOUNDATION (MANDATORY)\n**Duration**: 2-3 minutes\n**Actions**:\n```bash\n# MANDATORY: Complete error inventory\ngolangci-lint run [target_file] --timeout=5m\n# MANDATORY: Symbol dependency analysis\ncodebase_search \"undefined symbols usage patterns\"\n```\n**Checkpoint**: All undefined symbols catalogued with dependency analysis\n**User Control**: Proceed to Stage 2? [Y/N]\n\n### STAGE 2: TYPE AND IMPORT RESOLUTION (TDD-COMPLIANT)\n**Duration**: 3-5 minutes\n**Actions**:\n- ‚úÖ **CHECKPOINT A**: Validate all type references\n- ‚úÖ **CHECKPOINT C**: Validate all import statements\n- ‚úÖ **REUSE existing types** from codebase search results\n- ‚ùå **FORBIDDEN**: Create new types without business requirement\n**Checkpoint**: All imports and types resolved through existing code\n**User Control**: Proceed to Stage 3? [Y/N]\n\n### STAGE 3: FUNCTION AND METHOD RESOLUTION (TDD-COMPLIANT)\n**Duration**: 5-7 minutes\n**Actions**:\n- ‚úÖ **CHECKPOINT B**: Validate all function signatures\n- ‚úÖ **REUSE existing functions** from codebase patterns\n- ‚úÖ **ADAPT calls** to match existing signatures\n- ‚ùå **FORBIDDEN**: Create new functions without analysis\n**Checkpoint**: All function calls use existing implementations\n**User Control**: Proceed to Stage 4? [Y/N]\n\n### STAGE 4: INTEGRATION VALIDATION (MANDATORY)\n**Duration**: 3-5 minutes\n**Actions**:\n```bash\n# MANDATORY: Verify main application integration\ngrep -r \"[ComponentName]\" cmd/ --include=\"*.go\"\n# MANDATORY: Validate business requirement mapping\ngrep -r \"BR-\" [target_file]\n```\n**Checkpoint**: All business components integrated in main applications\n**User Control**: Complete fix? [Y/N]\n\n## STAGE CONTROLS:\n- **PAUSE**: User can stop at any stage\n- **ROLLBACK**: Automatic rollback if stage fails validation\n- **ESCALATE**: Auto-escalate to full /fix-build if complexity exceeds threshold\n- **VALIDATE**: Each stage must pass TDD checkpoints to proceed\n\n## MANDATORY COMPLIANCE PER STAGE:\n- ‚úÖ **NO stage** bypasses mandatory checkpoints\n- ‚úÖ **ALL stages** require user approval to proceed\n- ‚úÖ **AUTOMATIC escalation** when TDD violations detected\n- ‚úÖ **ROLLBACK capability** at each stage\n\nNote: Progressive approach provides control while maintaining methodology compliance.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"staged",
				"progressive",
				"tdd-compliant"
			]
		},
		{
			"name": "TDD-Enhanced Emergency Build Fix",
			"trigger": "/build-broken",
			"description": "Emergency build fix with mandatory TDD compliance maintained under pressure",
			"command": "TDD-ENHANCED EMERGENCY BUILD FIX:\n\n## EMERGENCY TDD PROTOCOL (NO SHORTCUTS)\n**CRITICAL**: Even under pressure, TDD methodology is MANDATORY\n\n### PHASE 1: RAPID BUT COMPLETE CHECKPOINT D\n1. **EMERGENCY ANALYSIS** (accelerated but comprehensive):\n   ```bash\n   # HALT: Even in emergency, validate symbols\n   codebase_search \"[undefined_symbol] usage patterns\"\n   grep -r \"[undefined_symbol]\" . --include=\"*.go\" -n\n   ```\n\n2. **EMERGENCY TRIAGE**: Categorize errors by TDD-compliant fix complexity:\n   ```\n   üö® EMERGENCY BUILD TRIAGE:\n   Blocking Errors: [count]\n   Quick TDD Fixes: [imports, existing types]\n   Medium TDD Fixes: [signature corrections]\n   Complex Issues: [require full analysis]\n   ```\n\n### PHASE 2: EMERGENCY TDD-COMPLIANT REMEDIATION\n**Priority Order** (all with TDD compliance):\n1. **Import fixes** (existing packages only)\n2. **Type corrections** (use existing types only)\n3. **Signature fixes** (match existing implementations)\n4. **Escalate complex issues** to full TDD process\n\n### EMERGENCY CONSTRAINTS:\n- ‚úÖ **REUSE existing code** (no new implementations under pressure)\n- ‚úÖ **VALIDATE critical fixes** (mandatory even in emergency)\n- ‚úÖ **PRESERVE integration** (main app functionality maintained)\n- ‚ùå **FORBIDDEN**: Skip TDD checkpoints (quality maintained under pressure)\n- ‚ùå **FORBIDDEN**: Create new code without analysis (no technical debt)\n\n## EMERGENCY SUCCESS CRITERIA:\n- ‚úÖ Build unblocked through existing code reuse\n- ‚úÖ TDD methodology preserved (accelerated, not bypassed)\n- ‚úÖ No technical debt introduced\n- ‚úÖ Main application integration maintained\n\n**EMERGENCY PRINCIPLE**: Speed through efficiency, NOT through shortcuts that bypass TDD methodology.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"emergency",
				"tdd-enhanced",
				"critical"
			]
		},
		{
			"name": "TDD-Enhanced Critical Build Fix",
			"trigger": "/fix-build-critical",
			"description": "Critical build fix maintaining TDD methodology under time pressure",
			"command": "TDD-ENHANCED CRITICAL BUILD FIX:\n\n## CRITICAL TDD PROTOCOL (ACCELERATED, NOT BYPASSED)\n**PRINCIPLE**: Critical situations require FASTER TDD execution, not TDD abandonment\n\n### PHASE 1: CRITICAL CHECKPOINT EXECUTION\n1. **CRITICAL CHECKPOINT D**: Immediate but thorough analysis:\n   ```bash\n   # HALT: Critical mode still requires validation\n   codebase_search \"[undefined_symbol] usage patterns\"\n   grep -r \"[undefined_symbol]\" . --include=\"*.go\" -n\n   ```\n\n2. **CRITICAL IMPACT ASSESSMENT**:\n   ```\n   üö® CRITICAL BUILD ANALYSIS:\n   Blocking Issue: [description]\n   Impact Scope: [files affected]\n   TDD Fix Strategy: [reuse/enhance/minimal]\n   Time Estimate: [minutes]\n   Risk Level: [low/medium/high]\n   ```\n\n### PHASE 2: CRITICAL TDD-COMPLIANT RESOLUTION\n**Accelerated TDD Process**:\n- **Parallel validation**: Run checkpoints concurrently\n- **Focused scope**: Target only blocking issues\n- **Existing code priority**: Use established patterns first\n- **Immediate approval**: Streamlined but required approval process\n\n### CRITICAL EXECUTION RULES:\n- ‚úÖ **ACCELERATED checkpoints** (faster execution, same validation)\n- ‚úÖ **FOCUSED remediation** (blocking issues only)\n- ‚úÖ **EXISTING patterns** (proven solutions first)\n- ‚úÖ **STREAMLINED approval** (required but expedited)\n- ‚ùå **FORBIDDEN**: Skip validation (quality non-negotiable)\n- ‚ùå **FORBIDDEN**: Create untested code (reliability critical)\n\n## CRITICAL SUCCESS CRITERIA:\n- ‚úÖ Blocking build issues resolved\n- ‚úÖ TDD methodology maintained (accelerated execution)\n- ‚úÖ System stability preserved\n- ‚úÖ No cascade failures introduced\n\n**CRITICAL PHILOSOPHY**: True urgency demands BETTER methodology execution, not methodology abandonment.",
			"category": "debugging",
			"tags": [
				"build",
				"error",
				"critical",
				"tdd-enhanced",
				"urgent"
			]
		},
		{
			"name": "TDD-Compliant Code Refactoring",
			"trigger": "/refactor",
			"description": "Systematic code refactoring following TDD methodology with comprehensive testing strategy validation and stop-and-plan approach",
			"command": "You are tasked with refactoring code following the mandatory TDD REFACTOR methodology from @00-core-development-methodology.mdc and @03-testing-strategy.mdc with enhanced validation.\n\nCRITICAL: You MUST follow this exact sequence with STOP-AND-PLAN approach to prevent cascade failures and ensure testing strategy compliance:\n\n## PHASE 1: COMPREHENSIVE REFACTORING IMPACT ANALYSIS (MANDATORY STOP-AND-PLAN)\n\n### INHERITED VALIDATION FROM /fix-build + TESTING STRATEGY:\n1. **MANDATORY**: Execute ALL CHECKPOINT validations (A, B, C, D + Testing Strategy):\n   ```bash\n   # CHECKPOINT A: Type Reference Validation\n   read_file [target_file]\n   grep -r \"type.*[TypeName].*struct\" pkg/ --include=\"*.go\"\n   \n   # CHECKPOINT B-ENHANCED: Function Reference + Testing Framework Validation  \n   grep -r \"func.*[FunctionName]\" . --include=\"*.go\" -A 3\n   \n   # MANDATORY TESTING STRATEGY VALIDATION (if test file):\n   if [[ \"[target_file]\" == *\"_test.go\" ]]; then\n       # HALT: Validate Ginkgo/Gomega BDD framework compliance\n       grep -r \"func Test.*testing\\.T\" [target_file]\n       if [ $? -eq 0 ]; then\n           echo \"‚ùå VIOLATION: Standard Go testing found - MUST use Ginkgo/Gomega BDD framework\"\n           echo \"REQUIRED: Convert to Describe/It pattern with business requirement mapping\"\n           exit 1\n       fi\n       \n       # HALT: Validate BDD structure exists\n       grep -r \"Describe\\|It\\|BeforeEach\\|Expect\" [target_file]\n       if [ $? -ne 0 ]; then\n           echo \"‚ùå VIOLATION: Missing Ginkgo/Gomega BDD structure\"\n           echo \"REQUIRED: Use Describe(), It(), BeforeEach(), Expect() patterns\"\n           exit 1\n       fi\n       \n       # HALT: Validate business requirement mapping\n       grep -r \"BR-.*-.*:\" [target_file]\n       if [ $? -ne 0 ]; then\n           echo \"‚ùå VIOLATION: Missing business requirement mapping in test descriptions\"\n           echo \"REQUIRED: All test descriptions must reference BR-XXX-XXX requirements\"\n           exit 1\n       fi\n   fi\n   \n   # CHECKPOINT C: Import Validation\n   grep -r \"import.*[PackageName]\" [target_file]\n   \n   # CHECKPOINT D: Symbol Analysis\n   codebase_search \"[symbol] usage patterns and dependencies\"\n   grep -r \"[symbol]\" . --include=\"*.go\" -n\n   ```\n\n### ENHANCED REFACTORING-SPECIFIC ANALYSIS:\n2. **MANDATORY**: Refactoring Impact Assessment:\n   ```bash\n   # HALT: Analyze refactoring scope and dependencies\n   codebase_search \"existing [ComponentType] implementations and usage patterns\"\n   grep -r \"[ComponentName]\" cmd/ pkg/ test/ --include=\"*.go\"\n   \n   # HALT: Cross-package dependency analysis\n   go mod graph | grep [target_package]\n   \n   # HALT: Test coverage impact analysis\n   go test -coverprofile=before_refactor.out ./...\n   \n   # HALT: Testing strategy impact analysis\n   if [[ \"[target_files]\" == *\"test\"* ]]; then\n       echo \"üîç TESTING STRATEGY IMPACT ANALYSIS:\"\n       grep -r \"Mock\" [target_files] --include=\"*_test.go\" | wc -l\n       echo \"Current mock usage count: [result]\"\n       \n       find pkg/testutil/mocks/ -name \"*Mock*\" -type f | wc -l\n       echo \"Available centralized mocks: [result]\"\n   fi\n   ```\n\n3. **MANDATORY**: Present complete refactoring analysis:\n   ```\n   üö® COMPREHENSIVE REFACTORING ANALYSIS:\n   Target Component: [component_name]\n   Current Usage: [N files across M packages]\n   Dependency Chain: [complete mapping]\n   Test Coverage: [current %]\n   Testing Framework Compliance: [Ginkgo/Gomega ‚úÖ/‚ùå]\n   Mock Usage Analysis: [centralized ‚úÖ/‚ùå, appropriate by test type ‚úÖ/‚ùå]\n   Integration Points: [main app usage locations]\n   Refactoring Scope: [minimal/medium/extensive]\n   \n   REFACTORING IMPACT ASSESSMENT:\n   Files Affected: [X direct, Y indirect]\n   Test Files Requiring Updates: [Z files]\n   Testing Strategy Violations: [list any BDD/mock issues]\n   Integration Points at Risk: [list critical points]\n   Performance Impact: [estimated]\n   \n   TDD-COMPLIANT REFACTORING OPTIONS:\n   A) Enhance existing structure ([X] files, low risk)\n   B) Restructure with preservation ([Y] files, medium risk)\n   C) Comprehensive refactoring ([Z] files, high risk)\n   D) Alternative approach: [suggest safer option]\n   ```\n\n4. **MANDATORY**: Ask for user approval of refactoring plan before ANY implementation.\n\n## PHASE 2: REFACTORING BOUNDARY VALIDATION (ENHANCED CHECKPOINTS + TESTING STRATEGY)\n\n### CHECKPOINT R1: Refactoring Scope Validation\n**TRIGGER**: About to modify any code structure\n**MANDATORY ACTION**:\n```bash\n# HALT: Validate refactoring boundaries\ncodebase_search \"[ComponentType] integration patterns across codebase\"\ngrep -r \"[ComponentName]\" cmd/ --include=\"*.go\" -B 2 -A 2\n# RULE: All integration points must be preserved or safely migrated\n```\n\n### CHECKPOINT R2: Dependency Cascade Validation\n**TRIGGER**: About to change interfaces or function signatures\n**MANDATORY ACTION**:\n```bash\n# HALT: Analyze dependency cascade effects\ngrep -r \"[InterfaceName]\\|[FunctionName]\" . --include=\"*.go\" -n\ngo list -f '{{.ImportPath}} {{.Imports}}' ./... | grep [target_package]\n# RULE: All dependent code must be analyzed before structural changes\n```\n\n### CHECKPOINT R3-ENHANCED: Test Coverage + Testing Strategy Preservation\n**TRIGGER**: About to refactor tested code\n**MANDATORY ACTION**:\n```bash\n# HALT: Ensure test coverage preservation\ngo test -coverprofile=current.out [target_package]\ngrep -r \"[ComponentName]\" test/ --include=\"*_test.go\"\n# RULE: Refactoring must maintain or improve test coverage\n\n# MANDATORY TESTING STRATEGY PRESERVATION:\nif [[ \"[target_files]\" == *\"test\"* ]]; then\n    # HALT: Validate no new mock creation during refactoring\n    grep -r \"type.*Mock.*struct\" [target_files] --include=\"*_test.go\"\n    if [ $? -eq 0 ]; then\n        echo \"‚ùå VIOLATION: New mock creation detected during refactoring\"\n        echo \"REQUIRED: Use existing mocks from pkg/testutil/mock_factory.go\"\n        exit 1\n    fi\n    \n    # HALT: Validate appropriate mock usage by test type\n    if [[ \"[target_files]\" == *\"integration\"* ]]; then\n        mock_count=$(grep -r \"Mock\" [target_files] --include=\"*_test.go\" | wc -l)\n        if [ \"$mock_count\" -gt 5 ]; then\n            echo \"‚ö†Ô∏è  WARNING: Integration tests should minimize mocking\"\n            echo \"PREFERRED: Use real business components, mock only external APIs\"\n        fi\n    fi\n    \n    if [[ \"[target_files]\" == *\"e2e\"* ]]; then\n        mock_count=$(grep -r \"Mock\" [target_files] --include=\"*_test.go\" | wc -l)\n        if [ \"$mock_count\" -gt 3 ]; then\n            echo \"‚ùå VIOLATION: E2E tests should use minimal mocking\"\n            echo \"REQUIRED: Use real business workflows, mock only external services\"\n            exit 1\n        fi\n    fi\nfi\n```\n\n### CHECKPOINT R4: Business Integration Preservation\n**TRIGGER**: About to refactor business logic components\n**MANDATORY ACTION**:\n```bash\n# HALT: Verify business integration preservation\ngrep -r \"[BusinessComponent]\" cmd/ --include=\"*.go\"\ngrep -r \"BR-\" [target_files] # Business requirement mapping\n# RULE: All business integrations must be preserved during refactoring\n```\n\n## PHASE 3: TDD-ENHANCED REFACTOR EXECUTION + TESTING STRATEGY ENFORCEMENT\n\n### ENHANCED REFACTOR RULES (Less Restrictive than /fix-build):\n1. **STRUCTURAL IMPROVEMENTS ALLOWED** - With comprehensive validation\n2. **INTERFACE ENHANCEMENTS PERMITTED** - With dependency analysis\n3. **CODE REORGANIZATION ENABLED** - With integration preservation\n4. **PERFORMANCE OPTIMIZATIONS SUPPORTED** - With regression testing\n5. **TESTING FRAMEWORK MODERNIZATION REQUIRED** - Convert standard Go tests to Ginkgo/Gomega\n6. **MOCK CONSOLIDATION ENCOURAGED** - Migrate to centralized mock factory\n\n### MANDATORY REFACTORING PRINCIPLES:\n- ‚úÖ **PRESERVE all existing functionality** - No behavior changes\n- ‚úÖ **MAINTAIN integration points** - Main application usage preserved\n- ‚úÖ **ENHANCE code quality** - Improve structure, readability, performance\n- ‚úÖ **VALIDATE continuously** - Check after each refactoring step\n- ‚úÖ **ENFORCE BDD framework** - Convert all tests to Ginkgo/Gomega\n- ‚úÖ **CONSOLIDATE mocks** - Use centralized mock factory\n- ‚ùå **FORBIDDEN**: Break existing interfaces without migration plan\n- ‚ùå **FORBIDDEN**: Remove business logic without replacement\n- ‚ùå **FORBIDDEN**: Skip validation for \"simple\" refactoring\n- ‚ùå **FORBIDDEN**: Assume dependencies without verification\n- ‚ùå **FORBIDDEN**: Leave standard Go testing in place\n- ‚ùå **FORBIDDEN**: Create new local mocks during refactoring\n\n## PHASE 4: SYSTEMATIC REFACTORING IMPLEMENTATION + TESTING STRATEGY COMPLIANCE\n\n### For Structural Refactoring:\n1. **ANALYZE**: Current structure and usage patterns\n2. **PLAN**: Migration strategy with backward compatibility\n3. **IMPLEMENT**: Incremental changes with continuous validation\n4. **VERIFY**: All integration points still functional\n\n### For Interface Enhancement:\n1. **DISCOVER**: All interface implementations and usages\n2. **DESIGN**: Enhanced interface with migration path\n3. **MIGRATE**: Update implementations systematically\n4. **VALIDATE**: All callers updated and functional\n\n### For Performance Optimization:\n1. **BENCHMARK**: Current performance baseline\n2. **OPTIMIZE**: Implement performance improvements\n3. **MEASURE**: Validate performance gains\n4. **REGRESSION**: Ensure no functionality degradation\n\n### For Test Refactoring (MANDATORY TESTING STRATEGY COMPLIANCE):\n1. **GINKGO/GOMEGA CONVERSION** (if standard Go testing found):\n   ```bash\n   # MANDATORY: Convert func Test* to Ginkgo/Gomega BDD\n   # FROM: func TestComponentName(t *testing.T) {\n   # TO:   var _ = Describe(\"BR-XXX-XXX: Component Business Requirement\", func() {\n   #           It(\"should [business behavior]\", func() {\n   #               Expect([business_outcome]).To([matcher])\n   ```\n\n2. **MOCK CONSOLIDATION**:\n   ```bash\n   # MANDATORY: Replace local mocks with centralized ones\n   # FROM: type mockComponent struct{}\n   # TO:   mockComponent := mocks.NewMockComponent()\n   \n   # MANDATORY: Use existing mock factory\n   find pkg/testutil/mocks/ -name \"*Mock*\" -type f\n   echo \"‚úÖ AVAILABLE MOCKS: Migrate to these instead of local mocks\"\n   ```\n\n3. **TEST TYPE OPTIMIZATION**:\n   ```bash\n   # MANDATORY: Optimize mock usage by test type\n   if [[ \"[test_file]\" == *\"unit\"* ]]; then\n       echo \"‚úÖ Unit tests: Mock external dependencies, use real business logic\"\n   elif [[ \"[test_file]\" == *\"integration\"* ]]; then\n       echo \"‚úÖ Integration tests: Use real components, mock only external APIs\"\n   elif [[ \"[test_file]\" == *\"e2e\"* ]]; then\n       echo \"‚úÖ E2E tests: Minimal mocking, real business workflows\"\n   fi\n   ```\n\n## PHASE 5: COMPREHENSIVE REFACTORING VERIFICATION + TESTING STRATEGY VALIDATION\n\n### MANDATORY CHECKS (Inherited + Enhanced + Testing Strategy):\n1. **Build Validation**: `go build ./...`\n2. **Lint Compliance**: `golangci-lint run --timeout=10m`\n3. **Test Compilation**: `go test -c ./test/...`\n4. **Test Execution**: `go test ./... -timeout=30m`\n5. **Integration Preserved**: `grep -r \"[ComponentName]\" cmd/ --include=\"*.go\"`\n6. **Coverage Maintained**: `go test -coverprofile=after_refactor.out ./...`\n7. **Performance Regression**: Compare benchmarks before/after\n8. **Business Requirements**: Validate BR-XXX-XXX mapping preserved\n9. **BDD Framework Compliance**: `grep -r \"Describe\\|It\\|Expect\" test/ --include=\"*_test.go\" | wc -l`\n10. **Mock Usage Validation**: `./scripts/validate-test-mock-usage.sh [affected_test_files]`\n11. **Testing Strategy Compliance**: `./scripts/validate-testing-pyramid.sh [test_directories]`\n\n### REFACTORING SUCCESS CRITERIA:\n- ‚úÖ All build errors resolved\n- ‚úÖ No new lint errors introduced\n- ‚úÖ All tests pass (existing + new)\n- ‚úÖ Test coverage maintained or improved\n- ‚úÖ Main application integration preserved\n- ‚úÖ Performance maintained or improved\n- ‚úÖ Business requirements still satisfied\n- ‚úÖ Code quality metrics improved\n- ‚úÖ All test files use Ginkgo/Gomega BDD framework\n- ‚úÖ No local mocks created (centralized mocks used)\n- ‚úÖ Integration/E2E tests use appropriate mock levels\n- ‚úÖ All tests map to business requirements (BR-XXX-XXX)\n- ‚úÖ Testing pyramid strategy maintained\n\n## EMERGENCY PROTOCOLS (Inherited from /fix-build + Testing Strategy):\n\n### If Refactoring Cascade Failures Occur:\n1. **STOP** immediately\n2. **RESTORE** to last known good state: `git checkout HEAD~1 -- [affected_files]`\n3. **ANALYZE** full refactoring impact before proceeding\n4. **REASSESS** refactoring approach with user\n5. **RESTART** from PHASE 1 with adjusted scope\n\n### If Testing Strategy Violations Detected:\n1. **HALT** current refactoring approach\n2. **REPORT** specific testing strategy violation\n3. **PROVIDE** exact conversion requirements (standard Go ‚Üí Ginkgo/Gomega)\n4. **PROVIDE** mock consolidation plan (local mocks ‚Üí centralized mocks)\n5. **REQUEST** approval for testing framework modernization\n6. **RESTART** from PHASE 2 with proper testing strategy compliance\n\n### If Methodology Violations Detected:\n1. **HALT** current refactoring approach\n2. **REPORT** specific methodology violation\n3. **REQUEST** approval for corrective action\n4. **RESTART** from PHASE 1 with proper methodology\n\n## CONFIDENCE ASSESSMENT (REQUIRED):\nAfter completion, provide:\n```\nRefactoring Confidence: [60-100]%\nMethodology Compliance: ‚úÖ/‚ùå All checkpoints executed (A,B,C,D,R1,R2,R3,R4)\nTesting Strategy Compliance: ‚úÖ/‚ùå Ginkgo/Gomega BDD framework enforced\nMock Usage Compliance: ‚úÖ/‚ùå Centralized mocks used, no new local mocks\nTest Type Compliance: ‚úÖ/‚ùå Appropriate mock levels by test type\nIntegration Preserved: ‚úÖ/‚ùå Main application usage maintained\nCode Quality Improvement: ‚úÖ/‚ùå Measurable quality metrics improved\nTest Coverage: [before%] ‚Üí [after%]\nBusiness Requirement Mapping: ‚úÖ/‚ùå All tests reference BR-XXX-XXX\nTesting Pyramid Compliance: ‚úÖ/‚ùå Unit/Integration/E2E ratios maintained\nPerformance Impact: [baseline] ‚Üí [optimized]\nRisk Assessment: [Description of remaining risks]\n```\n\n## REFACTORING PHILOSOPHY:\nRefactoring is **ENHANCEMENT WITHOUT BEHAVIOR CHANGE**. Every refactoring step must improve code quality while preserving all existing functionality and integration points. The goal is to make code better while maintaining 100% compatibility with existing usage patterns AND ensuring full compliance with testing strategy requirements.\n\n**STOP-AND-PLAN PRINCIPLE**: Never proceed to implementation without complete analysis and explicit user approval. Refactoring requires even more careful planning than build fixes because the scope of change is typically larger and must include testing strategy modernization.",
			"category": "refactoring",
			"tags": [
				"refactor",
				"tdd",
				"methodology",
				"systematic",
				"validation",
				"enhancement",
				"stop-and-plan"
			]
		},
		{
			"name": "APDC Analysis Phase",
			"trigger": "/analyze",
			"description": "Comprehensive context understanding and impact assessment following APDC methodology",
			"command": "APDC ANALYSIS PHASE - COMPREHENSIVE CONTEXT UNDERSTANDING:\n\n## MANDATORY ANALYSIS PROTOCOL\n\n### PHASE 1: BUSINESS REQUIREMENT ALIGNMENT ANALYSIS\n1. **MANDATORY**: Business requirement identification and validation:\n   ```bash\n   # HALT: Identify and validate business requirements\n   grep -r \"BR-[A-Z]+-[0-9]+\" docs/requirements/ --include=\"*.md\"\n   codebase_search \"business requirement [BR-XXX-XXX] existing implementations\"\n   ```\n\n2. **BUSINESS VALUE ASSESSMENT**:\n   ```\n   üìã BUSINESS REQUIREMENT ANALYSIS:\n   Target BR: [BR-XXX-XXX]\n   Business Value: [description of business need]\n   Current Implementation: [existing/partial/missing]\n   Gap Analysis: [what needs to be implemented]\n   Priority Level: [high/medium/low]\n   ```\n\n### PHASE 2: TECHNICAL IMPACT ASSESSMENT\n1. **MANDATORY**: Comprehensive technical analysis:\n   ```bash\n   # HALT: Analyze existing implementations and dependencies\n   codebase_search \"existing [ComponentType] implementations and dependencies\"\n   grep -r \"[ComponentName]\" cmd/ pkg/ test/ --include=\"*.go\" -c\n   \n   # HALT: Integration point identification\n   grep -r \"New[ComponentType]\\|Create[ComponentType]\" cmd/ --include=\"*.go\"\n   \n   # HALT: Dependency impact analysis\n   go mod graph | grep [target_package]\n   ./scripts/analyze-dependency-impact.sh [component]\n   ```\n\n2. **TECHNICAL CONTEXT MAPPING**:\n   ```\n   üîç TECHNICAL IMPACT ANALYSIS:\n   Existing Implementations: [N files found]\n   Integration Points: [main app usage locations]\n   Dependencies: [package dependencies mapped]\n   Affected Components: [list of impacted components]\n   Architecture Alignment: [fits existing patterns ‚úÖ/‚ùå]\n   ```\n\n### PHASE 3: RISK AND COMPLEXITY EVALUATION\n1. **MANDATORY**: Risk assessment and complexity analysis:\n   ```bash\n   # HALT: Complexity evaluation\n   find . -name \"*.go\" -path \"./pkg/*\" -exec wc -l {} + | sort -n\n   grep -r \"interface\\|struct\" pkg/[target_package]/ --include=\"*.go\" | wc -l\n   \n   # HALT: Change impact assessment\n   git log --oneline --since=\"1 month ago\" -- pkg/[target_package]/ | wc -l\n   ```\n\n2. **RISK EVALUATION MATRIX**:\n   ```\n   ‚ö†Ô∏è  RISK AND COMPLEXITY ASSESSMENT:\n   Complexity Level: [simple/medium/complex]\n   Breaking Change Risk: [low/medium/high]\n   Integration Risk: [low/medium/high]\n   Performance Impact: [minimal/moderate/significant]\n   Testing Requirements: [unit/integration/e2e coverage needed]\n   Timeline Estimate: [hours/days]\n   ```\n\n### PHASE 4: ANALYSIS DELIVERABLES\n**MANDATORY OUTPUT FORMAT**:\n```\nüìä APDC ANALYSIS COMPLETE:\n\n**BUSINESS CONTEXT**:\n- Business Requirement: [BR-XXX-XXX]\n- Business Value: [clear description]\n- Current State: [existing implementation status]\n- Business Impact: [expected outcome]\n\n**TECHNICAL CONTEXT**:\n- Existing Implementations: [found N similar components]\n- Integration Points: [X main app integrations identified]\n- Dependencies: [Y packages affected]\n- Architecture Fit: [aligns with existing patterns ‚úÖ/‚ùå]\n\n**IMPACT ASSESSMENT**:\n- Files Affected: [direct: X, indirect: Y]\n- Cascade Effects: [list potential impacts]\n- Performance Implications: [expected impact level]\n- Testing Requirements: [coverage strategy needed]\n\n**RISK EVALUATION**:\n- Complexity Level: [simple/medium/complex]\n- Implementation Risk: [low/medium/high]\n- Integration Risk: [low/medium/high]\n- Mitigation Needs: [list risk mitigation requirements]\n\n**RECOMMENDED NEXT PHASE**: Plan Phase\n**ESTIMATED PLANNING TIME**: [X minutes]\n**READY FOR PLANNING**: [Yes/No - requires additional analysis]\n```\n\n## ANALYSIS SUCCESS CRITERIA:\n- ‚úÖ Business requirement clearly identified and validated\n- ‚úÖ Technical context comprehensively mapped\n- ‚úÖ Integration points identified and assessed\n- ‚úÖ Risk factors evaluated and documented\n- ‚úÖ Complexity level determined with evidence\n- ‚úÖ Clear deliverables provided for planning phase\n\n**NEXT STEP**: Use `/plan` command with analysis results to create detailed implementation strategy.",
			"category": "apdc",
			"tags": [
				"analysis",
				"apdc",
				"context",
				"assessment",
				"business-requirement",
				"technical-impact"
			]
		},
		{
			"name": "APDC Plan Phase",
			"trigger": "/plan",
			"description": "Detailed implementation strategy development with TDD phase mapping and success criteria",
			"command": "APDC PLAN PHASE - DETAILED IMPLEMENTATION STRATEGY:\n\n## MANDATORY PLANNING PROTOCOL\n\n### PHASE 1: TDD PHASE MAPPING AND TIMELINE ESTIMATION\n1. **MANDATORY**: TDD workflow breakdown:\n   ```bash\n   # HALT: Estimate TDD phases based on analysis\n   ./scripts/estimate-tdd-phases.sh [component] [complexity]\n   \n   # HALT: Validate implementation dependencies\n   ./scripts/validate-implementation-dependencies.sh [analysis-results]\n   ```\n\n2. **TDD PHASE BREAKDOWN**:\n   ```\n   üìã TDD IMPLEMENTATION PLAN:\n   \n   **ANALYSIS PHASE** (Already Complete):\n   - Duration: [X minutes completed]\n   - Deliverables: ‚úÖ Business context, technical assessment, risk evaluation\n   \n   **PLAN PHASE** (Current):\n   - Duration: [Y minutes estimated]\n   - Deliverables: Implementation strategy, success criteria, risk mitigation\n   \n   **DO-RED PHASE**:\n   - Duration: [Z minutes estimated]\n   - Actions: Write failing tests for [specific business requirements]\n   - Validation: Tests must fail initially, cover [X]% of business logic\n   \n   **DO-GREEN PHASE**:\n   - Duration: [W minutes estimated]\n   - Actions: Minimal implementation + mandatory main app integration\n   - Validation: Tests pass, component appears in cmd/ applications\n   \n   **DO-REFACTOR PHASE**:\n   - Duration: [V minutes estimated]\n   - Actions: Enhance implementation with sophisticated logic\n   - Validation: Improved code quality, preserved integration\n   \n   **CHECK PHASE**:\n   - Duration: [U minutes estimated]\n   - Actions: Comprehensive validation and confidence assessment\n   - Validation: Business requirements met, quality gates passed\n   ```\n\n### PHASE 2: SUCCESS CRITERIA DEFINITION\n1. **MANDATORY**: Measurable outcomes definition:\n   ```bash\n   # HALT: Define success criteria with measurable outcomes\n   ./scripts/define-success-criteria.sh [business-requirement] [technical-goals]\n   ```\n\n2. **SUCCESS CRITERIA MATRIX**:\n   ```\n   üéØ SUCCESS CRITERIA DEFINITION:\n   \n   **BUSINESS SUCCESS CRITERIA**:\n   - BR-XXX-XXX Requirements: [specific measurable outcomes]\n   - Business Value Delivered: [quantifiable benefits]\n   - User Experience Impact: [expected improvements]\n   - Performance Targets: [specific metrics to achieve]\n   \n   **TECHNICAL SUCCESS CRITERIA**:\n   - Build Success: All components compile without errors\n   - Test Coverage: [X]% unit test coverage achieved\n   - Integration Success: Component integrated in [N] main applications\n   - Code Quality: Lint score improved by [Y]%\n   - Performance: Response time within [Z]ms\n   \n   **VALIDATION CHECKPOINTS**:\n   - Checkpoint A: Type references validated ‚úÖ/‚ùå\n   - Checkpoint B: Function signatures validated ‚úÖ/‚ùå\n   - Checkpoint C: Import statements validated ‚úÖ/‚ùå\n   - Checkpoint D: Symbol dependencies validated ‚úÖ/‚ùå\n   - Business Integration: Main app usage confirmed ‚úÖ/‚ùå\n   ```\n\n### PHASE 3: RISK MITIGATION STRATEGY DEVELOPMENT\n1. **MANDATORY**: Risk mitigation planning:\n   ```bash\n   # HALT: Create risk mitigation strategies\n   ./scripts/create-risk-mitigation-plan.sh [identified-risks]\n   ```\n\n2. **RISK MITIGATION PLAN**:\n   ```\n   üõ°Ô∏è RISK MITIGATION STRATEGIES:\n   \n   **HIGH RISK FACTORS**:\n   - Risk: [specific risk from analysis]\n   - Probability: [low/medium/high]\n   - Impact: [low/medium/high]\n   - Mitigation: [specific prevention strategy]\n   - Contingency: [fallback plan if risk occurs]\n   \n   **MEDIUM RISK FACTORS**:\n   - Risk: [specific risk from analysis]\n   - Mitigation: [prevention strategy]\n   - Monitoring: [how to detect if risk materializes]\n   \n   **ROLLBACK PROCEDURES**:\n   - Rollback Trigger: [conditions requiring rollback]\n   - Rollback Steps: [specific recovery procedures]\n   - Recovery Time: [estimated time to restore]\n   - Data Protection: [how to preserve existing functionality]\n   ```\n\n### PHASE 4: RESOURCE AND DEPENDENCY PLANNING\n1. **MANDATORY**: Resource requirements and dependencies:\n   ```\n   üì¶ RESOURCE AND DEPENDENCY PLAN:\n   \n   **IMPLEMENTATION DEPENDENCIES**:\n   - Required Packages: [list of Go packages needed]\n   - External Services: [AI services, databases, etc.]\n   - Development Tools: [testing frameworks, validation scripts]\n   - Infrastructure: [Kind cluster, test environments]\n   \n   **SKILL REQUIREMENTS**:\n   - Go Development: [specific Go patterns needed]\n   - TDD Methodology: [specific TDD phases to execute]\n   - Business Domain: [domain knowledge required]\n   - Testing Strategy: [Ginkgo/Gomega, mock usage patterns]\n   \n   **TIME ALLOCATION**:\n   - Development Time: [X hours for implementation]\n   - Testing Time: [Y hours for comprehensive testing]\n   - Integration Time: [Z hours for main app integration]\n   - Validation Time: [W hours for quality assurance]\n   ```\n\n### PHASE 5: IMPLEMENTATION STRATEGY\n**MANDATORY OUTPUT FORMAT**:\n```\nüìã APDC IMPLEMENTATION PLAN:\n\n**IMPLEMENTATION STRATEGY**:\n- Approach: [enhance existing/create new/hybrid approach]\n- TDD Phase Sequence: Analysis ‚Üí Plan ‚Üí DO-RED ‚Üí DO-GREEN ‚Üí DO-REFACTOR ‚Üí Check\n- Integration Strategy: [how to integrate with main applications]\n- Testing Strategy: [unit/integration/e2e test approach]\n\n**TIMELINE ESTIMATION**:\n- Total Estimated Time: [X hours/days]\n- Critical Path: [sequence of dependent tasks]\n- Parallel Opportunities: [tasks that can be done simultaneously]\n- Buffer Time: [additional time for unexpected issues]\n\n**SUCCESS CRITERIA** (Measurable):\n- Business: [specific BR-XXX-XXX outcomes]\n- Technical: [build success, test coverage, integration]\n- Quality: [lint compliance, performance targets]\n- Validation: [all checkpoints passed]\n\n**RISK MITIGATION**:\n- High Priority Risks: [list with mitigation strategies]\n- Monitoring Plan: [how to detect issues early]\n- Rollback Plan: [recovery procedures if needed]\n- Contingency Options: [alternative approaches if primary fails]\n\n**RESOURCE REQUIREMENTS**:\n- Dependencies: [packages, services, tools needed]\n- Skills: [specific expertise required]\n- Time: [detailed time allocation by phase]\n- Infrastructure: [development and testing environments]\n\n**APPROVAL REQUIRED**: Do you approve this implementation plan? (YES/NO)\n**READY FOR EXECUTION**: [Yes/No - requires plan refinement]\n```\n\n## PLANNING SUCCESS CRITERIA:\n- ‚úÖ TDD phases mapped with realistic time estimates\n- ‚úÖ Success criteria defined with measurable outcomes\n- ‚úÖ Risk mitigation strategies developed for all identified risks\n- ‚úÖ Resource requirements clearly specified\n- ‚úÖ Implementation strategy provides clear execution path\n- ‚úÖ User approval obtained before proceeding to DO phase\n\n**NEXT STEP**: Use `/do` command with approved plan to begin controlled TDD execution.",
			"category": "apdc",
			"tags": [
				"planning",
				"apdc",
				"strategy",
				"tdd-mapping",
				"success-criteria",
				"risk-mitigation"
			]
		},
		{
			"name": "APDC Do Phase",
			"trigger": "/do",
			"description": "Controlled TDD execution with continuous validation and checkpoint-driven implementation",
			"command": "APDC DO PHASE - CONTROLLED TDD EXECUTION:\n\n## MANDATORY EXECUTION PROTOCOL\n\n### PRE-EXECUTION VALIDATION\n1. **MANDATORY**: Verify approved plan exists:\n   ```\n   üìã PRE-EXECUTION CHECKLIST:\n   - ‚úÖ Analysis phase completed with business requirement validation\n   - ‚úÖ Plan phase completed with approved implementation strategy\n   - ‚úÖ Success criteria defined with measurable outcomes\n   - ‚úÖ Risk mitigation strategies in place\n   - ‚úÖ User approval received for implementation plan\n   ```\n\n2. **EXECUTION READINESS CONFIRMATION**:\n   ```\n   üöÄ EXECUTION READINESS:\n   Business Requirement: [BR-XXX-XXX]\n   Implementation Strategy: [approved approach]\n   Estimated Duration: [total time from plan]\n   Risk Level: [low/medium/high]\n   Rollback Plan: [available ‚úÖ/‚ùå]\n   ```\n\n### DO-DISCOVERY PHASE (Analysis-Guided Component Research)\n**Duration**: 5-10 minutes\n**Purpose**: Execute planned component research with analysis insights\n\n1. **MANDATORY**: Analysis-guided discovery:\n   ```bash\n   # HALT: Execute planned component search\n   codebase_search \"existing [Component] implementations\" [target_directories]\n   \n   # HALT: Validate analysis predictions\n   grep -r \"[ComponentName]\" cmd/ pkg/workflow/ --include=\"*.go\"\n   ```\n\n2. **DISCOVERY VALIDATION**:\n   ```\n   üîç DISCOVERY RESULTS:\n   Analysis Prediction: [X similar components expected]\n   Actual Findings: [Y components found]\n   Prediction Accuracy: [accurate/needs adjustment]\n   Integration Points: [confirmed/additional found]\n   Decision: [enhance existing/create new - based on findings]\n   ```\n\n### DO-RED PHASE (Plan-Structured Test Creation)\n**Duration**: 10-15 minutes (from plan)\n**Purpose**: Write failing tests following planned test strategy\n\n1. **MANDATORY**: Plan-guided test creation:\n   ```bash\n   # HALT: Create tests following planned structure\n   # Import existing business interfaces per plan\n   # Call existing methods with expected signatures per plan\n   \n   # VALIDATION: Tests MUST fail initially\n   go test ./path/to/test.go 2>&1 | grep \"FAIL\" || echo \"‚ùå Tests not failing\"\n   ```\n\n2. **RED PHASE VALIDATION**:\n   ```\n   üî¥ RED PHASE CHECKPOINT:\n   Tests Created: [N test cases for BR-XXX-XXX]\n   Business Logic Covered: [X% of planned coverage]\n   Test Framework: [Ginkgo/Gomega BDD ‚úÖ/‚ùå]\n   Failure Status: [tests failing as expected ‚úÖ/‚ùå]\n   Plan Adherence: [following planned test strategy ‚úÖ/‚ùå]\n   ```\n\n### DO-GREEN PHASE (Plan-Guided Implementation)\n**Duration**: 15-20 minutes (from plan)\n**Purpose**: Minimal implementation + mandatory integration following plan\n\n1. **MANDATORY**: Plan-guided minimal implementation:\n   ```bash\n   # HALT: Implement minimal solution per plan\n   # Component MUST appear in cmd/ applications per plan\n   grep -r \"NewComponent\" cmd/ --include=\"*.go\" || echo \"‚ùå Missing integration\"\n   \n   # HALT: Validate plan compliance\n   ./scripts/validate-plan-compliance.sh [implementation] [approved-plan]\n   ```\n\n2. **GREEN PHASE VALIDATION**:\n   ```\n   üü¢ GREEN PHASE CHECKPOINT:\n   Implementation: [minimal solution created]\n   Tests Passing: [all tests now pass ‚úÖ/‚ùå]\n   Integration: [component integrated in main app ‚úÖ/‚ùå]\n   Plan Adherence: [following approved implementation strategy ‚úÖ/‚ùå]\n   Quality Gates: [build success, basic lint compliance ‚úÖ/‚ùå]\n   ```\n\n### DO-REFACTOR PHASE (Plan-Structured Enhancement)\n**Duration**: 20-30 minutes (from plan)\n**Purpose**: Enhance existing code following planned sophistication strategy\n\n1. **MANDATORY**: Plan-structured enhancement:\n   ```bash\n   # HALT: Enhance per planned sophistication level\n   # Integration MUST be preserved per plan\n   git diff HEAD~1 | grep \"^+type.*struct\" && echo \"‚ùå New types forbidden in REFACTOR\"\n   \n   # HALT: Validate enhancement scope per plan\n   ./scripts/validate-refactor-scope.sh [enhancement] [planned-scope]\n   ```\n\n2. **REFACTOR PHASE VALIDATION**:\n   ```\n   üîÑ REFACTOR PHASE CHECKPOINT:\n   Enhancement Level: [planned sophistication achieved ‚úÖ/‚ùå]\n   Code Quality: [improved metrics per plan ‚úÖ/‚ùå]\n   Integration Preserved: [main app usage maintained ‚úÖ/‚ùå]\n   Performance: [meets planned performance targets ‚úÖ/‚ùå]\n   Plan Adherence: [enhancement follows approved strategy ‚úÖ/‚ùå]\n   ```\n\n### CONTINUOUS VALIDATION THROUGHOUT DO PHASE\n**MANDATORY CHECKPOINTS** (executed continuously):\n\n```bash\n# CHECKPOINT A: Type Reference Validation (before each type reference)\nread_file [target_file]\ngrep -r \"type.*[TypeName].*struct\" pkg/ --include=\"*.go\"\n\n# CHECKPOINT B: Function Reference Validation (before each function call)\ngrep -r \"func.*[FunctionName]\" . --include=\"*.go\" -A 3\n\n# CHECKPOINT C: Import Validation (before using packages)\ngrep -r \"import.*[PackageName]\" [target_file]\n\n# CHECKPOINT D: Symbol Analysis (for any undefined symbols)\ncodebase_search \"[symbol] usage patterns and dependencies\"\ngrep -r \"[symbol]\" . --include=\"*.go\" -n\n```\n\n### REAL-TIME PROGRESS TRACKING\n**MANDATORY PROGRESS UPDATES**:\n```\n‚è±Ô∏è DO PHASE PROGRESS:\nCurrent Sub-Phase: [Discovery/RED/GREEN/REFACTOR]\nTime Elapsed: [X minutes of Y estimated]\nPlan Adherence: [on track/ahead/behind schedule]\nQuality Gates: [passed/pending/failed]\nRisk Status: [no issues/minor concerns/major issues]\nNext Checkpoint: [upcoming validation point]\n```\n\n### DO PHASE COMPLETION VALIDATION\n**MANDATORY FINAL CHECKS**:\n```bash\n# Build validation\ngo build ./...\n\n# Lint compliance\ngolangci-lint run --timeout=5m\n\n# Test execution\ngo test ./... -timeout=10m\n\n# Integration verification\ngrep -r \"[ComponentName]\" cmd/ --include=\"*.go\"\n\n# Plan compliance validation\n./scripts/validate-final-implementation.sh [implementation] [approved-plan]\n```\n\n### DO PHASE DELIVERABLES\n**MANDATORY OUTPUT FORMAT**:\n```\nüéØ DO PHASE COMPLETE:\n\n**IMPLEMENTATION SUMMARY**:\n- Business Requirement: [BR-XXX-XXX implemented]\n- Implementation Approach: [followed approved plan]\n- TDD Phases Executed: Discovery ‚Üí RED ‚Üí GREEN ‚Üí REFACTOR\n- Total Time: [X minutes of Y estimated]\n- Plan Adherence: [excellent/good/acceptable/needs improvement]\n\n**QUALITY VALIDATION**:\n- Build Status: [success ‚úÖ/failed ‚ùå]\n- Test Coverage: [X% achieved vs Y% planned]\n- Lint Compliance: [clean ‚úÖ/issues ‚ùå]\n- Integration Status: [main app integration confirmed ‚úÖ/‚ùå]\n- Performance: [meets targets ‚úÖ/needs optimization ‚ùå]\n\n**CHECKPOINT COMPLIANCE**:\n- Checkpoint A (Type References): [validated ‚úÖ/‚ùå]\n- Checkpoint B (Function References): [validated ‚úÖ/‚ùå]\n- Checkpoint C (Import Statements): [validated ‚úÖ/‚ùå]\n- Checkpoint D (Symbol Dependencies): [validated ‚úÖ/‚ùå]\n\n**RISK ASSESSMENT**:\n- Planned Risks: [mitigated successfully ‚úÖ/‚ùå]\n- Unexpected Issues: [none/minor/major]\n- Rollback Required: [no ‚úÖ/yes ‚ùå]\n- Quality Concerns: [none/minor/major]\n\n**READY FOR CHECK PHASE**: [Yes/No - requires additional work]\n```\n\n## DO PHASE SUCCESS CRITERIA:\n- ‚úÖ All TDD sub-phases executed following approved plan\n- ‚úÖ Continuous validation checkpoints passed\n- ‚úÖ Implementation matches planned approach and scope\n- ‚úÖ Quality gates met (build, test, lint, integration)\n- ‚úÖ Risk mitigation strategies successfully applied\n- ‚úÖ Real-time progress tracking maintained\n\n**NEXT STEP**: Use `/check` command to perform comprehensive result validation and confidence assessment.",
			"category": "apdc",
			"tags": [
				"implementation",
				"apdc",
				"tdd-execution",
				"controlled",
				"validation",
				"checkpoints"
			]
		},
		{
			"name": "APDC Check Phase",
			"trigger": "/check",
			"description": "Comprehensive result validation with business verification and confidence assessment",
			"command": "APDC CHECK PHASE - COMPREHENSIVE RESULT VALIDATION:\n\n## MANDATORY VALIDATION PROTOCOL\n\n### PRE-CHECK VALIDATION\n1. **MANDATORY**: Verify DO phase completion:\n   ```\n   üìã PRE-CHECK VERIFICATION:\n   - ‚úÖ Analysis phase completed with business context\n   - ‚úÖ Plan phase completed with approved strategy\n   - ‚úÖ DO phase completed with TDD implementation\n   - ‚úÖ All checkpoints passed during implementation\n   - ‚úÖ Quality gates met (build, test, lint)\n   ```\n\n### PHASE 1: BUSINESS REQUIREMENT FULFILLMENT VERIFICATION\n1. **MANDATORY**: Business requirement validation:\n   ```bash\n   # HALT: Validate business requirement fulfillment\n   ./scripts/validate-business-requirement-fulfillment.sh \"BR-XXX-XXX\" [implementation]\n   \n   # HALT: Verify business value delivery\n   codebase_search \"BR-XXX-XXX implementation validation\"\n   grep -r \"BR-XXX-XXX\" [implementation_files] --include=\"*.go\"\n   ```\n\n2. **BUSINESS VERIFICATION MATRIX**:\n   ```\n   üìä BUSINESS REQUIREMENT VERIFICATION:\n   \n   **PRIMARY BUSINESS REQUIREMENT**:\n   - Requirement ID: [BR-XXX-XXX]\n   - Requirement Description: [original business need]\n   - Implementation Status: [fully met/partially met/not met]\n   - Business Value Delivered: [quantifiable outcomes]\n   - User Impact: [positive/neutral/negative]\n   \n   **SECONDARY REQUIREMENTS** (if applicable):\n   - Additional BRs Addressed: [list any bonus requirements met]\n   - Cross-Requirement Impact: [effects on other business requirements]\n   - Integration Benefits: [additional value from main app integration]\n   \n   **BUSINESS VALIDATION SCORE**: [0-100%]\n   ```\n\n### PHASE 2: TECHNICAL VALIDATION COMPREHENSIVE CHECK\n1. **MANDATORY**: Complete technical validation:\n   ```bash\n   # HALT: Comprehensive build validation\n   go build ./...\n   \n   # HALT: Complete test suite execution\n   go test ./... -timeout=30m -coverprofile=coverage.out\n   \n   # HALT: Lint compliance verification\n   golangci-lint run --timeout=10m --max-issues-per-linter=0\n   \n   # HALT: Integration testing validation\n   ./scripts/run-integration-validation.sh [component]\n   ```\n\n2. **TECHNICAL VALIDATION MATRIX**:\n   ```\n   üîß TECHNICAL VALIDATION RESULTS:\n   \n   **BUILD AND COMPILATION**:\n   - Build Status: [success ‚úÖ/failed ‚ùå]\n   - Compilation Errors: [0 ‚úÖ/N errors ‚ùå]\n   - Import Resolution: [all resolved ‚úÖ/issues ‚ùå]\n   - Type Safety: [validated ‚úÖ/concerns ‚ùå]\n   \n   **TEST COVERAGE AND QUALITY**:\n   - Unit Test Coverage: [X% achieved]\n   - Integration Test Coverage: [Y% achieved]\n   - Test Framework Compliance: [Ginkgo/Gomega BDD ‚úÖ/‚ùå]\n   - Test Execution: [all pass ‚úÖ/N failures ‚ùå]\n   - Business Requirement Mapping: [all tests map to BRs ‚úÖ/‚ùå]\n   \n   **CODE QUALITY METRICS**:\n   - Lint Score: [clean ‚úÖ/N issues ‚ùå]\n   - Cyclomatic Complexity: [acceptable ‚úÖ/high ‚ùå]\n   - Code Duplication: [minimal ‚úÖ/excessive ‚ùå]\n   - Documentation Coverage: [adequate ‚úÖ/insufficient ‚ùå]\n   \n   **TECHNICAL VALIDATION SCORE**: [0-100%]\n   ```\n\n### PHASE 3: INTEGRATION CONFIRMATION\n1. **MANDATORY**: Main application integration verification:\n   ```bash\n   # HALT: Verify main application integration\n   grep -r \"[ComponentName]\" cmd/ --include=\"*.go\"\n   ./scripts/validate-main-app-integration.sh [component]\n   \n   # HALT: Validate integration patterns\n   codebase_search \"[ComponentType] integration patterns in main applications\"\n   ```\n\n2. **INTEGRATION CONFIRMATION MATRIX**:\n   ```\n   üîó INTEGRATION VERIFICATION:\n   \n   **MAIN APPLICATION INTEGRATION**:\n   - Component Usage in cmd/: [found in N applications ‚úÖ/not found ‚ùå]\n   - Integration Pattern: [follows established patterns ‚úÖ/‚ùå]\n   - Dependency Injection: [properly wired ‚úÖ/issues ‚ùå]\n   - Configuration Loading: [integrated ‚úÖ/missing ‚ùå]\n   \n   **CROSS-COMPONENT INTEGRATION**:\n   - Package Dependencies: [properly managed ‚úÖ/conflicts ‚ùå]\n   - Interface Compliance: [implements required interfaces ‚úÖ/‚ùå]\n   - Data Flow: [correct data flow patterns ‚úÖ/issues ‚ùå]\n   - Error Handling: [integrated error handling ‚úÖ/gaps ‚ùå]\n   \n   **INTEGRATION VALIDATION SCORE**: [0-100%]\n   ```\n\n### PHASE 4: PERFORMANCE IMPACT ASSESSMENT\n1. **MANDATORY**: Performance evaluation:\n   ```bash\n   # HALT: Performance impact assessment\n   ./scripts/assess-performance-impact.sh [before-metrics] [after-metrics]\n   \n   # HALT: Benchmark comparison\n   go test -bench=. -benchmem ./... > benchmark_results.txt\n   ```\n\n2. **PERFORMANCE ASSESSMENT MATRIX**:\n   ```\n   ‚ö° PERFORMANCE IMPACT ANALYSIS:\n   \n   **PERFORMANCE METRICS**:\n   - Response Time: [baseline vs current]\n   - Memory Usage: [baseline vs current]\n   - CPU Utilization: [baseline vs current]\n   - Throughput: [baseline vs current]\n   \n   **PERFORMANCE IMPACT**:\n   - Overall Impact: [improved/neutral/degraded]\n   - Critical Path Impact: [no impact ‚úÖ/minor impact/major impact ‚ùå]\n   - Resource Efficiency: [improved ‚úÖ/maintained/degraded ‚ùå]\n   - Scalability: [improved ‚úÖ/maintained/reduced ‚ùå]\n   \n   **PERFORMANCE VALIDATION SCORE**: [0-100%]\n   ```\n\n### PHASE 5: RULE COMPLIANCE CONFIRMATION\n1. **MANDATORY**: Comprehensive rule compliance check:\n   ```bash\n   # HALT: Rule compliance validation\n   ./scripts/validate-rule-compliance.sh [implementation] [affected-rules]\n   \n   # HALT: TDD methodology compliance\n   ./scripts/validate-tdd-methodology-compliance.sh [development-session]\n   \n   # HALT: APDC methodology compliance\n   ./scripts/validate-apdc-compliance.sh [full-cycle]\n   ```\n\n2. **RULE COMPLIANCE MATRIX**:\n   ```\n   üìã RULE COMPLIANCE VERIFICATION:\n   \n   **CORE METHODOLOGY COMPLIANCE**:\n   - TDD Methodology: [RED-GREEN-REFACTOR followed ‚úÖ/‚ùå]\n   - APDC Methodology: [Analysis-Plan-Do-Check executed ‚úÖ/‚ùå]\n   - Business Integration: [main app integration required ‚úÖ/‚ùå]\n   - Testing Strategy: [defense-in-depth pyramid followed ‚úÖ/‚ùå]\n   \n   **TECHNICAL RULE COMPLIANCE**:\n   - Go Coding Standards: [followed ‚úÖ/violations ‚ùå]\n   - Interface Validation: [proper interface usage ‚úÖ/‚ùå]\n   - AI/ML Guidelines: [followed if applicable ‚úÖ/‚ùå/N/A]\n   - Kubernetes Safety: [followed if applicable ‚úÖ/‚ùå/N/A]\n   \n   **RULE COMPLIANCE SCORE**: [0-100%]\n   ```\n\n### PHASE 6: CONFIDENCE ASSESSMENT GENERATION\n1. **MANDATORY**: Comprehensive confidence evaluation:\n   ```bash\n   # HALT: Generate confidence assessment\n   ./scripts/generate-confidence-assessment.sh [implementation] [validation-results]\n   ```\n\n2. **CONFIDENCE ASSESSMENT CALCULATION**:\n   ```\n   üéØ CONFIDENCE ASSESSMENT:\n   \n   **COMPONENT SCORES**:\n   - Business Validation: [X%]\n   - Technical Validation: [Y%]\n   - Integration Validation: [Z%]\n   - Performance Validation: [W%]\n   - Rule Compliance: [V%]\n   \n   **WEIGHTED CONFIDENCE CALCULATION**:\n   - Business (40%): [X% √ó 0.4 = A%]\n   - Technical (25%): [Y% √ó 0.25 = B%]\n   - Integration (20%): [Z% √ó 0.2 = C%]\n   - Performance (10%): [W% √ó 0.1 = D%]\n   - Compliance (5%): [V% √ó 0.05 = E%]\n   \n   **OVERALL CONFIDENCE**: [A + B + C + D + E = TOTAL%]\n   ```\n\n### CHECK PHASE DELIVERABLES\n**MANDATORY FINAL ASSESSMENT**:\n```\n‚úÖ APDC CHECK PHASE COMPLETE:\n\n**BUSINESS VERIFICATION**:\n- Business Requirement: [BR-XXX-XXX fully satisfied ‚úÖ/‚ùå]\n- Business Value: [quantified value delivered]\n- User Impact: [positive outcomes achieved]\n- Business Validation Score: [X%]\n\n**TECHNICAL VALIDATION**:\n- Build Status: [success ‚úÖ/issues ‚ùå]\n- Test Coverage: [X% unit, Y% integration, Z% e2e]\n- Code Quality: [lint clean ‚úÖ/N issues ‚ùå]\n- Technical Validation Score: [Y%]\n\n**INTEGRATION CONFIRMATION**:\n- Main App Integration: [confirmed in N applications ‚úÖ/‚ùå]\n- Cross-Component Integration: [validated ‚úÖ/issues ‚ùå]\n- Integration Validation Score: [Z%]\n\n**PERFORMANCE ASSESSMENT**:\n- Performance Impact: [improved/neutral/degraded]\n- Critical Metrics: [within acceptable ranges ‚úÖ/‚ùå]\n- Performance Validation Score: [W%]\n\n**RULE COMPLIANCE**:\n- Methodology Compliance: [APDC + TDD fully followed ‚úÖ/‚ùå]\n- Technical Standards: [all rules followed ‚úÖ/violations ‚ùå]\n- Rule Compliance Score: [V%]\n\n**OVERALL CONFIDENCE ASSESSMENT**: [TOTAL%]\n\n**DETAILED JUSTIFICATION**:\n[Comprehensive explanation of confidence rating including:\n- Implementation approach and business alignment\n- Technical quality and integration assessment\n- Risk factors and mitigation effectiveness\n- Validation thoroughness and methodology compliance\n- Areas of strength and potential concerns]\n\n**RECOMMENDATIONS FOR IMPROVEMENT** (if confidence < 90%):\n[Specific actionable recommendations to increase confidence]\n\n**APDC CYCLE STATUS**: [COMPLETE ‚úÖ/REQUIRES ITERATION ‚ùå]\n```\n\n## CHECK PHASE SUCCESS CRITERIA:\n- ‚úÖ Business requirement fulfillment comprehensively verified\n- ‚úÖ Technical validation completed with all quality gates\n- ‚úÖ Integration confirmation validated across all touchpoints\n- ‚úÖ Performance impact assessed and within acceptable ranges\n- ‚úÖ Rule compliance confirmed across all applicable standards\n- ‚úÖ Confidence assessment generated with detailed justification\n- ‚úÖ Overall confidence rating ‚â• 60% (minimum acceptable threshold)\n\n**APDC METHODOLOGY COMPLETE**: All four phases (Analysis-Plan-Do-Check) successfully executed with comprehensive validation and documentation.",
			"category": "apdc",
			"tags": [
				"validation",
				"apdc",
				"verification",
				"confidence-assessment",
				"business-validation",
				"technical-validation"
			]
		},
		{
			"name": "Complete APDC Cycle",
			"trigger": "/apdc-full",
			"description": "Execute complete Analysis-Plan-Do-Check cycle for comprehensive development workflow",
			"command": "COMPLETE APDC CYCLE - COMPREHENSIVE DEVELOPMENT WORKFLOW:\n\n## FULL APDC METHODOLOGY EXECUTION\n\n### APDC CYCLE OVERVIEW\n```\nüîÑ COMPLETE APDC DEVELOPMENT CYCLE:\n\n**PHASE 1: ANALYSIS** (5-15 minutes)\n‚îú‚îÄ‚îÄ Business requirement alignment analysis\n‚îú‚îÄ‚îÄ Technical impact assessment\n‚îú‚îÄ‚îÄ Integration point identification\n‚îî‚îÄ‚îÄ Risk and complexity evaluation\n\n**PHASE 2: PLAN** (10-20 minutes)\n‚îú‚îÄ‚îÄ TDD phase mapping and timeline estimation\n‚îú‚îÄ‚îÄ Success criteria definition with measurable outcomes\n‚îú‚îÄ‚îÄ Risk mitigation strategy development\n‚îî‚îÄ‚îÄ Resource and dependency planning\n\n**PHASE 3: DO** (Variable duration)\n‚îú‚îÄ‚îÄ DO-DISCOVERY: Analysis-guided component research\n‚îú‚îÄ‚îÄ DO-RED: Plan-structured test creation\n‚îú‚îÄ‚îÄ DO-GREEN: Plan-guided implementation + integration\n‚îî‚îÄ‚îÄ DO-REFACTOR: Plan-structured enhancement\n\n**PHASE 4: CHECK** (5-10 minutes)\n‚îú‚îÄ‚îÄ Business requirement fulfillment verification\n‚îú‚îÄ‚îÄ Technical validation comprehensive check\n‚îú‚îÄ‚îÄ Integration confirmation\n‚îú‚îÄ‚îÄ Performance impact assessment\n‚îú‚îÄ‚îÄ Rule compliance confirmation\n‚îî‚îÄ‚îÄ Confidence assessment generation\n```\n\n### MANDATORY APDC EXECUTION PROTOCOL\n\n#### PHASE 1: COMPREHENSIVE ANALYSIS\n**EXECUTE**: `/analyze` command functionality\n\n1. **Business Requirement Analysis**:\n   - Identify and validate business requirements (BR-XXX-XXX)\n   - Assess business value and current implementation status\n   - Evaluate business impact and expected outcomes\n\n2. **Technical Impact Assessment**:\n   - Analyze existing implementations and dependencies\n   - Identify integration points and architecture alignment\n   - Map dependency chains and affected components\n\n3. **Risk and Complexity Evaluation**:\n   - Assess complexity level and implementation risks\n   - Evaluate integration risks and performance implications\n   - Determine testing requirements and timeline estimates\n\n**ANALYSIS GATE**: Must complete with clear deliverables before proceeding to Plan\n\n#### PHASE 2: DETAILED PLANNING\n**EXECUTE**: `/plan` command functionality\n\n1. **TDD Phase Mapping**:\n   - Break down TDD workflow with realistic time estimates\n   - Map business requirements to specific TDD phases\n   - Validate implementation dependencies\n\n2. **Success Criteria Definition**:\n   - Define measurable business and technical outcomes\n   - Establish validation checkpoints and quality gates\n   - Set performance targets and compliance requirements\n\n3. **Risk Mitigation Strategy**:\n   - Develop specific mitigation strategies for identified risks\n   - Create rollback procedures and contingency plans\n   - Plan resource allocation and dependency management\n\n**PLANNING GATE**: Must receive user approval before proceeding to Do\n\n#### PHASE 3: CONTROLLED EXECUTION\n**EXECUTE**: `/do` command functionality\n\n1. **DO-DISCOVERY**: Execute analysis-guided component research\n2. **DO-RED**: Create failing tests following planned structure\n3. **DO-GREEN**: Implement minimal solution with mandatory integration\n4. **DO-REFACTOR**: Enhance implementation following planned sophistication\n\n**Continuous Validation**: All checkpoints (A, B, C, D) executed throughout\n\n**EXECUTION GATE**: Must meet all quality gates before proceeding to Check\n\n#### PHASE 4: COMPREHENSIVE VALIDATION\n**EXECUTE**: `/check` command functionality\n\n1. **Business Verification**: Confirm BR-XXX-XXX requirements fulfilled\n2. **Technical Validation**: Validate build, test, lint, and quality metrics\n3. **Integration Confirmation**: Verify main application integration\n4. **Performance Assessment**: Evaluate performance impact\n5. **Rule Compliance**: Confirm methodology and technical rule adherence\n6. **Confidence Assessment**: Generate comprehensive confidence rating\n\n**VALIDATION GATE**: Must achieve ‚â•60% confidence for cycle completion\n\n### APDC CYCLE MANAGEMENT\n\n#### PHASE TRANSITION CONTROLS\n```\nüö¶ PHASE TRANSITION GATES:\n\nAnalysis ‚Üí Plan:\n- ‚úÖ Business context clearly understood\n- ‚úÖ Technical impact comprehensively assessed\n- ‚úÖ Risk factors identified and evaluated\n- ‚úÖ Analysis deliverables complete\n\nPlan ‚Üí Do:\n- ‚úÖ Implementation strategy defined\n- ‚úÖ Success criteria established\n- ‚úÖ Risk mitigation strategies developed\n- ‚úÖ User approval received for plan\n\nDo ‚Üí Check:\n- ‚úÖ All TDD phases executed (Discovery/RED/GREEN/REFACTOR)\n- ‚úÖ Quality gates passed (build/test/lint/integration)\n- ‚úÖ Continuous validation checkpoints completed\n- ‚úÖ Implementation matches approved plan\n\nCheck ‚Üí Complete:\n- ‚úÖ Business requirements verified as fulfilled\n- ‚úÖ Technical validation passed all criteria\n- ‚úÖ Integration confirmed across touchpoints\n- ‚úÖ Confidence assessment ‚â•60% achieved\n```\n\n#### CYCLE MONITORING AND CONTROL\n```\nüìä APDC CYCLE PROGRESS TRACKING:\n\nCurrent Phase: [Analysis/Plan/Do/Check]\nPhase Progress: [X% complete]\nOverall Cycle Progress: [Y% complete]\nTime Elapsed: [Z minutes of W estimated]\nQuality Status: [on track/concerns/issues]\nRisk Status: [green/yellow/red]\nNext Gate: [upcoming validation checkpoint]\n```\n\n### EMERGENCY PROTOCOLS\n\n#### CYCLE INTERRUPTION HANDLING\n```\nüö® EMERGENCY PROTOCOLS:\n\n**PHASE FAILURE**:\n- HALT current phase execution\n- ANALYZE failure cause and impact\n- DETERMINE recovery strategy\n- ROLLBACK to last successful gate if needed\n- RESTART from appropriate phase with adjustments\n\n**QUALITY GATE FAILURE**:\n- STOP progression to next phase\n- IDENTIFY specific quality issues\n- IMPLEMENT corrective actions\n- RE-VALIDATE quality criteria\n- PROCEED only after gate criteria met\n\n**RISK MATERIALIZATION**:\n- ACTIVATE planned risk mitigation strategies\n- ASSESS impact on cycle timeline and quality\n- ADJUST plan and expectations as needed\n- COMMUNICATE changes to stakeholders\n- CONTINUE with modified approach\n```\n\n### APDC CYCLE COMPLETION\n**MANDATORY FINAL DELIVERABLES**:\n```\nüéØ APDC CYCLE COMPLETE:\n\n**CYCLE SUMMARY**:\n- Business Requirement: [BR-XXX-XXX successfully implemented]\n- Total Cycle Time: [X minutes/hours]\n- Methodology Compliance: [APDC fully executed ‚úÖ]\n- Quality Achievement: [all gates passed ‚úÖ]\n\n**PHASE OUTCOMES**:\n- Analysis: [comprehensive context understanding achieved]\n- Plan: [detailed strategy approved and executed]\n- Do: [TDD implementation completed with quality]\n- Check: [comprehensive validation passed]\n\n**FINAL CONFIDENCE ASSESSMENT**: [X% with detailed justification]\n\n**BUSINESS VALUE DELIVERED**:\n[Quantified business outcomes and user impact]\n\n**TECHNICAL ACHIEVEMENTS**:\n[Code quality, integration, and performance results]\n\n**LESSONS LEARNED**:\n[Key insights for future APDC cycles]\n\n**RECOMMENDATIONS**:\n[Suggestions for continuous improvement]\n```\n\n## APDC CYCLE SUCCESS CRITERIA:\n- ‚úÖ All four phases executed in sequence with proper gates\n- ‚úÖ Business requirements fully satisfied with measurable outcomes\n- ‚úÖ Technical quality meets or exceeds established standards\n- ‚úÖ Integration successfully completed across all touchpoints\n- ‚úÖ Methodology compliance maintained throughout cycle\n- ‚úÖ Overall confidence assessment ‚â•60% achieved\n- ‚úÖ Comprehensive documentation and deliverables provided\n\n**APDC METHODOLOGY MASTERY**: Complete systematic development approach ensuring quality, compliance, and business value delivery.",
			"category": "apdc",
			"tags": [
				"apdc-full",
				"complete-cycle",
				"methodology",
				"systematic",
				"comprehensive",
				"workflow"
			]
		}
	],
	"instructions": {
		"setup": "To use these shortcuts in Cursor:",
		"steps": [
			"1. Copy the command text from any shortcut above",
			"2. Open Cursor Settings (Cmd/Ctrl + ,)",
			"3. Go to 'Composer' or 'Custom Instructions' section",
			"4. Add new instruction with the trigger and command text",
			"5. Use the trigger (e.g., /investigate-build) in chat to activate"
		],
		"alternative": "Or simply copy-paste the command text directly into chat when needed"
	}
}