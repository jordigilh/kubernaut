---
alwaysApply: true
globs: "**/*,pkg/ai/**/*,test/**/*ai*"
description: "Core development methodology: principles, TDD phases, and AI-specific patterns"
---
# Core Development Methodology

## 🚨 **MANDATORY PRINCIPLES**

### Critical Decision Process
**MANDATORY**: Ask for input on ALL critical decisions including:
- Architecture changes and design patterns
- New dependencies or external integrations
- Performance trade-offs and optimization decisions
- Security implementations and access controls
- Refactoring that affects system complexity

**Format**: Provide recommendation with detailed justification when asking for input.

### Business Requirements Mandate
**MANDATORY**: Every code change must be backed by at least ONE business requirement (BR-XXX-XXX format).
- All tests must map to specific business requirements
- All implementation code must serve documented business needs
- No speculative or "nice to have" code without business backing
- Business requirements dictate functionality; technical patterns enable business logic

## 🧪 **APDC-Enhanced TDD Methodology - MANDATORY SEQUENCE**

### Analysis-Plan-Do-Check (APDC) Framework Integration
**PRINCIPLE**: Systematic development through structured phases that enhance TDD methodology

#### APDC Phase Overview
| Phase | Duration | Purpose | TDD Integration |
|-------|----------|---------|-----------------|
| **Analysis** | 5-15 min | Comprehensive context understanding | Enhances Discovery phase |
| **Plan** | 10-20 min | Detailed implementation strategy | Structures RED-GREEN-REFACTOR approach |
| **Do** | Variable | Controlled implementation execution | Executes TDD phases with validation |
| **Check** | 5-10 min | Comprehensive result validation | Extends TDD validation with business verification |

### Enhanced TDD Workflow - REQUIRED
1. **ANALYSIS**: Comprehensive context and impact assessment
2. **PLAN**: Detailed implementation strategy with TDD phase mapping
3. **DO-RED**: Write unit tests defining business contract (aim for 70%+ coverage)
4. **DO-GREEN**: Define business interfaces and minimal implementation
5. **DO-REFACTOR**: Enhance existing code with sophisticated logic
6. **CHECK**: Comprehensive validation and confidence assessment
7. **NEVER**: Use `Skip()` to avoid test failures or bypass APDC phases

### Defense-in-Depth Testing Requirements
**MANDATORY**: Follow pyramid testing strategy from [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc):
- **Unit Tests**: 70%+ coverage using real business logic with external mocks only
- **Integration Tests**: <20% coverage for component interactions requiring infrastructure
- **E2E Tests**: <10% coverage for critical user journeys only

## 🔍 **APDC Phase Specifications - MANDATORY SEQUENCE**

### Analysis Phase - COMPREHENSIVE CONTEXT UNDERSTANDING
**Duration**: 5-15 minutes
**Purpose**: Systematic evaluation before any implementation
**Validation**: `./scripts/validate-apdc-analysis.sh [component] [business-requirement]`

#### Analysis Phase Requirements
```bash
# Business requirement alignment analysis
grep -r "BR-[A-Z]+-[0-9]+" docs/requirements/ --include="*.md"
codebase_search "business requirement [BR-XXX-XXX] existing implementations"

# Technical impact assessment
codebase_search "existing [ComponentType] implementations and dependencies"
grep -r "[ComponentName]" cmd/ pkg/ test/ --include="*.go" -c

# Integration point identification
grep -r "New[ComponentType]\|Create[ComponentType]" cmd/ --include="*.go"

# Risk and complexity evaluation
go mod graph | grep [target_package]
./scripts/analyze-dependency-impact.sh [component]
```

#### Analysis Deliverables - MANDATORY
1. **Business Context**: BR-XXX-XXX alignment and business value assessment
2. **Technical Context**: Existing implementations, dependencies, integration points
3. **Impact Assessment**: Files affected, cascade effects, performance implications
4. **Risk Evaluation**: Complexity level, potential breaking changes, mitigation needs

### Plan Phase - DETAILED IMPLEMENTATION STRATEGY
**Duration**: 10-20 minutes
**Purpose**: Structured approach to implementation with clear success criteria
**Validation**: `./scripts/validate-apdc-plan.sh [analysis-results] [implementation-strategy]`

#### Plan Phase Requirements
```bash
# TDD phase mapping and timeline estimation
./scripts/estimate-tdd-phases.sh [component] [complexity]

# Resource and dependency planning
./scripts/validate-implementation-dependencies.sh [plan]

# Success criteria definition with measurable outcomes
./scripts/define-success-criteria.sh [business-requirement] [technical-goals]

# Risk mitigation strategy development
./scripts/create-risk-mitigation-plan.sh [identified-risks]
```

#### Plan Deliverables - MANDATORY
1. **Implementation Strategy**: TDD phase breakdown with specific actions
2. **Timeline Estimation**: Realistic duration for each phase
3. **Success Criteria**: Measurable outcomes and validation checkpoints
4. **Risk Mitigation**: Specific strategies for identified risks
5. **Rollback Plan**: Recovery procedures if implementation fails

### Do Phase - CONTROLLED TDD EXECUTION
**Duration**: Variable (based on complexity)
**Purpose**: Systematic implementation following TDD methodology with continuous validation
**Validation**: Continuous checkpoint validation throughout execution

#### Enhanced TDD Phase Decision Matrix
| Phase | Duration | Action | APDC Integration | Validation Tool |
|-------|----------|--------|------------------|----------------|
| **DO-DISCOVERY** | 5-10 min | Execute planned component research | Analysis-guided search | `codebase_search "existing [Component] implementations"` |
| **DO-RED** | 10-15 min | Write failing tests per plan | Plan-structured test creation | `./scripts/phase2-red-validation.sh` |
| **DO-GREEN** | 15-20 min | Minimal implementation + integration | Plan-guided implementation | `./scripts/phase3-green-validation.sh` |
| **DO-REFACTOR** | 20-30 min | Enhance existing code per plan | Plan-structured enhancement | `./scripts/phase4-refactor-validation.sh` |

### Check Phase - COMPREHENSIVE RESULT VALIDATION
**Duration**: 5-10 minutes
**Purpose**: Systematic verification of implementation quality and business alignment
**Validation**: `./scripts/validate-apdc-results.sh [implementation] [success-criteria]`

#### Check Phase Requirements
```bash
# Business requirement fulfillment verification
./scripts/validate-business-requirement-fulfillment.sh "BR-XXX-XXX" [implementation]

# Integration testing validation
./scripts/run-integration-validation.sh [component]

# Performance impact assessment
./scripts/assess-performance-impact.sh [before-metrics] [after-metrics]

# Rule compliance confirmation
./scripts/validate-rule-compliance.sh [implementation] [affected-rules]

# Confidence assessment generation
./scripts/generate-confidence-assessment.sh [implementation] [validation-results]
```

#### Check Deliverables - MANDATORY
1. **Business Verification**: Confirmation that BR-XXX-XXX requirements are met
2. **Technical Validation**: Build success, test passage, lint compliance
3. **Integration Confirmation**: Main application integration verified
4. **Performance Assessment**: Impact on system performance evaluated
5. **Confidence Rating**: 60-100% confidence with detailed justification

#### Discovery Phase - MANDATORY
```bash
# Component research before creation
codebase_search "existing [ComponentType] implementations in pkg/"
grep -r "[Component]" cmd/ pkg/workflow/ --include="*.go"

# Decision point: enhance vs create (requires justification)
```

#### TDD RED Phase - MANDATORY
```bash
# Import existing business interfaces
# Call existing methods with expected signatures
# Validation: Tests MUST fail initially
go test ./path/to/test.go 2>&1 | grep "FAIL" || echo "❌ Tests not failing"
```

#### TDD GREEN Phase - MANDATORY
```bash
# Minimal implementation + MANDATORY integration
# Component MUST appear in cmd/ applications
grep -r "NewComponent" cmd/ --include="*.go" || echo "❌ Missing integration"
```

#### TDD REFACTOR Phase - MANDATORY
```bash
# Enhance existing code only (NO new types/methods/files)
# Integration MUST be preserved
git diff HEAD~1 | grep "^+type.*struct" && echo "❌ New types forbidden in REFACTOR"
```

## 🤖 **AI/ML Specific TDD - COMPREHENSIVE METHODOLOGY**

### AI TDD Phases

#### AI Discovery Phase (5-10 min)
**Action**: `./scripts/ai-component-discovery.sh ComponentName`
**Rule**: Search existing AI interfaces before creating new
**Mandatory Checks**:
```bash
# Check existing AI interfaces
grep -r "Client.*interface" pkg/ai/ --include="*.go"
# Check main app AI usage
grep -r "AI\|LLM\|Holmes" cmd/ --include="*.go"
# Decision point: enhance existing vs create new AI component
```

#### AI RED Phase (15-20 min)
**Rule**: Import existing AI interfaces (`pkg/ai/llm.Client`)
**Forbidden**: Creating new AI interfaces
**Validation**: `./scripts/validate-ai-development.sh red`
**AI-Specific RED Pattern**:
```go
// ✅ CORRECT AI RED: Uses existing AI interface
var _ = Describe("AI Context Optimization", func() {
    var (
        llmClient llm.Client  // Existing interface
        ctx       context.Context
    )

    BeforeEach(func() {
        llmClient = testutil.NewMockLLMClient() // Existing factory
        ctx = context.Background()
    })

    It("should optimize context using AI analysis", func() {
        // Call existing AI interface method
        analysis, err := llmClient.AnalyzeContext(ctx, "test content")
        Expect(err).ToNot(HaveOccurred())
        Expect(analysis.Quality).To(BeNumerically(">", 0.8))
    })
})
```

#### AI GREEN Phase (20-25 min)
**Rule**: Enhance existing AI client (e.g., `ClientImpl`)
**Integration**: Add to main app (`cmd/*/main.go`)
**Forbidden**: New AI service files
**Validation**: `./scripts/validate-ai-development.sh green`
**AI-Specific GREEN Pattern**:
```go
// ✅ CORRECT AI GREEN: Enhance existing AI client
// In pkg/ai/llm/client.go
type Client interface {
    // ... existing methods ...
    AnalyzeContext(ctx context.Context, content string) (*ContextAnalysis, error) // ADD TO EXISTING
}

type ClientImpl struct {
    // ... existing fields ...
}

func (c *ClientImpl) AnalyzeContext(ctx context.Context, content string) (*ContextAnalysis, error) {
    // Minimal implementation to pass tests
    return &ContextAnalysis{Quality: 0.8}, nil
}
```

#### AI REFACTOR Phase (25-35 min)
**Rule**: Enhance same AI methods tests call
**REFACTOR NEVER MEANS**: Create new parallel/additional AI code
**Forbidden**: New AI types, files, interfaces
**Validation**: `./scripts/validate-ai-development.sh refactor`
**AI-Specific REFACTOR Focus**:
```go
// ✅ CORRECT AI REFACTOR: Enhance existing method
func (c *ClientImpl) AnalyzeContext(ctx context.Context, content string) (*ContextAnalysis, error) {
    // Enhanced implementation with sophisticated logic
    tokens := c.tokenizer.Tokenize(content)
    embeddings := c.embeddingGenerator.Generate(tokens)
    quality := c.qualityAnalyzer.CalculateQuality(embeddings)

    return &ContextAnalysis{
        Quality: quality,
        TokenCount: len(tokens),
        OptimizationSuggestions: c.generateSuggestions(embeddings),
    }, nil
}
```

### AI Integration Conflict Resolution
**When AI rules conflict with general TDD**:
1. **AI Discovery** overrides general component discovery (AI-specific search patterns)
2. **AI Interface Reuse** overrides new interface creation (use `pkg/ai/llm.Client`)
3. **AI Client Enhancement** overrides new service creation (enhance existing clients)
4. **AI REFACTOR** focuses on method enhancement, not structural changes

### AI Integration Pattern
```go
// cmd/kubernaut/main.go
llmClient := llm.NewClient(config.LLM)
workflowEngine.SetLLMClient(llmClient)
processor := processor.New(llmClient, deps...)
```

### AI Mock Usage Decision Matrix
| Component | Action |
|-----------|--------|
| **External AI APIs** (HolmesGPT, OpenAI) | MOCK |
| **AI Business Logic** (analysis algorithms) | REAL |
| **Error Simulation** | MOCK |
| **Performance Testing** | MOCK |

## 💻 **Code Quality Standards**

### Error Handling - MANDATORY
- **ALWAYS** handle errors, never ignore them
- **ALWAYS** add log entry for every error
- Use structured error types from [internal/errors/](mdc:internal/errors/)

### Type System Guidelines
- **AVOID** using `any` or `interface{}` unless absolutely necessary
- **ALWAYS** use structured field values with specific types
- **AVOID** local type definitions to resolve import cycles
- Use shared types from [pkg/shared/types/](mdc:pkg/shared/types/) instead

### Code Integration Requirements
- **MANDATORY**: Integrate all new business code with main code
- Remove any code not backed by business requirements
- Ensure seamless integration with existing architecture

## 🚨 **MANDATORY REAL-TIME INTEGRATION CHECKPOINTS**

### **CHECKPOINT 1: Before Creating ANY New Type**
**TRIGGER**: About to type `type NewComponent struct` or `func NewComponent`
**MANDATORY ACTION**:
```bash
# HALT: Run this command BEFORE creating new type
grep -r "NewComponent\|ComponentName" cmd/ pkg/workflow/ pkg/processor/ pkg/api/
# RULE: If ZERO results, ask "Why isn't this enhancing existing code?"
```

### **CHECKPOINT 2: During TDD GREEN Phase**
**TRIGGER**: Tests are passing (GREEN phase complete)
**MANDATORY ACTION**:
```bash
# HALT: Verify integration BEFORE proceeding to REFACTOR
find cmd/ -name "*.go" -exec grep -l "YourNewComponent" {} \;
# RULE: Must show at least ONE main application file, or STOP and integrate
```

### **CHECKPOINT 3: After ANY Sophisticated Enhancement**
**TRIGGER**: Adding complex algorithms, ML features, or sophisticated logic
**MANDATORY ACTION**:
```bash
# HALT: Check main app instantiation
grep -r "New.*Optimizer\|New.*Engine\|New.*Builder" cmd/ --include="*.go"
# RULE: New sophisticated code MUST appear in main application startup
```

### **AUTOMATIC VIOLATION DETECTION**
Add to pre-commit hook:
```bash
#!/bin/bash
# Auto-detect orphaned business code
SOPHISTICATED_TYPES=$(grep -r "type.*Optimizer\|type.*Engine\|type.*Analyzer" pkg/ --include="*.go" | grep -v "_test.go")
for type_def in $SOPHISTICATED_TYPES; do
    TYPE_NAME=$(echo $type_def | grep -o "type [A-Za-z]*" | cut -d' ' -f2)
    MAIN_USAGE=$(grep -r "$TYPE_NAME" cmd/ --include="*.go" | wc -l)
    if [ "$MAIN_USAGE" -eq 0 ]; then
        echo "❌ VIOLATION: Sophisticated type $TYPE_NAME not integrated in main applications"
        exit 1
    fi
done
```

## 📋 **Anti-Patterns - FORBIDDEN**

### TDD Phase Violations
- **Discovery Skip**: Creating without searching existing → Use `codebase_search` first
- **RED Skip**: Implementation without failing tests → Write tests first
- **GREEN Complexity**: Sophisticated logic in GREEN → Keep minimal, enhance in REFACTOR
- **REFACTOR Creation**: New types in REFACTOR → Enhance existing only
- **Integration Delay**: Component not integrated in GREEN → MANDATORY integration

### AI-Specific Anti-Patterns
- Creating parallel AI components during REFACTOR
- AI components only used in tests
- Hardcoded AI endpoints
- AI-only testing without business validation

### Testing Anti-Patterns
- **NULL-TESTING**: Weak assertions (not nil, > 0, empty checks)
- **IMPLEMENTATION TESTING**: Testing how instead of what business outcome
- **MOCK OVERUSE**: In integration tests - use real components when possible

## 🎯 **Completion Requirements**

### Post-Development Checklist - MANDATORY
After completing any development task:

1. **Build Validation**: Code builds without errors from changes made
2. **Lint Compliance**: No new lint errors (unusedparam, unusedfunc, etc.)
3. **Business Integration**: Provide confidence assessment of business code integration
4. **Enhancement Proposals**: Suggest improvements with ≥60% confidence level

### Confidence Assessment Format - REQUIRED
Provide BOTH:
- **Simple Percentage**: 60-100% confidence rating
- **Detailed Justification**: Including risks, assumptions, and validation approach

Example:
```
Confidence Assessment: 85%
Justification: Implementation follows established patterns in pkg/workflow/engine/
and integrates cleanly with existing HolmesGPT client. Risk: Minor performance
impact on high-alert scenarios. Validation: Unit tests cover 90% of edge cases.
```

## 🔧 **APDC-Enhanced Validation Commands**

### APDC Phase Validation
```bash
# Analysis phase validation
./scripts/validate-apdc-analysis.sh [component] [business-requirement]
./scripts/analyze-dependency-impact.sh [component]
./scripts/assess-business-alignment.sh "BR-XXX-XXX" [component]

# Plan phase validation
./scripts/validate-apdc-plan.sh [analysis-results] [implementation-strategy]
./scripts/estimate-tdd-phases.sh [component] [complexity]
./scripts/validate-implementation-dependencies.sh [plan]

# Do phase validation (Enhanced TDD)
./scripts/phase2-red-validation.sh test_file.go      # DO-RED phase
./scripts/phase3-green-validation.sh component_name  # DO-GREEN phase
./scripts/phase4-refactor-validation.sh             # DO-REFACTOR phase

# Check phase validation
./scripts/validate-apdc-results.sh [implementation] [success-criteria]
./scripts/validate-business-requirement-fulfillment.sh "BR-XXX-XXX" [implementation]
./scripts/assess-performance-impact.sh [before-metrics] [after-metrics]
./scripts/generate-confidence-assessment.sh [implementation] [validation-results]
```

### Complete APDC Workflow Validation
```bash
# Full APDC cycle validation
./scripts/validate-apdc-cycle.sh [component] "BR-XXX-XXX"

# APDC compliance check
./scripts/check-apdc-compliance.sh [development-session]

# Business requirements validation (Enhanced)
./scripts/validate-tdd-completeness.sh "BR-XXX-XXX"
./scripts/validate-apdc-business-alignment.sh "BR-XXX-XXX"

# Integration validation (Enhanced)
./scripts/run-integration-validation.sh
./scripts/validate-main-app-integration.sh [component]
```

### AI-Specific APDC Validation
```bash
# AI component discovery (APDC-enhanced)
./scripts/ai-component-discovery.sh ComponentName
./scripts/validate-ai-apdc-analysis.sh [ai-component] [business-requirement]

# AI development phase validation (APDC-integrated)
./scripts/validate-ai-development.sh <phase>  # red, green, refactor
./scripts/validate-ai-apdc-cycle.sh [ai-component] "BR-AI-XXX"
```

## ⚡ **APDC-Enhanced Quick Reference Checklist**

### Before any code submission - APDC Compliance:

#### Analysis Phase Completion:
- [ ] Business requirement mapped and analyzed (BR-XXX-XXX)
- [ ] Technical impact assessment completed
- [ ] Integration points identified and validated
- [ ] Risk and complexity evaluation documented

#### Plan Phase Completion:
- [ ] Implementation strategy defined with TDD phase mapping
- [ ] Timeline estimation and resource planning completed
- [ ] Success criteria established with measurable outcomes
- [ ] Risk mitigation strategies documented
- [ ] User approval received for implementation plan

#### Do Phase Completion:
- [ ] APDC-enhanced TDD workflow followed (Analysis → Plan → DO-RED → DO-GREEN → DO-REFACTOR)
- [ ] All tests written first, then implementation
- [ ] All errors handled and logged
- [ ] No lint or compilation errors
- [ ] Code integrated with main business logic
- [ ] Continuous validation checkpoints passed

#### Check Phase Completion:
- [ ] Business requirement fulfillment verified
- [ ] Integration testing validation completed
- [ ] Performance impact assessed
- [ ] Rule compliance confirmed
- [ ] Confidence assessment provided (60-100% with justification)
- [ ] Critical decisions escalated if needed
- [ ] AI components follow AI-specific APDC phases (if applicable)

### APDC Methodology Compliance:
- [ ] All four APDC phases executed in sequence
- [ ] Phase deliverables completed and documented
- [ ] Validation tools executed for each phase
- [ ] Business alignment maintained throughout process

## 🔗 **Integration Points**

This rule establishes mandatory methodology that controls:
- [01-project-structure.mdc](mdc:.cursor/rules/01-project-structure.mdc) - Architecture navigation
- [02-technical-implementation.mdc](mdc:.cursor/rules/02-technical-implementation.mdc) - Technical patterns
- [03-testing-strategy.mdc](mdc:.cursor/rules/03-testing-strategy.mdc) - Testing framework
- [05-kubernetes-safety.mdc](mdc:.cursor/rules/05-kubernetes-safety.mdc) - Safety patterns

**Priority**: FOUNDATIONAL - all other rules operate within this methodology framework