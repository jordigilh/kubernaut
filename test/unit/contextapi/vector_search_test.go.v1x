package contextapi

import (
	"context"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/jordigilh/kubernaut/pkg/contextapi/models"
	"github.com/jordigilh/kubernaut/pkg/contextapi/sqlbuilder"
)

var _ = Describe("Vector Search", func() {
	// BR-CONTEXT-002: Semantic search on embeddings

	var (
		builder *sqlbuilder.Builder
		_       = context.Background() // ctx unused in skipped tests
	)

	BeforeEach(func() {
		builder = sqlbuilder.NewBuilder()
	})

	Context("Semantic Search Query Building", func() {
		It("should build semantic search query with vector similarity", func() {
			// BR-CONTEXT-002: Semantic search using pgvector
			embedding := make([]float32, 384)
			for i := range embedding {
				embedding[i] = 0.1 // Sample embedding vector
			}

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, args, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("embedding <=>"))
			Expect(sql).To(ContainSubstring("ORDER BY distance"))
			Expect(args).To(HaveLen(2)) // embedding + limit
		})

		It("should handle similarity threshold filtering", func() {
			// BR-CONTEXT-002: Filter results by similarity threshold
			embedding := make([]float32, 384)
			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("embedding IS NOT NULL"))
			Expect(sql).To(ContainSubstring("LIMIT"))
		})

		It("should combine semantic search with namespace filter", func() {
			// BR-CONTEXT-002: Semantic search with namespace filtering
			// BR-CONTEXT-004: Namespace filtering
			embedding := make([]float32, 384)
			namespace := "production"

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Namespace:      &namespace,
				Limit:          10,
			}

			sql, args, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("namespace ="))
			Expect(args).To(HaveLen(3)) // embedding + namespace + limit
		})

		It("should combine semantic search with severity filter", func() {
			// BR-CONTEXT-002: Semantic search with severity filtering
			embedding := make([]float32, 384)
			severity := "critical"

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Severity:       &severity,
				Limit:          5,
			}

			sql, args, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("severity ="))
			Expect(args).To(HaveLen(3)) // embedding + severity + limit
		})

		It("should validate embedding dimension", func() {
			// BR-CONTEXT-002: Validate 384-dimensional embeddings
			wrongSizeEmbedding := make([]float32, 256) // Wrong size

			params := &models.SemanticSearchParams{
				QueryEmbedding: wrongSizeEmbedding,
				Limit:          10,
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrInvalidEmbeddingDimension))
		})
	})

	Context("Vector Similarity Thresholds", func() {
		// These tests validate similarity scoring behavior
		// In actual implementation, these would test against real pgvector results

		It("should order results by similarity (closest first)", func() {
			// BR-CONTEXT-002: Most similar incidents first
			embedding := make([]float32, 384)
			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("ORDER BY distance"))
			// Note: <=> operator returns distance (lower = more similar)
			// ORDER BY distance ASC means most similar first
		})

		It("should handle empty embedding vector", func() {
			// BR-CONTEXT-002: Validate non-empty embedding
			params := &models.SemanticSearchParams{
				QueryEmbedding: []float32{}, // Empty
				Limit:          10,
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrMissingEmbedding))
		})

		It("should respect result limit", func() {
			// BR-CONTEXT-002: Limit number of similar results
			embedding := make([]float32, 384)

			// Test default limit (10)
			params1 := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          0, // Should default to 10
			}

			err := params1.Validate()
			Expect(err).ToNot(HaveOccurred())
			Expect(params1.Limit).To(Equal(10))

			// Test custom limit
			params2 := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          25,
			}

			sql, args, err := builder.BuildSemanticSearchQuery(params2)
			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("LIMIT"))
			Expect(args[len(args)-1]).To(Equal(25))
		})

		It("should reject limit exceeding maximum (50)", func() {
			// BR-CONTEXT-002: Maximum 50 results per semantic search
			embedding := make([]float32, 384)

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          100, // Too large
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrLimitTooLarge))
		})

		It("should handle normalized vs unnormalized embeddings", func() {
			// BR-CONTEXT-002: pgvector cosine distance with <=> operator
			// Note: pgvector expects embeddings to be stored normalized
			// The <=> operator computes cosine distance

			embedding := make([]float32, 384)
			// Simulate normalized embedding (length = 1)
			for i := range embedding {
				embedding[i] = 0.01 // Small values that sum to ~1 when normalized
			}

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			Expect(sql).To(ContainSubstring("embedding <=>"))
			// pgvector <=> operator handles cosine similarity calculation
		})
	})

	Context("Vector Search Performance", func() {
		It("should use HNSW index for fast vector search", func() {
			// BR-CONTEXT-002: Fast semantic search using HNSW index
			// Note: Index usage is a database concern, but query structure matters

			embedding := make([]float32, 384)
			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			// Query structure should allow index usage:
			// 1. WHERE embedding IS NOT NULL (index scan)
			// 2. ORDER BY distance (index order)
			// 3. LIMIT (early termination)
			Expect(sql).To(ContainSubstring("WHERE embedding IS NOT NULL"))
		})

		It("should handle large result sets efficiently", func() {
			// BR-CONTEXT-002: Efficient retrieval even with many similar results
			embedding := make([]float32, 384)

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          50, // Maximum allowed
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			// LIMIT clause ensures we don't fetch more than needed
			Expect(sql).To(ContainSubstring("LIMIT"))
		})
	})

	Context("Vector Search Edge Cases", func() {
		It("should handle nil embedding pointer", func() {
			// BR-CONTEXT-002: Validate embedding presence
			params := &models.SemanticSearchParams{
				QueryEmbedding: nil,
				Limit:          10,
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrMissingEmbedding))
		})

		It("should handle zero limit", func() {
			// BR-CONTEXT-002: Default to 10 results when limit not specified
			embedding := make([]float32, 384)

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          0,
			}

			err := params.Validate()
			Expect(err).ToNot(HaveOccurred())
			Expect(params.Limit).To(Equal(10)) // Default applied
		})

		It("should handle negative limit", func() {
			// BR-CONTEXT-002: Reject invalid limit values
			embedding := make([]float32, 384)

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          -5,
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrInvalidLimit))
		})

		It("should handle invalid severity value in semantic search", func() {
			// BR-CONTEXT-002: Validate severity filter
			embedding := make([]float32, 384)
			invalidSeverity := "super-critical" // Invalid

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Severity:       &invalidSeverity,
				Limit:          10,
			}

			_, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).To(HaveOccurred())
			Expect(err).To(Equal(models.ErrInvalidSeverity))
		})

		It("should handle all-zero embedding vector", func() {
			// BR-CONTEXT-002: Handle edge case of zero vector
			// Note: Zero vector has no semantic meaning but should not crash
			embedding := make([]float32, 384) // All zeros

			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			sql, _, err := builder.BuildSemanticSearchQuery(params)

			Expect(err).ToNot(HaveOccurred())
			// Query should build successfully
			// Database may return no results or all results with equal distance
			Expect(sql).To(ContainSubstring("embedding <=>"))
		})
	})

	Context("Integration with Cached Executor", func() {
		It("should cache semantic search results", func() {
			// BR-CONTEXT-002: Semantic search results
			// BR-CONTEXT-003: Multi-tier caching
			// Note: This will be tested with real CachedExecutor in integration tests

			embedding := make([]float32, 384)
			params := &models.SemanticSearchParams{
				QueryEmbedding: embedding,
				Limit:          10,
			}

			// Verify params are cacheable (have Validate method)
			err := params.Validate()
			Expect(err).ToNot(HaveOccurred())

			// Cache key generation tested in cache_test.go
		})
	})
})

// Helper function to create sample incident with embedding
// Note: In production, embeddings are generated by Data Storage Service
// Context API only queries pre-existing embeddings
func createIncidentWithEmbedding(id int64, namespace string, embedding []float32) *models.IncidentEvent {
	now := time.Now()
	return &models.IncidentEvent{
		ID:                   id,
		Name:                 "test-alert",
		Namespace:            namespace,
		Phase:                "completed",
		Status:               "success",
		Severity:             "critical",
		AlertFingerprint:     "fp-001",
		RemediationRequestID: "req-001",
		Embedding:            embedding,
		CreatedAt:            now,
		UpdatedAt:            now,
	}
}

// Helper function to create sample embedding vector for testing
// Note: Context API doesn't generate embeddings - these are test fixtures only
// In production, embeddings come from Data Storage Service via remediation_audit table
func createSampleEmbedding() []float32 {
	embedding := make([]float32, 384)
	// Create a simple pattern for testing
	for i := range embedding {
		embedding[i] = float32(i%10) * 0.1
	}
	return embedding
}
