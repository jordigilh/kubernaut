/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package adapters

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/jordigilh/kubernaut/pkg/gateway/middleware"
	"github.com/jordigilh/kubernaut/pkg/gateway/types"
)

// KubernetesEventAdapter converts Kubernetes Event API signals to NormalizedSignal
//
// Kubernetes Events are generated by the K8s control plane and controllers to record
// state changes and issues. This adapter handles:
// - Warning events (OOMKilled, FailedScheduling, BackOff, etc.)
// - Error-level events (container crashes, resource conflicts)
// - Normal events are FILTERED OUT (informational only, no remediation needed)
//
// Business Value:
// - Complements Prometheus alerts with cluster-internal failures
// - Provides immediate notification (no scrape interval delay)
// - Enables remediation for events Prometheus doesn't detect (scheduler issues, API server errors)
//
// Design Decision: Event API vs Watch
// - V1: HTTP POST endpoint /api/v1/signals/kubernetes-event (consistent with Prometheus adapter)
// - V2: Consider watch-based ingestion if needed (more complex, real-time)
// OwnerResolver resolves the top-level controller owner of a Kubernetes resource.
//
// This interface enables the KubernetesEventAdapter to resolve the owner chain
// (e.g., Pod -> ReplicaSet -> Deployment) for fingerprinting purposes.
// By fingerprinting at the owner level (e.g., Deployment), events from different
// pods of the same Deployment are correctly deduplicated.
//
// Business Requirement: Prevents duplicate remediation workflows for events that
// originate from the same root cause (same Deployment/StatefulSet/DaemonSet).
type OwnerResolver interface {
	// ResolveTopLevelOwner traverses the ownerReference chain to find the top-level
	// controller (e.g., Deployment, StatefulSet, DaemonSet).
	//
	// Parameters:
	// - ctx: Context for cancellation/timeout
	// - namespace: Resource namespace
	// - kind: Resource kind (e.g., "Pod")
	// - name: Resource name (e.g., "payment-api-789abc")
	//
	// Returns:
	// - ownerKind: Top-level owner kind (e.g., "Deployment")
	// - ownerName: Top-level owner name (e.g., "payment-api")
	// - err: Resolution error (RBAC, timeout, not found). Callers should fall back
	//         to involvedObject on error.
	ResolveTopLevelOwner(ctx context.Context, namespace, kind, name string) (ownerKind, ownerName string, err error)
}

type KubernetesEventAdapter struct {
	name          string
	version       string
	description   string
	ownerResolver OwnerResolver
}

// kubernetesEvent represents the minimal K8s Event structure we need to parse
//
// Full Event API structure is large (~30 fields). We only extract what's needed
// for signal normalization and remediation targeting.
type kubernetesEvent struct {
	Type    string `json:"type"`    // "Normal", "Warning", "Error"
	Reason  string `json:"reason"`  // "OOMKilled", "FailedScheduling", etc.
	Message string `json:"message"` // Human-readable description

	// InvolvedObject identifies which resource triggered the event
	InvolvedObject struct {
		Kind            string `json:"kind"`            // "Pod", "Node", "Deployment", etc.
		Namespace       string `json:"namespace"`       // Namespace (empty for cluster-scoped)
		Name            string `json:"name"`            // Resource name
		UID             string `json:"uid"`             // Resource UID
		APIVersion      string `json:"apiVersion"`      // API version
		ResourceVersion string `json:"resourceVersion"` // Resource version
	} `json:"involvedObject"`

	// Timestamps
	FirstTimestamp time.Time `json:"firstTimestamp"` // First occurrence
	LastTimestamp  time.Time `json:"lastTimestamp"`  // Most recent occurrence
	Count          int       `json:"count"`          // Number of occurrences

	// Source information
	Source struct {
		Component string `json:"component"` // "kubelet", "scheduler", etc.
		Host      string `json:"host"`      // Node name
	} `json:"source"`
}

// NewKubernetesEventAdapter creates a new Kubernetes Event adapter.
//
// Parameters:
// - ownerResolver: Optional. If non-nil, the adapter resolves the top-level owner
//   (e.g., Deployment) for fingerprinting, enabling deduplication across pods from
//   the same controller. If nil, fingerprinting falls back to the involvedObject
//   directly (legacy behavior).
func NewKubernetesEventAdapter(ownerResolver ...OwnerResolver) *KubernetesEventAdapter {
	adapter := &KubernetesEventAdapter{
		name:        "kubernetes-event",
		version:     "1.0",
		description: "Handles Kubernetes Event API signals (Warning/Error types)",
	}
	if len(ownerResolver) > 0 && ownerResolver[0] != nil {
		adapter.ownerResolver = ownerResolver[0]
	}
	return adapter
}

// Name returns the adapter identifier
func (a *KubernetesEventAdapter) Name() string {
	return a.name
}

// GetRoute returns the HTTP route for Kubernetes Events
//
// Kubernetes Event sources can POST events to this endpoint:
// - Event watchers (custom controllers observing Event API)
// - Event forwarders (tools that convert watch to webhook)
// - Test/integration scenarios
func (a *KubernetesEventAdapter) GetRoute() string {
	return "/api/v1/signals/kubernetes-event"
}

// ReplayValidator returns body-based replay prevention middleware (BR-GATEWAY-075).
// Kubernetes Event sources (e.g., kubernetes-event-exporter) cannot set dynamic
// HTTP headers. Instead, event freshness is validated from the event's
// lastTimestamp/firstTimestamp fields in the request body.
func (a *KubernetesEventAdapter) ReplayValidator(tolerance time.Duration) func(http.Handler) http.Handler {
	return middleware.EventFreshnessValidator(tolerance)
}

// GetSourceService returns the monitoring system name (BR-GATEWAY-027)
//
// Returns "kubernetes-events" (the monitoring system) instead of "k8s-event-adapter" (the adapter name).
// The LLM uses this to select appropriate investigation tools:
// - signal_source="kubernetes-events" → LLM uses kubectl for investigation
//
// This is the SOURCE MONITORING SYSTEM, not the adapter implementation name.
func (a *KubernetesEventAdapter) GetSourceService() string {
	return "kubernetes-events"
}

// GetSourceType returns the signal type identifier (BR-GATEWAY-027)
//
// Returns "alert" (normalized signal type) per OpenAPI enum validation and authoritative documentation.
// Used for metrics, logging, signal classification, and audit events.
func (a *KubernetesEventAdapter) GetSourceType() string {
	return SourceTypeKubernetesEvent // Kubernetes events
}

// Parse converts Kubernetes Event JSON to NormalizedSignal
//
// Parsing flow:
// 1. Unmarshal JSON to kubernetesEvent struct
// 2. Validate required fields (type, reason, involvedObject)
// 3. Filter event types (only Warning/Error, skip Normal)
// 4. Map event severity (Warning → warning, Error → critical)
// 5. Extract resource information for remediation targeting
// 6. Generate fingerprint for deduplication
// 7. Populate NormalizedSignal
//
// Returns:
// - NormalizedSignal: Unified format for Gateway processing
// - error: Parse/validation errors
func (a *KubernetesEventAdapter) Parse(ctx context.Context, rawData []byte) (*types.NormalizedSignal, error) {
	// 1. Unmarshal JSON
	var event kubernetesEvent
	if err := json.Unmarshal(rawData, &event); err != nil {
		return nil, fmt.Errorf("invalid JSON: %w", err)
	}

	// 2. Validate required fields
	if event.Reason == "" {
		return nil, fmt.Errorf("missing reason field")
	}
	if event.InvolvedObject.Kind == "" {
		return nil, fmt.Errorf("missing involvedObject.kind field")
	}
	if event.InvolvedObject.Name == "" {
		return nil, fmt.Errorf("missing involvedObject.name field")
	}

	// 3. Filter event types (business logic: only Warning/Error need remediation)
	if event.Type == "Normal" {
		return nil, fmt.Errorf("normal events not processed (informational only)")
	}
	if event.Type != "Warning" && event.Type != "Error" {
		return nil, fmt.Errorf("unsupported event type: %s (expected Warning or Error)", event.Type)
	}

	// 4. BR-GATEWAY-111: Pass through event type as severity (no transformation)
	// Gateway acts as "dumb pipe" - extract and preserve, never transform
	// Examples: "Warning" → "Warning", "Error" → "Error"
	// SignalProcessing Rego will normalize via BR-SP-105 based on reason+type
	severity := event.Type
	if severity == "" {
		severity = "unknown" // Only default if missing entirely
	}

	// 5. Extract resource information
	resource := types.ResourceIdentifier{
		Kind:      event.InvolvedObject.Kind,
		Name:      event.InvolvedObject.Name,
		Namespace: event.InvolvedObject.Namespace,
	}

	// 6. Generate fingerprint for deduplication (BR-GATEWAY-004)
	//
	// Strategy depends on whether OwnerResolver is configured:
	// - With OwnerResolver: SHA256(namespace:ownerKind:ownerName) — reason excluded
	//   Resolves owner chain (Pod → ReplicaSet → Deployment) so events from
	//   different pods/reasons of the same Deployment produce one fingerprint.
	// - Without OwnerResolver (legacy): SHA256(reason:namespace:kind:name)
	var fingerprint string
	if a.ownerResolver != nil {
		ownerKind, ownerName, err := a.ownerResolver.ResolveTopLevelOwner(
			ctx, resource.Namespace, resource.Kind, resource.Name)
		if err == nil && ownerKind != "" && ownerName != "" {
			// Owner resolved: fingerprint at owner level
			fingerprint = types.CalculateOwnerFingerprint(types.ResourceIdentifier{
				Namespace: resource.Namespace,
				Kind:      ownerKind,
				Name:      ownerName,
			})
		} else {
			// Fallback: involvedObject without reason (graceful degradation)
			fingerprint = types.CalculateOwnerFingerprint(resource)
		}
	} else {
		// Legacy behavior: includes reason in fingerprint
		fingerprint = types.CalculateFingerprint(event.Reason, resource)
	}

	// 7. Populate NormalizedSignal
	signal := &types.NormalizedSignal{
		Fingerprint:  fingerprint,
		SignalName:    event.Reason, // "OOMKilled", "FailedScheduling", etc.
		Severity:     severity,
		Namespace:    event.InvolvedObject.Namespace,
		Resource:     resource,
		Labels:       a.extractLabels(event),
		Annotations:  a.extractAnnotations(event),
		FiringTime:   event.FirstTimestamp,
		ReceivedTime: time.Now(),
		SourceType:   a.GetSourceType(),
		Source:       a.GetSourceService(),
		RawPayload:   rawData, // Preserve for audit trail
	}

	return signal, nil
}

// Validate checks if the parsed signal meets requirements
//
// Validation rules:
// - AlertName must be populated
// - Fingerprint must be populated
// - Severity must be valid (critical/warning/info)
// - Resource kind and name must be populated
func (a *KubernetesEventAdapter) Validate(signal *types.NormalizedSignal) error {
	if signal.SignalName == "" {
		return fmt.Errorf("alertName is required")
	}
	if signal.Fingerprint == "" {
		return fmt.Errorf("fingerprint is required")
	}
	// BR-GATEWAY-181: Gateway passes through raw severity. SignalProcessing will validate.
	// Only validate if severity is completely empty, otherwise accept any string.
	if signal.Severity == "" {
		return fmt.Errorf("severity is required (cannot be empty)")
	}
	if signal.Resource.Kind == "" {
		return fmt.Errorf("resource kind is required")
	}
	if signal.Resource.Name == "" {
		return fmt.Errorf("resource name is required")
	}

	return nil
}

// GetMetadata returns adapter information for observability
func (a *KubernetesEventAdapter) GetMetadata() AdapterMetadata {
	return AdapterMetadata{
		Name:                  a.name,
		Version:               a.version,
		Description:           a.description,
		SupportedContentTypes: []string{"application/json"},
		RequiredHeaders:       []string{"Authorization"}, // Bearer token required
	}
}

// generateFingerprint creates a unique identifier for deduplication
//
// Fingerprint format: SHA256(reason:namespace:kind:name)
//
// Examples:
// - "OOMKilled:production:Pod:payment-api" → SHA256 hash
// - "DiskPressure::Node:worker-1" → SHA256 hash (empty namespace for cluster-scoped)
//
// Design Decision: Why include reason in fingerprint?
// - Same resource can have multiple failure types simultaneously
// - Example: Pod can be OOMKilled AND BackOff at same time
// - Different reasons = different remediation strategies

// extractLabels extracts labels from Kubernetes Event for CRD propagation
//
// Labels enable:
// - Controller filtering (label selectors)
// - Team/ownership tracking
// - Environment classification
func (a *KubernetesEventAdapter) extractLabels(event kubernetesEvent) map[string]string {
	labels := make(map[string]string)

	// Add source component as label
	if event.Source.Component != "" {
		labels["kubernaut.ai/event-source"] = event.Source.Component
	}

	// Add event type as label
	labels["kubernaut.ai/event-type"] = strings.ToLower(event.Type)

	// Add resource kind as label (for filtering)
	labels["kubernaut.ai/resource-kind"] = strings.ToLower(event.InvolvedObject.Kind)

	return labels
}

// extractAnnotations extracts annotations from Kubernetes Event
//
// Annotations provide additional context:
// - Human-readable message
// - Event count (how many times fired)
// - Source host (which node)
func (a *KubernetesEventAdapter) extractAnnotations(event kubernetesEvent) map[string]string {
	annotations := make(map[string]string)

	// Add event message
	if event.Message != "" {
		annotations["kubernaut.ai/event-message"] = event.Message
	}

	// Add event count
	if event.Count > 0 {
		annotations["kubernaut.ai/event-count"] = fmt.Sprintf("%d", event.Count)
	}

	// Add source host
	if event.Source.Host != "" {
		annotations["kubernaut.ai/source-host"] = event.Source.Host
	}

	// Add timestamps
	if !event.FirstTimestamp.IsZero() {
		annotations["kubernaut.ai/first-timestamp"] = event.FirstTimestamp.Format(time.RFC3339)
	}
	if !event.LastTimestamp.IsZero() {
		annotations["kubernaut.ai/last-timestamp"] = event.LastTimestamp.Format(time.RFC3339)
	}

	return annotations
}
