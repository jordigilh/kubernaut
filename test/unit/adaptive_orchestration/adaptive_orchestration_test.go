//go:build unit
// +build unit

/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package adaptive_orchestration

import (
	"context"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"

	"github.com/jordigilh/kubernaut/pkg/workflow/engine"
)

// Suite structure moved to orchestration_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Adaptive Orchestration - Business Requirements Testing", func() {
	var (
		ctx                  context.Context
		adaptiveOrchestrator *MockAdaptiveOrchestrator
		configManager        *MockConfigManager
		maintainabilityTools *MockMaintainabilityTools
	)

	BeforeEach(func() {
		ctx = context.Background()

		adaptiveOrchestrator = NewMockAdaptiveOrchestrator()
		configManager = NewMockConfigManager()
		maintainabilityTools = NewMockMaintainabilityTools()
	})

	// BR-ORCH-001: MUST continuously optimize orchestration strategies based on outcomes
	Context("BR-ORCH-001: Self-Optimization Framework", func() {
		It("should continuously optimize orchestration strategies based on execution outcomes", func() {
			// Arrange: Create execution history for optimization
			executionHistory := []ExecutionMetrics{
				{
					WorkflowID:       "memory-scaling-001",
					ExecutionTime:    3*time.Minute + 30*time.Second,
					ResourceUsage:    0.75,
					SuccessRate:      0.92,
					UserSatisfaction: 0.88,
					CostEfficiency:   0.83,
					Timestamp:        time.Now().Add(-24 * time.Hour),
				},
				{
					WorkflowID:       "memory-scaling-002",
					ExecutionTime:    2*time.Minute + 45*time.Second,
					ResourceUsage:    0.68,
					SuccessRate:      0.95,
					UserSatisfaction: 0.91,
					CostEfficiency:   0.87,
					Timestamp:        time.Now().Add(-12 * time.Hour),
				},
				{
					WorkflowID:       "memory-scaling-003",
					ExecutionTime:    2*time.Minute + 15*time.Second,
					ResourceUsage:    0.62,
					SuccessRate:      0.97,
					UserSatisfaction: 0.94,
					CostEfficiency:   0.91,
					Timestamp:        time.Now().Add(-2 * time.Hour),
				},
			}

			// Setup optimization results
			optimizationResult := &OptimizationResult{
				StrategyUpdates: map[string]interface{}{
					"execution_parallelism":      3,    // Increased from 2
					"resource_allocation_weight": 0.85, // Optimized
					"timeout_buffer":             1.2,  // Refined
					"retry_strategy":             "exponential_backoff",
				},
				PerformanceGains: map[string]float64{
					"execution_time_reduction": 0.35, // 35% improvement
					"resource_efficiency":      0.18, // 18% improvement
					"cost_optimization":        0.13, // 13% improvement
				},
				OptimizationConfidence: 0.89,
				LearningMetrics: map[string]interface{}{
					"data_points_analyzed": len(executionHistory),
					"trend_confidence":     0.92,
					"prediction_accuracy":  0.87,
				},
			}

			adaptiveOrchestrator.SetOptimizationResult(optimizationResult)

			// Act: Perform continuous optimization
			result, err := adaptiveOrchestrator.OptimizeStrategies(ctx, executionHistory)

			// **Business Requirement BR-ORCH-001**: Validate continuous optimization
			Expect(err).ToNot(HaveOccurred(), "Should successfully optimize orchestration strategies")
			Expect(result.OptimizationConfidence).To(BeNumerically(">=", 0.8),
				"BR-ORCH-001: Optimization should have high confidence (≥80%)")

			// **Business Value Validation**: Verify performance improvements
			executionTimeReduction := result.PerformanceGains["execution_time_reduction"]
			Expect(executionTimeReduction).To(BeNumerically(">", 0),
				"BR-ORCH-001: Should demonstrate execution time improvements")
			Expect(executionTimeReduction).To(BeNumerically(">=", 0.15),
				"BR-ORCH-001: Should achieve significant performance gains (≥15%)")

			resourceEfficiency := result.PerformanceGains["resource_efficiency"]
			Expect(resourceEfficiency).To(BeNumerically(">", 0),
				"BR-ORCH-001: Should improve resource efficiency")

			// Validate strategy updates
			Expect(len(result.StrategyUpdates)).To(BeNumerically(">=", 3),
				"BR-ORCH-001: Should update multiple orchestration strategies")

			parallelism, exists := result.StrategyUpdates["execution_parallelism"]
			Expect(exists).To(BeTrue(), "BR-ORCH-001: Should optimize execution parallelism")
			Expect(parallelism).To(BeNumerically(">=", 2),
				"BR-ORCH-001: Parallelism optimization should be reasonable")

			// **BR-ORCH-004**: Validate learning from failures
			retryStrategy, exists := result.StrategyUpdates["retry_strategy"]
			Expect(exists).To(BeTrue(), "BR-ORCH-004: Should learn and adjust retry strategies")
			Expect(retryStrategy).ToNot(BeEmpty(),
				"BR-ORCH-004: Retry strategy should be meaningful")
		})

		It("should adapt resource allocation based on workload patterns", func() {
			// Arrange: Create workload pattern data
			workloadPatterns := []WorkloadPattern{
				{
					TimeWindow:     "morning_peak",
					AverageLoad:    0.85,
					PeakLoad:       0.95,
					ResourceDemand: "high",
					PatternType:    "predictable_spike",
					Frequency:      "daily",
				},
				{
					TimeWindow:     "afternoon_steady",
					AverageLoad:    0.45,
					PeakLoad:       0.60,
					ResourceDemand: "medium",
					PatternType:    "steady_state",
					Frequency:      "daily",
				},
				{
					TimeWindow:     "evening_decline",
					AverageLoad:    0.25,
					PeakLoad:       0.40,
					ResourceDemand: "low",
					PatternType:    "gradual_decline",
					Frequency:      "daily",
				},
			}

			// Setup adaptive resource allocation
			allocationResult := &ResourceAllocationResult{
				AllocationStrategies: map[string]interface{}{
					"morning_peak": map[string]interface{}{
						"cpu_allocation":    "aggressive",
						"memory_allocation": "conservative",
						"scaling_policy":    "proactive",
						"buffer_percentage": 0.20,
					},
					"afternoon_steady": map[string]interface{}{
						"cpu_allocation":    "balanced",
						"memory_allocation": "balanced",
						"scaling_policy":    "reactive",
						"buffer_percentage": 0.10,
					},
					"evening_decline": map[string]interface{}{
						"cpu_allocation":    "conservative",
						"memory_allocation": "minimal",
						"scaling_policy":    "cost_optimized",
						"buffer_percentage": 0.05,
					},
				},
				PredictiveScaling: map[string]interface{}{
					"enabled":           true,
					"prediction_window": "15m",
					"accuracy_rate":     0.87,
					"cost_savings":      0.23,
				},
				AdaptationConfidence: 0.91,
			}

			adaptiveOrchestrator.SetResourceAllocationResult(allocationResult)

			// Act: Adapt resource allocation
			result, err := adaptiveOrchestrator.AdaptResourceAllocation(ctx, workloadPatterns)

			// **Business Requirement BR-ORCH-002**: Validate resource allocation adaptation
			Expect(err).ToNot(HaveOccurred(), "Should successfully adapt resource allocation")
			Expect(result.AdaptationConfidence).To(BeNumerically(">=", 0.85),
				"BR-ORCH-002: Resource adaptation should have high confidence (≥85%)")

			// **Business Value Validation**: Verify pattern-based allocation
			Expect(len(result.AllocationStrategies)).To(Equal(len(workloadPatterns)),
				"BR-ORCH-002: Should create allocation strategy for each workload pattern")

			// Validate morning peak strategy
			morningStrategy, exists := result.AllocationStrategies["morning_peak"]
			Expect(exists).To(BeTrue(), "BR-ORCH-002: Should handle morning peak pattern")
			strategy, ok := morningStrategy.(map[string]interface{})
			Expect(ok).To(BeTrue(), "BR-ORCH-002: Strategy should be structured")

			scalingPolicy := strategy["scaling_policy"]
			Expect(scalingPolicy).To(Equal("proactive"),
				"BR-ORCH-002: High load patterns should use proactive scaling")

			// **BR-ORCH-005**: Validate predictive scaling
			predictiveScaling, exists := result.PredictiveScaling["enabled"]
			Expect(exists).To(BeTrue(), "BR-ORCH-005: Should implement predictive scaling")
			Expect(predictiveScaling).To(BeTrue(),
				"BR-ORCH-005: Predictive scaling should be enabled for workload adaptation")

			accuracyRate := result.PredictiveScaling["accuracy_rate"]
			Expect(accuracyRate).To(BeNumerically(">=", 0.8),
				"BR-ORCH-005: Predictive scaling should have high accuracy (≥80%)")
		})
	})

	// BR-ORCH-006: MUST support dynamic configuration updates without restart
	Context("BR-ORCH-006: Dynamic Configuration Management", func() {
		It("should support dynamic configuration updates without service restart", func() {
			// Arrange: Create configuration update scenario
			currentConfig := &OrchestrationConfig{
				MaxConcurrentWorkflows: 50,
				ResourceLimits: map[string]interface{}{
					"cpu_limit":    "2000m",
					"memory_limit": "4Gi",
				},
				RetryPolicy: map[string]interface{}{
					"max_retries":      3,
					"backoff_strategy": "exponential",
					"base_delay":       "5s",
				},
				Timeouts: map[string]interface{}{
					"execution_timeout": "30m",
					"step_timeout":      "5m",
				},
				Version: "1.2.0",
			}

			configUpdates := map[string]interface{}{
				"MaxConcurrentWorkflows": 75, // Increase capacity
				"ResourceLimits": map[string]interface{}{
					"cpu_limit":    "3000m", // Increase CPU
					"memory_limit": "6Gi",   // Increase memory
				},
				"RetryPolicy": map[string]interface{}{
					"max_retries": 5,    // More retries
					"base_delay":  "3s", // Faster initial retry
				},
			}

			// Setup dynamic update result
			updateResult := &ConfigUpdateResult{
				Success: true,
				UpdatesApplied: []string{
					"MaxConcurrentWorkflows",
					"ResourceLimits.cpu_limit",
					"ResourceLimits.memory_limit",
					"RetryPolicy.max_retries",
					"RetryPolicy.base_delay",
				},
				ValidationResults: map[string]interface{}{
					"capacity_check":      true,
					"resource_validation": true,
					"compatibility_check": true,
				},
				ImpactAnalysis: map[string]interface{}{
					"restart_required":     false,
					"performance_impact":   "minimal",
					"capacity_improvement": 0.50,
					"estimated_downtime":   "0s",
				},
				RollbackCapability: true,
				ConfigVersion:      "1.3.0",
			}

			configManager.SetCurrentConfig(currentConfig)
			configManager.SetUpdateResult(updateResult)

			// Act: Apply dynamic configuration updates
			result, err := configManager.UpdateConfiguration(ctx, configUpdates)

			// **Business Requirement BR-ORCH-006**: Validate dynamic updates
			Expect(err).ToNot(HaveOccurred(), "Should successfully apply dynamic configuration updates")
			Expect(result.Success).To(BeTrue(), "BR-ORCH-006: Configuration updates should succeed")
			Expect(len(result.UpdatesApplied)).To(BeNumerically(">=", 4),
				"BR-ORCH-006: Should apply multiple configuration changes")

			// **Business Value Validation**: Verify no restart required
			impactAnalysis, exists := result.ImpactAnalysis["restart_required"]
			Expect(exists).To(BeTrue(), "BR-ORCH-006: Should analyze restart impact")
			Expect(impactAnalysis).To(BeFalse(),
				"BR-ORCH-006: Dynamic updates should not require restart")

			estimatedDowntime := result.ImpactAnalysis["estimated_downtime"]
			Expect(estimatedDowntime).To(Equal("0s"),
				"BR-ORCH-006: Dynamic updates should have zero downtime")

			// **BR-ORCH-008**: Validate configuration validation
			capacityCheck := result.ValidationResults["capacity_check"]
			Expect(capacityCheck).To(BeTrue(),
				"BR-ORCH-008: Should validate configuration capacity requirements")

			resourceValidation := result.ValidationResults["resource_validation"]
			Expect(resourceValidation).To(BeTrue(),
				"BR-ORCH-008: Should validate resource configuration")

			// **BR-ORCH-008**: Validate rollback capability
			Expect(result.RollbackCapability).To(BeTrue(),
				"BR-ORCH-008: Should provide configuration rollback capability")
		})

		It("should maintain configuration consistency across orchestrator instances", func() {
			// Arrange: Create multi-instance consistency scenario
			instanceConfigs := map[string]*OrchestrationConfig{
				"orchestrator-1": {
					MaxConcurrentWorkflows: 50,
					Version:                "1.2.0",
				},
				"orchestrator-2": {
					MaxConcurrentWorkflows: 50,
					Version:                "1.2.0",
				},
				"orchestrator-3": {
					MaxConcurrentWorkflows: 45,      // Inconsistent
					Version:                "1.1.0", // Outdated
				},
			}

			// Setup consistency check result
			consistencyResult := &ConsistencyCheckResult{
				ConsistentInstances:   []string{"orchestrator-1", "orchestrator-2"},
				InconsistentInstances: []string{"orchestrator-3"},
				ConsistencyScore:      0.67, // 2/3 instances consistent
				SynchronizationPlan: map[string]interface{}{
					"orchestrator-3": map[string]interface{}{
						"config_updates": []string{"MaxConcurrentWorkflows", "Version"},
						"sync_priority":  "high",
						"estimated_time": "30s",
					},
				},
				AutoSyncEnabled: true,
				SyncStatus:      "in_progress",
			}

			configManager.SetInstanceConfigs(instanceConfigs)
			configManager.SetConsistencyResult(consistencyResult)

			// Act: Check and maintain configuration consistency
			result, err := configManager.EnsureConsistency(ctx)

			// **Business Requirement BR-ORCH-007**: Validate configuration consistency
			Expect(err).ToNot(HaveOccurred(), "Should successfully check configuration consistency")
			Expect(len(result.ConsistentInstances)).To(BeNumerically(">=", 2),
				"BR-ORCH-007: Should identify consistent instances")
			Expect(len(result.InconsistentInstances)).To(BeNumerically(">=", 1),
				"BR-ORCH-007: Should detect inconsistent instances")

			// **Business Value Validation**: Verify synchronization plan
			Expect(len(result.SynchronizationPlan)).To(Equal(len(result.InconsistentInstances)),
				"BR-ORCH-007: Should create synchronization plan for inconsistent instances")

			syncPlan, exists := result.SynchronizationPlan["orchestrator-3"]
			Expect(exists).To(BeTrue(), "BR-ORCH-007: Should plan sync for inconsistent instance")

			plan, ok := syncPlan.(map[string]interface{})
			Expect(ok).To(BeTrue(), "BR-ORCH-007: Sync plan should be structured")

			configUpdates := plan["config_updates"]
			Expect(configUpdates).ToNot(BeEmpty(),
				"BR-ORCH-007: Should specify configuration updates needed")

			// Validate auto-sync capability
			Expect(result.AutoSyncEnabled).To(BeTrue(),
				"BR-ORCH-007: Should enable automatic synchronization")
		})
	})

	// BR-ORCH-011: MUST provide comprehensive operational visibility and control
	Context("BR-ORCH-011: Operational Visibility & Control", func() {
		It("should provide comprehensive operational visibility with detailed metrics", func() {
			// Arrange: Create operational metrics scenario
			operationalMetrics := &OperationalMetrics{
				SystemHealth: map[string]interface{}{
					"overall_health":       "healthy",
					"health_score":         0.92,
					"active_workflows":     28,
					"queued_workflows":     5,
					"failed_workflows":     2,
					"resource_utilization": 0.68,
				},
				PerformanceMetrics: map[string]interface{}{
					"avg_execution_time":  "4m30s",
					"p95_execution_time":  "8m15s",
					"success_rate":        0.94,
					"throughput_per_hour": 45,
					"error_rate":          0.06,
				},
				ResourceMetrics: map[string]interface{}{
					"cpu_usage":         0.72,
					"memory_usage":      0.65,
					"storage_usage":     0.48,
					"network_bandwidth": 0.35,
				},
				AlertingStatus: map[string]interface{}{
					"active_alerts":   3,
					"warning_alerts":  2,
					"critical_alerts": 1,
					"alert_trends":    "stable",
				},
				LastUpdated: time.Now(),
			}

			maintainabilityTools.SetOperationalMetrics(operationalMetrics)

			// Act: Retrieve operational visibility
			metrics, err := maintainabilityTools.GetOperationalVisibility(ctx)

			// **Business Requirement BR-ORCH-011**: Validate operational visibility
			Expect(err).ToNot(HaveOccurred(), "Should successfully provide operational visibility")

			// Validate system health metrics
			systemHealth, exists := metrics.SystemHealth["health_score"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should provide system health scoring")
			Expect(systemHealth).To(BeNumerically(">=", 0.85),
				"BR-ORCH-011: System health should be high (≥85%)")

			activeWorkflows, exists := metrics.SystemHealth["active_workflows"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should track active workflows")
			Expect(activeWorkflows).To(BeNumerically(">=", 0),
				"BR-ORCH-011: Active workflow count should be valid")

			// **Business Value Validation**: Verify performance visibility
			successRate, exists := metrics.PerformanceMetrics["success_rate"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should track success rates")
			Expect(successRate).To(BeNumerically(">=", 0.9),
				"BR-ORCH-011: Success rate should be high (≥90%)")

			throughput, exists := metrics.PerformanceMetrics["throughput_per_hour"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should track system throughput")
			Expect(throughput).To(BeNumerically(">", 0),
				"BR-ORCH-011: Throughput should be positive")

			// Validate resource monitoring
			cpuUsage, exists := metrics.ResourceMetrics["cpu_usage"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should monitor CPU usage")
			Expect(cpuUsage).To(BeNumerically("<=", 0.8),
				"BR-ORCH-011: CPU usage should be within reasonable limits (≤80%)")

			memoryUsage, exists := metrics.ResourceMetrics["memory_usage"]
			Expect(exists).To(BeTrue(), "BR-ORCH-011: Should monitor memory usage")
			Expect(memoryUsage).To(BeNumerically("<=", 0.8),
				"BR-ORCH-011: Memory usage should be within reasonable limits (≤80%)")

			// **BR-ORCH-012**: Validate alerting visibility
			activeAlerts, exists := metrics.AlertingStatus["active_alerts"]
			Expect(exists).To(BeTrue(), "BR-ORCH-012: Should track active alerts")
			Expect(activeAlerts).To(BeNumerically(">=", 0),
				"BR-ORCH-012: Alert count should be valid")
		})

		It("should provide operational control capabilities with safety mechanisms", func() {
			// Arrange: Create operational control scenario
			controlActions := []ControlAction{
				{
					Type:        "pause_orchestration",
					Target:      "all_workflows",
					Reason:      "Planned maintenance window",
					SafetyLevel: "high",
				},
				{
					Type:        "emergency_stop",
					Target:      "workflow-abc-123",
					Reason:      "Critical error detected",
					SafetyLevel: "critical",
				},
				{
					Type:        "resource_scaling",
					Target:      "orchestrator_cluster",
					Reason:      "High load detected",
					SafetyLevel: "medium",
					Parameters: map[string]interface{}{
						"scale_factor":  1.5,
						"max_instances": 10,
					},
				},
			}

			controlResults := map[string]*ControlResult{
				"pause_orchestration": {
					Success:       true,
					ExecutionTime: 15 * time.Second,
					SafetyChecks: map[string]interface{}{
						"active_workflows_paused": true,
						"state_preservation":      true,
						"rollback_capability":     true,
					},
					Impact: map[string]interface{}{
						"affected_workflows": 28,
						"estimated_downtime": "5m",
						"data_safety":        "guaranteed",
					},
				},
				"emergency_stop": {
					Success:       true,
					ExecutionTime: 3 * time.Second,
					SafetyChecks: map[string]interface{}{
						"data_consistency_preserved": true,
						"cleanup_completed":          true,
						"resources_released":         true,
					},
					Impact: map[string]interface{}{
						"workflow_stopped":  "workflow-abc-123",
						"cleanup_time":      "10s",
						"resource_recovery": "complete",
					},
				},
				"resource_scaling": {
					Success:       true,
					ExecutionTime: 45 * time.Second,
					SafetyChecks: map[string]interface{}{
						"capacity_validation": true,
						"gradual_scaling":     true,
						"health_monitoring":   true,
					},
					Impact: map[string]interface{}{
						"instances_added":         2,
						"capacity_increase":       "50%",
						"performance_improvement": 0.35,
					},
				},
			}

			maintainabilityTools.SetControlResults(controlResults)

			// Act: Execute operational control actions
			for _, action := range controlActions {
				result, err := maintainabilityTools.ExecuteControlAction(ctx, action)

				// **Business Requirement BR-ORCH-011**: Validate operational control
				Expect(err).ToNot(HaveOccurred(),
					"Should successfully execute %s control action", action.Type)
				Expect(result.Success).To(BeTrue(),
					"BR-ORCH-011: Control actions should execute successfully")

				// **Business Value Validation**: Verify safety mechanisms
				safetyChecks := result.SafetyChecks
				Expect(len(safetyChecks)).To(BeNumerically(">=", 2),
					"BR-ORCH-011: Should perform comprehensive safety checks")

				// Validate action-specific safety measures
				switch action.Type {
				case "pause_orchestration":
					statePreservation := safetyChecks["state_preservation"]
					Expect(statePreservation).To(BeTrue(),
						"BR-ORCH-011: Pause should preserve workflow state")

					rollbackCapability := safetyChecks["rollback_capability"]
					Expect(rollbackCapability).To(BeTrue(),
						"BR-ORCH-011: Should maintain rollback capability")

				case "emergency_stop":
					dataConsistency := safetyChecks["data_consistency_preserved"]
					Expect(dataConsistency).To(BeTrue(),
						"BR-ORCH-011: Emergency stop should preserve data consistency")

					cleanupCompleted := safetyChecks["cleanup_completed"]
					Expect(cleanupCompleted).To(BeTrue(),
						"BR-ORCH-011: Should complete cleanup after emergency stop")

				case "resource_scaling":
					gradualScaling := safetyChecks["gradual_scaling"]
					Expect(gradualScaling).To(BeTrue(),
						"BR-ORCH-011: Should perform gradual resource scaling")

					healthMonitoring := safetyChecks["health_monitoring"]
					Expect(healthMonitoring).To(BeTrue(),
						"BR-ORCH-011: Should monitor health during scaling")
				}

				// Validate execution time is reasonable
				Expect(result.ExecutionTime).To(BeNumerically("<=", 1*time.Minute),
					"BR-ORCH-011: Control actions should execute quickly (≤1 minute)")
			}
		})
	})

	// BR-ORK-001: MUST generate 3-5 viable optimization candidates per workflow analysis
	Context("BR-ORK-001: Optimization Candidate Generation", func() {
		It("should generate viable optimization candidates based on performance analysis", func() {
			// Business Scenario: High-CPU workflow needs optimization
			workflowID := "high-cpu-workflow"

			// Arrange: Configure workflow with performance bottlenecks
			adaptiveOrchestrator.SetWorkflowAnalysis(workflowID, WorkflowPerformanceAnalysis{
				ExecutionTime: 5*time.Minute + 30*time.Second, // Exceeds 4-minute target
				ResourceUsage: ResourceUsageMetrics{
					CPUUsage:    0.95, // High CPU usage
					MemoryUsage: 0.60, // Normal memory
					NetworkIO:   0.30, // Low network
				},
				Bottlenecks: []BottleneckIdentification{
					{Type: "resource_constraint", Severity: "high", StepID: "analyze-logs"},
					{Type: "sequential_execution", Severity: "medium", StepID: "workflow"},
				},
				Effectiveness: 0.70, // Below 0.85 target
			})

			// Act: Generate optimization candidates
			result, err := adaptiveOrchestrator.OptimizeWorkflow(ctx, workflowID)

			// Assert: Business requirement validation
			Expect(err).To(BeNil(), "Optimization should complete successfully")
			Expect(result.OptimizationCandidates).ToNot(BeNil(), "OptimizationCandidates should not be nil")

			// BR-ORK-001 Success Criteria: Generate 3-5 viable optimization candidates
			candidateList := getOptimizationCandidates(result)
			Expect(len(candidateList)).To(BeNumerically(">=", 3), "Must generate at least 3 optimization candidates")
			Expect(len(candidateList)).To(BeNumerically("<=", 5), "Must not exceed 5 optimization candidates for focus")

			// BR-ORK-001 Success Criteria: Predicted improvements >70% accuracy
			for _, candidate := range candidateList {
				Expect(candidate.Confidence).To(BeNumerically(">=", 0.70), "Candidate confidence must meet 70% accuracy requirement")
				Expect(candidate.Impact).To(BeNumerically(">=", 0.15), "Candidate must predict >=15% workflow time improvement")
			}

			// BR-ORK-001 Success Criteria: Optimization types address bottlenecks
			optimizationTypes := extractOptimizationTypes(candidateList)
			Expect(optimizationTypes).To(ContainElement("resource_optimization"), "Must address CPU bottleneck")
			Expect(optimizationTypes).To(ContainElement("parallel_execution"), "Must address sequential bottleneck")

			// Business Value: Performance improvement validation
			bestCandidate := selectHighestImpactCandidate(candidateList)
			Expect(bestCandidate.PredictedTimeReduction).To(BeNumerically(">=", 0.15), "Must reduce execution time by >15%")
		})

		It("should calculate accurate ROI scores for optimization priorities", func() {
			// Business Scenario: Multiple workflows need different optimizations
			workflowID := "mixed-performance-workflow"

			// Arrange: Workflow with multiple optimization opportunities
			adaptiveOrchestrator.SetWorkflowAnalysis(workflowID, WorkflowPerformanceAnalysis{
				ExecutionTime: 3*time.Minute + 45*time.Second,
				ResourceUsage: ResourceUsageMetrics{
					CPUUsage:    0.80,
					MemoryUsage: 0.85, // High memory usage
					NetworkIO:   0.90, // High network usage
				},
				Effectiveness: 0.78,
				CostMetrics: CostAnalysisMetrics{
					ResourceCost:       45.50, // USD per hour
					InfrastructureCost: 12.30,
					OperationalCost:    8.90,
				},
			})

			// Act: Generate optimization candidates with ROI calculation
			result, err := adaptiveOrchestrator.OptimizeWorkflow(ctx, workflowID)

			// Assert: ROI-based prioritization
			Expect(err).To(BeNil())
			candidates := getOptimizationCandidates(result)

			// BR-ORK-001 Success Criteria: Calculate ROI scores for optimization priorities
			for _, candidate := range candidates {
				Expect(candidate.ROIScore).To(BeNumerically(">", 0), "Each candidate must have positive ROI score")
				Expect(candidate.CostReduction).To(BeNumerically(">=", 0), "Cost reduction must be non-negative")
				Expect(candidate.ImplementationEffort).To(BeAssignableToTypeOf(time.Duration(0)), "Implementation effort must be estimated")
			}

			// Business Value: Highest ROI candidate should be prioritized
			highestROI := findHighestROICandidate(candidates)
			for _, candidate := range candidates {
				if candidate != highestROI {
					Expect(candidate.ROIScore).To(BeNumerically("<=", highestROI.ROIScore), "Candidates should be ROI-ordered")
				}
			}
		})
	})

	// BR-ORK-002: MUST implement context-aware execution and real-time adaptation
	Context("BR-ORK-002: Adaptive Step Execution", func() {
		It("should analyze system state before step execution and adapt parameters", func() {
			// Business Scenario: High-load system requires adaptive execution
			workflowID := "adaptive-execution-workflow"
			stepContext := StepExecutionContext{
				WorkflowID: workflowID,
				StepID:     "cpu-intensive-analysis",
				SystemLoad: SystemLoadMetrics{
					CPULoad:    0.90, // High CPU load
					MemoryLoad: 0.75, // High memory usage
					NetworkIO:  0.40, // Moderate network
				},
				ExecutionHistory: []StepExecutionRecord{
					{
						StepID:        "cpu-intensive-analysis",
						ExecutionTime: 8 * time.Minute, // Previous executions were slow
						SuccessRate:   0.60,            // Low success rate
						Timestamp:     time.Now().Add(-1 * time.Hour),
					},
				},
			}

			// Act: Execute step with context-aware adaptation
			result, err := adaptiveOrchestrator.ExecuteAdaptiveStep(ctx, stepContext)

			// Assert: Business requirement validation
			Expect(err).To(BeNil(), "Adaptive step execution should complete successfully")
			Expect(result.AdaptationApplied).To(BeTrue(), "BR-ORK-002: Execution result must confirm successful adaptation application for context-aware orchestration")

			// BR-ORK-002 Success Criteria: Context-aware execution
			Expect(result.AdaptationApplied).To(BeTrue(), "Must apply adaptations based on system state")
			adaptations := result.GetAdaptations()
			Expect(len(adaptations)).To(BeNumerically(">=", 1), "Must apply at least one adaptation")

			// BR-ORK-002 Success Criteria: Real-time parameter adjustment
			timeoutAdaptation := findAdaptationByType(adaptations, "timeout_adjustment")
			Expect(timeoutAdaptation.Type).To(Equal("timeout_adjustment"), "BR-ORK-002: Timeout adaptation must provide measurable adjustment type for system load responsiveness")
			Expect(timeoutAdaptation.NewValue).To(BeNumerically(">", timeoutAdaptation.OldValue), "Must increase timeout under high load")

			// BR-ORK-002 Success Criteria: Learning integration
			Expect(result.LearningApplied).To(BeTrue(), "Must apply lessons from previous executions")
			Expect(result.ExecutionTime).To(BeNumerically("<", 8*time.Minute), "Must improve based on historical patterns")
		})

		It("should switch execution strategies when initial approach fails", func() {
			// Business Scenario: Network-dependent step fails and needs strategy switch
			workflowID := "network-dependent-workflow"
			stepContext := StepExecutionContext{
				WorkflowID: workflowID,
				StepID:     "network-api-call",
				SystemLoad: SystemLoadMetrics{
					CPULoad:    0.30,
					MemoryLoad: 0.40,
					NetworkIO:  0.95, // Network bottleneck
				},
				ExecutionHistory: []StepExecutionRecord{
					{
						StepID:      "network-api-call",
						SuccessRate: 0.30, // Frequent failures
						FailureType: "network_timeout",
						Timestamp:   time.Now().Add(-30 * time.Minute),
					},
				},
			}

			// Arrange: Configure orchestrator to simulate initial failure and strategy switch
			adaptiveOrchestrator.SetExecutionFailure(stepContext.StepID, "network_timeout", 1) // Fail first attempt
			adaptiveOrchestrator.SetAlternativeStrategy(stepContext.StepID, "retry_with_backoff")

			// Act: Execute step that will trigger strategy switching
			result, err := adaptiveOrchestrator.ExecuteAdaptiveStep(ctx, stepContext)

			// Assert: Strategy switching validation
			Expect(err).To(BeNil(), "Should recover from initial failure")
			Expect(result.StrategySwitch).To(BeTrue(), "Must switch execution strategy on failure")

			// BR-ORK-002 Success Criteria: Dynamic strategy switching
			strategies := result.GetStrategiesUsed()
			Expect(len(strategies)).To(BeNumerically(">=", 2), "Must try multiple strategies")
			Expect(strategies[0]).To(Equal("default"), "Should start with default strategy")
			Expect(strategies[1]).To(Equal("retry_with_backoff"), "Should switch to alternative strategy")

			// BR-ORK-002 Success Criteria: Success after adaptation
			Expect(result.FinalResult.Success).To(BeTrue(), "Must succeed after strategy adaptation")
			Expect(result.AdaptationReason).To(ContainSubstring("network_timeout"), "Must document adaptation reason")
		})
	})

	// BR-ORK-003: MUST implement execution metrics collection and performance trend analysis
	Context("BR-ORK-003: Statistics Tracking and Analysis", func() {
		It("should track workflow execution times, success rates, and resource usage", func() {
			// Business Scenario: Multiple workflow executions need comprehensive tracking
			workflowID := "statistics-tracking-workflow"

			// Arrange: Execute multiple workflows to generate statistics
			executionMetrics := []WorkflowExecutionData{
				{
					WorkflowID:    workflowID,
					ExecutionTime: 2*time.Minute + 30*time.Second,
					SuccessRate:   1.0, // 100% success
					ResourceUsage: ResourceUsageMetrics{CPUUsage: 0.60, MemoryUsage: 0.45},
					Timestamp:     time.Now().Add(-2 * time.Hour),
				},
				{
					WorkflowID:    workflowID,
					ExecutionTime: 3*time.Minute + 15*time.Second,
					SuccessRate:   1.0, // 100% success
					ResourceUsage: ResourceUsageMetrics{CPUUsage: 0.70, MemoryUsage: 0.55},
					Timestamp:     time.Now().Add(-1 * time.Hour),
				},
				{
					WorkflowID:    workflowID,
					ExecutionTime: 2*time.Minute + 45*time.Second,
					SuccessRate:   0.0, // Failure
					ResourceUsage: ResourceUsageMetrics{CPUUsage: 0.85, MemoryUsage: 0.75},
					Timestamp:     time.Now().Add(-30 * time.Minute),
				},
			}

			// Configure orchestrator with execution data
			adaptiveOrchestrator.SetExecutionHistory(workflowID, executionMetrics)

			// Act: Collect execution statistics
			statistics, err := adaptiveOrchestrator.CollectExecutionStatistics(ctx, workflowID)

			// Assert: Business requirement validation
			Expect(err).To(BeNil(), "Statistics collection should complete successfully")
			Expect(statistics.GetOverallSuccessRate()).To(BeNumerically(">=", 0), "BR-ORK-003: Execution statistics must provide measurable success rate for performance tracking")

			// BR-ORK-003 Success Criteria: Track execution times
			executionTimes := statistics.GetExecutionTimes()
			Expect(len(executionTimes)).To(Equal(3), "Must track all execution times")
			avgExecutionTime := statistics.GetAverageExecutionTime()
			Expect(avgExecutionTime).To(BeNumerically(">", 2*time.Minute), "Average execution time must be calculated correctly")

			// BR-ORK-003 Success Criteria: Track success rates
			successRate := statistics.GetOverallSuccessRate()
			Expect(successRate).To(BeNumerically("~", 0.67, 0.01), "Success rate should be ~67% (2/3 successes)")

			// BR-ORK-003 Success Criteria: Track resource usage
			avgResourceUsage := statistics.GetAverageResourceUsage()
			Expect(avgResourceUsage.CPUUsage).To(BeNumerically(">", 0.60), "Average CPU usage must be tracked")
			Expect(avgResourceUsage.MemoryUsage).To(BeNumerically(">", 0.45), "Average memory usage must be tracked")

			// BR-ORK-003 Success Criteria: Monitor step-level performance and failure patterns
			stepMetrics := statistics.GetStepLevelMetrics()
			Expect(len(stepMetrics)).To(BeNumerically(">=", 1), "BR-ORK-003: Step-level metrics must track individual step performance for granular analysis")
			failurePatterns := statistics.GetFailurePatterns()
			Expect(len(failurePatterns)).To(BeNumerically(">=", 0), "BR-ORK-003: Failure pattern analysis must provide measurable failure classification for orchestration reliability")
		})

		It("should calculate performance trends over time periods and detect degradation", func() {
			// Business Scenario: Long-running workflow shows performance degradation over time
			workflowID := "performance-trends-workflow"

			// Arrange: Create execution history showing performance degradation
			executionMetrics := []WorkflowExecutionData{
				// Week 1: Good performance
				{WorkflowID: workflowID, ExecutionTime: 1*time.Minute + 30*time.Second, SuccessRate: 1.0, Timestamp: time.Now().Add(-7 * 24 * time.Hour)},
				{WorkflowID: workflowID, ExecutionTime: 1*time.Minute + 45*time.Second, SuccessRate: 1.0, Timestamp: time.Now().Add(-6 * 24 * time.Hour)},
				// Week 2: Declining performance
				{WorkflowID: workflowID, ExecutionTime: 2*time.Minute + 30*time.Second, SuccessRate: 0.9, Timestamp: time.Now().Add(-3 * 24 * time.Hour)},
				{WorkflowID: workflowID, ExecutionTime: 3*time.Minute + 15*time.Second, SuccessRate: 0.8, Timestamp: time.Now().Add(-2 * 24 * time.Hour)},
				// Recent: Poor performance
				{WorkflowID: workflowID, ExecutionTime: 4*time.Minute + 30*time.Second, SuccessRate: 0.6, Timestamp: time.Now().Add(-1 * time.Hour)},
			}

			adaptiveOrchestrator.SetExecutionHistory(workflowID, executionMetrics)

			// Act: Analyze performance trends
			trendAnalysis, err := adaptiveOrchestrator.AnalyzePerformanceTrends(ctx, workflowID, 7*24*time.Hour)

			// Assert: Trend analysis validation
			Expect(err).To(BeNil(), "Trend analysis should complete successfully")
			Expect(len(trendAnalysis.GetWeeklyTrends())).To(BeNumerically(">=", 1), "BR-ORK-003: Trend analysis must provide measurable performance trends for weekly periods")

			// BR-ORK-003 Success Criteria: Calculate performance trends over time periods
			weeklyTrends := trendAnalysis.GetWeeklyTrends()
			Expect(len(weeklyTrends)).To(BeNumerically(">=", 2), "Must calculate trends for multiple weeks")

			// BR-ORK-003 Success Criteria: Detect performance degradation early
			degradationDetected := trendAnalysis.HasPerformanceDegradation()
			Expect(degradationDetected).To(BeTrue(), "Must detect performance degradation")
			degradationSeverity := trendAnalysis.GetDegradationSeverity()
			Expect(degradationSeverity).To(Equal("high"), "Should identify high degradation severity")

			// BR-ORK-003 Success Criteria: Identify seasonal patterns
			seasonalPatterns := trendAnalysis.GetSeasonalPatterns()
			Expect(len(seasonalPatterns)).To(BeNumerically(">=", 0), "BR-ORK-003: Seasonal pattern analysis must provide measurable pattern detection for orchestration optimization")

			// Business Value: Performance improvement recommendations
			recommendations := trendAnalysis.GetPerformanceRecommendations()
			Expect(len(recommendations)).To(BeNumerically(">=", 1), "Must provide performance improvement recommendations")
		})

		It("should collect system resource impact during orchestration", func() {
			// Business Scenario: Monitor system impact of orchestration operations
			workflowID := "resource-impact-workflow"

			// Arrange: Configure orchestrator with resource monitoring
			adaptiveOrchestrator.EnableResourceMonitoring(true)
			resourceBaseline := SystemResourceSnapshot{
				CPUUsage:    0.40,
				MemoryUsage: 0.35,
				NetworkIO:   0.20,
				DiskIO:      0.15,
				Timestamp:   time.Now().Add(-5 * time.Minute),
			}
			adaptiveOrchestrator.SetResourceBaseline(resourceBaseline)

			// Act: Execute workflow with resource monitoring
			executionResult, err := adaptiveOrchestrator.ExecuteWorkflowWithResourceMonitoring(ctx, workflowID)

			// Assert: Resource impact tracking
			Expect(err).To(BeNil(), "Workflow execution with monitoring should succeed")
			Expect(executionResult.Success).To(BeTrue(), "BR-ORK-003: Execution result must confirm successful workflow completion for resource impact measurement")

			// BR-ORK-003 Success Criteria: Collect system resource impact during orchestration
			resourceImpact := executionResult.GetResourceImpact()
			Expect(resourceImpact.CPUDelta).ToNot(BeNumerically("==", 0), "BR-ORK-003: Resource impact must provide measurable CPU delta for orchestration performance tracking")
			Expect(resourceImpact.CPUDelta).ToNot(BeNumerically("==", 0), "CPU impact must be measured")
			Expect(resourceImpact.MemoryDelta).ToNot(BeNumerically("==", 0), "Memory impact must be measured")

			// BR-ORK-003 Success Criteria: System resource impact metrics
			impactSummary := resourceImpact.GetImpactSummary()
			Expect(impactSummary.MaxCPUIncrease).To(BeNumerically(">=", 0), "Maximum CPU increase must be tracked")
			Expect(impactSummary.PeakMemoryUsage).To(BeNumerically(">=", resourceBaseline.MemoryUsage), "Peak memory usage must be tracked")
			Expect(impactSummary.NetworkIOPattern).ToNot(BeEmpty(), "Network IO patterns must be identified")

			// Business Value: Resource efficiency scoring
			efficiencyScore := resourceImpact.GetResourceEfficiencyScore()
			Expect(efficiencyScore).To(BeNumerically(">=", 0.0), "Resource efficiency score must be calculated")
			Expect(efficiencyScore).To(BeNumerically("<=", 1.0), "Resource efficiency score must be normalized")
		})
	})
})

// Helper functions for BR-ORK-001 tests

// getOptimizationCandidates extracts optimization candidates from result
func getOptimizationCandidates(result *engine.OptimizationResult) []*OptimizationCandidate {
	if result.OptimizationCandidates == nil {
		return []*OptimizationCandidate{}
	}

	// Type assertion to get the candidates
	candidates, ok := result.OptimizationCandidates.([]*OptimizationCandidate)
	if !ok {
		return []*OptimizationCandidate{}
	}

	return candidates
}
func extractOptimizationTypes(candidates []*OptimizationCandidate) []string {
	types := make([]string, len(candidates))
	for i, candidate := range candidates {
		types[i] = candidate.Type
	}
	return types
}

func selectHighestImpactCandidate(candidates []*OptimizationCandidate) *OptimizationCandidate {
	if len(candidates) == 0 {
		return nil
	}

	best := candidates[0]
	for _, candidate := range candidates[1:] {
		if candidate.Impact > best.Impact {
			best = candidate
		}
	}
	return best
}

func findHighestROICandidate(candidates []*OptimizationCandidate) *OptimizationCandidate {
	if len(candidates) == 0 {
		return nil
	}

	best := candidates[0]
	for _, candidate := range candidates[1:] {
		if candidate.ROIScore > best.ROIScore {
			best = candidate
		}
	}
	return best
}

// Helper functions for BR-ORK-002 tests

// findAdaptationByType finds an adaptation of a specific type
func findAdaptationByType(adaptations []*ExecutionAdaptation, adaptationType string) *ExecutionAdaptation {
	for _, adaptation := range adaptations {
		if adaptation.Type == adaptationType {
			return adaptation
		}
	}
	return nil
}
