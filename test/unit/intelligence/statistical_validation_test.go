package intelligence

import (
	"testing"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/sirupsen/logrus"

	"github.com/jordigilh/kubernaut/pkg/intelligence/learning"
	sharedtypes "github.com/jordigilh/kubernaut/pkg/shared/types"
)

// Suite structure moved to intelligence_suite_test.go - generated by ginkgo bootstrap

var _ = Describe("Statistical Validation - Business Requirements Testing", func() {
	var (
		statisticalValidator *learning.StatisticalValidator
		config               *learning.PatternDiscoveryConfig
		logger               *logrus.Logger
	)

	BeforeEach(func() {
		logger = logrus.New()
		logger.SetLevel(logrus.WarnLevel)

		config = &learning.PatternDiscoveryConfig{
			MinExecutionsForPattern: 10,
			MaxHistoryDays:          30,
		}

		statisticalValidator = learning.NewStatisticalValidator(config, logger)
	})

	// BR-STAT-001: MUST validate statistical assumptions for business models
	Context("BR-STAT-001: Statistical Assumption Validation", func() {
		It("should validate comprehensive statistical assumptions for business confidence", func() {
			// Given: Execution data requiring statistical validation for business decisions
			executionData := createStatisticalExecutionData(100)

			// When: Validating statistical assumptions for business model reliability
			result := statisticalValidator.ValidateStatisticalAssumptions(executionData)

			// Then: Should provide comprehensive statistical validation
			Expect(result.IsValid).To(BeAssignableToTypeOf(bool(false)), "Should provide validity assessment")
			Expect(len(result.Assumptions)).To(BeNumerically(">=", 1), "Should provide detailed assumption checks")
			Expect(result.SampleSizeAdequate).To(BeAssignableToTypeOf(bool(false)), "Should assess sample size adequacy")

			// **Business Value**: Verify validation enables confident business model use
			Expect(result.DataQualityScore).To(BeNumerically(">=", 0.0), "Should provide data quality assessment")
			Expect(result.OverallReliability).To(BeNumerically(">=", 0.0), "Should provide overall reliability score")
			Expect(len(result.Recommendations)).To(BeNumerically(">=", 0), "Should provide business recommendations")

			// Validate individual assumption checks
			for _, assumption := range result.Assumptions {
				Expect(assumption.Name).ToNot(BeEmpty(), "Assumption checks should have descriptive names")
				Expect(assumption.Score).To(BeNumerically(">=", 0.0), "Should provide assumption scores")
			}
		})

		It("should provide actionable recommendations for statistical improvements", func() {
			// Given: Potentially inadequate data requiring improvement guidance
			limitedData := createStatisticalExecutionData(15) // Small sample

			// When: Validating with potentially insufficient data
			result := statisticalValidator.ValidateStatisticalAssumptions(limitedData)

			// Then: Should provide actionable improvement recommendations
			Expect(result.MinRecommendedSamples).To(BeNumerically(">", 0), "Should recommend minimum sample sizes")

			// **Business Value**: Verify recommendations enable data collection optimization
			if !result.SampleSizeAdequate {
				Expect(len(result.Recommendations)).To(BeNumerically(">", 0), "Should provide recommendations for improvement")
			}
		})
	})

	// BR-STAT-002: MUST provide confidence interval analysis for business decisions
	Context("BR-STAT-002: Confidence Interval Analysis", func() {
		It("should calculate confidence intervals for business metrics", func() {
			// Given: Business metrics requiring confidence assessment
			successfulExecutions := 85
			totalExecutions := 100
			confidenceLevel := 0.95

			// When: Calculating confidence intervals for business reporting
			confidenceResult := statisticalValidator.CalculateConfidenceInterval(successfulExecutions, totalExecutions, confidenceLevel)

			// Then: Should provide actionable confidence intervals
			Expect(confidenceResult.Lower).To(BeNumerically(">=", 0.0), "Should provide lower bound")
			Expect(confidenceResult.Upper).To(BeNumerically("<=", 1.0), "Should provide upper bound")
			Expect(confidenceResult.ConfidenceLevel).To(Equal(confidenceLevel), "Should match requested confidence level")

			// **Business Value**: Verify confidence intervals enable risk assessment
			Expect(confidenceResult.IsReliable).To(BeAssignableToTypeOf(bool(false)), "Should assess reliability for business use")
			Expect(confidenceResult.SampleSize).To(Equal(totalExecutions), "Should track sample size for business context")
			Expect(confidenceResult.Method).ToNot(BeEmpty(), "Should specify calculation method for business transparency")
		})

		It("should handle various confidence levels for different business needs", func() {
			// Given: Different business scenarios requiring different confidence levels
			successes := 75
			total := 100
			businessConfidenceLevels := []float64{0.90, 0.95, 0.99}

			// When: Calculating confidence intervals for different business requirements
			for _, confidenceLevel := range businessConfidenceLevels {
				result := statisticalValidator.CalculateConfidenceInterval(successes, total, confidenceLevel)

				// Then: Should provide appropriate intervals for each business need
				Expect(result.ConfidenceLevel).To(Equal(confidenceLevel), "Should match requested confidence level")

				// **Business Value**: Verify higher confidence levels produce wider intervals
				intervalWidth := result.Upper - result.Lower
				Expect(intervalWidth).To(BeNumerically(">", 0), "Should provide meaningful interval width")
			}
		})
	})

	// BR-STAT-003: MUST assess reliability for business model confidence
	Context("BR-STAT-003: Reliability Assessment", func() {
		It("should assess reliability of statistical models for business use", func() {
			// Given: Execution data requiring reliability assessment for business confidence
			businessExecutionData := createStatisticalExecutionData(80)

			// When: Assessing reliability for business decision making
			reliabilityResult := statisticalValidator.AssessReliability(businessExecutionData)

			// Then: Should provide comprehensive reliability assessment
			Expect(reliabilityResult.IsReliable).To(BeAssignableToTypeOf(bool(false)), "Should provide reliability determination")
			Expect(reliabilityResult.ReliabilityScore).To(BeNumerically(">=", 0.0), "Should provide reliability score")
			Expect(reliabilityResult.RecommendedMinSize).To(BeNumerically(">", 0), "Should recommend minimum sample size")

			// **Business Value**: Verify reliability assessment enables confident business decisions
			Expect(reliabilityResult.ActualSize).To(Equal(len(businessExecutionData)), "Should track actual sample size")
			Expect(reliabilityResult.DataQuality).To(BeNumerically(">=", 0.0), "Should assess data quality")
			Expect(reliabilityResult.TemporalStability).To(BeNumerically(">=", 0.0), "Should assess temporal stability")
			Expect(reliabilityResult.StatisticalValidity).To(BeNumerically(">=", 0.0), "Should assess statistical validity")
			Expect(len(reliabilityResult.Recommendations)).To(BeNumerically(">=", 0), "Should provide business recommendations")
		})

		It("should provide different reliability assessments for varying data quality", func() {
			// Given: Different quality datasets for comparison
			highQualityData := createStatisticalExecutionData(100) // Large, high-quality sample
			lowQualityData := createStatisticalExecutionData(20)   // Small, potentially lower quality

			// When: Assessing reliability for different business scenarios
			highQualityReliability := statisticalValidator.AssessReliability(highQualityData)
			lowQualityReliability := statisticalValidator.AssessReliability(lowQualityData)

			// Then: Should provide appropriate reliability assessments
			Expect(highQualityReliability.ReliabilityScore).To(BeNumerically(">=", 0.0), "Should assess high-quality data")
			Expect(lowQualityReliability.ReliabilityScore).To(BeNumerically(">=", 0.0), "Should assess low-quality data")

			// **Business Value**: Verify reliability scales with data quality
			Expect(highQualityReliability.ActualSize).To(BeNumerically(">", lowQualityReliability.ActualSize), "Should reflect different sample sizes")

			// Higher quality data should generally have better or equal reliability metrics
			if highQualityReliability.IsReliable && !lowQualityReliability.IsReliable {
				Expect(len(lowQualityReliability.Recommendations)).To(BeNumerically(">", 0), "Should provide improvement recommendations for lower quality data")
			}
		})
	})

	// Comprehensive Business Value Validation
	Context("Comprehensive Statistical Validation for Business Confidence", func() {
		It("should provide integrated statistical analysis for business decision making", func() {
			// Given: Complete business dataset requiring comprehensive statistical analysis
			businessDataset := createStatisticalExecutionData(90)

			// When: Performing comprehensive statistical analysis for business confidence
			assumptionResult := statisticalValidator.ValidateStatisticalAssumptions(businessDataset)
			reliabilityResult := statisticalValidator.AssessReliability(businessDataset)
			confidenceResult := statisticalValidator.CalculateConfidenceInterval(75, 90, 0.95)

			// Then: Should provide comprehensive business decision support
			Expect(assumptionResult.IsValid).To(BeAssignableToTypeOf(bool(false)), "Should provide assumption validation")
			Expect(reliabilityResult.IsReliable).To(BeAssignableToTypeOf(bool(false)), "Should provide reliability assessment")
			Expect(confidenceResult.IsReliable).To(BeAssignableToTypeOf(bool(false)), "Should provide confidence intervals")

			// **Business Value**: Verify integrated analysis enables confident business decisions
			if assumptionResult.IsValid && reliabilityResult.IsReliable {
				Expect(confidenceResult.IsReliable).To(BeTrue(), "Should provide reliable confidence intervals for valid, reliable data")
			}

			// Ensure all components provide business value
			Expect(len(assumptionResult.Recommendations)+len(reliabilityResult.Recommendations)).To(BeNumerically(">=", 0),
				"Should provide comprehensive business recommendations")
		})

		It("should handle various business scenarios with appropriate statistical guidance", func() {
			// Given: Different business scenarios requiring statistical guidance
			scenarios := []struct {
				name string
				size int
			}{
				{"small_pilot", 25},
				{"medium_study", 50},
				{"large_analysis", 100},
			}

			// When: Analyzing different business scenarios
			for _, scenario := range scenarios {
				data := createStatisticalExecutionData(scenario.size)
				reliability := statisticalValidator.AssessReliability(data)

				// Then: Should provide scenario-appropriate guidance
				Expect(reliability.ActualSize).To(Equal(scenario.size), "Should track actual size for %s", scenario.name)

				// **Business Value**: Verify guidance scales appropriately with business context
				if scenario.size >= 50 {
					// Larger samples should generally be more reliable
					Expect(reliability.ReliabilityScore).To(BeNumerically(">=", 0.0), "Should provide reliability score for %s", scenario.name)
				}
			}
		})
	})
})

// Helper functions for creating test data aligned with actual statistical validator API

func createStatisticalExecutionData(count int) []*sharedtypes.WorkflowExecutionData {
	data := make([]*sharedtypes.WorkflowExecutionData, count)

	for i := 0; i < count; i++ {
		data[i] = &sharedtypes.WorkflowExecutionData{
			ExecutionID: fmt.Sprintf("stat-exec-%d", i),
			WorkflowID:  fmt.Sprintf("stat-workflow-%d", i%5),
			Timestamp:   time.Now().Add(-time.Duration(i) * time.Hour),
			Duration:    time.Duration(60+i*2) * time.Minute,
			Success:     i%4 != 0, // 75% success rate
			Metrics: map[string]float64{
				"cpu_usage":      float64(20 + i%50),
				"memory_usage":   float64(30 + i%60),
				"execution_time": float64(60 + i*2),
				"error_rate":     float64(0.01 + float64(i%3)*0.01),
			},
			Metadata: map[string]interface{}{
				"environment":        "production",
				"cluster":            fmt.Sprintf("cluster-%d", i%3),
				"business_priority":  i % 4,
				"data_quality_score": 0.8 + float64(i%20)*0.01,
			},
		}
	}

	return data
}

// End of statistical validation test helper functions

// TestRunner bootstraps the Ginkgo test suite
func TestUstatisticalUvalidation(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "UstatisticalUvalidation Suite")
}
