/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/go-logr/logr"
	"github.com/jmoiron/sqlx"
	"github.com/pgvector/pgvector-go"

	"github.com/jordigilh/kubernaut/pkg/datastorage/embedding"
	"github.com/jordigilh/kubernaut/pkg/datastorage/models"
)

// ========================================
// WORKFLOW REPOSITORY
// ========================================
// Authority: DD-STORAGE-008 v2.0 (Workflow Catalog Schema)
// Business Requirement: BR-STORAGE-012 (Workflow Semantic Search)
// Design Decision: DD-WORKFLOW-002 (MCP Workflow Catalog Architecture)
// ========================================

// WorkflowRepository handles workflow catalog operations
type WorkflowRepository struct {
	db              *sqlx.DB
	logger          logr.Logger
	embeddingClient embedding.Client
}

// NewWorkflowRepository creates a new workflow repository
// BR-STORAGE-014: Embedding client is optional (nil = no automatic embedding generation)
func NewWorkflowRepository(db *sqlx.DB, logger logr.Logger, embeddingClient embedding.Client) *WorkflowRepository {
	return &WorkflowRepository{
		db:              db,
		logger:          logger,
		embeddingClient: embeddingClient,
	}
}

// ========================================
// CREATE OPERATIONS
// ========================================

// Create inserts a new workflow into the catalog
// BR-STORAGE-012: Workflow catalog persistence
// BR-STORAGE-014: Automatic embedding generation for semantic search
// DD-WORKFLOW-002 v3.0: Handles is_latest_version flag within a transaction
func (r *WorkflowRepository) Create(ctx context.Context, workflow *models.RemediationWorkflow) error {
	// Generate embedding if not provided and embedding client is available
	if workflow.Embedding == nil && r.embeddingClient != nil {
		// Construct searchable text from workflow metadata
		searchText := r.buildSearchText(workflow)

		// Generate embedding vector
		embeddingVec, err := r.embeddingClient.Embed(ctx, searchText)
		if err != nil {
			r.logger.Info("failed to generate embedding, proceeding without it",
				"workflow_id", workflow.WorkflowID,
				"version", workflow.Version,
				"error", err)
			// Continue without embedding (graceful degradation)
		} else {
			// Convert []float32 to *pgvector.Vector
			vec := pgvector.NewVector(embeddingVec)
			workflow.Embedding = &vec
			r.logger.V(1).Info("generated embedding for workflow",
				"workflow_id", workflow.WorkflowID,
				"version", workflow.Version,
				"dimensions", len(embeddingVec))
		}
	}

	// DD-WORKFLOW-002 v3.0: Use transaction to ensure is_latest_version consistency
	// When creating a new version, mark all previous versions as not latest
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		r.logger.Error(err, "failed to begin transaction",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version)
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// DD-WORKFLOW-002 v3.0: Mark previous versions as not latest
	// This ensures only one version per workflow_name has is_latest_version=true
	if workflow.IsLatestVersion {
		updateQuery := `
			UPDATE remediation_workflow_catalog
			SET is_latest_version = false, updated_at = NOW()
			WHERE workflow_name = $1 AND is_latest_version = true
		`
		result, err := tx.ExecContext(ctx, updateQuery, workflow.WorkflowName)
		if err != nil {
			r.logger.Error(err, "failed to update previous versions",
				"workflow_name", workflow.WorkflowName,
				"version", workflow.Version)
			return fmt.Errorf("failed to update previous versions: %w", err)
		}
		rowsAffected, _ := result.RowsAffected()
		if rowsAffected > 0 {
			r.logger.Info("marked previous versions as not latest",
				"workflow_name", workflow.WorkflowName,
				"versions_updated", rowsAffected)
		}
	}

	// DD-WORKFLOW-002 v3.0: workflow_id is UUID (auto-generated by DB), workflow_name is human-readable
	// DD-WORKFLOW-001 v1.6: Added custom_labels and detected_labels columns
	// Use QueryRowContext with positional parameters to get the RETURNING value
	// sqlx doesn't support RETURNING with NamedExecContext, so we need to use positional parameters
	insertQuery := `
		INSERT INTO remediation_workflow_catalog (
			workflow_name, version, name, description, owner, maintainer,
			content, content_hash, labels, custom_labels, detected_labels, embedding, status,
			is_latest_version, previous_version, version_notes, change_summary,
			approved_by, approved_at, expected_success_rate, expected_duration_seconds,
			created_by
		) VALUES (
			$1, $2, $3, $4, $5, $6,
			$7, $8, $9, $10, $11, $12, $13,
			$14, $15, $16, $17,
			$18, $19, $20, $21,
			$22
		)
		RETURNING workflow_id
	`

	// Ensure custom_labels and detected_labels default to empty JSON if nil
	customLabels := workflow.CustomLabels
	if customLabels == nil {
		customLabels = []byte("{}")
	}
	detectedLabels := workflow.DetectedLabels
	if detectedLabels == nil {
		detectedLabels = []byte("{}")
	}

	var generatedID string
	err = tx.QueryRowContext(ctx, insertQuery,
		workflow.WorkflowName, workflow.Version, workflow.Name, workflow.Description, workflow.Owner, workflow.Maintainer,
		workflow.Content, workflow.ContentHash, workflow.Labels, customLabels, detectedLabels, workflow.Embedding, workflow.Status,
		workflow.IsLatestVersion, workflow.PreviousVersion, workflow.VersionNotes, workflow.ChangeSummary,
		workflow.ApprovedBy, workflow.ApprovedAt, workflow.ExpectedSuccessRate, workflow.ExpectedDurationSeconds,
		workflow.CreatedBy,
	).Scan(&generatedID)
	if err != nil {
		r.logger.Error(err, "failed to create workflow",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version,
			"error", err)
		return fmt.Errorf("failed to create workflow: %w", err)
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		r.logger.Error(err, "failed to commit transaction",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version)
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Set the generated UUID on the workflow
	workflow.WorkflowID = generatedID

	r.logger.Info("workflow created",
		"workflow_id", workflow.WorkflowID,
		"workflow_name", workflow.WorkflowName,
		"version", workflow.Version,
		"has_embedding", workflow.Embedding != nil,
		"is_latest_version", workflow.IsLatestVersion)

	return nil
}

// ========================================
// READ OPERATIONS
// ========================================

// GetByID retrieves a workflow by UUID (primary key)
// DD-WORKFLOW-002 v3.0: workflow_id is the sole UUID primary key
func (r *WorkflowRepository) GetByID(ctx context.Context, workflowID string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_id = $1
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s", workflowID)
		}
		r.logger.Error(err, "failed to get workflow",
			"workflow_id", workflowID,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow: %w", err)
	}

	return &workflow, nil
}

// GetByNameAndVersion retrieves a specific workflow by name and version
// DD-WORKFLOW-002 v3.0: workflow_name + version is unique constraint
func (r *WorkflowRepository) GetByNameAndVersion(ctx context.Context, workflowName, version string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1 AND version = $2
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowName, version)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s@%s", workflowName, version)
		}
		r.logger.Error(err, "failed to get workflow",
			"workflow_name", workflowName,
			"version", version,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow: %w", err)
	}

	return &workflow, nil
}

// GetLatestVersion retrieves the latest version of a workflow by name
// DD-WORKFLOW-002 v3.0: Use workflow_name to find latest version
func (r *WorkflowRepository) GetLatestVersion(ctx context.Context, workflowName string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1 AND is_latest_version = true
		LIMIT 1
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s", workflowName)
		}
		r.logger.Error(err, "failed to get latest workflow version", "workflow_name", workflowName)
		return nil, fmt.Errorf("failed to get latest workflow version: %w", err)
	}

	return &workflow, nil
}

// GetVersionsByName retrieves all versions of a workflow by name
// DD-WORKFLOW-002 v3.0: List all versions by workflow_name
func (r *WorkflowRepository) GetVersionsByName(ctx context.Context, workflowName string) ([]models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1
		ORDER BY created_at DESC
	`

	var workflows []models.RemediationWorkflow
	err := r.db.SelectContext(ctx, &workflows, query, workflowName)
	if err != nil {
		r.logger.Error(err, "failed to get workflow versions",
			"workflow_name", workflowName,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow versions: %w", err)
	}

	r.logger.Info("workflow versions retrieved",
		"workflow_name", workflowName,
		"count", len(workflows))

	return workflows, nil
}

// List retrieves workflows with optional filtering
func (r *WorkflowRepository) List(ctx context.Context, filters *models.WorkflowSearchFilters, limit, offset int) ([]models.RemediationWorkflow, int, error) {
	// Build WHERE clause
	whereClauses := []string{}
	args := []interface{}{}
	argIndex := 1

	// Default: only active workflows
	if filters == nil || len(filters.Status) == 0 {
		whereClauses = append(whereClauses, fmt.Sprintf("status = $%d", argIndex))
		args = append(args, "active")
		argIndex++
	} else {
		// Filter by specified statuses
		placeholders := []string{}
		for _, status := range filters.Status {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argIndex))
			args = append(args, status)
			argIndex++
		}
		whereClauses = append(whereClauses, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))
	}

	// Only latest versions by default
	whereClauses = append(whereClauses, "is_latest_version = true")

	// Apply label filters (updated for DD-LLM-001 taxonomy)
	if filters != nil {
		// Mandatory: signal_type (single value)
		if filters.SignalType != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'signal_type' = $%d", argIndex))
			args = append(args, filters.SignalType)
			argIndex++
		}

		// Mandatory: severity
		if filters.Severity != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'severity' = $%d", argIndex))
			args = append(args, filters.Severity)
			argIndex++
		}

		// DD-WORKFLOW-001 v1.4: 5 mandatory labels (3 more added)
		// Mandatory: component
		if filters.Component != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'component' = $%d", argIndex))
			args = append(args, filters.Component)
			argIndex++
		}

		// Mandatory: environment (moved from optional)
		if filters.Environment != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'environment' = $%d", argIndex))
			args = append(args, filters.Environment)
			argIndex++
		}

		// Mandatory: priority (moved from optional)
		if filters.Priority != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'priority' = $%d", argIndex))
			args = append(args, filters.Priority)
			argIndex++
		}

		// DD-WORKFLOW-001 v1.5: Custom labels (subdomain-based)
		// Format: custom_labels @> '{"subdomain": ["value"]}'::jsonb
		for subdomain, values := range filters.CustomLabels {
			if len(values) > 0 {
				customLabelJSON, _ := json.Marshal(map[string][]string{subdomain: values})
				whereClauses = append(whereClauses, fmt.Sprintf("custom_labels @> $%d::jsonb", argIndex))
				args = append(args, string(customLabelJSON))
				argIndex++
			}
		}
	}

	whereClause := strings.Join(whereClauses, " AND ")

	// Count total results
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM remediation_workflow_catalog WHERE %s", whereClause)
	var total int
	err := r.db.GetContext(ctx, &total, countQuery, args...)
	if err != nil {
		r.logger.Error(err, "failed to count workflows")
		return nil, 0, fmt.Errorf("failed to count workflows: %w", err)
	}

	// Get paginated results
	query := fmt.Sprintf(`
		SELECT * FROM remediation_workflow_catalog
		WHERE %s
		ORDER BY created_at DESC
		LIMIT $%d OFFSET $%d
	`, whereClause, argIndex, argIndex+1)

	args = append(args, limit, offset)

	var workflows []models.RemediationWorkflow
	err = r.db.SelectContext(ctx, &workflows, query, args...)
	if err != nil {
		r.logger.Error(err, "failed to list workflows")
		return nil, 0, fmt.Errorf("failed to list workflows: %w", err)
	}

	return workflows, total, nil
}

// ========================================
// SEMANTIC SEARCH (pgvector)
// ========================================
// BR-STORAGE-013: Semantic Search API
// DD-WORKFLOW-002: MCP Workflow Catalog Architecture

// SearchByEmbedding performs semantic search using pgvector
// TDD CYCLE 1: Mandatory Label Filtering (GREEN Phase)
// BR-STORAGE-013: Hybrid Weighted Scoring
// DD-WORKFLOW-004 v1.1: Hybrid Weighted Label Scoring
func (r *WorkflowRepository) SearchByEmbedding(ctx context.Context, request *models.WorkflowSearchRequest) (*models.WorkflowSearchResponse, error) {
	if request.Embedding == nil {
		return nil, fmt.Errorf("embedding is required for semantic search")
	}

	// Build WHERE clause for filters
	whereClauses := []string{}
	args := []interface{}{request.Embedding} // $1 is the embedding vector
	argIndex := 2

	// Default: only active workflows unless IncludeDisabled is true
	if !request.IncludeDisabled {
		whereClauses = append(whereClauses, fmt.Sprintf("status = $%d", argIndex))
		args = append(args, "active")
		argIndex++
	}

	// Only latest versions
	whereClauses = append(whereClauses, "is_latest_version = true")

	// ========================================
	// TDD CYCLE 1: MANDATORY LABEL FILTERING (REFACTOR)
	// ========================================
	// Authority: DD-LLM-001 v1.0 (MCP Search Taxonomy)
	// DD-WORKFLOW-004 v1.1: Hybrid Weighted Label Scoring
	//
	// Mandatory labels provide strict filtering (Phase 1):
	// - signal_type: Exact match required (e.g., "OOMKilled", "MemoryLeak")
	// - severity: Exact match required (e.g., "critical", "high", "medium", "low")
	//
	// These filters reduce the candidate set before semantic ranking.
	// Only workflows matching BOTH mandatory labels proceed to scoring.

	// Apply mandatory label filters
	// DD-WORKFLOW-001 v1.6: 5 mandatory labels with snake_case JSON tags
	if request.Filters != nil {
		// Mandatory Filter 1: signal_type (exact match)
		// Example: labels->>'signal_type' = 'OOMKilled'
		if request.Filters.SignalType != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'signal_type' = $%d", argIndex))
			args = append(args, request.Filters.SignalType)
			argIndex++
		}

		// Mandatory Filter 2: severity (exact match)
		// Example: labels->>'severity' = 'critical'
		if request.Filters.Severity != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'severity' = $%d", argIndex))
			args = append(args, request.Filters.Severity)
			argIndex++
		}

		// Mandatory Filter 3: component (exact match)
		// Example: labels->>'component' = 'pod'
		if request.Filters.Component != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'component' = $%d", argIndex))
			args = append(args, request.Filters.Component)
			argIndex++
		}

		// Mandatory Filter 4: environment (exact match)
		// Example: labels->>'environment' = 'production'
		if request.Filters.Environment != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'environment' = $%d", argIndex))
			args = append(args, request.Filters.Environment)
			argIndex++
		}

		// Mandatory Filter 5: priority (exact match)
		// Example: labels->>'priority' = 'P0'
		if request.Filters.Priority != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'priority' = $%d", argIndex))
			args = append(args, request.Filters.Priority)
			argIndex++
		}

		// DD-WORKFLOW-001 v1.5: Custom labels (subdomain-based)
		// Format: custom_labels @> '{"subdomain": ["value"]}'::jsonb
		for subdomain, values := range request.Filters.CustomLabels {
			if len(values) > 0 {
				customLabelJSON, _ := json.Marshal(map[string][]string{subdomain: values})
				whereClauses = append(whereClauses, fmt.Sprintf("custom_labels @> $%d::jsonb", argIndex))
				args = append(args, string(customLabelJSON))
				argIndex++
			}
		}
	}

	// Apply minimum similarity threshold
	minSimilarity := 0.7 // Default: 70% similarity
	if request.MinSimilarity != nil {
		minSimilarity = *request.MinSimilarity
	}

	// pgvector cosine similarity: 1 - (embedding <=> $1)
	// Higher similarity = closer to 1.0
	whereClauses = append(whereClauses, fmt.Sprintf("(1 - (embedding <=> $1)) >= $%d", argIndex))
	args = append(args, minSimilarity)
	argIndex++

	whereClause := ""
	if len(whereClauses) > 0 {
		whereClause = "WHERE " + strings.Join(whereClauses, " AND ")
	}

	// Set default TopK
	topK := 10
	if request.TopK > 0 {
		topK = request.TopK
	}

	// ========================================
	// TDD CYCLE 2: HYBRID SCORING SQL QUERY WITH LABEL BOOSTING (GREEN)
	// ========================================
	// Semantic search query with pgvector + hybrid scoring
	// ORDER BY: final_score DESC (highest score first)
	// Score components:
	//   - base_similarity: cosine similarity from pgvector (0.0-1.0)
	//   - label_boost: boost from matching optional labels (0.0-0.46)
	//   - label_penalty: penalty from conflicting optional labels (0.0-0.20) [TDD Cycle 3]
	//   - final_score: LEAST(base_similarity + label_boost - label_penalty, 1.0) [TDD Cycle 4]
	//
	// Boost Weights (DD-WORKFLOW-004 v1.1):
	//   - resource_management: +0.10
	//   - gitops_tool: +0.10
	//   - environment: +0.08
	//   - business_category: +0.08
	//   - priority: +0.05
	//   - risk_tolerance: +0.05
	//   - Max total boost: 0.46

	// ========================================
	// TDD CYCLE 2: LABEL BOOST CALCULATION (REFACTOR)
	// ========================================
	// DD-WORKFLOW-001 v1.6: Boost/penalty applies to DetectedLabels string fields
	// Build label boost calculation using extracted constants
	// Each matching optional label adds its weight to the total boost
	boostCases := []string{}

	// DetectedLabels boosts (only if filter provided)
	// DD-WORKFLOW-001 v1.6: Only string fields support boost/penalty
	if request.Filters != nil && request.Filters.DetectedLabels != nil {
		dl := request.Filters.DetectedLabels

		// Boost 1: git_ops_tool (+0.10)
		// Example: argocd workflow gets boost when searching for argocd
		// Wildcard "*" matches any non-null value
		if dl.GitOpsTool != nil {
			if *dl.GitOpsTool == "*" {
				// Wildcard: boost if any value is present
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'git_ops_tool' IS NOT NULL THEN %.2f", boostWeightGitOpsTool))
			} else {
				// Exact match
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'git_ops_tool' = $%d THEN %.2f", argIndex, boostWeightGitOpsTool))
				args = append(args, *dl.GitOpsTool)
				argIndex++
			}
		}

		// Boost 2: pod_security_level (+0.08)
		// Example: restricted workflow gets boost when searching for restricted
		if dl.PodSecurityLevel != nil {
			if *dl.PodSecurityLevel == "*" {
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'pod_security_level' IS NOT NULL THEN %.2f", boostWeightEnvironment))
			} else {
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'pod_security_level' = $%d THEN %.2f", argIndex, boostWeightEnvironment))
				args = append(args, *dl.PodSecurityLevel)
				argIndex++
			}
		}

		// Boost 3: service_mesh (+0.08)
		// Example: istio workflow gets boost when searching for istio
		if dl.ServiceMesh != nil {
			if *dl.ServiceMesh == "*" {
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'service_mesh' IS NOT NULL THEN %.2f", boostWeightBusinessCategory))
			} else {
				boostCases = append(boostCases, fmt.Sprintf("WHEN detected_labels->>'service_mesh' = $%d THEN %.2f", argIndex, boostWeightBusinessCategory))
				args = append(args, *dl.ServiceMesh)
				argIndex++
			}
		}
	}

	// Build label boost SQL expression
	labelBoostSQL := "0.0"
	if len(boostCases) > 0 {
		// Sum all matching label boosts
		caseExpressions := []string{}
		for _, boostCase := range boostCases {
			caseExpressions = append(caseExpressions, fmt.Sprintf("(CASE %s ELSE 0.0 END)", boostCase))
		}
		labelBoostSQL = strings.Join(caseExpressions, " + ")
	}

	// ========================================
	// TDD CYCLE 3: LABEL PENALTY CALCULATION (REFACTOR)
	// ========================================
	// Build label penalty calculation
	// DD-WORKFLOW-001 v1.6: Penalty applies to DetectedLabels string fields
	//
	// Penalty Logic:
	// - Applies when workflow label EXISTS but CONFLICTS with search filter
	// - Only git_ops_tool has penalties (other DetectedLabels don't)
	// - Rationale: GitOps tool is a critical decision (argocd vs flux)
	//
	// Examples:
	// - Searching for argocd, find flux workflow → -0.10 penalty
	// - Searching for "*" (any GitOps), find flux workflow → 0.0 penalty (wildcard matches)
	penaltyCases := []string{}

	if request.Filters != nil && request.Filters.DetectedLabels != nil {
		dl := request.Filters.DetectedLabels

		// Penalty 1: git_ops_tool conflict (-0.10)
		// Critical label: ArgoCD vs Flux are incompatible tools
		// Wildcard "*" does NOT apply penalty (matches any value)
		if dl.GitOpsTool != nil && *dl.GitOpsTool != "*" {
			// Exact match required - penalty if workflow has different tool
			penaltyCases = append(penaltyCases, fmt.Sprintf(
				"WHEN detected_labels->>'git_ops_tool' IS NOT NULL AND detected_labels->>'git_ops_tool' != $%d THEN %.2f",
				argIndex-len(boostCases), // Reuse the same parameter from boost
				penaltyWeightGitOpsTool,
			))
		}
	}

	// Build label penalty SQL expression
	labelPenaltySQL := "0.0"
	if len(penaltyCases) > 0 {
		// Sum all conflicting label penalties
		caseExpressions := []string{}
		for _, penaltyCase := range penaltyCases {
			caseExpressions = append(caseExpressions, fmt.Sprintf("(CASE %s ELSE 0.0 END)", penaltyCase))
		}
		labelPenaltySQL = strings.Join(caseExpressions, " + ")
	}

	// ========================================
	// TDD CYCLE 4: FINAL SCORE CALCULATION WITH CAPPING (GREEN)
	// ========================================
	// Final Score Formula:
	//   final_score = LEAST(base_similarity + label_boost - label_penalty, 1.0)
	//
	// Capping Rationale:
	//   - Scores must remain in [0.0, 1.0] range for consistency
	//   - High base similarity (e.g., 0.95) + high boost (e.g., 0.18) could exceed 1.0
	//   - LEAST() function caps the score at 1.0
	//
	// Example:
	//   base=0.95, boost=0.18, penalty=0.0 → uncapped=1.13 → final=1.0 (capped)
	//   base=0.80, boost=0.10, penalty=0.0 → uncapped=0.90 → final=0.90 (not capped)

	query := fmt.Sprintf(`
		SELECT
			*,
			(1 - (embedding <=> $1)) AS base_similarity,
			(%s) AS label_boost,
			(%s) AS label_penalty,
			LEAST((1 - (embedding <=> $1)) + (%s) - (%s), 1.0) AS final_score,
			(1 - (embedding <=> $1)) AS similarity_score
		FROM remediation_workflow_catalog
		%s
		ORDER BY final_score DESC
		LIMIT $%d
	`, labelBoostSQL, labelPenaltySQL, labelBoostSQL, labelPenaltySQL, whereClause, argIndex)

	args = append(args, topK)

	// Execute query
	type workflowWithScore struct {
		models.RemediationWorkflow
		BaseSimilarity  float64 `db:"base_similarity"`
		LabelBoost      float64 `db:"label_boost"`
		LabelPenalty    float64 `db:"label_penalty"`
		FinalScore      float64 `db:"final_score"`
		SimilarityScore float64 `db:"similarity_score"`
	}

	var results []workflowWithScore
	err := r.db.SelectContext(ctx, &results, query, args...)
	if err != nil {
		r.logger.Error(err, "failed to search workflows", "query", request.Query)
		return nil, fmt.Errorf("failed to search workflows: %w", err)
	}

	// Build response with DD-WORKFLOW-002 v3.0 flat structure
	searchResults := make([]models.WorkflowSearchResult, len(results))
	for i, result := range results {
		// Extract signal_type from labels JSONB
		signalType := ""
		if result.Labels != nil {
			var labels map[string]interface{}
			if err := json.Unmarshal(result.Labels, &labels); err == nil {
				if st, ok := labels["signal_type"].(string); ok {
					signalType = st
				}
			}
		}

		// Handle optional pointer fields
		containerImage := ""
		if result.ContainerImage != nil {
			containerImage = *result.ContainerImage
		}
		containerDigest := ""
		if result.ContainerDigest != nil {
			containerDigest = *result.ContainerDigest
		}

		// DD-WORKFLOW-002 v3.0: Flat response structure
		searchResults[i] = models.WorkflowSearchResult{
			// Flat fields per DD-WORKFLOW-002 v3.0
			WorkflowID:      result.WorkflowID,
			Title:           result.Name, // DD-WORKFLOW-002 v3.0: "name" renamed to "title"
			Description:     result.Description,
			SignalType:      signalType,
			ContainerImage:  containerImage,
			ContainerDigest: containerDigest,

			// Scoring fields
			Confidence:      result.FinalScore, // DD-WORKFLOW-002 v3.0: "confidence" = final_score
			BaseSimilarity:  result.BaseSimilarity,
			LabelBoost:      result.LabelBoost,
			LabelPenalty:    result.LabelPenalty,
			FinalScore:      result.FinalScore,
			SimilarityScore: result.SimilarityScore,
			Rank:            i + 1,

			// DD-WORKFLOW-001 v1.6: Label columns in response
			CustomLabels:   result.CustomLabels,
			DetectedLabels: result.DetectedLabels,

			// Internal: full workflow for audit/logging (not serialized)
			Workflow: result.RemediationWorkflow,
		}
	}

	response := &models.WorkflowSearchResponse{
		Workflows:    searchResults,
		TotalResults: len(searchResults),
		Query:        request.Query,
		Filters:      request.Filters,
	}

	r.logger.Info("semantic search completed",
		"query", request.Query,
		"results", len(searchResults))

	return response, nil
}

// ========================================
// UPDATE OPERATIONS
// ========================================

// UpdateSuccessMetrics updates the success metrics for a workflow
func (r *WorkflowRepository) UpdateSuccessMetrics(ctx context.Context, workflowID, version string, totalExecutions, successfulExecutions int) error {
	query := `
		UPDATE remediation_workflow_catalog
		SET
			total_executions = $1,
			successful_executions = $2,
			actual_success_rate = CASE
				WHEN $1 > 0 THEN $2::DECIMAL / $1::DECIMAL
				ELSE NULL
			END,
			updated_at = NOW()
		WHERE workflow_id = $3 AND version = $4
	`

	result, err := r.db.ExecContext(ctx, query, totalExecutions, successfulExecutions, workflowID, version)
	if err != nil {
		r.logger.Error(err, "failed to update workflow success metrics",
			"workflow_id", workflowID,
			"version", version,
			"error", err)
		return fmt.Errorf("failed to update workflow success metrics: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("workflow not found: %s@%s", workflowID, version)
	}

	r.logger.Info("workflow success metrics updated",
		"workflow_id", workflowID,
		"version", version,
		"total_executions", totalExecutions,
		"successful_executions", successfulExecutions)

	return nil
}

// UpdateStatus updates the workflow status
// DD-WORKFLOW-002 v3.0: workflow_id is UUID primary key, no version needed
func (r *WorkflowRepository) UpdateStatus(ctx context.Context, workflowID, version, status, reason, updatedBy string) error {
	// DD-WORKFLOW-002 v3.0: workflow_id (UUID) is the primary key
	// Version is kept in signature for backward compatibility but not used in query
	//
	// Note: We use separate parameters for status comparison to avoid PostgreSQL
	// type inference issues with $1 being used in both SET and CASE expressions
	query := `
		UPDATE remediation_workflow_catalog
		SET
			status = $1::text,
			disabled_at = CASE WHEN $1::text = 'disabled' THEN NOW() ELSE disabled_at END,
			disabled_by = CASE WHEN $1::text = 'disabled' THEN $2 ELSE disabled_by END,
			disabled_reason = CASE WHEN $1::text = 'disabled' THEN $3 ELSE disabled_reason END,
			updated_at = NOW(),
			updated_by = $2
		WHERE workflow_id = $4::uuid
	`

	result, err := r.db.ExecContext(ctx, query, status, updatedBy, reason, workflowID)
	if err != nil {
		r.logger.Error(err, "failed to update workflow status",
			"workflow_id", workflowID,
			"status", status,
			"error", err)
		return fmt.Errorf("failed to update workflow status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("workflow not found: %s", workflowID)
	}

	r.logger.Info("workflow status updated",
		"workflow_id", workflowID,
		"status", status)

	return nil
}

// ========================================
// HELPER FUNCTIONS
// ========================================

// buildSearchText constructs searchable text from workflow metadata for embedding generation
// BR-STORAGE-014: Semantic search text construction
//
// Strategy: Combine name, description, and content for comprehensive semantic representation
// Weight: Name (high), Description (medium), Content preview (low)
func (r *WorkflowRepository) buildSearchText(workflow *models.RemediationWorkflow) string {
	var parts []string

	// Name (highest weight - include 3 times for emphasis)
	if workflow.Name != "" {
		parts = append(parts, workflow.Name, workflow.Name, workflow.Name)
	}

	// Description (medium weight - include 2 times)
	if workflow.Description != "" {
		parts = append(parts, workflow.Description, workflow.Description)
	}

	// Content preview (low weight - first 500 chars only)
	if workflow.Content != "" {
		contentPreview := workflow.Content
		if len(contentPreview) > 500 {
			contentPreview = contentPreview[:500]
		}
		parts = append(parts, contentPreview)
	}

	return strings.Join(parts, " ")
}

// toJSONArray converts a string slice to a JSON array string
func toJSONArray(items []string) string {
	if len(items) == 0 {
		return "[]"
	}

	quoted := make([]string, len(items))
	for i, item := range items {
		quoted[i] = fmt.Sprintf(`"%s"`, item)
	}

	return fmt.Sprintf("[%s]", strings.Join(quoted, ", "))
}

// ========================================
// HYBRID SCORING CONSTANTS
// ========================================
// Authority: DD-WORKFLOW-004 v1.1 (Hybrid Weighted Label Scoring)
// TDD Cycle 2: Optional Label Boost Weights
// TDD Cycle 3: Optional Label Penalty Weights

const (
	// Boost weights for optional labels (when they match)
	boostWeightResourceManagement = 0.10 // GitOps vs Manual vs Automated
	boostWeightGitOpsTool         = 0.10 // ArgoCD vs Flux vs None
	boostWeightEnvironment        = 0.08 // Production vs Staging vs Development
	boostWeightBusinessCategory   = 0.08 // Payments, Auth, Data-Processing, etc.
	boostWeightPriority           = 0.05 // P0, P1, P2, P3, P4
	boostWeightRiskTolerance      = 0.05 // Low, Medium, High

	// Penalty weights for optional labels (when they conflict)
	// Only resource_management and gitops_tool have penalties
	// Other labels (environment, business_category, priority, risk_tolerance) don't penalize
	penaltyWeightResourceManagement = 0.10 // Penalty for conflicting resource management
	penaltyWeightGitOpsTool         = 0.10 // Penalty for conflicting GitOps tool

	// Maximum possible boost (sum of all boost weights)
	maxLabelBoost = 0.46

	// Maximum possible penalty (sum of penalty weights)
	maxLabelPenalty = 0.20
)
