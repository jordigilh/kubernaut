/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package infrastructure

import (
	"fmt"
	"io"
	"os/exec"
	"path/filepath"
	"time"
)

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// WorkflowExecution Integration Infrastructure - DD-TEST-002 Go-Based Pattern
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
//
// Migration: Dec 25, 2025
// - FROM: Shell script (test/integration/workflowexecution/setup-infrastructure.sh)
// - TO: Go-based DD-TEST-002 pattern (aligns with Gateway, AIAnalysis, SignalProcessing, RO)
//
// Pattern: DD-TEST-002 Sequential Startup Pattern
// - Sequential container startup (eliminates race conditions)
// - Explicit health checks after each service
// - No podman-compose (avoids parallel startup issues)
// - Parallel-safe with unique ports (DD-TEST-001)
//
// Infrastructure Components:
// - PostgreSQL (port 15441): DataStorage backend
// - Redis (port 16387): DataStorage cache
// - DataStorage (port 18097): Audit event persistence
// - Metrics (port 19097): DataStorage metrics endpoint
//
// Related:
// - workflowexecution_integration.go: Port and container name constants
// - gateway.go: Reference implementation of DD-TEST-002
// - datastorage_bootstrap.go: Shared DataStorage bootstrap utilities
//
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

// StartWEIntegrationInfrastructure starts the WorkflowExecution integration test infrastructure
// using sequential podman run commands per DD-TEST-002.
//
// Pattern: DD-TEST-002 Sequential Startup Pattern
// - Sequential container startup (eliminates race conditions)
// - Explicit health checks after each service
// - No podman-compose (avoids parallel startup issues)
// - Parallel-safe with unique ports (DD-TEST-001)
//
// Infrastructure Components:
// - PostgreSQL (port 15441): DataStorage backend
// - Redis (port 16387): DataStorage cache
// - DataStorage (port 18097): Audit event persistence
// - Metrics (port 19097): DataStorage metrics endpoint
//
// Returns error if any infrastructure component fails to start.
func StartWEIntegrationInfrastructure(writer io.Writer) error {
	projectRoot := getProjectRoot()

	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	fmt.Fprintf(writer, "WorkflowExecution Integration Test Infrastructure Setup\n")
	fmt.Fprintf(writer, "Per DD-TEST-002: Sequential Startup Pattern\n")
	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	fmt.Fprintf(writer, "  PostgreSQL:     localhost:%d\n", WEIntegrationPostgresPort)
	fmt.Fprintf(writer, "  Redis:          localhost:%d (DD-TEST-001 v1.9: unique port)\n", WEIntegrationRedisPort)
	fmt.Fprintf(writer, "  DataStorage:    http://localhost:%d\n", WEIntegrationDataStoragePort)
	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n")

	// ============================================================================
	// STEP 1: Cleanup existing containers
	// ============================================================================
	fmt.Fprintf(writer, "ğŸ§¹ Cleaning up existing containers...\n")
	cleanupWEContainers(writer)
	fmt.Fprintf(writer, "   âœ… Cleanup complete\n\n")

	// ============================================================================
	// STEP 2: Network setup (SKIPPED - using port mapping for localhost connectivity)
	// ============================================================================
	// Note: Using port mapping (-p) instead of custom podman network to avoid DNS resolution issues
	// All services connect via localhost:PORT (same pattern as Gateway)
	fmt.Fprintf(writer, "ğŸŒ Network: Using port mapping for localhost connectivity\n\n")

	// ============================================================================
	// STEP 3: Start PostgreSQL FIRST
	// ============================================================================
	fmt.Fprintf(writer, "ğŸ˜ Starting PostgreSQL...\n")
	if err := startWEPostgreSQL(writer); err != nil {
		return fmt.Errorf("failed to start PostgreSQL: %w", err)
	}

	// CRITICAL: Wait for PostgreSQL to be ready before proceeding
	fmt.Fprintf(writer, "â³ Waiting for PostgreSQL to be ready...\n")
	if err := waitForWEPostgresReady(writer); err != nil {
		return fmt.Errorf("PostgreSQL failed to become ready: %w", err)
	}
	fmt.Fprintf(writer, "   âœ… PostgreSQL ready\n\n")

	// ============================================================================
	// STEP 4: Run migrations
	// ============================================================================
	fmt.Fprintf(writer, "ğŸ”„ Running database migrations...\n")
	if err := runWEMigrations(projectRoot, writer); err != nil {
		return fmt.Errorf("failed to run migrations: %w", err)
	}
	fmt.Fprintf(writer, "   âœ… Migrations applied successfully\n\n")

	// ============================================================================
	// STEP 5: Start Redis SECOND
	// ============================================================================
	fmt.Fprintf(writer, "ğŸ”´ Starting Redis...\n")
	if err := startWERedis(writer); err != nil {
		return fmt.Errorf("failed to start Redis: %w", err)
	}

	// Wait for Redis to be ready
	fmt.Fprintf(writer, "â³ Waiting for Redis to be ready...\n")
	if err := waitForWERedisReady(writer); err != nil {
		return fmt.Errorf("Redis failed to become ready: %w", err)
	}
	fmt.Fprintf(writer, "   âœ… Redis ready\n\n")

	// ============================================================================
	// STEP 6: Start DataStorage LAST
	// ============================================================================
	fmt.Fprintf(writer, "ğŸ“¦ Starting DataStorage service...\n")
	if err := startWEDataStorage(projectRoot, writer); err != nil {
		return fmt.Errorf("failed to start DataStorage: %w", err)
	}

	// CRITICAL: Wait for DataStorage HTTP endpoint to be ready
	fmt.Fprintf(writer, "â³ Waiting for DataStorage HTTP endpoint to be ready...\n")
	if err := waitForWEHTTPHealth(
		fmt.Sprintf("http://localhost:%d/health", WEIntegrationDataStoragePort),
		30*time.Second,
		writer,
	); err != nil {
		// Print container logs for debugging
		fmt.Fprintf(writer, "\nâš ï¸  DataStorage failed to become healthy. Container logs:\n")
		logsCmd := exec.Command("podman", "logs", WEIntegrationDataStorageContainer)
		logsCmd.Stdout = writer
		logsCmd.Stderr = writer
		_ = logsCmd.Run()
		return fmt.Errorf("DataStorage failed to become healthy: %w", err)
	}
	fmt.Fprintf(writer, "   âœ… DataStorage ready\n\n")

	// ============================================================================
	// SUCCESS
	// ============================================================================
	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	fmt.Fprintf(writer, "âœ… WorkflowExecution Integration Infrastructure Ready\n")
	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")
	fmt.Fprintf(writer, "  PostgreSQL:        localhost:%d\n", WEIntegrationPostgresPort)
	fmt.Fprintf(writer, "  Redis:             localhost:%d (DD-TEST-001 v1.9: unique port)\n", WEIntegrationRedisPort)
	fmt.Fprintf(writer, "  DataStorage HTTP:  http://localhost:%d\n", WEIntegrationDataStoragePort)
	fmt.Fprintf(writer, "  DataStorage Metrics: http://localhost:%d\n", WEIntegrationMetricsPort)
	fmt.Fprintf(writer, "  Database:          %s\n", WEIntegrationDBName)
	fmt.Fprintf(writer, "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n")

	return nil
}

// StopWEIntegrationInfrastructure stops all WorkflowExecution integration infrastructure containers.
func StopWEIntegrationInfrastructure(writer io.Writer) error {
	fmt.Fprintf(writer, "ğŸ›‘ Stopping WorkflowExecution integration infrastructure...\n")

	containers := []string{
		WEIntegrationDataStorageContainer,
		WEIntegrationRedisContainer,
		WEIntegrationPostgresContainer,
	}

	for _, container := range containers {
		stopCmd := exec.Command("podman", "stop", "-t", "5", container)
		stopCmd.Stdout = writer
		stopCmd.Stderr = writer
		if err := stopCmd.Run(); err != nil {
			fmt.Fprintf(writer, "   âš ï¸  Warning: Failed to stop %s: %v\n", container, err)
		} else {
			fmt.Fprintf(writer, "   âœ… Stopped %s\n", container)
		}

		rmCmd := exec.Command("podman", "rm", "-f", container)
		rmCmd.Stdout = writer
		rmCmd.Stderr = writer
		if err := rmCmd.Run(); err != nil {
			fmt.Fprintf(writer, "   âš ï¸  Warning: Failed to remove %s: %v\n", container, err)
		}
	}

	fmt.Fprintf(writer, "   âœ… All containers stopped\n")
	return nil
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// Internal Helper Functions
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

func cleanupWEContainers(writer io.Writer) {
	containers := []string{
		WEIntegrationDataStorageContainer,
		WEIntegrationRedisContainer,
		WEIntegrationPostgresContainer,
		WEIntegrationMigrationsContainer,
	}

	for _, container := range containers {
		// Stop container
		stopCmd := exec.Command("podman", "stop", "-t", "5", container)
		stopCmd.Stdout = writer
		stopCmd.Stderr = writer
		_ = stopCmd.Run() // Ignore errors (container might not exist)

		// Remove container
		rmCmd := exec.Command("podman", "rm", "-f", container)
		rmCmd.Stdout = writer
		rmCmd.Stderr = writer
		_ = rmCmd.Run() // Ignore errors (container might not exist)
	}
}

func startWEPostgreSQL(writer io.Writer) error {
	cmd := exec.Command("podman", "run",
		"-d",
		"--name", WEIntegrationPostgresContainer,
		"-p", fmt.Sprintf("%d:5432", WEIntegrationPostgresPort),
		"-e", "POSTGRES_DB="+WEIntegrationDBName,
		"-e", "POSTGRES_USER="+WEIntegrationDBUser,
		"-e", "POSTGRES_PASSWORD="+WEIntegrationDBPassword,
		"postgres:16-alpine",
	)
	cmd.Stdout = writer
	cmd.Stderr = writer
	return cmd.Run()
}

func waitForWEPostgresReady(writer io.Writer) error {
	maxAttempts := 30
	for i := 1; i <= maxAttempts; i++ {
		checkCmd := exec.Command("podman", "exec", WEIntegrationPostgresContainer,
			"pg_isready", "-U", WEIntegrationDBUser, "-d", WEIntegrationDBName)
		if err := checkCmd.Run(); err == nil {
			// Extra sleep to ensure PostgreSQL is fully ready for connections
			// The "server closed connection unexpectedly" error suggests timing issues
			time.Sleep(2 * time.Second)
			return nil
		}
		if i < maxAttempts {
			time.Sleep(1 * time.Second)
		}
	}
	return fmt.Errorf("PostgreSQL did not become ready after %d attempts", maxAttempts)
}

func runWEMigrations(projectRoot string, writer io.Writer) error {
	// Apply migrations using custom script (same pattern as Gateway)
	// Per DD-SCHEMA-001: Data Storage team owns migrations, but test infrastructure must apply them
	migrationsDir := filepath.Join(projectRoot, "migrations")

	// Apply migrations: extract only "Up" sections (stop at "-- +goose Down")
	migrationScript := `
		set -e
		echo "Applying migrations (Up sections only)..."
		find /migrations -maxdepth 1 -name "*.sql" -type f | sort | while read f; do
			echo "Applying $f..."
			sed -n "1,/^-- +goose Down/p" "$f" | grep -v "^-- +goose Down" | psql
		done
		echo "Migrations complete!"
	`

	// Use host.containers.internal for macOS compatibility (Podman VM can reach host)
	cmd := exec.Command("podman", "run", "--rm",
		"--name", WEIntegrationMigrationsContainer,
		"-v", fmt.Sprintf("%s:/migrations:ro", migrationsDir),
		"-e", "PGHOST=host.containers.internal",
		"-e", fmt.Sprintf("PGPORT=%d", WEIntegrationPostgresPort),
		"-e", "PGUSER="+WEIntegrationDBUser,
		"-e", "PGPASSWORD="+WEIntegrationDBPassword,
		"-e", "PGDATABASE="+WEIntegrationDBName,
		"postgres:16-alpine",
		"bash", "-c", migrationScript,
	)
	cmd.Stdout = writer
	cmd.Stderr = writer
	return cmd.Run()
}

func startWERedis(writer io.Writer) error {
	cmd := exec.Command("podman", "run",
		"-d",
		"--name", WEIntegrationRedisContainer,
		"-p", fmt.Sprintf("%d:6379", WEIntegrationRedisPort),
		"-e", "REDIS_PORT=6379",
		"redis:7-alpine",
		"--maxmemory", "256mb",
		"--maxmemory-policy", "allkeys-lru",
	)
	cmd.Stdout = writer
	cmd.Stderr = writer
	return cmd.Run()
}

func waitForWERedisReady(writer io.Writer) error {
	maxAttempts := 30
	for i := 0; i < maxAttempts; i++ {
		checkCmd := exec.Command("podman", "exec", WEIntegrationRedisContainer,
			"redis-cli", "ping")
		if err := checkCmd.Run(); err == nil {
			return nil
		}
		time.Sleep(1 * time.Second)
	}
	return fmt.Errorf("Redis did not become ready after %d attempts", maxAttempts)
}

func startWEDataStorage(projectRoot string, writer io.Writer) error {
	// Check if DataStorage image exists, build if not (same pattern as Gateway)
	checkCmd := exec.Command("podman", "image", "exists", "kubernaut/datastorage:latest")
	if checkCmd.Run() != nil {
		fmt.Fprintf(writer, "   Building DataStorage image...\n")
		buildCmd := exec.Command("podman", "build",
			"-t", "kubernaut/datastorage:latest",
			"-f", filepath.Join(projectRoot, "cmd", "datastorage", "Dockerfile"),
			projectRoot,
		)
		buildCmd.Stdout = writer
		buildCmd.Stderr = writer
		if err := buildCmd.Run(); err != nil {
			return fmt.Errorf("failed to build DataStorage image: %w", err)
		}
		fmt.Fprintf(writer, "   âœ… DataStorage image built\n")
	}

	// Mount config directory and set CONFIG_PATH (per ADR-030)
	configDir := filepath.Join(projectRoot, "test", "integration", "workflowexecution", "config")

	// DataStorage connects to PostgreSQL and Redis via host.containers.internal
	// This allows containers to reach services on the host via port mapping
	cmd := exec.Command("podman", "run",
		"-d",
		"--name", WEIntegrationDataStorageContainer,
		"-p", fmt.Sprintf("%d:8080", WEIntegrationDataStoragePort),
		"-p", fmt.Sprintf("%d:9090", WEIntegrationMetricsPort),
		"-v", fmt.Sprintf("%s:/etc/datastorage:ro", configDir),
		"-e", "CONFIG_PATH=/etc/datastorage/config.yaml",
		"-e", "LOG_LEVEL=debug",
		"-e", "PORT=8080",
		"-e", "METRICS_PORT=9090",
		"-e", "DB_HOST=host.containers.internal",
		"-e", "DB_PORT="+fmt.Sprintf("%d", WEIntegrationPostgresPort),
		"-e", "DB_NAME="+WEIntegrationDBName,
		"-e", "DB_USER="+WEIntegrationDBUser,
		"-e", "DB_PASSWORD="+WEIntegrationDBPassword,
		"-e", "DB_SSLMODE=disable",
		"-e", "REDIS_HOST=host.containers.internal",
		"-e", "REDIS_PORT="+fmt.Sprintf("%d", WEIntegrationRedisPort),
		"-e", "REDIS_DB=0",
		"kubernaut/datastorage:latest",
	)
	cmd.Stdout = writer
	cmd.Stderr = writer
	return cmd.Run()
}

func waitForWEHTTPHealth(url string, timeout time.Duration, writer io.Writer) error {
	return waitForHTTPHealth(url, timeout)
}

