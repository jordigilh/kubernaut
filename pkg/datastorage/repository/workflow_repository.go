/*
Copyright 2025 Jordi Gil.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"

	"github.com/go-logr/logr"
	"github.com/jmoiron/sqlx"

	"github.com/jordigilh/kubernaut/pkg/datastorage/embedding"
	"github.com/jordigilh/kubernaut/pkg/datastorage/models"
)

// ========================================
// WORKFLOW REPOSITORY
// ========================================
// Authority: DD-STORAGE-008 v2.0 (Workflow Catalog Schema)
// Business Requirement: BR-STORAGE-012 (Workflow Semantic Search)
// Design Decision: DD-WORKFLOW-002 (MCP Workflow Catalog Architecture)
// ========================================

// WorkflowRepository handles workflow catalog operations
type WorkflowRepository struct {
	db              *sqlx.DB
	logger          logr.Logger
	embeddingClient embedding.Client
}

// NewWorkflowRepository creates a new workflow repository
// BR-STORAGE-014: Embedding client is optional (nil = no automatic embedding generation)
func NewWorkflowRepository(db *sqlx.DB, logger logr.Logger, embeddingClient embedding.Client) *WorkflowRepository {
	return &WorkflowRepository{
		db:              db,
		logger:          logger,
		embeddingClient: embeddingClient,
	}
}

// ========================================
// CREATE OPERATIONS
// ========================================

// Create inserts a new workflow into the catalog
// BR-STORAGE-012: Workflow catalog persistence
// V1.0: Embedding generation removed (label-only search)
// DD-WORKFLOW-002 v3.0: Handles is_latest_version flag within a transaction
func (r *WorkflowRepository) Create(ctx context.Context, workflow *models.RemediationWorkflow) error {
	// V1.0: Embeddings no longer generated (label-only search)
	// Authority: CONFIDENCE_ASSESSMENT_REMOVE_EMBEDDINGS.md (92% confidence)

	// DD-WORKFLOW-002 v3.0: Use transaction to ensure is_latest_version consistency
	// When creating a new version, mark all previous versions as not latest
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		r.logger.Error(err, "failed to begin transaction",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version)
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// DD-WORKFLOW-002 v3.0: Mark previous versions as not latest
	// This ensures only one version per workflow_name has is_latest_version=true
	if workflow.IsLatestVersion {
		updateQuery := `
			UPDATE remediation_workflow_catalog
			SET is_latest_version = false, updated_at = NOW()
			WHERE workflow_name = $1 AND is_latest_version = true
		`
		result, err := tx.ExecContext(ctx, updateQuery, workflow.WorkflowName)
		if err != nil {
			r.logger.Error(err, "failed to update previous versions",
				"workflow_name", workflow.WorkflowName,
				"version", workflow.Version)
			return fmt.Errorf("failed to update previous versions: %w", err)
		}
		rowsAffected, _ := result.RowsAffected()
		if rowsAffected > 0 {
			r.logger.Info("marked previous versions as not latest",
				"workflow_name", workflow.WorkflowName,
				"versions_updated", rowsAffected)
		}
	}

	// DD-WORKFLOW-002 v3.0: workflow_id is UUID (auto-generated by DB), workflow_name is human-readable
	// DD-WORKFLOW-001 v1.6: Added custom_labels and detected_labels columns
	// DD-WORKFLOW-002 v2.4: Added container_image and container_digest columns
	// Use QueryRowContext with positional parameters to get the RETURNING value
	// sqlx doesn't support RETURNING with NamedExecContext, so we need to use positional parameters
	insertQuery := `
		INSERT INTO remediation_workflow_catalog (
			workflow_name, version, name, description, owner, maintainer,
			content, content_hash, parameters, execution_engine, container_image, container_digest,
			labels, custom_labels, detected_labels, status,
			is_latest_version, previous_version, version_notes, change_summary,
			approved_by, approved_at, expected_success_rate, expected_duration_seconds,
			created_by
		) VALUES (
			$1, $2, $3, $4, $5, $6,
			$7, $8, $9, $10, $11, $12,
			$13, $14, $15, $16,
			$17, $18, $19, $20,
			$21, $22, $23, $24,
			$25
		)
		RETURNING workflow_id
	`

	// Ensure custom_labels and detected_labels default to empty JSON if nil
	customLabels := workflow.CustomLabels
	if customLabels == nil {
		customLabels = []byte("{}")
	}
	detectedLabels := workflow.DetectedLabels
	if detectedLabels == nil {
		detectedLabels = []byte("{}")
	}

	var generatedID string
	err = tx.QueryRowContext(ctx, insertQuery,
		workflow.WorkflowName, workflow.Version, workflow.Name, workflow.Description, workflow.Owner, workflow.Maintainer,
		workflow.Content, workflow.ContentHash, workflow.Parameters, workflow.ExecutionEngine, workflow.ContainerImage, workflow.ContainerDigest,
		workflow.Labels, customLabels, detectedLabels, workflow.Status, // V1.0: no embedding column
		workflow.IsLatestVersion, workflow.PreviousVersion, workflow.VersionNotes, workflow.ChangeSummary,
		workflow.ApprovedBy, workflow.ApprovedAt, workflow.ExpectedSuccessRate, workflow.ExpectedDurationSeconds,
		workflow.CreatedBy,
	).Scan(&generatedID)
	if err != nil {
		r.logger.Error(err, "failed to create workflow",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version,
			"error", err)
		return fmt.Errorf("failed to create workflow: %w", err)
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		r.logger.Error(err, "failed to commit transaction",
			"workflow_name", workflow.WorkflowName,
			"version", workflow.Version)
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Set the generated UUID on the workflow
	workflow.WorkflowID = generatedID

	r.logger.Info("workflow created",
		"workflow_id", workflow.WorkflowID,
		"workflow_name", workflow.WorkflowName,
		"version", workflow.Version,
		"is_latest_version", workflow.IsLatestVersion)

	return nil
}

// ========================================
// READ OPERATIONS
// ========================================

// GetByID retrieves a workflow by UUID (primary key)
// DD-WORKFLOW-002 v3.0: workflow_id is the sole UUID primary key
func (r *WorkflowRepository) GetByID(ctx context.Context, workflowID string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_id = $1
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s", workflowID)
		}
		r.logger.Error(err, "failed to get workflow",
			"workflow_id", workflowID,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow: %w", err)
	}

	return &workflow, nil
}

// GetByNameAndVersion retrieves a specific workflow by name and version
// DD-WORKFLOW-002 v3.0: workflow_name + version is unique constraint
func (r *WorkflowRepository) GetByNameAndVersion(ctx context.Context, workflowName, version string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1 AND version = $2
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowName, version)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s@%s", workflowName, version)
		}
		r.logger.Error(err, "failed to get workflow",
			"workflow_name", workflowName,
			"version", version,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow: %w", err)
	}

	return &workflow, nil
}

// GetLatestVersion retrieves the latest version of a workflow by name
// DD-WORKFLOW-002 v3.0: Use workflow_name to find latest version
func (r *WorkflowRepository) GetLatestVersion(ctx context.Context, workflowName string) (*models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1 AND is_latest_version = true
		LIMIT 1
	`

	var workflow models.RemediationWorkflow
	err := r.db.GetContext(ctx, &workflow, query, workflowName)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("workflow not found: %s", workflowName)
		}
		r.logger.Error(err, "failed to get latest workflow version", "workflow_name", workflowName)
		return nil, fmt.Errorf("failed to get latest workflow version: %w", err)
	}

	return &workflow, nil
}

// GetVersionsByName retrieves all versions of a workflow by name
// DD-WORKFLOW-002 v3.0: List all versions by workflow_name
func (r *WorkflowRepository) GetVersionsByName(ctx context.Context, workflowName string) ([]models.RemediationWorkflow, error) {
	query := `
		SELECT * FROM remediation_workflow_catalog
		WHERE workflow_name = $1
		ORDER BY created_at DESC
	`

	var workflows []models.RemediationWorkflow
	err := r.db.SelectContext(ctx, &workflows, query, workflowName)
	if err != nil {
		r.logger.Error(err, "failed to get workflow versions",
			"workflow_name", workflowName,
			"error", err)
		return nil, fmt.Errorf("failed to get workflow versions: %w", err)
	}

	r.logger.Info("workflow versions retrieved",
		"workflow_name", workflowName,
		"count", len(workflows))

	return workflows, nil
}

// List retrieves workflows with optional filtering
func (r *WorkflowRepository) List(ctx context.Context, filters *models.WorkflowSearchFilters, limit, offset int) ([]models.RemediationWorkflow, int, error) {
	// Build WHERE clause
	whereClauses := []string{}
	args := []interface{}{}
	argIndex := 1

	// Default: only active workflows
	if filters == nil || len(filters.Status) == 0 {
		whereClauses = append(whereClauses, fmt.Sprintf("status = $%d", argIndex))
		args = append(args, "active")
		argIndex++
	} else {
		// Filter by specified statuses
		placeholders := []string{}
		for _, status := range filters.Status {
			placeholders = append(placeholders, fmt.Sprintf("$%d", argIndex))
			args = append(args, status)
			argIndex++
		}
		whereClauses = append(whereClauses, fmt.Sprintf("status IN (%s)", strings.Join(placeholders, ", ")))
	}

	// Only latest versions by default
	whereClauses = append(whereClauses, "is_latest_version = true")

	// Apply label filters (updated for DD-LLM-001 taxonomy)
	if filters != nil {
		// Mandatory: signal_type (single value)
		if filters.SignalType != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'signal_type' = $%d", argIndex))
			args = append(args, filters.SignalType)
			argIndex++
		}

		// Mandatory: severity
		if filters.Severity != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'severity' = $%d", argIndex))
			args = append(args, filters.Severity)
			argIndex++
		}

		// DD-WORKFLOW-001 v1.4: 5 mandatory labels (3 more added)
		// Mandatory: component
		if filters.Component != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'component' = $%d", argIndex))
			args = append(args, filters.Component)
			argIndex++
		}

		// Mandatory: environment (moved from optional)
		if filters.Environment != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'environment' = $%d", argIndex))
			args = append(args, filters.Environment)
			argIndex++
		}

		// Mandatory: priority (moved from optional)
		if filters.Priority != "" {
			whereClauses = append(whereClauses, fmt.Sprintf("labels->>'priority' = $%d", argIndex))
			args = append(args, filters.Priority)
			argIndex++
		}

		// DD-WORKFLOW-001 v1.5: Custom labels (subdomain-based)
		// Format: custom_labels @> '{"subdomain": ["value"]}'::jsonb
		for subdomain, values := range filters.CustomLabels {
			if len(values) > 0 {
				customLabelJSON, _ := json.Marshal(map[string][]string{subdomain: values})
				whereClauses = append(whereClauses, fmt.Sprintf("custom_labels @> $%d::jsonb", argIndex))
				args = append(args, string(customLabelJSON))
				argIndex++
			}
		}
	}

	whereClause := strings.Join(whereClauses, " AND ")

	// Count total results
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM remediation_workflow_catalog WHERE %s", whereClause)
	var total int
	err := r.db.GetContext(ctx, &total, countQuery, args...)
	if err != nil {
		r.logger.Error(err, "failed to count workflows")
		return nil, 0, fmt.Errorf("failed to count workflows: %w", err)
	}

	// Get paginated results
	query := fmt.Sprintf(`
		SELECT * FROM remediation_workflow_catalog
		WHERE %s
		ORDER BY created_at DESC
		LIMIT $%d OFFSET $%d
	`, whereClause, argIndex, argIndex+1)

	args = append(args, limit, offset)

	var workflows []models.RemediationWorkflow
	err = r.db.SelectContext(ctx, &workflows, query, args...)
	if err != nil {
		r.logger.Error(err, "failed to list workflows")
		return nil, 0, fmt.Errorf("failed to list workflows: %w", err)
	}

	return workflows, total, nil
}

// ========================================
// SEMANTIC SEARCH (pgvector)
// ========================================
// BR-STORAGE-013: Semantic Search API
// DD-WORKFLOW-002: MCP Workflow Catalog Architecture

// ========================================
// LABEL-ONLY SEARCH (V1.0)
// ========================================
// Authority: DD-WORKFLOW-004 v1.5 (Label-Only Scoring)
// Authority: CONFIDENCE_ASSESSMENT_REMOVE_EMBEDDINGS.md (92% confidence)

// SearchByLabels performs label-only workflow search with wildcard weighting
// V1.0: Pure SQL label matching without embeddings (increases correctness 81% → 95%)
//
// Rationale: Indeterministic LLM-generated keywords decrease workflow selection
// correctness. Label-only search with wildcard weighting provides deterministic
// matching with high accuracy.
//
// Scoring Formula:
//   - base_score: 5.0 (all 5 mandatory labels matched via hard WHERE filter)
//   - label_boost: DetectedLabel boosts (0.0-0.39) with wildcard support
//   - label_penalty: High-impact conflicting DetectedLabels (0.0-0.20)
//   - raw_score: base_score + label_boost - label_penalty
//   - final_score: raw_score / 10.0 (normalized to 0.0-1.0 range)
//
// Wildcard Weighting:
//   - Exact match (gitOpsTool='argocd'): Full boost (0.10)
//   - Wildcard match (gitOpsTool='*'): Half boost (0.05)
//   - Conflicting match: Full penalty (-0.10)
//
// See: docs/handoff/SQL_WILDCARD_WEIGHTING_IMPLEMENTATION.md
func (r *WorkflowRepository) SearchByLabels(ctx context.Context, request *models.WorkflowSearchRequest) (*models.WorkflowSearchResponse, error) {
	// Validate filters are provided (required for label-only search)
	if request.Filters == nil {
		return nil, fmt.Errorf("filters are required for label-only search")
	}

	// Build WHERE clause for hard filters
	whereClauses := []string{}
	args := []interface{}{}
	argIndex := 1

	// Default: only active workflows unless IncludeDisabled is true
	if !request.IncludeDisabled {
		whereClauses = append(whereClauses, fmt.Sprintf("status = $%d", argIndex))
		args = append(args, "active")
		argIndex++
	}

	// Only latest versions
	whereClauses = append(whereClauses, "is_latest_version = true")

	// ========================================
	// MANDATORY LABEL FILTERING (5 labels)
	// ========================================
	// Authority: DD-WORKFLOW-001 v1.6 (5 mandatory labels)
	// These filters provide the base score of 5.0 (one point per exact match)

	// Mandatory Filter 1: signal_type (exact match)
	if request.Filters.SignalType == "" {
		return nil, fmt.Errorf("filters.signal_type is required")
	}
	whereClauses = append(whereClauses, fmt.Sprintf("labels->>'signal_type' = $%d", argIndex))
	args = append(args, request.Filters.SignalType)
	argIndex++

	// Mandatory Filter 2: severity (exact match)
	if request.Filters.Severity == "" {
		return nil, fmt.Errorf("filters.severity is required")
	}
	whereClauses = append(whereClauses, fmt.Sprintf("labels->>'severity' = $%d", argIndex))
	args = append(args, request.Filters.Severity)
	argIndex++

	// Mandatory Filter 3: component (exact match)
	if request.Filters.Component == "" {
		return nil, fmt.Errorf("filters.component is required")
	}
	whereClauses = append(whereClauses, fmt.Sprintf("labels->>'component' = $%d", argIndex))
	args = append(args, request.Filters.Component)
	argIndex++

	// Mandatory Filter 4: environment (exact match)
	if request.Filters.Environment == "" {
		return nil, fmt.Errorf("filters.environment is required")
	}
	whereClauses = append(whereClauses, fmt.Sprintf("labels->>'environment' = $%d", argIndex))
	args = append(args, request.Filters.Environment)
	argIndex++

	// Mandatory Filter 5: priority (exact match)
	if request.Filters.Priority == "" {
		return nil, fmt.Errorf("filters.priority is required")
	}
	whereClauses = append(whereClauses, fmt.Sprintf("labels->>'priority' = $%d", argIndex))
	args = append(args, request.Filters.Priority)
	argIndex++

	// ========================================
	// CUSTOM LABELS REMOVED FROM HARD FILTERING
	// ========================================
	// V1.0: CustomLabels moved to scoring with wildcard support (no hard filtering)
	// Authority: DD-WORKFLOW-004 v1.5 + user confirmation 2025-12-11
	// Rationale: Wildcard matching allows workflows to specify "*" for any value,
	// enabling exact matches to rank higher than wildcard matches.

	whereClause := ""
	if len(whereClauses) > 0 {
		whereClause = "WHERE " + strings.Join(whereClauses, " AND ")
	}

	// Set default TopK
	topK := 10
	if request.TopK > 0 {
		topK = request.TopK
	}

	// ========================================
	// V1.0 SCORING: LABEL-ONLY WITH WILDCARD WEIGHTING
	// ========================================
	// Authority: DD-WORKFLOW-004 v1.5 (Label-Only Scoring)
	// Authority: SQL_WILDCARD_WEIGHTING_IMPLEMENTATION.md
	//
	// Scoring Components:
	//   - base_score: 5.0 (from 5 mandatory labels, hard-filtered in WHERE)
	//   - detected_label_boost: DetectedLabel boosts with wildcard support (0.0-0.39)
	//   - custom_label_boost: CustomLabel boosts with wildcard support (0.0-0.50) [V1.0 NEW]
	//   - label_penalty: High-impact conflicting DetectedLabels (0.0-0.20)
	//   - raw_score: base_score + detected_label_boost + custom_label_boost - label_penalty
	//   - final_score: raw_score / 10.0 (normalized to 0.0-1.0 range)
	//
	// Wildcard Logic (for ALL label types):
	//   - Exact match: Full boost (gitOpsTool='argocd' → +0.10)
	//   - Wildcard match: Half boost (gitOpsTool='*' → +0.05)
	//   - Conflicting match: Full penalty (gitOpsTool mismatch → -0.10)
	//   - No filter: No boost/penalty (gitOpsTool absent → 0.0)

	// Build scoring SQL components with wildcard support
	detectedLabelBoostSQL := r.buildDetectedLabelsBoostSQLWithWildcard(request)
	customLabelBoostSQL := r.buildCustomLabelsBoostSQLWithWildcard(request)
	labelPenaltySQL := r.buildDetectedLabelsPenaltySQL(request)

	query := fmt.Sprintf(`
		SELECT * FROM (
			SELECT
				*,
				%s AS detected_label_boost,
				%s AS custom_label_boost,
				%s AS label_penalty,
				(5.0 + (%s) + (%s) - (%s)) / 10.0 AS final_score
			FROM remediation_workflow_catalog
			%s
		) scored_workflows
		WHERE final_score >= $%d
		ORDER BY final_score DESC
		LIMIT $%d
	`, detectedLabelBoostSQL, customLabelBoostSQL, labelPenaltySQL,
		detectedLabelBoostSQL, customLabelBoostSQL, labelPenaltySQL,
		whereClause,
		argIndex, argIndex+1)

	// Add MinScore and TopK to args
	args = append(args, request.MinScore) // $argIndex
	args = append(args, topK)             // $argIndex+1

	// Execute query with label-only scoring (V1.0: includes CustomLabels wildcard)
	type workflowWithScore struct {
		models.RemediationWorkflow
		DetectedLabelBoost float64 `db:"detected_label_boost"`
		CustomLabelBoost   float64 `db:"custom_label_boost"`
		LabelPenalty       float64 `db:"label_penalty"`
		FinalScore         float64 `db:"final_score"`
	}

	var results []workflowWithScore
	err := r.db.SelectContext(ctx, &results, query, args...)
	if err != nil {
		r.logger.Error(err, "failed to search workflows by labels",
			"filters", request.Filters)
		return nil, fmt.Errorf("failed to search workflows: %w", err)
	}

	// Build response with DD-WORKFLOW-002 v3.0 flat structure
	searchResults := make([]models.WorkflowSearchResult, len(results))
	for i, result := range results {
		// Extract signal_type from labels JSONB
		signalType := ""
		if result.Labels != nil {
			var labels map[string]interface{}
			if err := json.Unmarshal(result.Labels, &labels); err == nil {
				if st, ok := labels["signal_type"].(string); ok {
					signalType = st
				}
			}
		}

		// Handle optional pointer fields
		containerImage := ""
		if result.ContainerImage != nil {
			containerImage = *result.ContainerImage
		}
		containerDigest := ""
		if result.ContainerDigest != nil {
			containerDigest = *result.ContainerDigest
		}

		// DD-WORKFLOW-002 v3.0: Flat response structure
		// V1.0: Label-only scoring (no BaseSimilarity or SimilarityScore)
		searchResults[i] = models.WorkflowSearchResult{
			// Flat fields per DD-WORKFLOW-002 v3.0
			WorkflowID:      result.WorkflowID,
			Title:           result.Name, // DD-WORKFLOW-002 v3.0: "name" renamed to "title"
			Description:     result.Description,
			SignalType:      signalType,
			ContainerImage:  containerImage,
			ContainerDigest: containerDigest,

			// V1.0: Label-only scoring fields (with CustomLabels wildcard support)
			Confidence:   result.FinalScore,                                   // DD-WORKFLOW-002 v3.0: "confidence" = final_score
			LabelBoost:   result.DetectedLabelBoost + result.CustomLabelBoost, // Combined boost
			LabelPenalty: result.LabelPenalty,
			FinalScore:   result.FinalScore,
			Rank:         i + 1,

			// DD-WORKFLOW-001 v1.6: Label columns in response
			CustomLabels:   result.CustomLabels,
			DetectedLabels: result.DetectedLabels,

			// Internal: full workflow for audit/logging (not serialized)
			Workflow: result.RemediationWorkflow,
		}
	}

	response := &models.WorkflowSearchResponse{
		Workflows:    searchResults,
		TotalResults: len(searchResults),
		Filters:      request.Filters,
	}

	r.logger.Info("label-only search completed",
		"filters", request.Filters,
		"results", len(searchResults))

	return response, nil
}

// ========================================
// HYBRID SCORING HELPER FUNCTIONS
// ========================================
// Authority: DD-WORKFLOW-004 v1.5 (Fixed DetectedLabel Weights)
// Package: pkg/datastorage/scoring

// sanitizeEnumValue validates that a string value is in the allowed enum set.
// Returns the value if valid, empty string if invalid.
// This prevents SQL injection from unexpected enum values.
func sanitizeEnumValue(value string, allowedValues []string) string {
	for _, allowed := range allowedValues {
		if value == allowed {
			return value
		}
	}
	return "" // Invalid value, return empty string
}

// sanitizeJSONBKey sanitizes JSONB keys for SQL queries
// Removes characters that could cause SQL injection
func sanitizeJSONBKey(key string) string {
	// Allow alphanumeric, underscore, hyphen only
	return regexp.MustCompile(`[^a-zA-Z0-9_\-]`).ReplaceAllString(key, "")
}

// sanitizeSQLString sanitizes string values for SQL queries
// Escapes single quotes to prevent SQL injection
func sanitizeSQLString(value string) string {
	return strings.ReplaceAll(value, "'", "''")
}

// buildDetectedLabelsBoostSQL generates SQL to calculate the label boost score.
// Returns SQL expression that sums weights for matching DetectedLabels.
//
// Logic:
//   - For each DetectedLabel in the query that matches workflow's detected_labels
//   - Add the fixed weight from scoring.DetectedLabelWeights
//   - If query has no DetectedLabels, return "0.0" (no boost)
//
// Example SQL output:
//
//	COALESCE(
//	  CASE WHEN detected_labels->>'git_ops_managed' = 'true' THEN 0.10 ELSE 0.0 END +
//	  CASE WHEN detected_labels->>'pdb_protected' = 'true' THEN 0.05 ELSE 0.0 END,
//	  0.0
//	)
func (r *WorkflowRepository) buildDetectedLabelsBoostSQL(request *models.WorkflowSearchRequest) string {
	if request.Filters == nil || request.Filters.DetectedLabels == nil {
		return "0.0" // No DetectedLabels in query = no boost
	}

	dl := request.Filters.DetectedLabels
	boostCases := []string{}

	// Import weights from scoring package (would need to import)
	// For now, use constants inline to avoid circular dependencies
	weights := map[string]float64{
		"git_ops_managed":  0.10,
		"git_ops_tool":     0.10,
		"pdb_protected":    0.05,
		"service_mesh":     0.05,
		"network_isolated": 0.03,
		"helm_managed":     0.02,
		"stateful":         0.02,
		"hpa_enabled":      0.02,
	}

	// GitOpsManaged (boolean)
	if dl.GitOpsManaged != nil && *dl.GitOpsManaged {
		weight := weights["git_ops_managed"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_managed' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// GitOpsTool (string)
	if dl.GitOpsTool != nil {
		weight := weights["git_ops_tool"]
		tool := sanitizeEnumValue(*dl.GitOpsTool, []string{"argocd", "flux"})
		if tool != "" {
			boostCases = append(boostCases,
				fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_tool' = '%s' THEN %.2f ELSE 0.0 END", tool, weight))
		}
	}

	// PDBProtected (boolean)
	if dl.PDBProtected != nil && *dl.PDBProtected {
		weight := weights["pdb_protected"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'pdb_protected' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// ServiceMesh (string)
	if dl.ServiceMesh != nil {
		weight := weights["service_mesh"]
		mesh := sanitizeEnumValue(*dl.ServiceMesh, []string{"istio", "linkerd"})
		if mesh != "" {
			boostCases = append(boostCases,
				fmt.Sprintf("CASE WHEN detected_labels->>'service_mesh' = '%s' THEN %.2f ELSE 0.0 END", mesh, weight))
		}
	}

	// NetworkIsolated (boolean)
	if dl.NetworkIsolated != nil && *dl.NetworkIsolated {
		weight := weights["network_isolated"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'network_isolated' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// HelmManaged (boolean)
	if dl.HelmManaged != nil && *dl.HelmManaged {
		weight := weights["helm_managed"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'helm_managed' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// Stateful (boolean)
	if dl.Stateful != nil && *dl.Stateful {
		weight := weights["stateful"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'stateful' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// HPAEnabled (boolean)
	if dl.HPAEnabled != nil && *dl.HPAEnabled {
		weight := weights["hpa_enabled"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'hpa_enabled' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	if len(boostCases) == 0 {
		return "0.0" // No matching labels = no boost
	}

	// Sum all boost cases
	return fmt.Sprintf("COALESCE((%s), 0.0)", strings.Join(boostCases, " + "))
}

// buildDetectedLabelsPenaltySQL generates SQL to calculate the label penalty score.
// Returns SQL expression that sums penalties for conflicting high-impact DetectedLabels.
//
// Logic:
//   - Only high-impact labels apply penalties: gitOpsManaged, gitOpsTool
//   - If query has DetectedLabel=true but workflow has DetectedLabel=false (or missing) → penalty
//   - If query has DetectedLabel=toolA but workflow has DetectedLabel=toolB → penalty
//
// Example SQL output:
//
//	COALESCE(
//	  CASE WHEN detected_labels->>'git_ops_managed' IS NULL OR detected_labels->>'git_ops_managed' = 'false' THEN 0.10 ELSE 0.0 END,
//	  0.0
//	)
func (r *WorkflowRepository) buildDetectedLabelsPenaltySQL(request *models.WorkflowSearchRequest) string {
	if request.Filters == nil || request.Filters.DetectedLabels == nil {
		return "0.0" // No DetectedLabels in query = no penalty
	}

	dl := request.Filters.DetectedLabels
	penaltyCases := []string{}

	// Only high-impact fields apply penalties (per scoring.ShouldApplyPenalty)
	highImpactWeights := map[string]float64{
		"git_ops_managed": 0.10,
		"git_ops_tool":    0.10,
	}

	// GitOpsManaged penalty: Query wants GitOps but workflow is NOT GitOps
	if dl.GitOpsManaged != nil && *dl.GitOpsManaged {
		weight := highImpactWeights["git_ops_managed"]
		// Penalty if workflow is NOT GitOps-managed (null or false)
		penaltyCases = append(penaltyCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_managed' IS NULL OR detected_labels->>'git_ops_managed' = 'false' THEN %.2f ELSE 0.0 END", weight))
	}

	// GitOpsTool penalty: Query wants specific tool but workflow has different tool or no tool
	if dl.GitOpsTool != nil {
		weight := highImpactWeights["git_ops_tool"]
		tool := sanitizeEnumValue(*dl.GitOpsTool, []string{"argocd", "flux"})
		if tool != "" {
			// Penalty if workflow has different tool or no tool
			penaltyCases = append(penaltyCases,
				fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_tool' IS NULL OR (detected_labels->>'git_ops_tool' != '%s' AND detected_labels->>'git_ops_tool' != '') THEN %.2f ELSE 0.0 END", tool, weight))
		}
	}

	if len(penaltyCases) == 0 {
		return "0.0" // No penalties = 0.0
	}

	// Sum all penalty cases
	return fmt.Sprintf("COALESCE((%s), 0.0)", strings.Join(penaltyCases, " + "))
}

// buildCustomLabelsBoostSQLWithWildcard generates SQL with wildcard weighting for CustomLabels.
// V1.0: CustomLabels wildcard support (2025-12-11 user approval)
// Authority: User confirmation 2025-12-11
//
// Wildcard Logic (for dynamic key-value pairs):
//   - Exact match: Full boost (incident has "cost-constrained", workflow has ["cost-constrained"] → +0.05)
//   - Wildcard match: Half boost (incident has "cost-constrained", workflow has ["*"] → +0.025)
//   - No match: No boost (incident has "cost-constrained", workflow has ["no-restart"] → 0.0)
//   - No filter: No boost (incident absent → 0.0)
//
// Weight: 0.05 per custom label key (up to 10 keys max = 0.50 total boost)
func (r *WorkflowRepository) buildCustomLabelsBoostSQLWithWildcard(request *models.WorkflowSearchRequest) string {
	if request.Filters == nil || len(request.Filters.CustomLabels) == 0 {
		return "0.0" // No CustomLabels in query = no boost
	}

	boostCases := []string{}
	const customLabelWeight = 0.05 // Weight per custom label key

	// Iterate over incident custom labels (from SP Rego)
	for key, incidentValues := range request.Filters.CustomLabels {
		if len(incidentValues) == 0 {
			continue
		}

		// For each incident value, generate matching SQL
		for _, incidentValue := range incidentValues {
			// Sanitize key and value for SQL injection prevention
			safeKey := sanitizeJSONBKey(key)
			safeValue := sanitizeSQLString(incidentValue)

			// SQL pattern: Check workflow's custom_labels JSONB
			//   - Exact match: custom_labels->>'key' ? 'value' → Full boost
			//   - Wildcard match: custom_labels->>'key' ? '*' → Half boost
			boostCase := fmt.Sprintf(`
				CASE
					WHEN custom_labels->'%s' @> '"%s"'::jsonb THEN %.2f
					WHEN custom_labels->'%s' @> '"*"'::jsonb THEN %.2f
					ELSE 0.0
				END`,
				safeKey, safeValue, customLabelWeight, // Exact match
				safeKey, customLabelWeight/2) // Wildcard match

			boostCases = append(boostCases, boostCase)
		}
	}

	if len(boostCases) == 0 {
		return "0.0"
	}

	// Sum all boost cases
	return fmt.Sprintf("COALESCE((%s), 0.0)", strings.Join(boostCases, " + "))
}

// buildDetectedLabelsBoostSQLWithWildcard generates SQL with wildcard weighting support.
// V1.0: Label-only scoring with wildcard differentiation
// Authority: SQL_WILDCARD_WEIGHTING_IMPLEMENTATION.md
//
// Wildcard Logic (for string fields like gitOpsTool, serviceMesh):
//   - Exact match: Full boost (gitOpsTool='argocd' + workflow='argocd' → +0.10)
//   - Wildcard match: Half boost (gitOpsTool='*' + workflow='argocd' → +0.05)
//   - No match: No boost (gitOpsTool='argocd' + workflow='flux' → 0.0)
//   - No filter: No boost (gitOpsTool absent → 0.0)
//
// Example SQL output:
//
//	COALESCE(
//	  CASE WHEN detected_labels->>'git_ops_managed' = 'true' THEN 0.10 ELSE 0.0 END +
//	  CASE
//	    WHEN detected_labels->>'git_ops_tool' = 'argocd' THEN 0.10  -- exact match
//	    WHEN detected_labels->>'git_ops_tool' IS NOT NULL THEN 0.05  -- wildcard match
//	    ELSE 0.0
//	  END,
//	  0.0
//	)
func (r *WorkflowRepository) buildDetectedLabelsBoostSQLWithWildcard(request *models.WorkflowSearchRequest) string {
	if request.Filters == nil || request.Filters.DetectedLabels == nil {
		return "0.0" // No DetectedLabels in query = no boost
	}

	dl := request.Filters.DetectedLabels
	boostCases := []string{}

	// Weights from scoring package (inline to avoid circular deps)
	weights := map[string]float64{
		"git_ops_managed":  0.10,
		"git_ops_tool":     0.10,
		"pdb_protected":    0.05,
		"service_mesh":     0.05,
		"network_isolated": 0.03,
		"helm_managed":     0.02,
		"stateful":         0.02,
		"hpa_enabled":      0.02,
	}

	// GitOpsManaged (boolean - no wildcard)
	if dl.GitOpsManaged != nil && *dl.GitOpsManaged {
		weight := weights["git_ops_managed"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_managed' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// GitOpsTool (string - wildcard support)
	if dl.GitOpsTool != nil {
		weight := weights["git_ops_tool"]
		if *dl.GitOpsTool == "*" {
			// Wildcard: Half boost if workflow has ANY git_ops_tool
			boostCases = append(boostCases,
				fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_tool' IS NOT NULL AND detected_labels->>'git_ops_tool' != '' THEN %.2f ELSE 0.0 END", weight/2))
		} else {
			// Exact match: Full boost
			tool := sanitizeEnumValue(*dl.GitOpsTool, []string{"argocd", "flux"})
			if tool != "" {
				boostCases = append(boostCases,
					fmt.Sprintf("CASE WHEN detected_labels->>'git_ops_tool' = '%s' THEN %.2f ELSE 0.0 END", tool, weight))
			}
		}
	}

	// PDBProtected (boolean - no wildcard)
	if dl.PDBProtected != nil && *dl.PDBProtected {
		weight := weights["pdb_protected"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'pdb_protected' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// ServiceMesh (string - wildcard support)
	if dl.ServiceMesh != nil {
		weight := weights["service_mesh"]
		if *dl.ServiceMesh == "*" {
			// Wildcard: Half boost if workflow has ANY service_mesh
			boostCases = append(boostCases,
				fmt.Sprintf("CASE WHEN detected_labels->>'service_mesh' IS NOT NULL AND detected_labels->>'service_mesh' != '' THEN %.2f ELSE 0.0 END", weight/2))
		} else {
			// Exact match: Full boost
			mesh := sanitizeEnumValue(*dl.ServiceMesh, []string{"istio", "linkerd"})
			if mesh != "" {
				boostCases = append(boostCases,
					fmt.Sprintf("CASE WHEN detected_labels->>'service_mesh' = '%s' THEN %.2f ELSE 0.0 END", mesh, weight))
			}
		}
	}

	// NetworkIsolated (boolean - no wildcard)
	if dl.NetworkIsolated != nil && *dl.NetworkIsolated {
		weight := weights["network_isolated"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'network_isolated' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// HelmManaged (boolean - no wildcard)
	if dl.HelmManaged != nil && *dl.HelmManaged {
		weight := weights["helm_managed"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'helm_managed' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// Stateful (boolean - no wildcard)
	if dl.Stateful != nil && *dl.Stateful {
		weight := weights["stateful"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'stateful' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	// HPAEnabled (boolean - no wildcard)
	if dl.HPAEnabled != nil && *dl.HPAEnabled {
		weight := weights["hpa_enabled"]
		boostCases = append(boostCases,
			fmt.Sprintf("CASE WHEN detected_labels->>'hpa_enabled' = 'true' THEN %.2f ELSE 0.0 END", weight))
	}

	if len(boostCases) == 0 {
		return "0.0" // No matching labels = no boost
	}

	// Sum all boost cases
	return fmt.Sprintf("COALESCE((%s), 0.0)", strings.Join(boostCases, " + "))
}

// ========================================
// UPDATE OPERATIONS
// ========================================

// UpdateSuccessMetrics updates the success metrics for a workflow
func (r *WorkflowRepository) UpdateSuccessMetrics(ctx context.Context, workflowID, version string, totalExecutions, successfulExecutions int) error {
	query := `
		UPDATE remediation_workflow_catalog
		SET
			total_executions = $1,
			successful_executions = $2,
			actual_success_rate = CASE
				WHEN $1 > 0 THEN $2::DECIMAL / $1::DECIMAL
				ELSE NULL
			END,
			updated_at = NOW()
		WHERE workflow_id = $3 AND version = $4
	`

	result, err := r.db.ExecContext(ctx, query, totalExecutions, successfulExecutions, workflowID, version)
	if err != nil {
		r.logger.Error(err, "failed to update workflow success metrics",
			"workflow_id", workflowID,
			"version", version,
			"error", err)
		return fmt.Errorf("failed to update workflow success metrics: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("workflow not found: %s@%s", workflowID, version)
	}

	r.logger.Info("workflow success metrics updated",
		"workflow_id", workflowID,
		"version", version,
		"total_executions", totalExecutions,
		"successful_executions", successfulExecutions)

	return nil
}

// UpdateStatus updates the workflow status
// DD-WORKFLOW-002 v3.0: workflow_id is UUID primary key, no version needed
func (r *WorkflowRepository) UpdateStatus(ctx context.Context, workflowID, version, status, reason, updatedBy string) error {
	// DD-WORKFLOW-002 v3.0: workflow_id (UUID) is the primary key
	// Version is kept in signature for backward compatibility but not used in query
	//
	// Note: We use separate parameters for status comparison to avoid PostgreSQL
	// type inference issues with $1 being used in both SET and CASE expressions
	query := `
		UPDATE remediation_workflow_catalog
		SET
			status = $1::text,
			disabled_at = CASE WHEN $1::text = 'disabled' THEN NOW() ELSE disabled_at END,
			disabled_by = CASE WHEN $1::text = 'disabled' THEN $2 ELSE disabled_by END,
			disabled_reason = CASE WHEN $1::text = 'disabled' THEN $3 ELSE disabled_reason END,
			updated_at = NOW(),
			updated_by = $2
		WHERE workflow_id = $4::uuid
	`

	result, err := r.db.ExecContext(ctx, query, status, updatedBy, reason, workflowID)
	if err != nil {
		r.logger.Error(err, "failed to update workflow status",
			"workflow_id", workflowID,
			"status", status,
			"error", err)
		return fmt.Errorf("failed to update workflow status: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("workflow not found: %s", workflowID)
	}

	r.logger.Info("workflow status updated",
		"workflow_id", workflowID,
		"status", status)

	return nil
}

// ========================================
// HELPER FUNCTIONS
// ========================================

// buildSearchText constructs searchable text from workflow metadata for embedding generation
// BR-STORAGE-014: Semantic search text construction
//
// Strategy: Combine name, description, and content for comprehensive semantic representation
// Weight: Name (high), Description (medium), Content preview (low)
func (r *WorkflowRepository) buildSearchText(workflow *models.RemediationWorkflow) string {
	var parts []string

	// Name (highest weight - include 3 times for emphasis)
	if workflow.Name != "" {
		parts = append(parts, workflow.Name, workflow.Name, workflow.Name)
	}

	// Description (medium weight - include 2 times)
	if workflow.Description != "" {
		parts = append(parts, workflow.Description, workflow.Description)
	}

	// Content preview (low weight - first 500 chars only)
	if workflow.Content != "" {
		contentPreview := workflow.Content
		if len(contentPreview) > 500 {
			contentPreview = contentPreview[:500]
		}
		parts = append(parts, contentPreview)
	}

	return strings.Join(parts, " ")
}

// toJSONArray converts a string slice to a JSON array string
func toJSONArray(items []string) string {
	if len(items) == 0 {
		return "[]"
	}

	quoted := make([]string, len(items))
	for i, item := range items {
		quoted[i] = fmt.Sprintf(`"%s"`, item)
	}

	return fmt.Sprintf("[%s]", strings.Join(quoted, ", "))
}

// ========================================
// V2.0+ ROADMAP: CONFIGURABLE LABEL WEIGHTS
// ========================================
// Authority: DD-WORKFLOW-004 v2.0 (Hybrid Weighted Label Scoring)
//
// V1.0 Decision: NO hardcoded boost/penalty weights
//   - Custom labels are customer-defined via Rego policies
//   - Kubernaut cannot assign weights to customer-defined labels
//   - Scoring uses base semantic similarity only
//
// V2.0+ Roadmap: Customer-configurable weights via ConfigMap
//   - Customers define their own label weights
//   - Dynamic SQL generation from configuration
//   - See DD-WORKFLOW-004 v2.0 for design
//
// These constants are PRESERVED for V2.0+ reference but NOT USED in V1.0:
//
// const (
// 	boostWeightResourceManagement = 0.10 // V2.0+: GitOps vs Manual vs Automated
// 	boostWeightGitOpsTool         = 0.10 // V2.0+: ArgoCD vs Flux vs None
// 	boostWeightEnvironment        = 0.08 // V2.0+: Production vs Staging vs Development
// 	boostWeightBusinessCategory   = 0.08 // V2.0+: Payments, Auth, Data-Processing, etc.
// 	boostWeightPriority           = 0.05 // V2.0+: P0, P1, P2, P3, P4
// 	boostWeightRiskTolerance      = 0.05 // V2.0+: Low, Medium, High
// 	penaltyWeightResourceManagement = 0.10 // V2.0+: Penalty for conflicting resource management
// 	penaltyWeightGitOpsTool         = 0.10 // V2.0+: Penalty for conflicting GitOps tool
// 	maxLabelBoost   = 0.46 // V2.0+: Maximum possible boost
// 	maxLabelPenalty = 0.20 // V2.0+: Maximum possible penalty
// )
